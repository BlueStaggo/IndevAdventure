--- net/minecraft/game/level/material/Material.java
+++ net/minecraft/game/level/material/Material.java
@@ -17,6 +17,9 @@
 	public static final Material circuits = new MaterialLogic();
 	public static final Material glass = new Material();
 	public static final Material tnt = new Material();
+	public static final Material ice = new Material();
+	public static final Material snow = new MaterialLogic();
+	public static final Material craftedSnow = new Material();
 
 	public boolean getIsLiquid() {
 		return false;
--- net/minecraft/game/level/block/BlockContainer.java
+++ net/minecraft/game/level/block/BlockContainer.java
@@ -5,7 +5,7 @@
 import net.minecraft.game.level.material.Material;
 
 public abstract class BlockContainer extends Block {
-	protected BlockContainer(int var1, Material var2) {
+	public BlockContainer(int var1, Material var2) {
 		super(var1, var2);
 	}
 
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeatureTaiga1.java
@@ -1,0 +1,88 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+
+import java.util.Random;
+
+public class FeatureTaiga1 implements Feature {
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		int var6 = var2.nextInt(5) + 7;
+		int var7 = var6 - var2.nextInt(2) - 3;
+		int var8 = var6 - var7;
+		int var9 = 1 + var2.nextInt(var8 + 1);
+		boolean var10 = true;
+		if(var4 >= 1 && var4 + var6 + 1 <= var1.height
+				&& var3 > 0 && var3 < var1.width - 1
+				&& var5 > 0 && var5 < var1.length - 1) {
+			int var11;
+			int var13;
+			int var14;
+			int var15;
+			int var18;
+			for(var11 = var4; var11 <= var4 + 1 + var6 && var10; ++var11) {
+				boolean var12 = true;
+				if(var11 - var4 < var7) {
+					var18 = 0;
+				} else {
+					var18 = var9;
+				}
+
+				for(var13 = var3 - var18; var13 <= var3 + var18 && var10; ++var13) {
+					for(var14 = var5 - var18; var14 <= var5 + var18 && var10; ++var14) {
+						if(var11 >= 0 && var11 < var1.height) {
+							var15 = var1.getBlockId(var13, var11, var14);
+							if(var15 != 0 && var15 != Block.leaves.blockID && var15 != Block.snow.blockID) {
+								var10 = false;
+							}
+						} else {
+							var10 = false;
+						}
+					}
+				}
+			}
+
+			if(!var10) {
+				return false;
+			} else {
+				var11 = var1.getBlockId(var3, var4 - 1, var5);
+				if((var11 == Block.grass.blockID || var11 == Block.dirt.blockID) && var4 < var1.height - var6 - 1) {
+					var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
+					var18 = 0;
+
+					for(var13 = var4 + var6; var13 >= var4 + var7; --var13) {
+						for(var14 = var3 - var18; var14 <= var3 + var18; ++var14) {
+							var15 = var14 - var3;
+
+							for(int var16 = var5 - var18; var16 <= var5 + var18; ++var16) {
+								int var17 = var16 - var5;
+								if((Math.abs(var15) != var18 || Math.abs(var17) != var18 || var18 <= 0) && !Block.opaqueCubeLookup[var1.getBlockId(var14, var13, var16)]) {
+									var1.setBlock(var14, var13, var16, Block.leaves.blockID);
+								}
+							}
+						}
+
+						if(var18 >= 1 && var13 == var4 + var7 + 1) {
+							--var18;
+						} else if(var18 < var9) {
+							++var18;
+						}
+					}
+
+					for(var13 = 0; var13 < var6 - 1; ++var13) {
+						var14 = var1.getBlockId(var3, var4 + var13, var5);
+						if(var14 == 0 || var14 == Block.leaves.blockID || var14 == Block.snow.blockID) {
+							var1.setBlock(var3, var4 + var13, var5, Block.wood.blockID);
+						}
+					}
+
+					return true;
+				} else {
+					return false;
+				}
+			}
+		} else {
+			return false;
+		}
+	}
+}
--- net/minecraft/client/gui/GuiLevelDialog.java
+++ net/minecraft/client/gui/GuiLevelDialog.java
@@ -21,8 +21,7 @@
 			}
 
 			var1.setDirectory(var5);
-			FilenameFilterLevel var6 = new FilenameFilterLevel(this);
-			var1.setFilenameFilter(var6);
+			var1.setFilenameFilter((f, s) -> s.toLowerCase().endsWith(".mclevel"));
 			var1.setLocationRelativeTo(this.screen.mc.mcCanvas);
 			var1.setVisible(true);
 			if(var1.getFile() != null) {
--- net/minecraft/game/level/EntityMap.java
+++ net/minecraft/game/level/EntityMap.java
@@ -94,13 +94,16 @@
 		return var2 == null ? this.entitiesExcludingEntity : this.getEntities(var1, var2.minX, var2.minY, var2.minZ, var2.maxX, var2.maxY, var2.maxZ, this.entitiesExcludingEntity);
 	}
 
-	public final void updateEntities() {
+	public final void updateEntities(int x, int y, int z, int dist, Entity playerEntity) {
 		for(int var1 = 0; var1 < this.entities.size(); ++var1) {
 			Entity var2 = (Entity)this.entities.get(var1);
 			var2.lastTickPosX = var2.posX;
 			var2.lastTickPosY = var2.posY;
 			var2.lastTickPosZ = var2.posZ;
-			var2.onEntityUpdate();
+			var2.notUpdating = var2 != playerEntity && var2.getDistanceSqToEntity(playerEntity) > dist * dist;
+			if (!var2.notUpdating) {
+				var2.onEntityUpdate();
+			}
 			if(var2.isDead) {
 				this.entities.remove(var1--);
 				this.slot.init(var2.lastTickPosX, var2.lastTickPosY, var2.lastTickPosZ).remove(var2);
--- net/minecraft/client/GuiMainMenu.java
+++ net/minecraft/client/GuiMainMenu.java
@@ -1,17 +1,140 @@
 package net.minecraft.client;
 
-import net.minecraft.client.gui.GuiButton;
-import net.minecraft.client.gui.GuiLoadLevel;
-import net.minecraft.client.gui.GuiNewLevel;
-import net.minecraft.client.gui.GuiOptions;
-import net.minecraft.client.gui.GuiScreen;
+import net.minecraft.client.gui.*;
 import net.minecraft.client.render.Tessellator;
 import org.lwjgl.opengl.GL11;
 import util.MathHelper;
 
+import java.io.IOException;
+
 public final class GuiMainMenu extends GuiScreen {
 	private float updateCounter = 0.0F;
-	private String[] splashes = new String[]{"Pre-beta!", "As seen on TV!", "Awesome!", "100% pure!", "May contain nuts!", "Better than Prey!", "More polygons!", "Sexy!", "Limited edition!", "Flashing letters!", "Made by Notch!", "Coming soon!", "Best in class!", "When it\'s finished!", "Absolutely dragon free!", "Excitement!", "More than 5000 sold!", "One of a kind!", "700+ hits on YouTube!", "Indev!", "Spiders everywhere!", "Check it out!", "Holy cow, man!", "It\'s a game!", "Made in Sweden!", "Uses LWJGL!", "Reticulating splines!", "Minecraft!", "Yaaay!", "Alpha version!", "Singleplayer!", "Keyboard compatible!", "Undocumented!", "Ingots!", "Exploding creepers!", "That\'s not a moon!", "l33t!", "Create!", "Survive!", "Dungeon!", "Exclusive!", "The bee\'s knees!", "Down with O.P.P.!", "Closed source!", "Classy!", "Wow!", "Not on steam!", "9.95 euro!", "Half price!", "Oh man!", "Check it out!", "Awesome community!", "Pixels!", "Teetsuuuuoooo!", "Kaaneeeedaaaa!", "Now with difficulty!", "Enhanced!", "90% bug free!", "Pretty!", "12 herbs and spices!", "Fat free!", "Absolutely no memes!", "Free dental!", "Ask your doctor!", "Minors welcome!", "Cloud computing!", "Legal in Finland!", "Hard to label!", "Technically good!", "Bringing home the bacon!", "Indie!", "GOTY!", "Ceci n\'est pas une title screen!", "Euclidian!", "Now in 3D!", "Inspirational!", "Herregud!", "Complex cellular automata!", "Yes, sir!", "Played by cowboys!", "OpenGL 1.1!", "Thousands of colors!", "Try it!", "Age of Wonders is better!", "Try the mushroom stew!", "Sensational!", "Hot tamale, hot hot tamale!", "Play him off, keyboard cat!", "Guaranteed!", "Macroscopic!", "Bring it on!", "Random splash!", "Call your mother!", "Monster infighting!", "Loved by millions!", "Ultimate edition!", "Freaky!", "You\'ve got a brand new key!", "Water proof!", "Uninflammable!", "Whoa, dude!", "All inclusive!", "Tell your friends!", "NP is not in P!", "Notch <3 Ez!", "Music by C418!"};
+	private String[] splashes = new String[]{"Pre-beta!",
+			"As seen on TV!",
+			"Awesome!",
+			"100% pure!",
+			"May contain nuts!",
+			"Better than Prey!",
+			"More polygons!",
+			"Sexy!",
+			"Limited edition!",
+			"Flashing letters!",
+			"Made by Notch!",
+			"Coming soon!",
+			"Best in class!",
+			"When it's finished!",
+			"Absolutely dragon free!",
+			"Excitement!",
+			"More than 5000 sold!",
+			"One of a kind!",
+			"700+ hits on YouTube!",
+			"Indev!",
+			"Spiders everywhere!",
+			"Check it out!",
+			"Holy cow, man!",
+			"It's a game!",
+			"Made in Sweden!",
+			"Uses LWJGL!",
+			"Reticulating splines!",
+			"Minecraft!",
+			"Yaaay!",
+			"Alpha version!",
+			"Singleplayer!",
+			"Keyboard compatible!",
+			"Undocumented!",
+			"Ingots!",
+			"Exploding creepers!",
+			"That's not a moon!",
+			"l33t!",
+			"Create!",
+			"Survive!",
+			"Dungeon!",
+			"Exclusive!",
+			"The bee's knees!",
+			"Down with O.P.P.!",
+			"Closed source!",
+			"Classy!",
+			"Wow!",
+			"Not on steam!",
+			"9.95 euro!",
+			"Half price!",
+			"Oh man!",
+			"Check it out!",
+			"Awesome community!",
+			"Pixels!",
+			"Teetsuuuuoooo!",
+			"Kaaneeeedaaaa!",
+			"Now with difficulty!",
+			"Enhanced!",
+			"90% bug free!",
+			"Pretty!",
+			"12 herbs and spices!",
+			"Fat free!",
+			"Absolutely no memes!",
+			"Free dental!",
+			"Ask your doctor!",
+			"Minors welcome!",
+			"Cloud computing!",
+			"Legal in Finland!",
+			"Hard to label!",
+			"Technically good!",
+			"Bringing home the bacon!",
+			"Indie!",
+			"GOTY!",
+			"Ceci n'est pas une title screen!",
+			"Euclidian!",
+			"Now in 3D!",
+			"Inspirational!",
+			"Herregud!",
+			"Complex cellular automata!",
+			"Yes, sir!",
+			"Played by cowboys!",
+			"OpenGL 1.1!",
+			"Thousands of colors!",
+			"Try it!",
+			"Age of Wonders is better!",
+			"Try the mushroom stew!",
+			"Sensational!",
+			"Hot tamale, hot hot tamale!",
+			"Play him off, keyboard cat!",
+			"Guaranteed!",
+			"Macroscopic!",
+			"Bring it on!",
+			"Random splash!",
+			"Call your mother!",
+			"Monster infighting!",
+			"Loved by millions!",
+			"Ultimate edition!",
+			"Freaky!",
+			"You've got a brand new key!",
+			"Water proof!",
+			"Uninflammable!",
+			"Whoa, dude!",
+			"All inclusive!",
+			"Tell your friends!",
+			"NP is not in P!",
+			"Notch <3 Ez!",
+			"Music by C418!",
+			"Ah, Yeah! This is happenin'!",
+			"Ah, Yeah! This could be fun!",
+			"Somethin' buggin' you?",
+			"Hey, there's no time to relax!",
+			"Also try Terraria!",
+			"Also try Minecraft Diverge!",
+			"Also try Better than Adventure!",
+			"Also try ReIndev!",
+			"Also try Classic+!",
+			"Also try Indev+!",
+			"Also try Infdev+!",
+			"Also try NSSS!",
+			"Also try New Frontier Craft!",
+			"Also try Voxels in Time!",
+			"Also try Classicube!",
+			"Also try Authentic Adventure!",
+			"Also try Betaria!",
+			"Also try Tropical Adventure!",
+			"Also try Beta 1.8.X!"
+	};
 	private String currentSplash = this.splashes[(int)(Math.random() * (double)this.splashes.length)];
 
 	public final void updateScreen() {
@@ -22,16 +145,10 @@
 	}
 
 	public final void initGui() {
-		this.controlList.clear();
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 48, "Generate new level..."));
-		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 72, "Load level.."));
-		this.controlList.add(new GuiButton(3, this.width / 2 - 100, this.height / 4 + 96, "Play tutorial level"));
 		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 120 + 12, "Options..."));
-		((GuiButton)this.controlList.get(2)).enabled = false;
-		if(this.mc.session == null) {
-			((GuiButton)this.controlList.get(1)).enabled = false;
-		}
-
+		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 48, "Play world..."));
+		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 72, "Generate new level..."));
+		this.controlList.add(new GuiButton(3, this.width / 2 - 100, this.height / 4 + 96, "Load level..."));
 	}
 
 	protected final void actionPerformed(GuiButton var1) {
@@ -39,11 +156,17 @@
 			this.mc.displayGuiScreen(new GuiOptions(this, this.mc.options));
 		}
 
-		if(var1.id == 1) {
+		if (var1.id == 1) {
+			this.mc.displayGuiScreen(new GuiLoadWorld(this));
+		}
+
+		if(var1.id == 2) {
+			this.mc.adventureMode = false;
 			this.mc.displayGuiScreen(new GuiNewLevel(this));
 		}
 
-		if(this.mc.session != null && var1.id == 2) {
+		if(var1.id == 3) {
+			this.mc.adventureMode = false;
 			this.mc.displayGuiScreen(new GuiLoadLevel(this));
 		}
 
@@ -52,10 +175,13 @@
 	public final void drawScreen(int var1, int var2, float var3) {
 		this.drawDefaultBackground();
 		Tessellator var4 = Tessellator.instance;
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/gui/logo.png"));
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 		var4.setColorOpaque_I(16777215);
 		this.drawTexturedModalRect((this.width - 256) / 2, 30, 0, 0, 256, 49);
+		GL11.glDisable(GL11.GL_BLEND);
 		GL11.glPushMatrix();
 		GL11.glTranslatef((float)(this.width / 2 + 90), 70.0F, 0.0F);
 		GL11.glRotatef(-20.0F, 0.0F, 0.0F, 1.0F);
--- /dev/null
+++ net/minecraft/client/gui/GuiSliderGeneric.java
@@ -1,0 +1,133 @@
+package net.minecraft.client.gui;
+
+import net.minecraft.client.Minecraft;
+
+import org.lwjgl.opengl.GL11;
+
+import java.util.function.Function;
+import java.util.function.UnaryOperator;
+
+public class GuiSliderGeneric extends GuiButton {
+	public final String label;
+	public float multiplier;
+	public float sliderValue;
+	public boolean round;
+	public boolean dragging;
+	public boolean vertical;
+	public boolean showMultiplier;
+	public Function<GuiSliderGeneric, String> formatter = s -> s.label + ": "
+			+ (s.round ? Integer.toString((int)s.getValue()) : Float.toString(s.getValue()))
+			+ (s.multiplier == 1.0F || !s.showMultiplier ? "" : " / "
+			+ (s.round ? Integer.toString((int)s.multiplier) : Float.toString(s.multiplier)));
+
+	public GuiSliderGeneric(int id, int x, int y, int w, int h, String label) {
+		super(id, x, y, w, h, label);
+		this.width = w;
+		this.height = h;
+		this.label = label;
+		this.displayString = this.getDisplayString();
+	}
+
+	protected byte getHoverState(boolean var1) {
+		return 0;
+	}
+
+	public float getValue() {
+		float value = this.sliderValue * this.multiplier;
+		if (round) {
+			value = Math.round(value);
+		}
+		return value;
+	}
+
+	public String getDisplayString() {
+		if (this.label == null) {
+			return "";
+		}
+
+		return this.formatter.apply(this);
+	}
+
+	public void updateText() {
+		this.displayString = getDisplayString();
+	}
+
+	protected void mouseDragged(Minecraft var1, int var2, int var3) {
+		if(this.visible) {
+			if(this.dragging) {
+				this.sliderValue = this.vertical
+						? (float)(var3 - (this.yPosition + 4)) / (float)(this.height - 8)
+						: (float)(var2 - (this.xPosition + 4)) / (float)(this.width - 8);
+				if(this.sliderValue < 0.0F) {
+					this.sliderValue = 0.0F;
+				}
+
+				if(this.sliderValue > 1.0F) {
+					this.sliderValue = 1.0F;
+				}
+
+				this.displayString = this.getDisplayString();
+			}
+
+
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			if (this.vertical) {
+				this.drawTexturedModalRect(this.xPosition, this.yPosition + (int)(this.sliderValue * (float)(this.height - 8)), 18, 112, this.width, 4);
+				this.drawTexturedModalRect(this.xPosition, this.yPosition + (int)(this.sliderValue * (float)(this.height - 8)) + 4, 18, 252, this.width, 4);
+			} else {
+				this.drawTexturedModalRect(this.xPosition + (int)(this.sliderValue * (float)(this.width - 8)), this.yPosition, 0, 66, 4, this.height);
+				this.drawTexturedModalRect(this.xPosition + (int)(this.sliderValue * (float)(this.width - 8)) + 4, this.yPosition, 196, 66, 4, this.height);
+			}
+		}
+	}
+
+	public boolean mousePressed(int var1, int var2) {
+		if(super.mousePressed(var1, var2)) {
+			this.sliderValue = this.vertical
+					? (float)(var1 - (this.yPosition + 4)) / (float)(this.height - 8)
+					: (float)(var1 - (this.xPosition + 4)) / (float)(this.width - 8);
+
+			if(this.sliderValue < 0.0F) {
+				this.sliderValue = 0.0F;
+			}
+
+			if(this.sliderValue > 1.0F) {
+				this.sliderValue = 1.0F;
+			}
+
+			this.dragging = true;
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	public void mouseReleased(int var1, int var2) {
+		this.dragging = false;
+	}
+
+	public void mouseScrolled(float delta) {
+		if (this.multiplier == 0.0F) return;
+
+		this.sliderValue -= delta / 120.0F / this.multiplier;
+
+		if(this.sliderValue < 0.0F) {
+			this.sliderValue = 0.0F;
+		}
+
+		if(this.sliderValue > 1.0F) {
+			this.sliderValue = 1.0F;
+		}
+	}
+
+	public void drawButton(Minecraft var1, int var2, int var3) {
+		if (this.visible) {
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, var1.renderEngine.getTexture("/gui/gui.png"));
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		}
+
+		if (!this.vertical) {
+			super.drawButton(var1, var2, var3);
+		}
+	}
+}
--- net/minecraft/client/render/entity/RenderPlayer.java
+++ net/minecraft/client/render/entity/RenderPlayer.java
@@ -8,6 +8,7 @@
 import net.minecraft.game.item.Item;
 import net.minecraft.game.item.ItemArmor;
 import net.minecraft.game.item.ItemStack;
+import org.lwjgl.opengl.GL11;
 
 public final class RenderPlayer extends RenderLiving {
 	private ModelBiped modelBipedMain = (ModelBiped)this.mainModel;
@@ -24,6 +25,7 @@
 	}
 
 	public final void drawFirstPersonHand() {
+		this.modelBipedMain.setFirstPersonHandAngles();
 		this.modelBipedMain.bipedRightArm.render(1.0F);
 	}
 
--- net/minecraft/game/level/generator/LevelGenerator.java
+++ net/minecraft/game/level/generator/LevelGenerator.java
@@ -1,13 +1,17 @@
 package net.minecraft.game.level.generator;
 
-import java.util.ArrayList;
-import java.util.Random;
+import java.util.*;
+
+import net.minecraft.game.item.ItemStack;
+import net.minecraft.game.level.EnumSkyBlock;
 import net.minecraft.game.level.MobSpawner;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.block.Block;
 import net.minecraft.game.level.block.BlockFlower;
-import net.minecraft.game.level.generator.noise.NoiseGeneratorDistort;
-import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+import net.minecraft.game.level.block.tileentity.TileEntityChest;
+import net.minecraft.game.level.generator.terrain.TerrainGenStage;
+import util.ByteArray3D;
+import util.IntArray2D;
 import util.IProgressUpdate;
 import util.MathHelper;
 
@@ -18,302 +22,125 @@
 	private int height;
 	private Random rand = new Random();
 	private byte[] blocksByteArray;
+	private ByteArray3D blockArray3D;
 	private int waterLevel;
 	private int groundLevel;
-	public boolean islandGen = false;
-	public boolean floatingGen = false;
-	public boolean flatGen = false;
-	public int levelType;
+	public LevelType levelType;
+	public LevelTheme levelTheme;
+	public LevelStructure levelStructure;
+	public boolean generateHouse = true;
+	public boolean spawnMobs = true;
+	public boolean survivalWorld = true;
 	private int phaseBar;
 	private int phases;
 	private float phaseBareLength = 0.0F;
 	private int[] floodFillBlocks = new int[1048576];
+	private Set<ChestPlacement> chestQueue = new HashSet<>();
+
+	private static class ChestPlacement {
+		final int x, y, z;
+		final ItemStack[] items;
+
+		public ChestPlacement(int x, int y, int z, ItemStack[] items) {
+			this.x = x;
+			this.y = y;
+			this.z = z;
+			this.items = items;
+		}
+	}
 
 	public LevelGenerator(IProgressUpdate var1) {
 		this.guiLoading = var1;
 	}
 
 	public final World generate(String var1, int var2, int var3, int var4) {
-		int var5 = 1;
-		if(this.floatingGen) {
-			var5 = (var4 - 64) / 48 + 1;
-		}
+		TerrainGenStage[] genStages = this.levelType.getTerrainGenStages(this.levelTheme);
+		TerrainGenStage[] structureStages = this.levelStructure.getTerrainGenStages(this.levelTheme);
+		int var5 = this.levelType.getLayerCount(var4);
 
-		this.phases = 13 + var5 * 4;
+		this.phases = 14 + var5 * genStages.length + structureStages.length;
 		this.guiLoading.displayProgressMessage("Generating level");
 		World var6 = new World();
+		Block fluid = levelTheme.getDefaultFluid();
+		var6.survivalWorld = this.survivalWorld;
 		var6.waterLevel = this.waterLevel;
 		var6.groundLevel = this.groundLevel;
-		this.width = var2;
-		this.depth = var3;
-		this.height = var4;
+		var6.width = this.width = var2;
+		var6.length = this.depth = var3;
+		var6.height = this.height = var4;
+		var6.levelType = this.levelType;
+		var6.levelTheme = this.levelTheme;
+		var6.levelStructure = this.levelStructure;
+		var6.skyColor = levelTheme.getSkyColor();
+		var6.fogColor = levelTheme.getFogColor();
+		var6.cloudColor = levelTheme.getCloudColor();
+		var6.skylightSubtracted = levelTheme.getSkylightSubtracted();
+		var6.skyBrightness = levelTheme.getSkyBrightness();
+		var6.defaultFluid = fluid != null ? fluid.blockID : 0;
 		this.blocksByteArray = new byte[var2 * var3 * var4];
+		this.blockArray3D = new ByteArray3D(this.blocksByteArray, var2, var3, var4);
 
 		int var7;
-		LevelGenerator var9;
-		int var21;
-		int var25;
-		int var31;
+		int x3;
+		int z;
+		int offsettedHeight;
 		int var45;
-		int var51;
-		int var52;
-		int var53;
+		int d;
+		int eX;
+		int eZ;
 		int var56;
+		IntArray2D heightmap = new IntArray2D(var2, var3);
 		for(var7 = 0; var7 < var5; ++var7) {
-			this.waterLevel = var4 - 32 - var7 * 48;
-			this.groundLevel = this.waterLevel - 2;
-			int[] var8;
-			NoiseGeneratorOctaves var13;
-			int var22;
-			double var32;
-			int[] var46;
-			if(this.flatGen) {
-				var8 = new int[var2 * var3];
-
-				for(var45 = 0; var45 < var8.length; ++var45) {
-					var8[var45] = 0;
-				}
-
-				this.loadingBar();
-				this.loadingBar();
-			} else {
-				this.guiLoading.displayLoadingString("Raising..");
-				this.loadingBar();
-				var9 = this;
-				NoiseGeneratorDistort var10 = new NoiseGeneratorDistort(new NoiseGeneratorOctaves(this.rand, 8), new NoiseGeneratorOctaves(this.rand, 8));
-				NoiseGeneratorDistort var11 = new NoiseGeneratorDistort(new NoiseGeneratorOctaves(this.rand, 8), new NoiseGeneratorOctaves(this.rand, 8));
-				NoiseGeneratorOctaves var12 = new NoiseGeneratorOctaves(this.rand, 6);
-				var13 = new NoiseGeneratorOctaves(this.rand, 2);
-				int[] var14 = new int[this.width * this.depth];
-				var22 = 0;
-
-				label349:
-				while(true) {
-					if(var22 >= var9.width) {
-						var8 = var14;
-						this.guiLoading.displayLoadingString("Eroding..");
-						this.loadingBar();
-						var46 = var14;
-						var9 = this;
-						var11 = new NoiseGeneratorDistort(new NoiseGeneratorOctaves(this.rand, 8), new NoiseGeneratorOctaves(this.rand, 8));
-						NoiseGeneratorDistort var50 = new NoiseGeneratorDistort(new NoiseGeneratorOctaves(this.rand, 8), new NoiseGeneratorOctaves(this.rand, 8));
-						var52 = 0;
-
-						while(true) {
-							if(var52 >= var9.width) {
-								break label349;
-							}
-
-							var9.setNextPhase((float)var52 * 100.0F / (float)(var9.width - 1));
-
-							for(var53 = 0; var53 < var9.depth; ++var53) {
-								double var20 = var11.generateNoise((double)(var52 << 1), (double)(var53 << 1)) / 8.0D;
-								var22 = var50.generateNoise((double)(var52 << 1), (double)(var53 << 1)) > 0.0D ? 1 : 0;
-								if(var20 > 2.0D) {
-									int var58 = var46[var52 + var53 * var9.width];
-									var58 = ((var58 - var22) / 2 << 1) + var22;
-									var46[var52 + var53 * var9.width] = var58;
-								}
-							}
-
-							++var52;
-						}
-					}
-
-					double var23 = Math.abs(((double)var22 / ((double)var9.width - 1.0D) - 0.5D) * 2.0D);
-					var9.setNextPhase((float)var22 * 100.0F / (float)(var9.width - 1));
-
-					for(var25 = 0; var25 < var9.depth; ++var25) {
-						double var26 = Math.abs(((double)var25 / ((double)var9.depth - 1.0D) - 0.5D) * 2.0D);
-						double var28 = var10.generateNoise((double)((float)var22 * 1.3F), (double)((float)var25 * 1.3F)) / 6.0D + -4.0D;
-						double var30 = var11.generateNoise((double)((float)var22 * 1.3F), (double)((float)var25 * 1.3F)) / 5.0D + 10.0D + -4.0D;
-						var32 = var12.generateNoise((double)var22, (double)var25) / 8.0D;
-						if(var32 > 0.0D) {
-							var30 = var28;
-						}
-
-						double var34 = Math.max(var28, var30) / 2.0D;
-						if(var9.islandGen) {
-							double var36 = Math.sqrt(var23 * var23 + var26 * var26) * (double)1.2F;
-							double var39 = var13.generateNoise((double)((float)var22 * 0.05F), (double)((float)var25 * 0.05F)) / 4.0D + 1.0D;
-							var36 = Math.min(var36, var39);
-							var36 = Math.max(var36, Math.max(var23, var26));
-							if(var36 > 1.0D) {
-								var36 = 1.0D;
-							}
-
-							if(var36 < 0.0D) {
-								var36 = 0.0D;
-							}
-
-							var36 *= var36;
-							var34 = var34 * (1.0D - var36) - var36 * 10.0D + 5.0D;
-							if(var34 < 0.0D) {
-								var34 -= var34 * var34 * (double)0.2F;
-							}
-						} else if(var34 < 0.0D) {
-							var34 *= 0.8D;
-						}
-
-						var14[var22 + var25 * var9.width] = (int)var34;
-					}
-
-					++var22;
-				}
-			}
-
-			this.guiLoading.displayLoadingString("Soiling..");
-			this.loadingBar();
-			var46 = var8;
-			var9 = this;
-			int var49 = this.width;
-			var51 = this.depth;
-			var52 = this.height;
-			NoiseGeneratorOctaves var54 = new NoiseGeneratorOctaves(this.rand, 8);
-			NoiseGeneratorOctaves var55 = new NoiseGeneratorOctaves(this.rand, 8);
-
-			for(var21 = 0; var21 < var49; ++var21) {
-				double var57 = Math.abs(((double)var21 / ((double)var49 - 1.0D) - 0.5D) * 2.0D);
-				var9.setNextPhase((float)var21 * 100.0F / (float)(var49 - 1));
-
-				for(int var24 = 0; var24 < var51; ++var24) {
-					double var64 = Math.abs(((double)var24 / ((double)var51 - 1.0D) - 0.5D) * 2.0D);
-					double var27 = Math.max(var57, var64);
-					var27 = var27 * var27 * var27;
-					int var29 = (int)(var54.generateNoise((double)var21, (double)var24) / 24.0D) - 4;
-					int var72 = var46[var21 + var24 * var49] + var9.waterLevel;
-					var31 = var72 + var29;
-					var46[var21 + var24 * var49] = Math.max(var72, var31);
-					if(var46[var21 + var24 * var49] > var52 - 2) {
-						var46[var21 + var24 * var49] = var52 - 2;
-					}
-
-					if(var46[var21 + var24 * var49] <= 0) {
-						var46[var21 + var24 * var49] = 1;
-					}
-
-					var32 = var55.generateNoise((double)var21 * 2.3D, (double)var24 * 2.3D) / 24.0D;
-					int var76 = (int)(Math.sqrt(Math.abs(var32)) * Math.signum(var32) * 20.0D) + var9.waterLevel;
-					var76 = (int)((double)var76 * (1.0D - var27) + var27 * (double)var9.height);
-					if(var76 > var9.waterLevel) {
-						var76 = var9.height;
-					}
-
-					for(int var35 = 0; var35 < var52; ++var35) {
-						int var79 = (var35 * var9.depth + var24) * var9.width + var21;
-						int var37 = 0;
-						if(var35 <= var72) {
-							var37 = Block.dirt.blockID;
-						}
-
-						if(var35 <= var31) {
-							var37 = Block.stone.blockID;
-						}
-
-						if(var9.floatingGen && var35 < var76) {
-							var37 = 0;
-						}
-
-						if(var9.blocksByteArray[var79] == 0) {
-							var9.blocksByteArray[var79] = (byte)var37;
-						}
-					}
-				}
-			}
-
-			this.guiLoading.displayLoadingString("Growing..");
-			this.loadingBar();
-			var46 = var8;
-			var9 = this;
-			var49 = this.width;
-			var51 = this.depth;
-			var13 = new NoiseGeneratorOctaves(this.rand, 8);
-			var54 = new NoiseGeneratorOctaves(this.rand, 8);
-			var56 = this.waterLevel - 1;
-			if(this.levelType == 2) {
-				var56 += 2;
-			}
-
-			for(var21 = 0; var21 < var49; ++var21) {
-				var9.setNextPhase((float)var21 * 100.0F / (float)(var49 - 1));
-
-				for(var22 = 0; var22 < var51; ++var22) {
-					boolean var60 = var13.generateNoise((double)var21, (double)var22) > 8.0D;
-					if(var9.islandGen) {
-						var60 = var13.generateNoise((double)var21, (double)var22) > -8.0D;
-					}
-
-					if(var9.levelType == 2) {
-						var60 = var13.generateNoise((double)var21, (double)var22) > -32.0D;
-					}
-
-					boolean var61 = var54.generateNoise((double)var21, (double)var22) > 12.0D;
-					if(var9.levelType == 1 || var9.levelType == 3) {
-						var60 = var13.generateNoise((double)var21, (double)var22) > -8.0D;
-					}
-
-					var25 = var46[var21 + var22 * var49];
-					int var65 = (var25 * var9.depth + var22) * var9.width + var21;
-					int var67 = var9.blocksByteArray[((var25 + 1) * var9.depth + var22) * var9.width + var21] & 255;
-					if((var67 == Block.waterMoving.blockID || var67 == Block.waterStill.blockID || var67 == 0) && var25 <= var9.waterLevel - 1 && var61) {
-						var9.blocksByteArray[var65] = (byte)Block.gravel.blockID;
-					}
-
-					if(var67 == 0) {
-						int var69 = -1;
-						if(var25 <= var56 && var60) {
-							var69 = Block.sand.blockID;
-							if(var9.levelType == 1) {
-								var69 = Block.grass.blockID;
-							}
-						}
-
-						if(var9.blocksByteArray[var65] != 0 && var69 > 0) {
-							var9.blocksByteArray[var65] = (byte)var69;
-						}
-					}
-				}
-			}
+			var6.waterLevel = this.waterLevel = Math.max(this.levelType.getGenHeight(var4, var7), 2);
+			var6.groundLevel = this.groundLevel = Math.max(this.waterLevel - 2, 1);
+
+			for (TerrainGenStage genStage : genStages) {
+				this.guiLoading.displayLoadingString(genStage.name);
+				this.setNextPhase(0.0F);
+				genStage.blockTransformer.transformBlocks(this.blockArray3D, heightmap, this.rand, var6, this::setNextPhase,
+						(cx, cy, cz) -> this.queueChest(cx, cy, cz, genStage.getChestItems(this.rand)));
+				this.loadingBar();
+			}
+			heightmap.clear();
 		}
 
 		this.guiLoading.displayLoadingString("Carving..");
 		this.loadingBar();
-		var9 = this;
-		var51 = this.width;
-		var52 = this.depth;
-		var53 = this.height;
-		var56 = var51 * var52 * var53 / 256 / 64 << 1;
+		d = this.width;
+		eX = this.depth;
+		eZ = this.height;
+		var56 = d * eX * eZ / 256 / 48;
 
-		for(var21 = 0; var21 < var56; ++var21) {
-			var9.setNextPhase((float)var21 * 100.0F / (float)(var56 - 1));
-			float var59 = var9.rand.nextFloat() * (float)var51;
-			float var63 = var9.rand.nextFloat() * (float)var53;
-			float var62 = var9.rand.nextFloat() * (float)var52;
-			var25 = (int)((var9.rand.nextFloat() + var9.rand.nextFloat()) * 200.0F);
-			float var66 = var9.rand.nextFloat() * (float)Math.PI * 2.0F;
+		for(x3 = 0; x3 < var56; ++x3) {
+			this.setNextPhase((float)x3 * 100.0F / (float)(var56 - 1));
+			float var59 = this.rand.nextFloat() * (float)d;
+			float var63 = this.rand.nextFloat() * (float)eZ;
+			float var62 = this.rand.nextFloat() * (float)eX;
+			z = (int)((this.rand.nextFloat() + this.rand.nextFloat()) * 250.0F);
+			float var66 = this.rand.nextFloat() * (float)Math.PI * 2.0F;
 			float var68 = 0.0F;
-			float var71 = var9.rand.nextFloat() * (float)Math.PI * 2.0F;
+			float var71 = this.rand.nextFloat() * (float)Math.PI * 2.0F;
 			float var70 = 0.0F;
-			float var73 = var9.rand.nextFloat() * var9.rand.nextFloat();
+			float var73 = this.rand.nextFloat() * (this.rand.nextFloat() * 0.65F + 0.35F);
 
-			for(var31 = 0; var31 < var25; ++var31) {
+			for(offsettedHeight = 0; offsettedHeight < z; ++offsettedHeight) {
 				var59 += MathHelper.sin(var66) * MathHelper.cos(var71);
 				var62 += MathHelper.cos(var66) * MathHelper.cos(var71);
 				var63 += MathHelper.sin(var71);
 				var66 += var68 * 0.2F;
 				var68 *= 0.9F;
-				var68 += var9.rand.nextFloat() - var9.rand.nextFloat();
+				var68 += this.rand.nextFloat() - this.rand.nextFloat();
 				var71 += var70 * 0.5F;
 				var71 *= 0.5F;
 				var70 *= 12.0F / 16.0F;
-				var70 += var9.rand.nextFloat() - var9.rand.nextFloat();
-				if(var9.rand.nextFloat() >= 0.25F) {
-					float var74 = var59 + (var9.rand.nextFloat() * 4.0F - 2.0F) * 0.2F;
-					float var33 = var63 + (var9.rand.nextFloat() * 4.0F - 2.0F) * 0.2F;
-					float var77 = var62 + (var9.rand.nextFloat() * 4.0F - 2.0F) * 0.2F;
-					float var75 = ((float)var9.height - var33) / (float)var9.height;
-					float var80 = 1.2F + (var75 * 3.5F + 1.0F) * var73;
-					float var78 = MathHelper.sin((float)var31 * (float)Math.PI / (float)var25) * var80;
+				var70 += this.rand.nextFloat() - this.rand.nextFloat();
+				if(this.rand.nextFloat() >= 0.25F) {
+					float var74 = var59 + (this.rand.nextFloat() * 4.0F - 2.0F) * 0.2F;
+					float var33 = var63 + (this.rand.nextFloat() * 4.0F - 2.0F) * 0.2F;
+					float var77 = var62 + (this.rand.nextFloat() * 4.0F - 2.0F) * 0.2F;
+					float var75 = ((float)this.height - var33) / (float)this.height;
+					float var80 = 1.5F + (var75 * 3.5F + 1.0F) * var73;
+					float var78 = MathHelper.sin((float)offsettedHeight * (float)Math.PI / (float)z) * var80;
 
 					for(var5 = (int)(var74 - var78); var5 <= (int)(var74 + var78); ++var5) {
 						for(int var81 = (int)(var33 - var78); var81 <= (int)(var33 + var78); ++var81) {
@@ -322,10 +149,11 @@
 								float var42 = (float)var81 - var33;
 								float var48 = (float)var40 - var77;
 								var41 = var41 * var41 + var42 * var42 * 2.0F + var48 * var48;
-								if(var41 < var78 * var78 && var5 > 0 && var81 > 0 && var40 > 0 && var5 < var9.width - 1 && var81 < var9.height - 1 && var40 < var9.depth - 1) {
-									var7 = (var81 * var9.depth + var40) * var9.width + var5;
-									if(var9.blocksByteArray[var7] == Block.stone.blockID) {
-										var9.blocksByteArray[var7] = 0;
+								if(var41 < var78 * var78 && var5 > 0 && var81 > 0 && var40 > 0 && var5 < this.width - 1 && var81 < this.height - 1 && var40 < this.depth - 1) {
+									var7 = (var81 * this.depth + var40) * this.width + var5;
+									int b = this.blocksByteArray[var7];
+									if(b == Block.stone.blockID) {
+										this.blocksByteArray[var7] = 0;
 									}
 								}
 							}
@@ -335,133 +163,131 @@
 			}
 		}
 
-		var7 = this.populateOre(Block.oreCoal.blockID, 1000, 10, (var4 << 2) / 5);
+		var7 = this.populateOre(Block.oreCoal.blockID, 1000, 10, var4 * 4 / 5);
 		int var44 = this.populateOre(Block.oreIron.blockID, 800, 8, var4 * 3 / 5);
-		var45 = this.populateOre(Block.oreGold.blockID, 500, 6, (var4 << 1) / 5);
+		int varC = this.populateOre(Block.oreCopper.blockID, 500, 6, var4 * 2 / 5);
+		var45 = this.populateOre(Block.oreGold.blockID, 500, 6, var4 * 2 / 5);
 		var5 = this.populateOre(Block.oreDiamond.blockID, 800, 2, var4 / 5);
-		System.out.println("Coal: " + var7 + ", Iron: " + var44 + ", Gold: " + var45 + ", Diamond: " + var5);
+		System.out.println("Coal: " + var7 + ", Iron: " + var44 + ", Gold: " + var45 + ", Copper: " + varC + ", Diamond: " + var5);
 		this.guiLoading.displayLoadingString("Melting..");
 		this.loadingBar();
 		this.lavaGen();
-		var6.cloudHeight = var4 + 2;
-		if(this.floatingGen) {
-			this.groundLevel = -128;
-			this.waterLevel = this.groundLevel + 1;
-			var6.cloudHeight = -16;
-		} else if(!this.islandGen) {
-			this.groundLevel = this.waterLevel + 1;
-			this.waterLevel = this.groundLevel - 16;
-		} else {
-			this.groundLevel = this.waterLevel - 9;
-		}
+		var6.cloudHeight = this.levelType.getCloudHeight(var4, this.waterLevel);
+		this.groundLevel = this.levelType.modifyGroundLevel(this.groundLevel, this.waterLevel);
+		this.waterLevel = this.levelType.modifyWaterLevel(this.groundLevel, this.waterLevel);
 
 		this.guiLoading.displayLoadingString("Watering..");
 		this.loadingBar();
 		this.liquidThemeSpawner();
-		if(!this.floatingGen) {
-			var5 = Block.waterStill.blockID;
-			if(this.levelType == 1) {
-				var5 = Block.lavaStill.blockID;
-			}
-
-			for(var7 = 0; var7 < var2; ++var7) {
-				this.floodFill(var7, this.waterLevel - 1, 0, 0, var5);
-				this.floodFill(var7, this.waterLevel - 1, var3 - 1, 0, var5);
-			}
-
-			for(var7 = 0; var7 < var3; ++var7) {
-				this.floodFill(var2 - 1, this.waterLevel - 1, var7, 0, var5);
-				this.floodFill(0, this.waterLevel - 1, var7, 0, var5);
-			}
-		}
-
-		if(this.levelType == 0) {
-			var6.skyColor = 10079487;
-			var6.fogColor = 16777215;
-			var6.cloudColor = 16777215;
-		}
-
-		if(this.levelType == 1) {
-			var6.cloudColor = 2164736;
-			var6.fogColor = 1049600;
-			var6.skyColor = 1049600;
-			var6.skylightSubtracted = var6.skyBrightness = 7;
-			var6.defaultFluid = Block.lavaMoving.blockID;
-			if(this.floatingGen) {
-				var6.cloudHeight = var4 + 2;
-				this.waterLevel = -16;
-			}
-		}
-
-		if(this.levelType == 2) {
-			var6.skyColor = 13033215;
-			var6.fogColor = 13033215;
-			var6.cloudColor = 15658751;
-			var6.skylightSubtracted = var6.skyBrightness = 15;
-			var6.skyBrightness = 16;
-			var6.cloudHeight = var4 + 64;
-		}
-
-		if(this.levelType == 3) {
-			var6.skyColor = 7699847;
-			var6.fogColor = 5069403;
-			var6.cloudColor = 5069403;
-			var6.skylightSubtracted = var6.skyBrightness = 12;
-		}
+		if(this.levelType.doEdgeFloodFill() && this.groundLevel <= this.waterLevel) {
+			fluid = this.levelTheme.getStillFluid();
+			if (fluid != null) {
+				var5 = fluid.blockID;
+
+				for(var7 = 0; var7 < var2; ++var7) {
+					this.floodFill(var7, this.waterLevel - 1, 0, 0, var5);
+					this.floodFill(var7, this.waterLevel - 1, var3 - 1, 0, var5);
+				}
+
+				for(var7 = 0; var7 < var3; ++var7) {
+					this.floodFill(var2 - 1, this.waterLevel - 1, var7, 0, var5);
+					this.floodFill(0, this.waterLevel - 1, var7, 0, var5);
+				}
+			}
+		}
+
+		var6.cloudHeight = levelTheme.modifyCloudHeight(var6.cloudHeight, var4, levelType);
+		this.waterLevel = levelTheme.modifyWaterLevel(this.waterLevel, levelType);
 
 		var6.waterLevel = this.waterLevel;
 		var6.groundLevel = this.groundLevel;
+
+		for (TerrainGenStage structureStage : structureStages) {
+			this.guiLoading.displayLoadingString(structureStage.name);
+			this.setNextPhase(0.0F);
+			structureStage.blockTransformer.transformBlocks(this.blockArray3D, heightmap, this.rand, var6, this::setNextPhase,
+					(cx, cy, cz) -> this.queueChest(cx, cy, cz, structureStage.getChestItems(this.rand)));
+			this.loadingBar();
+		}
+
 		this.guiLoading.displayLoadingString("Assembling..");
 		this.loadingBar();
 		this.setNextPhase(0.0F);
-		var6.generate(var2, var4, var3, this.blocksByteArray, (byte[])null);
+		var6.generate(var2, var4, var3, this.blocksByteArray, null, null, null);
 		this.guiLoading.displayLoadingString("Building..");
 		this.loadingBar();
 		this.setNextPhase(0.0F);
-		var6.findSpawn();
-		generateHouse(var6);
+
+		System.out.println("Chests: " + this.chestQueue.size());
+		for (ChestPlacement chest : this.chestQueue) {
+			if (var6.getBlockId(chest.x, chest.y, chest.z) == Block.crate.blockID) {
+				continue;
+			}
+
+			TileEntityChest chestTileEntity = new TileEntityChest();
+			for (int i = 0; i < chest.items.length; i++) {
+				chestTileEntity.setInventorySlotContents(i, chest.items[i]);
+			}
+
+			var6.setBlock(chest.x, chest.y, chest.z, Block.crate.blockID);
+			var6.setBlockTileEntity(chest.x, chest.y, chest.z, chestTileEntity);
+		}
+
+		var6.findSpawn(this.rand);
+		if (this.generateHouse) {
+			generateHouse(var6);
+		}
 		this.guiLoading.displayLoadingString("Planting..");
 		this.loadingBar();
-		if(this.levelType != 1) {
+		if (this.levelTheme.growGrassOnDirt()) {
 			this.growGrassOnDirt(var6);
 		}
 
 		this.loadingBar();
 		this.growTrees(var6);
-		if(this.levelType == 3) {
-			for(var5 = 0; var5 < 50; ++var5) {
-				this.growTrees(var6);
-			}
-		}
 
-		short var43 = 100;
-		if(this.levelType == 2) {
-			var43 = 1000;
-		}
+		int var43 = this.levelTheme.getFlowerCount();
+		int var43a = this.levelTheme.getMushroomCount();
 
 		this.loadingBar();
 		this.populateFlowersAndMushrooms(var6, Block.plantYellow, var43);
 		this.loadingBar();
 		this.populateFlowersAndMushrooms(var6, Block.plantRed, var43);
 		this.loadingBar();
-		this.populateFlowersAndMushrooms(var6, Block.mushroomBrown, 50);
-		this.loadingBar();
-		this.populateFlowersAndMushrooms(var6, Block.mushroomRed, 50);
-		this.guiLoading.displayLoadingString("Lighting..");
-		this.loadingBar();
+		this.populateFlowersAndMushrooms(var6, Block.plantBlue, var43);
+		this.loadingBar();
+		this.populateFlowersAndMushrooms(var6, Block.mushroomBrown, var43a);
+		this.loadingBar();
+		this.populateFlowersAndMushrooms(var6, Block.mushroomRed, var43a);
+		this.guiLoading.displayLoadingString("Lighting.. (Initializing)");
+		this.loadingBar();
+		var6.initLighting();
 
-		for(var7 = 0; var7 < 10000; ++var7) {
-			this.setNextPhase((float)(var7 * 100 / 10000));
-			var6.updateLighting();
+		for (EnumSkyBlock skyBlock : EnumSkyBlock.values()) {
+			var6.scheduleLightingUpdate(skyBlock, 0, 0, 0, var6.width, var6.height, var6.length);
+			int lightingUpdates = 10000;
+			int maxQueue = var6.getLightingQueue();
+			while (var6.updatingLighting() && lightingUpdates > 0) {
+				int queue = var6.getLightingQueue();
+				if (queue > maxQueue) {
+					maxQueue = queue;
+				}
+				this.guiLoading.displayLoadingString("Lighting.. (" + (skyBlock == EnumSkyBlock.Sky ? "Sky " : "Block ") + queue + " / " + maxQueue + ")");
+				this.setNextPhase((maxQueue - queue) * 100.0F / maxQueue);
+				lightingUpdates--;
+			}
 		}
 
 		this.guiLoading.displayLoadingString("Spawning..");
 		this.loadingBar();
-		MobSpawner var47 = new MobSpawner(var6);
-
-		for(var2 = 0; var2 < 1000; ++var2) {
-			this.setNextPhase((float)var2 * 100.0F / 999.0F);
-			var47.performSpawning();
+
+		if (this.spawnMobs) {
+			MobSpawner var47 = new MobSpawner(var6);
+
+			for(var2 = 0; var2 < 1000; ++var2) {
+				this.setNextPhase((float)var2 * 100.0F / 999.0F);
+				var47.performSpawning();
+			}
 		}
 
 		var6.createTime = System.currentTimeMillis();
@@ -474,6 +300,10 @@
 		}
 	}
 
+	private void queueChest(int x, int y, int z, ItemStack[] items) {
+		this.chestQueue.add(new ChestPlacement(x, y, z, items));
+	}
+
 	private static void generateHouse(World var0) {
 		int var1 = var0.xSpawn;
 		int var2 = var0.ySpawn;
@@ -507,45 +337,33 @@
 		for(int var2 = 0; var2 < this.width; ++var2) {
 			this.setNextPhase((float)var2 * 100.0F / (float)(this.width - 1));
 
-			for(int var3 = 0; var3 < this.height; ++var3) {
-				for(int var4 = 0; var4 < this.depth; ++var4) {
+			for(int var4 = 0; var4 < this.depth; ++var4) {
+				for(int var3 = 0; var3 < this.height; ++var3) {
 					if(var1.getBlockId(var2, var3, var4) == Block.dirt.blockID && var1.getBlockLightValue(var2, var3 + 1, var4) >= 4 && !var1.getBlockMaterial(var2, var3 + 1, var4).getCanBlockGrass()) {
 						var1.setBlock(var2, var3, var4, Block.grass.blockID);
 					}
 				}
+
+				if (this.levelTheme.hasSnow()) {
+					for (int var3 = this.height - 1; var3 > 0; var3--) {
+						Block ground = Block.blocksList[blocksByteArray[((var3 - 1) * this.depth + var4) * this.width + var2]];
+						if (ground != null) {
+							if (ground.isOpaqueCube() && ground.material.getIsSolid() && blocksByteArray[(var3 * this.depth + var4) * this.width + var2] == 0) {
+								blocksByteArray[(var3 * this.depth + var4) * this.width + var2] = (byte)Block.snow.blockID;
+							} else if (ground == Block.waterStill || ground == Block.waterMoving) {
+								blocksByteArray[((var3 - 1) * this.depth + var4) * this.width + var2] = (byte)Block.ice.blockID;
+							}
+							break;
+						}
+					}
+				}
 			}
 		}
 
 	}
 
 	private void growTrees(World var1) {
-		int var2 = this.width * this.depth * this.height / 80000;
-
-		for(int var3 = 0; var3 < var2; ++var3) {
-			if(var3 % 100 == 0) {
-				this.setNextPhase((float)var3 * 100.0F / (float)(var2 - 1));
-			}
-
-			int var4 = this.rand.nextInt(this.width);
-			int var5 = this.rand.nextInt(this.height);
-			int var6 = this.rand.nextInt(this.depth);
-
-			for(int var7 = 0; var7 < 25; ++var7) {
-				int var8 = var4;
-				int var9 = var5;
-				int var10 = var6;
-
-				for(int var11 = 0; var11 < 20; ++var11) {
-					var8 += this.rand.nextInt(12) - this.rand.nextInt(12);
-					var9 += this.rand.nextInt(3) - this.rand.nextInt(6);
-					var10 += this.rand.nextInt(12) - this.rand.nextInt(12);
-					if(var8 >= 0 && var9 >= 0 && var10 >= 0 && var8 < this.width && var9 < this.height && var10 < this.depth) {
-						var1.growTrees(var8, var9, var10);
-					}
-				}
-			}
-		}
-
+		this.levelTheme.growTrees(var1, this.rand, this::setNextPhase);
 	}
 
 	private void populateFlowersAndMushrooms(World var1, BlockFlower var2, int var3) {
@@ -570,7 +388,7 @@
 					var10 += this.rand.nextInt(2) - this.rand.nextInt(2);
 					var11 += this.rand.nextInt(4) - this.rand.nextInt(4);
 					if(var9 >= 0 && var11 >= 0 && var10 > 0 && var9 < this.width && var11 < this.depth && var10 < this.height && var1.getBlockId(var9, var10, var11) == 0 && var2.canBlockStay(var1, var9, var10, var11)) {
-						var1.setBlockWithNotify(var9, var10, var11, var2.blockID);
+						var1.setBlock(var9, var10, var11, var2.blockID);
 					}
 				}
 			}
@@ -636,12 +454,14 @@
 	}
 
 	private void liquidThemeSpawner() {
-		int var1 = Block.waterStill.blockID;
-		if(this.levelType == 1) {
-			var1 = Block.lavaStill.blockID;
+		Block fluid = this.levelTheme.getStillFluid();
+		if (this.levelType.getLakeRarity() <= 0 || fluid == null) {
+			return;
 		}
 
-		int var2 = this.width * this.depth * this.height / 1000;
+		int var1 = fluid.blockID;
+		int var2 = this.width * this.depth * this.height / this.levelType.getLakeRarity();
+		long lakeSize = this.levelType.getMaxLakeSize();
 
 		for(int var3 = 0; var3 < var2; ++var3) {
 			if(var3 % 100 == 0) {
@@ -649,11 +469,11 @@
 			}
 
 			int var4 = this.rand.nextInt(this.width);
-			int var5 = this.rand.nextInt(this.height);
+			int var5 = this.rand.nextInt(this.height / 2 + 8) + this.height / 2 - 8;
 			int var6 = this.rand.nextInt(this.depth);
 			if(this.blocksByteArray[(var5 * this.depth + var6) * this.width + var4] == 0) {
-				long var7 = this.floodFill(var4, var5, var6, 0, 255);
-				if(var7 > 0L && var7 < 640L) {
+				long var7 = this.floodFill(var4, var5, var6, 0, 255, lakeSize);
+				if(var7 > 0L && (var7 < lakeSize || lakeSize <= 0)) {
 					this.floodFill(var4, var5, var6, 255, var1);
 				} else {
 					this.floodFill(var4, var5, var6, 255, 0);
@@ -674,7 +494,7 @@
 		if(var1 < 0.0F) {
 			throw new IllegalStateException("Failed to set next phase!");
 		} else {
-			int var2 = (int)(((float)(this.phaseBar - 1) + var1 / 100.0F) * 100.0F / (float)this.phases);
+			int var2 = (int)(((float)(this.phaseBar) + var1 / 100.0F) * 100.0F / (float)(this.phases + 1));
 			this.guiLoading.setLoadingProgress(var2);
 		}
 	}
@@ -692,7 +512,7 @@
 			int var5 = Math.min(Math.min(this.rand.nextInt(var2), this.rand.nextInt(var2)), Math.min(this.rand.nextInt(var2), this.rand.nextInt(var2)));
 			int var6 = this.rand.nextInt(this.depth);
 			if(this.blocksByteArray[(var5 * this.depth + var6) * this.width + var4] == 0) {
-				long var7 = this.floodFill(var4, var5, var6, 0, 255);
+				long var7 = this.floodFill(var4, var5, var6, 0, 255, 640L);
 				if(var7 > 0L && var7 < 640L) {
 					this.floodFill(var4, var5, var6, 255, Block.lavaStill.blockID);
 				} else {
@@ -704,69 +524,88 @@
 		this.setNextPhase(100.0F);
 	}
 
-	private long floodFill(int var1, int var2, int var3, int var4, int var5) {
+	private long floodFill(int sx, int sy, int sz, int var4, int var5) {
+		return this.floodFill(sx,  sy, sz, var4, var5, 0L);
+	}
+
+	private long floodFill(int sx, int sy, int sz, int var4, int var5, long var5a) {
 		byte var6 = (byte)var5;
 		byte var22 = (byte)var4;
 		ArrayList var7 = new ArrayList();
 		byte var8 = 0;
-		int var9 = 1;
-
-		int var10;
-		for(var10 = 1; 1 << var9 < this.width; ++var9) {
-		}
-
-		while(1 << var10 < this.depth) {
-			++var10;
-		}
-
-		int var11 = this.depth - 1;
-		int var12 = this.width - 1;
+		int widthOff = 1;
+
+		int depthOff;
+		for(depthOff = 1; 1 << widthOff < this.width; ++widthOff) {
+		}
+
+		while(1 << depthOff < this.depth) {
+			++depthOff;
+		}
+
+		int depthClip = 1;
+		int widthClip = 1;
+
+		while (depthClip < this.depth - 1) {
+			depthClip <<= 1;
+			depthClip |= 1;
+		}
+
+		while (widthClip < this.width - 1) {
+			widthClip <<= 1;
+			widthClip |= 1;
+		}
+
 		int var23 = var8 + 1;
-		this.floodFillBlocks[0] = ((var2 << var10) + var3 << var9) + var1;
+		this.floodFillBlocks[0] = ((sy << depthOff) + sz << widthOff) + sx;
 		long var14 = 0L;
-		var1 = this.width * this.depth;
+		sx = this.width * this.depth;
 
 		while(var23 > 0) {
 			--var23;
-			var2 = this.floodFillBlocks[var23];
+			sy = this.floodFillBlocks[var23];
 			if(var23 == 0 && var7.size() > 0) {
 				this.floodFillBlocks = (int[])var7.remove(var7.size() - 1);
 				var23 = this.floodFillBlocks.length;
 			}
 
-			var3 = var2 >> var9 & var11;
-			int var13 = var2 >> var9 + var10;
-			int var16 = var2 & var12;
-
-			int var17;
-			for(var17 = var16; var16 > 0 && this.blocksByteArray[var2 - 1] == var22; --var2) {
-				--var16;
-			}
-
-			while(var17 < this.width && this.blocksByteArray[var2 + var17 - var16] == var22) {
-				++var17;
-			}
-
-			int var18 = var2 >> var9 & var11;
-			int var19 = var2 >> var9 + var10;
-			if(var5 == 255 && (var16 == 0 || var17 == this.width - 1 || var13 == 0 || var13 == this.height - 1 || var3 == 0 || var3 == this.depth - 1)) {
+			sz = sy >> widthOff & depthClip;
+			int y = sy >> widthOff + depthOff;
+			int x = sy & widthClip;
+
+			int var2b = (y * this.depth + sz) * this.width + x;
+
+			int x2;
+			for(x2 = x; x > 0 && this.blocksByteArray[var2b - 1] == var22; --sy, --var2b) {
+				--x;
+			}
+
+			while(x2 < this.width && this.blocksByteArray[var2b + x2 - x] == var22) {
+				++x2;
+			}
+
+			int z2 = sy >> widthOff & depthClip;
+			int y2 = sy >> widthOff + depthOff;
+			if(var5 == 255 && (x == 0 || x2 == this.width - 1 || y == 0 || y == this.height - 1 || sz == 0 || sz == this.depth - 1) && (!this.levelType.doFloodFillToEdge() || y >= this.waterLevel)) {
 				return -1L;
 			}
 
-			if(var18 != var3 || var19 != var13) {
+			if(z2 != sz || y2 != y) {
 				System.out.println("Diagonal flood!?");
 			}
 
 			boolean var24 = false;
 			boolean var25 = false;
 			boolean var20 = false;
-			var14 += (long)(var17 - var16);
-
-			for(var16 = var16; var16 < var17; ++var16) {
-				this.blocksByteArray[var2] = var6;
+			var14 += (long)(x2 - x);
+
+			if (var5a > 0 && var14 >= var5a) return var14;
+
+			for(x = x; x < x2; ++x) {
+				this.blocksByteArray[var2b] = var6;
 				boolean var21;
-				if(var3 > 0) {
-					var21 = this.blocksByteArray[var2 - this.width] == var22;
+				if(sz > 0) {
+					var21 = this.blocksByteArray[var2b - this.width] == var22;
 					if(var21 && !var24) {
 						if(var23 == this.floodFillBlocks.length) {
 							var7.add(this.floodFillBlocks);
@@ -774,14 +613,14 @@
 							var23 = 0;
 						}
 
-						this.floodFillBlocks[var23++] = var2 - this.width;
+						this.floodFillBlocks[var23++] = sy - (1 << widthOff);
 					}
 
 					var24 = var21;
 				}
 
-				if(var3 < this.depth - 1) {
-					var21 = this.blocksByteArray[var2 + this.width] == var22;
+				if(sz < this.depth - 1) {
+					var21 = this.blocksByteArray[var2b + this.width] == var22;
 					if(var21 && !var25) {
 						if(var23 == this.floodFillBlocks.length) {
 							var7.add(this.floodFillBlocks);
@@ -789,16 +628,16 @@
 							var23 = 0;
 						}
 
-						this.floodFillBlocks[var23++] = var2 + this.width;
+						this.floodFillBlocks[var23++] = sy + (1 << widthOff);
 					}
 
 					var25 = var21;
 				}
 
-				if(var13 > 0) {
-					byte var26 = this.blocksByteArray[var2 - var1];
+				if(y > 0) {
+					byte var26 = this.blocksByteArray[var2b - sx];
 					if((var6 == Block.lavaMoving.blockID || var6 == Block.lavaStill.blockID) && (var26 == Block.waterMoving.blockID || var26 == Block.waterStill.blockID)) {
-						this.blocksByteArray[var2 - var1] = (byte)Block.stone.blockID;
+						this.blocksByteArray[var2b - sx] = (byte)Block.stone.blockID;
 					}
 
 					var21 = var26 == var22;
@@ -809,13 +648,14 @@
 							var23 = 0;
 						}
 
-						this.floodFillBlocks[var23++] = var2 - var1;
+						this.floodFillBlocks[var23++] = sy - (1 << widthOff + depthOff);
 					}
 
 					var20 = var21;
 				}
 
-				++var2;
+				++sy;
+				++var2b;
 			}
 		}
 
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/TerrainGenStage.java
@@ -1,0 +1,85 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.ItemStack;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+import util.ByteArray3D;
+import util.IntArray2D;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+import java.util.function.Consumer;
+
+public class TerrainGenStage {
+	public final String name;
+	public final BlockTransformer blockTransformer;
+	private List<ChestItem> chestItems;
+	private int minChestSlots = 5, chestSlotVariation = 11;
+
+	public TerrainGenStage(String name, BlockTransformer blockTransformer) {
+		this.name = name;
+		this.blockTransformer = blockTransformer;
+	}
+
+	protected static class ChestItem {
+		public final int id, count;
+		public final boolean damaged;
+
+		public ChestItem(int id, int count) {
+			this(id, count, false);
+		}
+
+		public ChestItem(int id, int count, boolean damaged) {
+			this.id = id;
+			this.count = count;
+			this.damaged = damaged;
+		}
+	}
+
+	protected void setChestSlots(int min, int max) {
+		if (max < min) throw new IllegalArgumentException("Maximum slots cannot be lower than minimum slots!");
+
+		this.minChestSlots = min;
+		this.chestSlotVariation = max - min + 1;
+	}
+
+		protected void addChestItem(ChestItem chestItem) {
+			if (chestItem == null) return;
+		if (this.chestItems == null) this.chestItems = new ArrayList<>();
+		this.chestItems.add(chestItem);
+	}
+
+	public ItemStack[] getChestItems(Random rand) {
+		ItemStack[] items = new ItemStack[27];
+		int slotCount = this.minChestSlots + rand.nextInt(this.chestSlotVariation);
+
+		for (int i = 0; i < slotCount; i++) {
+			int index;
+			do {
+				index = rand.nextInt(27);
+			} while (items[index] != null);
+
+			ChestItem chestItem = this.chestItems.get(rand.nextInt(this.chestItems.size()));
+			ItemStack item = new ItemStack(chestItem.id, rand.nextInt(chestItem.count) + 1);
+			if (chestItem.damaged) {
+				item.itemDamage = rand.nextInt(Item.itemsList[item.itemID].getMaxDamage());
+			}
+			items[index] = item;
+		}
+
+		return items;
+	}
+
+	@FunctionalInterface
+	public interface BlockTransformer {
+		void transformBlocks(ByteArray3D blocks, IntArray2D heightmap, Random rand, World world,
+		                     Consumer<Float> progressor, ChestPlacer chestPlacer);
+	}
+
+	@FunctionalInterface
+	public interface ChestPlacer {
+		void placeChest(int x, int y, int z);
+	}
+}
--- net/minecraft/game/level/block/BlockFarmland.java
+++ net/minecraft/game/level/block/BlockFarmland.java
@@ -6,7 +6,7 @@
 import net.minecraft.game.physics.AxisAlignedBB;
 
 public final class BlockFarmland extends Block {
-	protected BlockFarmland(int var1) {
+	public BlockFarmland(int var1) {
 		super(60, Material.ground);
 		this.blockIndexInTexture = 87;
 		this.setTickOnLoad(true);
@@ -14,7 +14,7 @@
 		this.setLightOpacity(255);
 	}
 
-	public final AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
+	public final AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
 		return new AxisAlignedBB((float)var1, (float)var2, (float)var3, (float)(var1 + 1), (float)(var2 + 1), (float)(var3 + 1));
 	}
 
@@ -30,6 +30,10 @@
 		return var1 == 1 && var2 > 0 ? this.blockIndexInTexture - 1 : (var1 == 1 ? this.blockIndexInTexture : 2);
 	}
 
+	public final int getBlockTextureFromSide(int var1) {
+		return var1 == 1 ? this.blockIndexInTexture : 2;
+	}
+
 	public final void updateTick(World var1, int var2, int var3, int var4, Random var5) {
 		if(var5.nextInt(5) == 0) {
 			int var8 = var4;
@@ -103,7 +107,7 @@
 
 	public final void onEntityWalking(World var1, int var2, int var3, int var4) {
 		if(var1.random.nextInt(4) == 0) {
-			var1.setBlockWithNotify(var2, var3, var4, Block.dirt.blockID);
+			var1.setBlockWithNotify(var2, var3 - 1, var4, Block.dirt.blockID);
 		}
 
 	}
--- net/minecraft/client/player/MovementInput.java
+++ net/minecraft/client/player/MovementInput.java
@@ -4,6 +4,8 @@
 	public float moveStrafe = 0.0F;
 	public float moveForward = 0.0F;
 	public boolean jump = false;
+	public boolean flyUp = false;
+	public boolean flyDown = false;
 
 	public void updatePlayerMoveState() {
 	}
--- net/minecraft/game/entity/EntityLiving.java
+++ net/minecraft/game/entity/EntityLiving.java
@@ -14,7 +14,6 @@
 	private float rotationYawHead;
 	private float prevRotationYawHead;
 	protected String texture = "/char.png";
-	private int scoreValue = 0;
 	public int health;
 	public int prevHealth;
 	private int livingSoundTime;
@@ -35,6 +34,7 @@
 	protected boolean isJumping;
 	private float defaultPitch;
 	protected float moveSpeed;
+	protected boolean flying;
 
 	public EntityLiving(World var1) {
 		super(var1);
@@ -405,13 +405,15 @@
 				this.motionY = 0.3F;
 			}
 		} else {
-			this.moveFlying(var2, var3, this.onGround ? 0.1F : 0.02F);
+			int block = this.worldObj.getBlockId((int)this.posX, (int)(this.posY - 0.2F - this.yOffset), (int)this.posZ);
+			boolean slippery = this.onGround && block == Block.ice.blockID;
+			this.moveFlying(var2, var3, (this.onGround ? 0.1F : 0.02F) * (this.flying ? 2.5F : 1.0F) * (slippery ? 0.05F : 1.0F));
 			this.moveEntity(this.motionX, this.motionY, this.motionZ);
-			this.motionX *= 0.91F;
+			this.motionX *= slippery ? 0.99F : 0.91F;
 			this.motionY *= 0.98F;
-			this.motionZ *= 0.91F;
-			this.motionY = (float)((double)this.motionY - 0.08D);
-			if(this.onGround) {
+			this.motionZ *= slippery ? 0.99F : 0.91F;
+			if (!this.flying) this.motionY -= 0.08F;
+			if(this.onGround && !slippery) {
 				this.motionX *= 0.6F;
 				this.motionZ *= 0.6F;
 			}
--- /dev/null
+++ util/DoubleArray3D.java
@@ -1,0 +1,35 @@
+package util;
+
+public class DoubleArray3D {
+	private final double[] array;
+	public final int width, length, height;
+
+	public DoubleArray3D(int width, int length, int height) {
+		this(null, width, length, height);
+	}
+
+	public DoubleArray3D(double[] array, int width, int length, int height) {
+		if (array == null) {
+			array = new double[width * length * height];
+		} else if (array.length < width * length * height) {
+			throw new IllegalArgumentException("Array is too small!");
+		}
+
+		this.array = array;
+		this.width = width;
+		this.length = length;
+		this.height = height;
+	}
+
+	public double get(int x, int y, int z) {
+		return this.array[(y * this.length + z) * this.width + x];
+	}
+
+	public void set(int x, int y, int z, double value) {
+		this.array[(y * this.length + z) * this.width + x] = value;
+	}
+
+	public double[] getArray() {
+		return array;
+	}
+}
--- net/minecraft/game/level/block/BlockMushroom.java
+++ net/minecraft/game/level/block/BlockMushroom.java
@@ -3,7 +3,7 @@
 import net.minecraft.game.level.World;
 
 public final class BlockMushroom extends BlockFlower {
-	protected BlockMushroom(int var1, int var2) {
+	public BlockMushroom(int var1, int var2) {
 		super(var1, var2);
 		this.setBlockBounds(0.3F, 0.0F, 0.3F, 0.7F, 0.4F, 0.7F);
 	}
--- net/minecraft/game/level/block/BlockSand.java
+++ net/minecraft/game/level/block/BlockSand.java
@@ -1,60 +1,112 @@
 package net.minecraft.game.level.block;
 
+import java.util.List;
 import java.util.Random;
+
+import net.minecraft.game.entity.Entity;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.material.Material;
+import net.minecraft.game.physics.AxisAlignedBB;
 
 public class BlockSand extends Block {
 	public BlockSand(int var1, int var2) {
 		super(var1, var2, Material.sand);
-		new Random();
+	}
+
+	public int tickRate() {
+		return 3;
+	}
+
+	protected int fallDirection(World var1, int var2, int var3, int var4) {
+		return -1;
+	}
+
+	protected boolean passGrates() {
+		return true;
 	}
 
 	public final void onBlockAdded(World var1, int var2, int var3, int var4) {
-		this.tryToFall(var1, var2, var3, var4);
+		var1.scheduleBlockUpdate(var2, var3, var4, this.blockID);
 	}
 
 	public final void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
-		this.tryToFall(var1, var2, var3, var4);
-	}
-
-	private void tryToFall(World var1, int var2, int var3, int var4) {
-		int var5 = var3;
-
-		while(true) {
-			int var8 = var5 - 1;
-			int var6 = var1.getBlockId(var2, var8, var4);
-			boolean var10000;
-			if(var6 == 0) {
-				var10000 = true;
-			} else if(var6 == Block.fire.blockID) {
-				var10000 = true;
-			} else {
-				Material var10 = Block.blocksList[var6].material;
-				var10000 = var10 == Material.water ? true : var10 == Material.lava;
-			}
-
-			if(!var10000 || var5 < 0) {
-				if(var5 < 0) {
-					var1.setTileNoUpdate(var2, var3, var4, 0);
-				}
-
-				if(var5 != var3) {
-					var6 = var1.getBlockId(var2, var5, var4);
-					if(var6 > 0 && Block.blocksList[var6].material != Material.air) {
-						var1.setTileNoUpdate(var2, var5, var4, 0);
-					}
-
-					var1.swap(var2, var3, var4, var2, var5, var4);
-				}
-
+		var1.scheduleBlockUpdate(var2, var3, var4, this.blockID);
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+		world.scheduleBlockUpdate(x, y, z, this.blockID);
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		this.fall(var1, var2, var3, var4);
+	}
+
+	public void dropBlockAsItemWithChance(World var1, int var2, int var3, int var4, int var5, float var6) {
+		if ((var5 & 1) == 1) {
+			Block.grate.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, var6);
+		}
+		super.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, var6);
+	}
+
+	public void fall(World var1, int var2, int var3, int var4) {
+		int dir = this.fallDirection(var1, var2, var3, var4);
+		int dirSign = dir > 0 ? 1 : -1;
+
+		for (int i = 0; i < Math.abs(dir); i++) {
+			int meta = var1.getBlockMetadata(var2, var3, var4) & 255;
+			boolean grated = ((meta >>> 4) & 3) == 1;
+			boolean woodenGrated = ((meta >>> 4) & 3) == 2;
+
+			if (var3 + dirSign == -1 || var3 + dirSign == var1.height) {
 				return;
 			}
 
-			--var5;
-			if(var1.getBlockId(var2, var5, var4) == Block.fire.blockID) {
-				var1.setBlock(var2, var5, var4, 0);
+			AxisAlignedBB aabb = this.getCollisionBoundingBoxFromPool(var1, var2, var3 + 1, var4);
+			aabb.minY -= 1.0F;
+			var3 += dirSign;
+			Block blockBelow = Block.blocksList[var1.getBlockId(var2, var3, var4)];
+			if (blockBelow != null && (blockBelow.getCollisionBoundingBoxFromPool(var1, var2, var3, var4) != null
+					|| !passGrates() && (blockBelow == Block.grate || blockBelow == Block.woodenGrate))) return;
+
+			if (blockBelow != null && blockBelow != Block.grate && blockBelow != Block.woodenGrate) {
+				blockBelow.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+			}
+
+			var1.setTileNoUpdate(var2, var3, var4, 0);
+			var1.swap(var2, var3 - dirSign, var4, var2, var3, var4);
+
+			meta &= 15;
+			if (blockBelow == Block.grate && passGrates()) {
+				meta |= 16;
+			} else if (blockBelow == Block.woodenGrate && passGrates()) {
+				meta |= 32;
+			}
+			var1.setBlockMetadata(var2, var3, var4, meta);
+
+			if (grated) {
+				var1.setBlock(var2, var3 - dirSign, var4, Block.grate.blockID);
+				var1.setBlockMetadata(var2, var3 - dirSign, var4, 1);
+			} else if (woodenGrated) {
+				var1.setBlock(var2, var3 - dirSign, var4, Block.woodenGrate.blockID);
+				var1.setBlockMetadata(var2, var3 - dirSign, var4, 1);
+			}
+
+			List ridingEntities = var1.entityMap.getEntitiesWithinAABB(null, aabb);
+			if (var1.playerEntity.boundingBox.intersectsWith(aabb)) {
+				ridingEntities.add(var1.playerEntity);
+			}
+
+			for (Object object : ridingEntities) {
+				Entity entity = (Entity)object;
+				if (dirSign != -1 && !entity.onGround) continue;
+				entity.boundingBox.minY = (dirSign == -1 ? aabb.minY : aabb.maxY);
+				entity.boundingBox.maxY = entity.boundingBox.minY + entity.height;
+				entity.posY = entity.boundingBox.minY + entity.yOffset;
+				entity.lastTickPosY = entity.prevPosY = entity.posY;
+				entity.onGround = true;
 			}
 		}
+
+		var1.scheduleBlockUpdate(var2, var3, var4, this.blockID);
 	}
 }
--- /dev/null
+++ util/IntArray2D.java
@@ -1,0 +1,40 @@
+package util;
+
+import java.util.Arrays;
+
+public class IntArray2D {
+	private final int[] array;
+	public final int width, length;
+
+	public IntArray2D(int width, int length) {
+		this(null, width, length);
+	}
+
+	public IntArray2D(int[] array, int width, int length) {
+		if (array == null) {
+			array = new int[width * length];
+		} else if (array.length < width * length) {
+			throw new IllegalArgumentException("Array is too small!");
+		}
+
+		this.array = array;
+		this.width = width;
+		this.length = length;
+	}
+
+	public int get(int x, int z) {
+		return this.array[x + z * this.width];
+	}
+
+	public void set(int x, int z, int value) {
+		this.array[x + z * this.width] = value;
+	}
+
+	public int[] getArray() {
+		return array;
+	}
+
+	public void clear() {
+		Arrays.fill(array, 0);
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageFortifying.java
@@ -1,0 +1,128 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.level.block.Block;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public class StageFortifying extends TerrainGenStage {
+	public StageFortifying() {
+		super("Fortifying..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			int ruinCount = blocks.width * blocks.length / (1000 * world.height / 128);
+			int baseY = Math.max(Math.max(world.waterLevel, world.groundLevel), world.height / 4);
+			if ((blocks.height - baseY - 16) / 2 <= 0) {
+				return;
+			}
+
+			for (int i = 0; i < ruinCount; i++) {
+				progressor.accept(i * 100.0F / ruinCount);
+
+				int x = rand.nextInt(blocks.width - 48) + 16;
+				int y = rand.nextInt((blocks.height - baseY - 16) / 2) + baseY;
+				int z = rand.nextInt(blocks.length - 48) + 16;
+				int subRuinCount = 10;
+
+				for (int j = 0; j < subRuinCount; j++) {
+					int sx = x + rand.nextInt(33) - 16;
+					int sy = y + rand.nextInt(17) - 8;
+					int sz = z + rand.nextInt(33) - 16;
+					int width = rand.nextInt(13) + 4;
+					int length = rand.nextInt(13) + 4;
+					boolean hasFloor = rand.nextInt(2) == 0;
+
+					Set<Integer> floorHeights = new HashSet<>();
+					int minFloorHeight = sy - rand.nextInt(5) - 1;
+					floorHeights.add(minFloorHeight);
+
+					for (int xx = sx; xx < sx + width; xx++) {
+						for (int zz = sz; zz < sz + length; zz++) {
+							if (Block.opaqueCubeLookup[blocks.get(xx, sy, zz)]) {
+								continue;
+							}
+
+							boolean wall = xx == sx || xx == sx + width - 1 || zz == sz || zz == sz + length - 1;
+							boolean corner = (xx == sx || xx == sx + width - 1) && (zz == sz || zz == sz + length - 1);
+							boolean hasWindows = rand.nextInt(4) == 0;
+
+							for (int yy = sy + ((xx / 2 + zz / 2) % 2); yy > 0; yy--) {
+								int b = blocks.get(xx, yy, zz);
+
+								if (Block.opaqueCubeLookup[b]) {
+									boolean doorway = b == Block.planks.blockID;
+									if (b == Block.stairDouble.blockID && blocks.get(xx, yy - 2, zz) != Block.stairDouble.blockID) {
+										while (!floorHeights.contains(yy) && yy > 0) {
+											yy--;
+										}
+										if (yy > 0) {
+											doorway = true;
+										}
+									}
+
+									doorway &= rand.nextInt(2) == 0 || (xx + zz) % 2 == 0;
+
+									if (doorway) {
+										for (int yy2 = yy + 1; yy2 < yy + 4; yy2++) {
+											blocks.set(xx, yy2, zz, 0);
+										}
+									}
+									break;
+								}
+
+								if (yy <= minFloorHeight) {
+									minFloorHeight = yy - (rand.nextInt(5) + 3);
+									floorHeights.add(minFloorHeight);
+								}
+
+								if (wall) {
+									int wallBlock = Block.cobblestone.blockID;
+									if (yy >= sy || corner) {
+										wallBlock = Block.stairDouble.blockID;
+									} else if (hasWindows && yy < sy - 1 && (-(yy - sy) / 2) % 2 == 1
+											&& (!floorHeights.contains(yy) || !hasFloor)) {
+										wallBlock = 0;
+									} else if (rand.nextInt(3) != 0 && -rand.nextInt(10) > yy - sy) {
+										wallBlock = Block.cobblestoneMossy.blockID;
+									}
+									blocks.set(xx, yy, zz, wallBlock);
+								} else if (hasFloor && floorHeights.contains(yy)) {
+									blocks.set(xx, yy, zz, Block.planks.blockID);
+								}
+							}
+						}
+					}
+
+					if (hasFloor && !floorHeights.isEmpty()) {
+						while (rand.nextInt(5) == 0) {
+							int cx = sx + 1 + rand.nextInt(width - 2);
+							int cz = sz + 1 + rand.nextInt(length - 2);
+							int cy = floorHeights.size() == 1
+									? floorHeights.stream().findFirst().get()
+									: floorHeights.stream().skip(rand.nextInt(floorHeights.size() - 1)).findFirst().orElse(-1)
+									+ 1;
+							if (cy > 0) {
+								chestPlacer.placeChest(cx, cy, cz);
+							}
+						}
+					}
+				}
+			}
+		});
+
+		this.addChestItem(new ChestItem(Item.swordSteel.shiftedIndex, 1, true));
+		this.addChestItem(new ChestItem(Item.helmetChain.shiftedIndex, 1, true));
+		this.addChestItem(new ChestItem(Item.plateChain.shiftedIndex, 1, true));
+		this.addChestItem(new ChestItem(Item.legsChain.shiftedIndex, 1, true));
+		this.addChestItem(new ChestItem(Item.bootsChain.shiftedIndex, 1, true));
+		this.addChestItem(new ChestItem(Item.bow.shiftedIndex, 1));
+		this.addChestItem(new ChestItem(Item.arrow.shiftedIndex, 64));
+		this.addChestItem(new ChestItem(Item.ingotIron.shiftedIndex, 8));
+
+		for (int i = 0; i < 5; i++) {
+			this.addChestItem(new ChestItem(Block.leaves.blockID, 20));
+			this.addChestItem(new ChestItem(Block.cobblestone.blockID, 20));
+			this.addChestItem(new ChestItem(Block.planks.blockID, 20));
+			this.addChestItem(new ChestItem(Item.stick.shiftedIndex, 10));
+		}
+	}
+}
--- net/minecraft/client/Session.java
+++ net/minecraft/client/Session.java
@@ -2,6 +2,8 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
+import net.minecraft.game.item.Item;
 import net.minecraft.game.level.block.Block;
 
 public final class Session {
@@ -15,7 +17,8 @@
 	}
 
 	static {
-		(registeredBlocksList = new ArrayList()).add(Block.stone);
+		registeredBlocksList = new ArrayList();
+		registeredBlocksList.add(Block.stone);
 		registeredBlocksList.add(Block.cobblestone);
 		registeredBlocksList.add(Block.brick);
 		registeredBlocksList.add(Block.dirt);
@@ -24,15 +27,23 @@
 		registeredBlocksList.add(Block.leaves);
 		registeredBlocksList.add(Block.torch);
 		registeredBlocksList.add(Block.stairSingle);
+		registeredBlocksList.add(Block.stairDouble);
+		registeredBlocksList.add(Block.woodStairSingle);
 		registeredBlocksList.add(Block.glass);
 		registeredBlocksList.add(Block.cobblestoneMossy);
+		registeredBlocksList.add(Block.grass);
 		registeredBlocksList.add(Block.sapling);
 		registeredBlocksList.add(Block.plantYellow);
 		registeredBlocksList.add(Block.plantRed);
+		registeredBlocksList.add(Block.plantBlue);
 		registeredBlocksList.add(Block.mushroomBrown);
 		registeredBlocksList.add(Block.mushroomRed);
 		registeredBlocksList.add(Block.sand);
 		registeredBlocksList.add(Block.gravel);
+		registeredBlocksList.add(Block.cactus);
+		registeredBlocksList.add(Block.ice);
+		registeredBlocksList.add(Block.blockSnow);
+		registeredBlocksList.add(Block.snow);
 		registeredBlocksList.add(Block.sponge);
 		registeredBlocksList.add(Block.clothRed);
 		registeredBlocksList.add(Block.clothOrange);
@@ -52,12 +63,38 @@
 		registeredBlocksList.add(Block.clothWhite);
 		registeredBlocksList.add(Block.oreCoal);
 		registeredBlocksList.add(Block.oreIron);
+		registeredBlocksList.add(Block.oreCopper);
 		registeredBlocksList.add(Block.oreGold);
+		registeredBlocksList.add(Block.oreDiamond);
 		registeredBlocksList.add(Block.blockSteel);
+		registeredBlocksList.add(Block.blockCopper);
 		registeredBlocksList.add(Block.blockGold);
+		registeredBlocksList.add(Block.blockDiamond);
 		registeredBlocksList.add(Block.bookShelf);
 		registeredBlocksList.add(Block.tnt);
 		registeredBlocksList.add(Block.obsidian);
+		registeredBlocksList.add(Block.workbench);
+		registeredBlocksList.add(Block.stoneOvenIdle);
+		registeredBlocksList.add(Block.stoneOvenActive);
+		registeredBlocksList.add(Block.crate);
+		registeredBlocksList.add(Block.tilledField);
+		registeredBlocksList.add(Block.activator);
+		registeredBlocksList.add(Block.observer);
+		registeredBlocksList.add(Block.diode);
+		registeredBlocksList.add(Block.logicGate);
+		registeredBlocksList.add(Block.cog);
+		registeredBlocksList.add(Block.woodenGrate);
+		registeredBlocksList.add(Block.grate);
+		registeredBlocksList.add(Block.lampInactive);
+		registeredBlocksList.add(Block.lampActive);
+		registeredBlocksList.add(Block.piston);
+		registeredBlocksList.add(Block.pistonCopper);
+		registeredBlocksList.add(Block.pistonGold);
+		registeredBlocksList.add(Block.magneticPlatform);
+		registeredBlocksList.add(Item.wrench);
+		registeredBlocksList.add(Block.waterMoving);
+		registeredBlocksList.add(Block.lavaMoving);
+		registeredBlocksList.add(Block.fire);
 		System.out.println(registeredBlocksList.size());
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageGrowing.java
@@ -1,0 +1,91 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public final class StageGrowing extends TerrainGenStage {
+	private static final Set<Integer> GRAVEL_BEACH_REPLACABLES = new HashSet<>();
+
+	static {
+		GRAVEL_BEACH_REPLACABLES.add(Block.waterMoving.blockID);
+		GRAVEL_BEACH_REPLACABLES.add(Block.waterStill.blockID);
+		GRAVEL_BEACH_REPLACABLES.add(0);
+	}
+
+	private StageGrowing(Builder properties) {
+		super("Growing..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			NoiseGenerator sandBeachNoise = new NoiseGeneratorOctaves(rand, 8);
+			NoiseGenerator gravelBeachNoise = new NoiseGeneratorOctaves(rand, 8);
+
+			for (int x = 0; x < blocks.width; x++) {
+				progressor.accept(x * 100.0F / (float)(blocks.width - 1));
+
+				for (int z = 0; z < blocks.length; z++) {
+					boolean sandBeach = sandBeachNoise.generateNoise(x, z) > properties.sandBeachThreshold;
+					boolean gravelBeach = gravelBeachNoise.generateNoise(x, z) > properties.gravelBeachThreshold;
+
+					int y = heightmap.get(x, z);
+					int blockAbove = blocks.get(x, y + 1, z);
+					if (gravelBeach && y <= world.waterLevel + properties.beachHeightOffset && GRAVEL_BEACH_REPLACABLES.contains(blockAbove)) {
+						blocks.set(x, y, z, properties.gravelBeachBlock.blockID);
+					}
+
+					if (sandBeach && blockAbove == 0 && y <= world.waterLevel + properties.beachHeightOffset) {
+						blocks.set(x, y, z, properties.sandBeachBlock.blockID);
+					}
+				}
+			}
+		});
+	}
+
+	public static class Builder {
+		public double sandBeachThreshold = 8.0D;
+		public double gravelBeachThreshold = 12.0D;
+		public Block sandBeachBlock = Block.sand;
+		public Block gravelBeachBlock = Block.gravel;
+		public int beachHeightOffset = -1;
+
+		public Builder sandBeachThreshold(double sandBeachThreshold) {
+			this.sandBeachThreshold = sandBeachThreshold;
+			return this;
+		}
+
+		public Builder gravelBeachThreshold(double gravelBeachThreshold) {
+			this.gravelBeachThreshold = gravelBeachThreshold;
+			return this;
+		}
+
+		public Builder sandBeachBlock(Block sandBeachBlock) {
+			this.sandBeachBlock = sandBeachBlock;
+			return this;
+		}
+
+		public Builder gravelBeachBlock(Block gravelBeachBlock) {
+			this.gravelBeachBlock = gravelBeachBlock;
+			return this;
+		}
+
+		public Builder beachHeightOffset(int beachHeightOffset) {
+			this.beachHeightOffset = beachHeightOffset;
+			return this;
+		}
+
+		public Builder applyTheme(LevelTheme theme) {
+			return this
+					.sandBeachThreshold(theme.modifySandBeachThreshold(this.sandBeachThreshold))
+					.gravelBeachThreshold(theme.modifyGravelBeachThreshold(this.gravelBeachThreshold))
+					.sandBeachBlock(theme.getSandBeachBlock())
+					.gravelBeachBlock(theme.getGravelBeachBlock())
+					.beachHeightOffset(theme.modifyBeachHeightOffset(this.beachHeightOffset));
+		}
+
+		public StageGrowing build() {
+			return new StageGrowing(this);
+		}
+	}
+}
--- net/minecraft/game/entity/player/EntityPlayer.java
+++ net/minecraft/game/entity/player/EntityPlayer.java
@@ -24,6 +24,7 @@
 	public float prevCameraYaw;
 	public float cameraYaw;
 	private int damageRemainder = 0;
+	protected int flyToggleTimer;
 
 	public EntityPlayer(World var1) {
 		super(var1);
@@ -52,7 +53,10 @@
 	}
 
 	public void onLivingUpdate() {
-		this.worldObj.playSoundEffect(this.posX, this.posY, this.posZ, "calm", 0.0F);
+		if(this.flyToggleTimer > 0) {
+			--this.flyToggleTimer;
+		}
+
 		if(this.worldObj.difficultySetting == 0 && this.health < 20 && this.ticksExisted % 20 << 2 == 0) {
 			this.heal(1);
 		}
@@ -67,6 +71,21 @@
 
 		this.prevCameraYaw = this.cameraYaw;
 		super.onLivingUpdate();
+
+		if (this.flying) {
+			if (this.flyDown() && this.flyUp()) {
+				this.motionY = 0.0F;
+			} else if (this.flyUp()) {
+				this.motionY = 0.4F;
+			} else if (this.flyDown()) {
+				this.motionY = -0.4F;
+			} else {
+				this.motionY *= 0.5F;
+			}
+			this.flying = !this.onGround;
+			this.distanceWalkedModified = this.prevDistanceWalkedModified;
+		}
+
 		float var1 = MathHelper.sqrt_float(this.motionX * this.motionX + this.motionZ * this.motionZ);
 		float var2 = (float)Math.atan((double)(-this.motionY * 0.2F)) * 15.0F;
 		if(var1 > 0.1F) {
@@ -218,5 +237,13 @@
 	}
 
 	public void displayGUIFurnace(TileEntityFurnace var1) {
+	}
+
+	protected boolean flyUp() {
+		return false;
+	}
+
+	protected boolean flyDown() {
+		return false;
 	}
 }
--- net/minecraft/client/gui/GuiGameOver.java
+++ net/minecraft/client/gui/GuiGameOver.java
@@ -6,10 +6,12 @@
 public final class GuiGameOver extends GuiScreen {
 	public final void initGui() {
 		this.controlList.clear();
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 72, "Generate new level..."));
-		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 96, "Load level.."));
-		if(this.mc.session == null) {
-			((GuiButton)this.controlList.get(1)).enabled = false;
+		if (this.mc.adventureMode) {
+			this.controlList.add(new GuiButton(3, this.width / 2 - 100, this.height / 4 + 72, "Respawn"));
+			this.controlList.add(new GuiButton(4, this.width / 2 - 100, this.height / 4 + 96, "Quit to title"));
+		} else {
+			this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 72, "Generate new level..."));
+			this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 96, "Load level..."));
 		}
 
 	}
@@ -26,10 +28,20 @@
 			this.mc.displayGuiScreen(new GuiNewLevel(this));
 		}
 
-		if(this.mc.session != null && var1.id == 2) {
+		if(var1.id == 2) {
 			this.mc.displayGuiScreen(new GuiLoadLevel(this));
 		}
 
+		if(var1.id == 3) {
+			this.mc.respawn();
+			this.mc.displayGuiScreen(null);
+		}
+
+		if(var1.id == 4) {
+			this.mc.respawn();
+			this.mc.setLevel(null);
+		}
+
 	}
 
 	public final void drawScreen(int var1, int var2, float var3) {
@@ -38,10 +50,7 @@
 		GL11.glScalef(2.0F, 2.0F, 2.0F);
 		drawCenteredString(this.fontRenderer, "Game over!", this.width / 2 / 2, 30, 16777215);
 		GL11.glPopMatrix();
-		FontRenderer var10000 = this.fontRenderer;
-		StringBuilder var10001 = (new StringBuilder()).append("Score: &e");
-		EntityPlayerSP var4 = this.mc.thePlayer;
-		drawCenteredString(var10000, var10001.append(var4.getScore).toString(), this.width / 2, 100, 16777215);
+		drawCenteredString(this.fontRenderer, "Score: &e" + this.mc.thePlayer.getScore, this.width / 2, 100, 16777215);
 		super.drawScreen(var1, var2, var3);
 	}
 
--- net/minecraft/client/render/RenderEngine.java
+++ net/minecraft/client/render/RenderEngine.java
@@ -26,6 +26,7 @@
 	private Map urlToImageDataMap = new HashMap();
 	private GameSettings options;
 	private boolean clampTexture = false;
+	private boolean bilinearTexture = false;
 
 	public RenderEngine(GameSettings var1) {
 		this.options = var1;
@@ -46,6 +47,10 @@
 					this.clampTexture = true;
 					this.setupTexture(ImageIO.read(RenderEngine.class.getResourceAsStream(var1.substring(2))), var4);
 					this.clampTexture = false;
+				} else if(var1.startsWith("$$")) {
+					this.bilinearTexture = true;
+					this.setupTexture(ImageIO.read(RenderEngine.class.getResourceAsStream(var1.substring(2))), var4);
+					this.bilinearTexture = false;
 				} else {
 					this.setupTexture(ImageIO.read(RenderEngine.class.getResourceAsStream(var1)), var4);
 				}
@@ -73,8 +78,13 @@
 
 	private void setupTexture(BufferedImage var1, int var2) {
 		GL11.glBindTexture(GL11.GL_TEXTURE_2D, var2);
-		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
-		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
+		if (this.bilinearTexture) {
+			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
+			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
+		} else {
+			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
+			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
+		}
 		if(this.clampTexture) {
 			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_CLAMP);
 			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_CLAMP);
--- net/minecraft/client/gui/GuiScreen.java
+++ net/minecraft/client/gui/GuiScreen.java
@@ -15,6 +15,7 @@
 	protected List controlList = new ArrayList();
 	public boolean allowUserInput = false;
 	protected FontRenderer fontRenderer;
+	private GuiButton selectedButton = null;
 
 	public void drawScreen(int var1, int var2, float var3) {
 		for(int var5 = 0; var5 < this.controlList.size(); ++var5) {
@@ -37,12 +38,22 @@
 			for(var3 = 0; var3 < this.controlList.size(); ++var3) {
 				GuiButton var4 = (GuiButton)this.controlList.get(var3);
 				if(var4.mousePressed(var1, var2)) {
+					this.selectedButton = var4;
 					this.mc.sndManager.playSoundFX("random.click", 1.0F, 1.0F);
 					this.actionPerformed(var4);
 				}
 			}
 		}
-
+	}
+
+	protected void mouseMovedOrUp(int var1, int var2, int var3) {
+		if(this.selectedButton != null && var3 == 0) {
+			this.selectedButton.mouseReleased(var1, var2);
+			this.selectedButton = null;
+		}
+	}
+
+	protected void mouseScrolled(int delta) {
 	}
 
 	protected void actionPerformed(GuiButton var1) {
@@ -53,6 +64,7 @@
 		this.fontRenderer = var1.fontRenderer;
 		this.width = var2;
 		this.height = var3;
+		this.controlList.clear();
 		this.initGui();
 	}
 
@@ -65,9 +77,13 @@
 			int var2 = this.height - Mouse.getEventY() * this.height / this.mc.displayHeight - 1;
 			this.drawSlotInventory(var1, var2, Mouse.getEventButton());
 		} else {
-			Mouse.getEventX();
-			Mouse.getEventY();
-			Mouse.getEventButton();
+			int var1 = Mouse.getEventX() * this.width / this.mc.displayWidth;
+			int var2 = this.height - Mouse.getEventY() * this.height / this.mc.displayHeight - 1;
+			this.mouseMovedOrUp(var1, var2, Mouse.getEventButton());
+		}
+
+		if(Mouse.getEventDWheel() != 0) {
+			this.mouseScrolled(Mouse.getEventDWheel());
 		}
 	}
 
@@ -97,15 +113,54 @@
 			GL11.glDisable(GL11.GL_LIGHTING);
 			GL11.glDisable(GL11.GL_FOG);
 			Tessellator var2 = Tessellator.instance;
-			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/dirt.png"));
+//			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/dirt.png"));
+//			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+//			var2.startDrawingQuads();
+//			var2.setColorOpaque_I(4210752);
+//			var2.addVertexWithUV(0.0F, (float)this.height, 0.0F, 0.0F, (float)this.height / 32.0F);
+//			var2.addVertexWithUV((float)this.width, (float)this.height, 0.0F, (float)this.width / 32.0F, (float)this.height / 32.0F);
+//			var2.addVertexWithUV((float)this.width, 0.0F, 0.0F, (float)this.width / 32.0F, 0.0F);
+//			var2.addVertexWithUV(0.0F, 0.0F, 0.0F, 0.0F, 0.0F);
+//			var2.draw();
+
+			// Sky
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, 0);
+			var2.startDrawingQuads();
+			var2.setColorRGBA_F(0.9F, 0.95F, 1.0F, 1.0F);
+			var2.addVertex(0.0F, this.height, 0.0F);
+			var2.addVertex(this.width, this.height, 0.0F);
+//			var2.setColorRGBA_F(0.6F, 0.8F, 1.0F, 1.0F);
+			var2.setColorRGBA_F(0.35F, 0.7F, 1.0F, 1.0F);
+			var2.addVertex(this.width, 0.0F, 0.0F);
+			var2.addVertex(0.0F, 0.0F, 0.0F);
+			var2.draw();
+
+			// Horizon
+			float scale = 4.0F;
+			float scroll = (System.currentTimeMillis() % 250000L) / 250000.0F;
+			GL11.glColor4f(0.6F, 0.8F, 1.0F, 1.0F);
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/horizon/hills.png"));
+			var2.startDrawingQuads();
+			var2.addVertexWithUV(0.0F, this.height, 0.0F, scroll, 1.0F);
+			var2.addVertexWithUV((float)this.width, this.height, 0.0F, 1.0F / scale + scroll, 1.0F);
+			var2.addVertexWithUV((float)this.width, this.height - (float)this.width / this.height * 16.0F * scale, 0.0F, 1.0F / scale + scroll, 0.0F);
+			var2.addVertexWithUV(0.0F, this.height - (float)this.width / this.height * 16.0F * scale, 0.0F, scroll, 0.0F);
+			var2.draw();
+
+			// Clouds
+			scale = (float)(this.height / 2.0F) / 12.0F;
+			scroll = (System.currentTimeMillis() % 250000L) / 250000.0F;
 			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/clouds.png"));
 			var2.startDrawingQuads();
-			var2.setColorOpaque_I(4210752);
-			var2.addVertexWithUV(0.0F, (float)this.height, 0.0F, 0.0F, (float)this.height / 32.0F);
-			var2.addVertexWithUV((float)this.width, (float)this.height, 0.0F, (float)this.width / 32.0F, (float)this.height / 32.0F);
-			var2.addVertexWithUV((float)this.width, 0.0F, 0.0F, (float)this.width / 32.0F, 0.0F);
-			var2.addVertexWithUV(0.0F, 0.0F, 0.0F, 0.0F, 0.0F);
+			var2.setColorRGBA_F(1.0F, 1.0F, 1.0F, 1.0F);
+			var2.addVertexWithUV(0.0F, 0.0F, 0.0F, scroll, 1.0F / scale / 2.5F + 0.25F);
+			var2.addVertexWithUV((float)this.width, 0.0F, 0.0F, 1.0F / scale + scroll, 1.0F / scale / 2.5F + 0.25F);
+			var2.setColorRGBA_F(0.6F, 0.8F, 1.0F, 0.0F);
+			var2.addVertexWithUV((float)this.width, this.height / 2.0F, 0.0F, 1.0F / scale + scroll, 0.25F);
+			var2.addVertexWithUV(0.0F, this.height / 2.0F, 0.0F, scroll, 0.25F);
 			var2.draw();
+			GL11.glDisable(GL11.GL_BLEND);
 		}
 	}
 
--- net/minecraft/game/level/block/BlockStep.java
+++ net/minecraft/game/level/block/BlockStep.java
@@ -7,10 +7,10 @@
 public final class BlockStep extends Block {
 	private boolean blockType;
 
-	public BlockStep(int var1, boolean var2) {
-		super(var1, 6, Material.rock);
-		this.blockType = var2;
-		if(!var2) {
+	public BlockStep(int var1, int var2, Material var3, boolean var4) {
+		super(var1, var2, var3);
+		this.blockType = var4;
+		if(!var4) {
 			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
 		}
 
@@ -18,7 +18,7 @@
 	}
 
 	public final int getBlockTextureFromSide(int var1) {
-		return var1 <= 1 ? 6 : 5;
+		return this.blockIndexInTexture == 6 ? (var1 <= 1 ? 6 : 5) : this.blockIndexInTexture;
 	}
 
 	public final boolean isOpaqueCube() {
@@ -31,20 +31,26 @@
 	}
 
 	public final void onBlockAdded(World var1, int var2, int var3, int var4) {
-		if(this != Block.stairSingle) {
+		if(this.blockType) {
 			super.onBlockAdded(var1, var2, var3, var4);
+			return;
 		}
 
+		int stairDouble = this.blockID - 1;
 		int var5 = var1.getBlockId(var2, var3 - 1, var4);
-		if(var5 == stairSingle.blockID) {
+		if(var5 == this.blockID) {
 			var1.setBlockWithNotify(var2, var3, var4, 0);
-			var1.setBlockWithNotify(var2, var3 - 1, var4, Block.stairDouble.blockID);
+			var1.setBlockWithNotify(var2, var3 - 1, var4, stairDouble);
 		}
 
+	}
+
+	public int quantityDropped(Random var1) {
+		return this.blockType ? 2 : 1;
 	}
 
 	public final int idDropped(int var1, Random var2) {
-		return Block.stairSingle.blockID;
+		return this.blockType ? this.blockID + 1 : this.blockID;
 	}
 
 	public final boolean renderAsNormalBlock() {
--- net/minecraft/game/level/block/BlockFluid.java
+++ net/minecraft/game/level/block/BlockFluid.java
@@ -4,16 +4,19 @@
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.material.Material;
 import net.minecraft.game.physics.AxisAlignedBB;
+import net.minecraft.game.physics.Vec3D;
 
 public class BlockFluid extends Block {
 	protected int stillId;
 	protected int movingId;
+	protected int liquidType = 1;
 
-	protected BlockFluid(int var1, Material var2) {
+	public BlockFluid(int var1, Material var2) {
 		super(var1, var2);
 		this.blockIndexInTexture = 14;
 		if(var2 == Material.lava) {
 			this.blockIndexInTexture = 30;
+			this.liquidType = 2;
 		}
 
 		Block.isBlockFluid[var1] = true;
@@ -24,60 +27,41 @@
 		this.setResistance(2.0F);
 	}
 
+	public void resetBlockBounds() {
+		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, getFluidHeightPercent(7), 1.0F);
+	}
+
+	public static float getFluidHeightPercent(int var0) {
+		if(var0 >= 8) {
+			var0 = 0;
+		}
+
+		float var1 = (float)(var0 + 1) / 9.0F;
+		return var1;
+	}
+
+	public void setBoundsForRender(World var1, int var2, int var3, int var4) {
+		if (Block.isBlockFluid[var1.getBlockId(var2, var3 + 1, var4)]) {
+			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+		} else {
+			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F - getFluidHeightPercent(var1.getBlockMetadata(var2, var3, var4)), 1.0F);
+		}
+	}
+
 	public final int getBlockTextureFromSide(int var1) {
 		return this.material == Material.lava ? this.blockIndexInTexture : (var1 == 1 ? this.blockIndexInTexture : (var1 == 0 ? this.blockIndexInTexture : this.blockIndexInTexture + 32));
 	}
 
+	protected final int getFlowDecay(World var1, int var2, int var3, int var4) {
+		return var1.getBlockMaterial(var2, var3, var4) != this.material ? -1 : var1.getBlockMetadata(var2, var3, var4);
+	}
+
 	public final boolean renderAsNormalBlock() {
 		return false;
 	}
 
 	public void onBlockAdded(World var1, int var2, int var3, int var4) {
-		var1.scheduleBlockUpdate(var2, var3, var4, this.movingId);
-	}
-
-	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
-		this.update(var1, var2, var3, var4, 0);
-	}
-
-	public boolean update(World var1, int var2, int var3, int var4, int var5) {
-		boolean var7 = false;
-
-		boolean var6;
-		do {
-			--var3;
-			if(!this.canFlow(var1, var2, var3, var4)) {
-				break;
-			}
-
-			var6 = var1.setBlockWithNotify(var2, var3, var4, this.movingId);
-			if(var6) {
-				var7 = true;
-			}
-		} while(var6 && this.material != Material.lava);
-
-		++var3;
-		if(this.material == Material.water || !var7) {
-			var7 |= this.flow(var1, var2 - 1, var3, var4);
-			var7 |= this.flow(var1, var2 + 1, var3, var4);
-			var7 |= this.flow(var1, var2, var3, var4 - 1);
-			var7 |= this.flow(var1, var2, var3, var4 + 1);
-		}
-
-		if(this.material == Material.lava) {
-			var7 |= extinguishFireLava(var1, var2 - 1, var3, var4);
-			var7 |= extinguishFireLava(var1, var2 + 1, var3, var4);
-			var7 |= extinguishFireLava(var1, var2, var3, var4 - 1);
-			var7 |= extinguishFireLava(var1, var2, var3, var4 + 1);
-		}
-
-		if(!var7) {
-			var1.setTileNoUpdate(var2, var3, var4, this.stillId);
-		} else {
-			var1.scheduleBlockUpdate(var2, var3, var4, this.movingId);
-		}
-
-		return var7;
+		this.checkForHarden(var1, var2, var3, var4);
 	}
 
 	protected final boolean canFlow(World var1, int var2, int var3, int var4) {
@@ -127,9 +111,18 @@
 	}
 
 	public boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
-		if(var2 >= 0 && var3 >= 0 && var4 >= 0 && var2 < var1.width && var4 < var1.length) {
+		if(var2 >= 0 && var3 >= 0 && var4 >= 0 && var2 < var1.width && var3 < var1.height && var4 < var1.length) {
 			int var6 = var1.getBlockId(var2, var3, var4);
-			return var6 != this.movingId && var6 != this.stillId ? (var5 != 1 || var1.getBlockId(var2 - 1, var3, var4) != 0 && var1.getBlockId(var2 + 1, var3, var4) != 0 && var1.getBlockId(var2, var3, var4 - 1) != 0 && var1.getBlockId(var2, var3, var4 + 1) != 0 ? super.shouldSideBeRendered(var1, var2, var3, var4, var5) : true) : false;
+			float var6a = getFluidHeightPercent(var1.getBlockMetadata(var2, var3, var4));
+			if (Block.isBlockFluid[var1.getBlockId(var2, var3 + 1, var4)]) var6a = 1.0F;
+			int var2o = var2 + (var5 == 4 ? 1 : var5 == 5 ? -1 : 0);
+			int var3o = var3 + (var5 == 0 ? 1 : var5 == 1 ? -1 : 0);
+			int var4o = var4 + (var5 == 2 ? 1 : var5 == 3 ? -1 : 0);
+			float var6b = getFluidHeightPercent(var1.getBlockMetadata(var2o, var3o, var4o));
+			if (Block.isBlockFluid[var1.getBlockId(var2o, var3o + 1, var4o)]) var6b = 1.0F;
+			return (var6 != this.movingId && var6 != this.stillId || var5 >= 2 && var6a != var6b)
+					&& (var5 == 1 && (var1.getBlockId(var2 - 1, var3, var4) == 0 || var1.getBlockId(var2 + 1, var3, var4) == 0 || var1.getBlockId(var2, var3, var4 - 1) == 0 || var1.getBlockId(var2, var3, var4 + 1) == 0)
+					|| super.shouldSideBeRendered(var1, var2, var3, var4, var5));
 		} else {
 			return false;
 		}
@@ -139,7 +132,7 @@
 		return false;
 	}
 
-	public AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
+	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
 		return null;
 	}
 
@@ -148,14 +141,111 @@
 	}
 
 	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
-		if(var5 != 0) {
-			Material var6 = Block.blocksList[var5].material;
-			if(this.material == Material.water && var6 == Material.lava || var6 == Material.water && this.material == Material.lava) {
-				var1.setBlockWithNotify(var2, var3, var4, Block.stone.blockID);
-			}
-		}
-
-		var1.scheduleBlockUpdate(var2, var3, var4, this.blockID);
+		this.checkForHarden(var1, var2, var3, var4);
+	}
+
+	private int getEffectiveFlowDecay(World var1, int var2, int var3, int var4) {
+		if(var1.getBlockMaterial(var2, var3, var4) != this.material) {
+			return -1;
+		} else {
+			int var5 = var1.getBlockMetadata(var2, var3, var4);
+			if(var5 >= 8) {
+				var5 = 0;
+			}
+
+			return var5;
+		}
+	}
+
+	private Vec3D getFlowVector(World var1, int var2, int var3, int var4) {
+		Vec3D var5 = new Vec3D(0.0F, 0.0F, 0.0F);
+		int var6 = this.getEffectiveFlowDecay(var1, var2, var3, var4);
+
+		for(int var7 = 0; var7 < 4; ++var7) {
+			int var8 = var2;
+			int var9 = var4;
+			if(var7 == 0) {
+				var8 = var2 - 1;
+			}
+
+			if(var7 == 1) {
+				var9 = var4 - 1;
+			}
+
+			if(var7 == 2) {
+				++var8;
+			}
+
+			if(var7 == 3) {
+				++var9;
+			}
+
+			int var10 = this.getEffectiveFlowDecay(var1, var8, var3, var9);
+			if(var10 < 0) {
+				var10 = this.getEffectiveFlowDecay(var1, var8, var3 - 1, var9);
+				if(var10 >= 0) {
+					var10 -= var6 - 8;
+					var5 = var5.addVector((float)((var8 - var2) * var10), (float)(var10 * 0), (float)((var9 - var4) * var10));
+				}
+			} else if(var10 >= 0) {
+				var10 -= var6;
+				var5 = var5.addVector((float)((var8 - var2) * var10), (float)(var10 * 0), (float)((var9 - var4) * var10));
+			}
+		}
+
+		if(var1.getBlockMetadata(var2, var3, var4) >= 8) {
+			boolean var11 = false;
+			if(this.getIsBlockSolid(var1, var2, var3, var4 - 1, 2)) {
+				var11 = true;
+			}
+
+			if(var11 || this.getIsBlockSolid(var1, var2, var3, var4 + 1, 3)) {
+				var11 = true;
+			}
+
+			if(var11 || this.getIsBlockSolid(var1, var2 - 1, var3, var4, 4)) {
+				var11 = true;
+			}
+
+			if(var11 || this.getIsBlockSolid(var1, var2 + 1, var3, var4, 5)) {
+				var11 = true;
+			}
+
+			if(var11 || this.getIsBlockSolid(var1, var2, var3 + 1, var4 - 1, 2)) {
+				var11 = true;
+			}
+
+			if(var11 || this.getIsBlockSolid(var1, var2, var3 + 1, var4 + 1, 3)) {
+				var11 = true;
+			}
+
+			if(var11 || this.getIsBlockSolid(var1, var2 - 1, var3 + 1, var4, 4)) {
+				var11 = true;
+			}
+
+			if(var11 || this.getIsBlockSolid(var1, var2 + 1, var3 + 1, var4, 5)) {
+				var11 = true;
+			}
+
+			if(var11) {
+				var5 = var5.normalize().addVector(0.0F, -6.0F, 0.0F);
+			}
+		}
+
+		var5 = var5.normalize();
+		return var5;
+	}
+
+	public final boolean getIsBlockSolid(World var1, int var2, int var3, int var4, int var5) {
+		Material var6 = var1.getBlockMaterial(var2, var3, var4);
+		return var6 == this.material ? false : (var5 == 1 ? true : !var1.isBlockNormalCube(var2, var3, var4));
+	}
+
+	public final void velocityToAddToEntity(World var1, int var2, int var3, int var4, Vec3D var5) {
+		Vec3D var6 = this.getFlowVector(var1, var2, var3, var4);
+		var5.xCoord += var6.xCoord;
+		var5.yCoord += var6.yCoord;
+		var5.zCoord += var6.zCoord;
 	}
 
 	public int tickRate() {
@@ -221,5 +311,53 @@
 		Material var4 = var0.getBlockMaterial(var1, var2, var3);
 		Material var5 = var0.getBlockMaterial(var1, var2 - 1, var3);
 		return !var4.getIsSolid() && !var4.getIsLiquid() ? var5.getIsSolid() || var5.getIsLiquid() : false;
+	}
+
+	private void checkForHarden(World var1, int var2, int var3, int var4) {
+		if(var1.getBlockId(var2, var3, var4) == this.blockID) {
+			if(this.material == Material.lava) {
+				boolean var5 = false;
+				if(var5 || var1.getBlockMaterial(var2, var3, var4 - 1) == Material.water) {
+					var5 = true;
+				}
+
+				if(var5 || var1.getBlockMaterial(var2, var3, var4 + 1) == Material.water) {
+					var5 = true;
+				}
+
+				if(var5 || var1.getBlockMaterial(var2 - 1, var3, var4) == Material.water) {
+					var5 = true;
+				}
+
+				if(var5 || var1.getBlockMaterial(var2 + 1, var3, var4) == Material.water) {
+					var5 = true;
+				}
+
+				if(var5 || var1.getBlockMaterial(var2, var3 + 1, var4) == Material.water) {
+					var5 = true;
+				}
+
+				if(var5) {
+					int var6 = var1.getBlockMetadata(var2, var3, var4);
+					if(var6 == 0) {
+						var1.setBlockWithNotify(var2, var3, var4, Block.obsidian.blockID);
+					} else if(var6 <= 4) {
+						var1.setBlockWithNotify(var2, var3, var4, Block.cobblestone.blockID);
+					}
+
+					this.triggerLavaMixEffects(var1, var2, var3, var4);
+				}
+			}
+
+		}
+	}
+
+	protected static void triggerLavaMixEffects(World var0, int var1, int var2, int var3) {
+//		var0.playSoundEffect(((float)var1 + 0.5F), ((float)var2 + 0.5F), ((float)var3 + 0.5F), "random.fizz", 2.6F + (var0.random.nextFloat() - var0.random.nextFloat()) * 0.8F);
+
+		for(int var4 = 0; var4 < 8; ++var4) {
+			var0.spawnParticle("largesmoke", var1 + (float)Math.random(), var2 + (float)1.2D, var3 + (float)Math.random(), 0.0F, 0.0F, 0.0F);
+		}
+
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeatureCacti.java
@@ -1,0 +1,27 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+
+import java.util.Random;
+
+public class FeatureCacti implements Feature {
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		for(int var6 = 0; var6 < 10; ++var6) {
+			int var7 = var3 + var2.nextInt(8) - var2.nextInt(8);
+			int var8 = var4 + var2.nextInt(4) - var2.nextInt(4);
+			int var9 = var5 + var2.nextInt(8) - var2.nextInt(8);
+			if(var1.getBlockId(var7, var8, var9) == 0) {
+				int var10 = 1 + var2.nextInt(var2.nextInt(3) + 2);
+
+				for(int var11 = 0; var11 < var10; ++var11) {
+					if(Block.cactus.canBlockStay(var1, var7, var8 + var11, var9)) {
+						var1.setBlock(var7, var8 + var11, var9, Block.cactus.blockID);
+					}
+				}
+			}
+		}
+
+		return true;
+	}
+}
--- net/minecraft/game/entity/monster/EntityCreeper.java
+++ net/minecraft/game/entity/monster/EntityCreeper.java
@@ -14,6 +14,7 @@
 	public EntityCreeper(World var1) {
 		super(var1);
 		this.texture = "/mob/creeper.png";
+		this.scoreValue = 250;
 	}
 
 	protected final void writeEntityToNBT(NBTTagCompound var1) {
--- net/minecraft/game/level/Light.java
+++ net/minecraft/game/level/Light.java
@@ -3,6 +3,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import net.minecraft.game.level.block.Block;
+import util.MathHelper;
 
 public final class Light {
 	private int lightingUpdateCounter = 0;
@@ -40,7 +41,7 @@
 	}
 
 	public final void updateSkylight(int var1, int var2, int var3, int var4) {
-		this.lightingUpdateList1.add(new MetadataChunkBlock(this, var1, var2, 0, var3, var4, 1));
+		this.lightingUpdateList1.add(0, new MetadataChunkBlock(null, var1, var2, 0, var3, var4, 1));
 	}
 
 	public final void updateDaylightCycle(int var1) {
@@ -61,7 +62,7 @@
 				this.updateLight(64);
 			}
 
-			this.metadataChunkBlock = new MetadataChunkBlock(this, 0, 0, 0, this.worldObj.width, this.worldObj.height, this.worldObj.length);
+			this.metadataChunkBlock = new MetadataChunkBlock(null, 0, 0, 0, this.worldObj.width, this.worldObj.height, this.worldObj.length);
 		}
 	}
 
@@ -103,8 +104,8 @@
 
 		for(var6 = 0; var6 < this.worldWidth; var6 += 32) {
 			for(var7 = 0; var7 < this.worldLength; var7 += 32) {
-				this.blockLightList.add(new MetadataChunkBlock(this, var6, 0, var7, var6 + 32, this.worldHeight, var7 + 32));
-				this.skyLightList.add(new MetadataChunkBlock(this, var6, 0, var7, var6 + 32, this.worldHeight, var7 + 32));
+				this.blockLightList.add(new MetadataChunkBlock(null, var6, 0, var7, var6 + 32, this.worldHeight, var7 + 32));
+				this.skyLightList.add(new MetadataChunkBlock(null, var6, 0, var7, var6 + 32, this.worldHeight, var7 + 32));
 			}
 		}
 
@@ -117,7 +118,7 @@
 	}
 
 	public final void updateBlockLight(int var1, int var2, int var3, int var4, int var5, int var6) {
-		this.blockLightList.add(new MetadataChunkBlock(this, var1, var2, var3, var4, var5, var6));
+		this.blockLightList.add(0, new MetadataChunkBlock(null, var1, var2, var3, var4, var5, var6));
 	}
 
 	private void updateLists(int var1, int var2, int var3, int var4, int var5, int var6) {
@@ -152,7 +153,7 @@
 			this.lightingUpdateList2.remove(this.lightingUpdateList2.size() - 1);
 		}
 
-		int var1 = 5;
+		int var1 = 50;
 
 		while(this.skyLightList.size() > 0 && var1-- > 0) {
 			MetadataChunkBlock var2 = (MetadataChunkBlock)this.skyLightList.remove(0);
@@ -184,7 +185,6 @@
 				int var11;
 				int var12;
 				int var13;
-				Light var22;
 				if(this.lightingUpdateList1.size() > 0) {
 					var20 = true;
 					var21 = (MetadataChunkBlock)this.lightingUpdateList1.remove(0);
@@ -192,26 +192,24 @@
 					var6 = var21.maxX;
 					var5 = var21.y;
 					var4 = var21.x;
-					var22 = this;
 
 					for(var8 = var4; var8 < var4 + var6; ++var8) {
 						for(var9 = var5; var9 < var5 + var7; ++var9) {
-							var10 = var22.heightMap[var8 + var9 * var22.worldWidth];
+							var10 = this.heightMap[var8 + var9 * this.worldWidth];
 
-							for(var11 = var22.worldHeight - 1; var11 > 0 && Block.lightOpacity[var22.blocks[(var11 * var22.worldLength + var9) * var22.worldWidth + var8]] == 0; --var11) {
+							for(var11 = this.worldHeight - 1; var11 > 0 && Block.lightOpacity[this.blocks[(var11 * this.worldLength + var9) * this.worldWidth + var8]] == 0; --var11) {
 							}
 
-							var22.heightMap[var8 + var9 * var22.worldWidth] = var11 + 1;
+							this.heightMap[var8 + var9 * this.worldWidth] = var11 + 1;
 							if(var10 != var11) {
 								var12 = var10 < var11 ? var10 : var11;
 								var13 = var10 > var11 ? var10 : var11;
-								var22.updateLists(var8, var12, var9, var8 + 1, var13, var9 + 1);
+								this.updateLists(var8, var12, var9, var8 + 1, var13, var9 + 1);
 							}
 						}
 					}
 				}
 
-				var22 = this;
 				var4 = this.worldObj.skylightSubtracted;
 				var5 = -999;
 				var6 = -999;
@@ -222,34 +220,34 @@
 				var11 = 1024;
 				var12 = 0;
 
-				while(var11-- > 0 && (var22.lightingUpdateCounter > 0 || var22.lightingUpdateList.size() > 0)) {
+				while(var11-- > 0 && (this.lightingUpdateCounter > 0 || this.lightingUpdateList.size() > 0)) {
 					++var12;
-					if(var22.lightingUpdateCounter == 0) {
-						if(var22.lightingUpdateList3 != null) {
-							int[] var23 = var22.lightingUpdateList3;
-							var22.lightingUpdateList2.add(var23);
+					if(this.lightingUpdateCounter == 0) {
+						if(this.lightingUpdateList3 != null) {
+							int[] var23 = this.lightingUpdateList3;
+							this.lightingUpdateList2.add(var23);
 						}
 
-						var22.lightingUpdateList3 = (int[])var22.lightingUpdateList.remove(var22.lightingUpdateList.size() - 1);
-						var22.lightingUpdateCounter = var22.lightingUpdateList3[var22.lightingUpdateList3.length - 1];
+						this.lightingUpdateList3 = (int[])this.lightingUpdateList.remove(this.lightingUpdateList.size() - 1);
+						this.lightingUpdateCounter = this.lightingUpdateList3[this.lightingUpdateList3.length - 1];
 					}
 
-					if(var22.lightingUpdateCounter > var22.lightingUpdateList3.length - 32) {
-						var13 = var22.lightingUpdateList3[--var22.lightingUpdateCounter];
-						var22.lightingUpdateList3[var22.lightingUpdateList3.length - 1] = var22.lightingUpdateCounter;
-						var22.lightingUpdateList.add(var22.lightingUpdateList3);
-						var22.lightingUpdateList3 = var22.getLightingUpdates();
-						var22.lightingUpdateCounter = 1;
-						var22.lightingUpdateList3[0] = var13;
+					if(this.lightingUpdateCounter > this.lightingUpdateList3.length - 32) {
+						var13 = this.lightingUpdateList3[--this.lightingUpdateCounter];
+						this.lightingUpdateList3[this.lightingUpdateList3.length - 1] = this.lightingUpdateCounter;
+						this.lightingUpdateList.add(this.lightingUpdateList3);
+						this.lightingUpdateList3 = this.getLightingUpdates();
+						this.lightingUpdateCounter = 1;
+						this.lightingUpdateList3[0] = var13;
 					} else {
-						var13 = var22.lightingUpdateList3[--var22.lightingUpdateCounter];
-						var1 = var13 % var22.worldWidth;
-						int var14 = var13 / var22.worldWidth % var22.worldHeight;
-						int var15 = var13 / var22.worldWidth / var22.worldHeight % var22.worldLength;
-						var22.chunks[var13 >> 3] = (byte)(var22.chunks[var13 >> 3] ^ 1 << (var13 & 7));
-						var13 = var22.heightMap[var1 + var15 * var22.worldWidth];
+						var13 = this.lightingUpdateList3[--this.lightingUpdateCounter];
+						var1 = var13 % this.worldWidth;
+						int var14 = var13 / this.worldWidth % this.worldHeight;
+						int var15 = var13 / this.worldWidth / this.worldHeight % this.worldLength;
+						this.chunks[var13 >> 3] = (byte)(this.chunks[var13 >> 3] ^ 1 << (var13 & 7));
+						var13 = this.heightMap[var1 + var15 * this.worldWidth];
 						int var16 = var14 >= var13 ? var4 : 0;
-						byte var24 = var22.blocks[(var14 * var22.worldLength + var15) * var22.worldWidth + var1];
+						byte var24 = this.blocks[(var14 * this.worldLength + var15) * this.worldWidth + var1];
 						int var17 = Block.lightOpacity[var24];
 						if(var17 > 100) {
 							var16 = 0;
@@ -261,42 +259,42 @@
 
 							int var18;
 							if(var1 > 0) {
-								var18 = (var22.data[(var14 * var22.worldLength + var15) * var22.worldWidth + (var1 - 1)] & 15) - var17;
+								var18 = (this.data[(var14 * this.worldLength + var15) * this.worldWidth + (var1 - 1)] & 15) - var17;
 								if(var18 > var16) {
 									var16 = var18;
 								}
 							}
 
-							if(var1 < var22.worldWidth - 1) {
-								var18 = (var22.data[(var14 * var22.worldLength + var15) * var22.worldWidth + var1 + 1] & 15) - var17;
+							if(var1 < this.worldWidth - 1) {
+								var18 = (this.data[(var14 * this.worldLength + var15) * this.worldWidth + var1 + 1] & 15) - var17;
 								if(var18 > var16) {
 									var16 = var18;
 								}
 							}
 
 							if(var14 > 0) {
-								var18 = (var22.data[((var14 - 1) * var22.worldLength + var15) * var22.worldWidth + var1] & 15) - var17;
+								var18 = (this.data[((var14 - 1) * this.worldLength + var15) * this.worldWidth + var1] & 15) - var17;
 								if(var18 > var16) {
 									var16 = var18;
 								}
 							}
 
-							if(var14 < var22.worldHeight - 1) {
-								var18 = (var22.data[((var14 + 1) * var22.worldLength + var15) * var22.worldWidth + var1] & 15) - var17;
+							if(var14 < this.worldHeight - 1) {
+								var18 = (this.data[((var14 + 1) * this.worldLength + var15) * this.worldWidth + var1] & 15) - var17;
 								if(var18 > var16) {
 									var16 = var18;
 								}
 							}
 
 							if(var15 > 0) {
-								var18 = (var22.data[(var14 * var22.worldLength + (var15 - 1)) * var22.worldWidth + var1] & 15) - var17;
+								var18 = (this.data[(var14 * this.worldLength + (var15 - 1)) * this.worldWidth + var1] & 15) - var17;
 								if(var18 > var16) {
 									var16 = var18;
 								}
 							}
 
-							if(var15 < var22.worldLength - 1) {
-								var18 = (var22.data[(var14 * var22.worldLength + var15 + 1) * var22.worldWidth + var1] & 15) - var17;
+							if(var15 < this.worldLength - 1) {
+								var18 = (this.data[(var14 * this.worldLength + var15 + 1) * this.worldWidth + var1] & 15) - var17;
 								if(var18 > var16) {
 									var16 = var18;
 								}
@@ -307,54 +305,54 @@
 							var16 = Block.lightValue[var24];
 						}
 
-						var17 = var22.data[(var14 * var22.worldLength + var15) * var22.worldWidth + var1] & 15;
+						var17 = this.data[(var14 * this.worldLength + var15) * this.worldWidth + var1] & 15;
 						if(var17 != var16) {
-							var22.data[(var14 * var22.worldLength + var15) * var22.worldWidth + var1] = (byte)((var22.data[(var14 * var22.worldLength + var15) * var22.worldWidth + var1] & 240) + var16);
-							if(var1 > 0 && (var22.data[(var14 * var22.worldLength + var15) * var22.worldWidth + (var1 - 1)] & 15) != var16 - 1) {
-								var13 = var1 - 1 + var14 * var22.worldWidth + var15 * var22.worldWidth * var22.worldHeight;
-								if((var22.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
-									var22.chunks[var13 >> 3] = (byte)(var22.chunks[var13 >> 3] | 1 << (var13 & 7));
-									var22.lightingUpdateList3[var22.lightingUpdateCounter++] = var13;
-								}
-							}
-
-							if(var1 < var22.worldWidth - 1 && (var22.data[(var14 * var22.worldLength + var15) * var22.worldWidth + var1 + 1] & 15) != var16 - 1) {
-								var13 = var1 + 1 + var14 * var22.worldWidth + var15 * var22.worldWidth * var22.worldHeight;
-								if((var22.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
-									var22.chunks[var13 >> 3] = (byte)(var22.chunks[var13 >> 3] | 1 << (var13 & 7));
-									var22.lightingUpdateList3[var22.lightingUpdateCounter++] = var13;
-								}
-							}
-
-							if(var14 > 0 && (var22.data[((var14 - 1) * var22.worldLength + var15) * var22.worldWidth + var1] & 15) != var16 - 1) {
-								var13 = var1 + (var14 - 1) * var22.worldWidth + var15 * var22.worldWidth * var22.worldHeight;
-								if((var22.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
-									var22.chunks[var13 >> 3] = (byte)(var22.chunks[var13 >> 3] | 1 << (var13 & 7));
-									var22.lightingUpdateList3[var22.lightingUpdateCounter++] = var13;
-								}
-							}
-
-							if(var14 < var22.worldHeight - 1 && (var22.data[((var14 + 1) * var22.worldLength + var15) * var22.worldWidth + var1] & 15) != var16 - 1) {
-								var13 = var1 + (var14 + 1) * var22.worldWidth + var15 * var22.worldWidth * var22.worldHeight;
-								if((var22.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
-									var22.chunks[var13 >> 3] = (byte)(var22.chunks[var13 >> 3] | 1 << (var13 & 7));
-									var22.lightingUpdateList3[var22.lightingUpdateCounter++] = var13;
-								}
-							}
-
-							if(var15 > 0 && (var22.data[(var14 * var22.worldLength + (var15 - 1)) * var22.worldWidth + var1] & 15) != var16 - 1) {
-								var13 = var1 + var14 * var22.worldWidth + (var15 - 1) * var22.worldWidth * var22.worldHeight;
-								if((var22.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
-									var22.chunks[var13 >> 3] = (byte)(var22.chunks[var13 >> 3] | 1 << (var13 & 7));
-									var22.lightingUpdateList3[var22.lightingUpdateCounter++] = var13;
-								}
-							}
-
-							if(var15 < var22.worldLength - 1 && (var22.data[(var14 * var22.worldLength + var15 + 1) * var22.worldWidth + var1] & 15) != var16 - 1) {
-								var13 = var1 + var14 * var22.worldWidth + (var15 + 1) * var22.worldWidth * var22.worldHeight;
-								if((var22.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
-									var22.chunks[var13 >> 3] = (byte)(var22.chunks[var13 >> 3] | 1 << (var13 & 7));
-									var22.lightingUpdateList3[var22.lightingUpdateCounter++] = var13;
+							this.data[(var14 * this.worldLength + var15) * this.worldWidth + var1] = (byte)((this.data[(var14 * this.worldLength + var15) * this.worldWidth + var1] & 240) + var16);
+							if(var1 > 0 && (this.data[(var14 * this.worldLength + var15) * this.worldWidth + (var1 - 1)] & 15) != var16 - 1) {
+								var13 = var1 - 1 + var14 * this.worldWidth + var15 * this.worldWidth * this.worldHeight;
+								if((this.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
+									this.chunks[var13 >> 3] = (byte)(this.chunks[var13 >> 3] | 1 << (var13 & 7));
+									this.lightingUpdateList3[this.lightingUpdateCounter++] = var13;
+								}
+							}
+
+							if(var1 < this.worldWidth - 1 && (this.data[(var14 * this.worldLength + var15) * this.worldWidth + var1 + 1] & 15) != var16 - 1) {
+								var13 = var1 + 1 + var14 * this.worldWidth + var15 * this.worldWidth * this.worldHeight;
+								if((this.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
+									this.chunks[var13 >> 3] = (byte)(this.chunks[var13 >> 3] | 1 << (var13 & 7));
+									this.lightingUpdateList3[this.lightingUpdateCounter++] = var13;
+								}
+							}
+
+							if(var14 > 0 && (this.data[((var14 - 1) * this.worldLength + var15) * this.worldWidth + var1] & 15) != var16 - 1) {
+								var13 = var1 + (var14 - 1) * this.worldWidth + var15 * this.worldWidth * this.worldHeight;
+								if((this.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
+									this.chunks[var13 >> 3] = (byte)(this.chunks[var13 >> 3] | 1 << (var13 & 7));
+									this.lightingUpdateList3[this.lightingUpdateCounter++] = var13;
+								}
+							}
+
+							if(var14 < this.worldHeight - 1 && (this.data[((var14 + 1) * this.worldLength + var15) * this.worldWidth + var1] & 15) != var16 - 1) {
+								var13 = var1 + (var14 + 1) * this.worldWidth + var15 * this.worldWidth * this.worldHeight;
+								if((this.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
+									this.chunks[var13 >> 3] = (byte)(this.chunks[var13 >> 3] | 1 << (var13 & 7));
+									this.lightingUpdateList3[this.lightingUpdateCounter++] = var13;
+								}
+							}
+
+							if(var15 > 0 && (this.data[(var14 * this.worldLength + (var15 - 1)) * this.worldWidth + var1] & 15) != var16 - 1) {
+								var13 = var1 + var14 * this.worldWidth + (var15 - 1) * this.worldWidth * this.worldHeight;
+								if((this.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
+									this.chunks[var13 >> 3] = (byte)(this.chunks[var13 >> 3] | 1 << (var13 & 7));
+									this.lightingUpdateList3[this.lightingUpdateCounter++] = var13;
+								}
+							}
+
+							if(var15 < this.worldLength - 1 && (this.data[(var14 * this.worldLength + var15 + 1) * this.worldWidth + var1] & 15) != var16 - 1) {
+								var13 = var1 + var14 * this.worldWidth + (var15 + 1) * this.worldWidth * this.worldHeight;
+								if((this.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
+									this.chunks[var13 >> 3] = (byte)(this.chunks[var13 >> 3] | 1 << (var13 & 7));
+									this.lightingUpdateList3[this.lightingUpdateCounter++] = var13;
 								}
 							}
 
@@ -389,7 +387,7 @@
 				}
 
 				if(var5 > -999) {
-					var22.skyLightList.add(new MetadataChunkBlock(var22, var5, var7, var9, var6, var8, var10));
+					this.skyLightList.add(new MetadataChunkBlock(null, var5, var7, var9, var6, var8, var10));
 				}
 
 				if(var12 > 0) {
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageFlooding.java
@@ -1,0 +1,26 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+
+public class StageFlooding extends TerrainGenStage {
+	public StageFlooding(Block block) {
+		super("Flooding..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			if (block == null) {
+				return;
+			}
+
+			for (int x = 0; x < blocks.width; x++) {
+				progressor.accept(x * 100.0F / (blocks.width - 1));
+
+				for (int z = 0; z < blocks.length; z++) {
+					for (int y = world.waterLevel - 1; y >= 0 && blocks.get(x, y, z) == 0; y--) {
+						blocks.set(x, y, z, block.blockID);
+						if (blocks.get(x, y - 1, z) == Block.grass.blockID) {
+							blocks.set(x, y - 1, z, Block.dirt.blockID);
+						}
+					}
+				}
+			}
+		});
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/block/BlockObserver.java
@@ -1,0 +1,50 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+import java.util.HashSet;
+import java.util.Random;
+import java.util.Set;
+
+public class BlockObserver extends Block {
+	public BlockObserver(int var1) {
+		super(var1, 84, Material.iron);
+	}
+
+	public int tickRate() {
+		return 0;
+	}
+
+	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
+		var1.setBlockMetadata(var2, var3, var4, var5);
+	}
+
+	public int getBlockTextureFromSide(int var1) {
+		return var1 == 3 ? 83 : var1 == 2 ? 118 : 84;
+	}
+
+	public int getBlockTexture(World var1, int var2, int var3, int var4, int var5) {
+		int dir = var1.getBlockMetadata(var2, var3, var4);
+		return var5 == dir ? 83 : var5 == dir / 2 * 2 + 1 - (dir % 2) ? 118 : 84;
+	}
+
+	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
+		if (var5 == var1.getBlockMetadata(var2, var3, var4)) {
+			for (int i = 0; i < 5; i++) {
+				var1.spawnParticle("largesmoke",
+						var2 + var1.random.nextFloat() * 1.5F - 0.25F,
+						var3 + var1.random.nextFloat() * 1.5F - 0.25F,
+						var4 + var1.random.nextFloat() * 1.5F - 0.25F,
+						0.0F, 0.0F, 0.0F);
+			}
+
+			var1.scheduleBlockUpdate(var2, var3, var4, this.blockID);
+		}
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		int dir = var1.getBlockMetadata(var2, var3, var4);
+		var1.transmitPowerInDirection(var2, var3, var4, dir / 2 * 2 + 1 - dir % 2);
+	}
+}
--- net/minecraft/game/level/block/BlockSponge.java
+++ net/minecraft/game/level/block/BlockSponge.java
@@ -4,7 +4,7 @@
 import net.minecraft.game.level.material.Material;
 
 public final class BlockSponge extends Block {
-	protected BlockSponge(int var1) {
+	public BlockSponge(int var1) {
 		super(19, Material.sponge);
 		this.blockIndexInTexture = 48;
 	}
--- net/minecraft/game/entity/animal/EntitySheep.java
+++ net/minecraft/game/entity/animal/EntitySheep.java
@@ -22,7 +22,7 @@
 			int var3 = 1 + this.rand.nextInt(3);
 
 			for(int var4 = 0; var4 < var3; ++var4) {
-				EntityItem var5 = this.entityDropItem(Block.clothGray.blockID, 1, 1.0F);
+				EntityItem var5 = this.entityDropItem(Block.clothWhite.blockID, 1, 1.0F);
 				var5.motionY += this.rand.nextFloat() * 0.05F;
 				var5.motionX += (this.rand.nextFloat() - this.rand.nextFloat()) * 0.1F;
 				var5.motionZ += (this.rand.nextFloat() - this.rand.nextFloat()) * 0.1F;
--- net/minecraft/game/entity/misc/EntityItem.java
+++ net/minecraft/game/entity/misc/EntityItem.java
@@ -27,6 +27,7 @@
 		this.motionY = 0.2F;
 		this.motionZ = (float)(Math.random() * (double)0.2F - (double)0.1F);
 		this.canTriggerWalking = false;
+		this.isDead = !var1.survivalWorld;
 	}
 
 	public EntityItem(World var1) {
--- net/minecraft/game/level/block/BlockStationary.java
+++ net/minecraft/game/level/block/BlockStationary.java
@@ -1,57 +1,23 @@
 package net.minecraft.game.level.block;
 
-import java.util.Random;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.material.Material;
 
 public final class BlockStationary extends BlockFluid {
-	protected BlockStationary(int var1, Material var2) {
+	public BlockStationary(int var1, Material var2) {
 		super(var1, var2);
 		this.movingId = var1 - 1;
 		this.stillId = var1;
 		this.setTickOnLoad(false);
 	}
 
-	public final void updateTick(World var1, int var2, int var3, int var4, Random var5) {
-	}
-
 	public final void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
-		boolean var6 = false;
-		if(this.canFlow(var1, var2, var3 - 1, var4)) {
-			var6 = true;
-		}
-
-		if(!var6 && this.canFlow(var1, var2 - 1, var3, var4)) {
-			var6 = true;
-		}
-
-		if(!var6 && this.canFlow(var1, var2 + 1, var3, var4)) {
-			var6 = true;
-		}
-
-		if(!var6 && this.canFlow(var1, var2, var3, var4 - 1)) {
-			var6 = true;
-		}
-
-		if(!var6 && this.canFlow(var1, var2, var3, var4 + 1)) {
-			var6 = true;
-		}
-
-		if(var5 != 0) {
-			Material var7 = Block.blocksList[var5].material;
-			if(this.material == Material.water && var7 == Material.lava || var7 == Material.water && this.material == Material.lava) {
-				var1.setBlockWithNotify(var2, var3, var4, Block.stone.blockID);
-				return;
-			}
-		}
-
-		if(Block.fire.getChanceOfNeighborsEncouragingFire(var5)) {
-			var6 = true;
-		}
-
-		if(var6) {
-			var1.setTileNoUpdate(var2, var3, var4, this.movingId);
-			var1.scheduleBlockUpdate(var2, var3, var4, this.movingId);
+		super.onNeighborBlockChange(var1, var2, var3, var4, var5);
+		if(var1.getBlockId(var2, var3, var4) == this.blockID) {
+			int var6 = var1.getBlockMetadata(var2, var3, var4);
+			var1.setBlockAndMetadata(var2, var3, var4, this.blockID - 1, var6);
+			var1.markBlocksDirty(var2, var3, var4, var2, var3, var4);
+			var1.scheduleBlockUpdate(var2, var3, var4, this.blockID - 1);
 		}
 
 	}
--- /dev/null
+++ net/minecraft/game/level/generator/LevelTheme.java
@@ -1,0 +1,590 @@
+package net.minecraft.game.level.generator;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.generator.feature.*;
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+import net.minecraft.game.level.generator.terrain.TerrainGenStage;
+
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+public enum LevelTheme {
+	NORMAL("Normal"),
+	HELL("Hell") {
+		@Override
+		public boolean canNaturallyGenerate() {
+			return false;
+		}
+
+		@Override
+		public int getSkyColor() {
+			return 0x100400;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0x100400;
+		}
+
+		@Override
+		public int getCloudColor() {
+			return 0x210800;
+		}
+
+		@Override
+		public int getSkyBrightness() {
+			return 7;
+		}
+
+		@Override
+		public int modifyCloudHeight(int cloudHeight, int levelHeight, LevelType levelType) {
+			return levelType == LevelType.FLOATING ? levelHeight + 2 : cloudHeight;
+		}
+
+		@Override
+		public int modifyWaterLevel(int waterLevel, LevelType levelType) {
+			return levelType == LevelType.FLOATING ? -16 : waterLevel;
+		}
+
+		@Override
+		public double modifySandBeachThreshold(double threshold) {
+			return -8.0D;
+		}
+
+		@Override
+		public Block getSandBeachBlock() {
+			return Block.grass;
+		}
+
+		@Override
+		public Block getStillFluid() {
+			return Block.lavaStill;
+		}
+
+		@Override
+		public Block getDefaultFluid() {
+			return Block.lavaMoving;
+		}
+
+		@Override
+		public boolean growGrassOnDirt() {
+			return false;
+		}
+	},
+	PARADISE("Paradise") {
+		private final Feature FEATURE_PALM_TREE = new FeaturePalmTree();
+
+		@Override
+		public int getSkyColor() {
+			return 0xc6deff;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0xc6deff;
+		}
+
+		@Override
+		public int getCloudColor() {
+			return 0xeeeeff;
+		}
+
+		@Override
+		public int getSkylightSubtracted() {
+			return 15;
+		}
+
+		@Override
+		public int getSkyBrightness() {
+			return 16;
+		}
+
+		@Override
+		public int modifyCloudHeight(int cloudHeight, int levelHeight, LevelType levelType) {
+			return levelHeight + 64;
+		}
+
+		@Override
+		public double modifySandBeachThreshold(double threshold) {
+			return -32.0D;
+		}
+
+		@Override
+		public int modifyBeachHeightOffset(int offset) {
+			return offset + 2;
+		}
+
+		@Override
+		public int getFlowerCount() {
+			return 1000;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return FEATURE_PALM_TREE;
+		}
+	},
+	WOODS("Woods") {
+		private final Feature FEATURE_BIG_TREE = new FeatureBigTree();
+
+		@Override
+		public int getSkyColor() {
+			return 0x757d87;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0x4d5a5b;
+		}
+
+		@Override
+		public int getCloudColor() {
+			return 0x4d5a5b;
+		}
+
+		@Override
+		public int getSkyBrightness() {
+			return 12;
+		}
+
+		@Override
+		public double modifySandBeachThreshold(double threshold) {
+			return -8.0D;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return rand.nextInt(3) == 0 ? FEATURE_TREE : FEATURE_BIG_TREE;
+		}
+
+		@Override
+		public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+			this.growTreesNoise(world, rand, progressor, 8, 2.0D, 25.0D, 0.5D, 5);
+		}
+	},
+	RAINFOREST("Rainforest") {
+		private final Feature FEATURE_RAINFOREST_TREE = new FeatureSwampTree(5, 20);
+
+		@Override
+		public int getSkyColor() {
+			return 0x88ddff;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0xffffdd;
+		}
+
+		@Override
+		public int getTreeSpread() {
+			return 20000;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return FEATURE_RAINFOREST_TREE;
+		}
+
+		@Override
+		public int getFlowerCount() {
+			return 250;
+		}
+
+		@Override
+		public int getMushroomCount() {
+			return 250;
+		}
+	},
+	WINTER("Winter") {
+		@Override
+		public int getSkyColor() {
+			return 0xaaaaff;
+		}
+
+		@Override
+		public boolean hasSnow() {
+			return true;
+		}
+	},
+	TAIGA("Taiga") {
+		private final Feature FEATURE_TAIGA_1 = new FeatureTaiga1();
+		private final Feature FEATURE_TAIGA_2 = new FeatureTaiga2();
+
+		@Override
+		public int getSkyColor() {
+			return 0x9fbbff;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0xddeeff;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return rand.nextInt(3) == 0 ? FEATURE_TAIGA_1 : FEATURE_TAIGA_2;
+		}
+
+		@Override
+		public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+			this.growTreesNoise(world, rand, progressor, 8, 2.0D, 25.0D, 0.5D, 5);
+		}
+	},
+	SNOWY_TAIGA("Snowy Taiga") {
+		private final Feature FEATURE_TAIGA_1 = new FeatureTaiga1();
+		private final Feature FEATURE_TAIGA_2 = new FeatureTaiga2();
+
+		@Override
+		public int getSkyColor() {
+			return 0xaa90ff;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0xddeeff;
+		}
+
+		@Override
+		public boolean hasSnow() {
+			return true;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return rand.nextInt(3) == 0 ? FEATURE_TAIGA_1 : FEATURE_TAIGA_2;
+		}
+
+		@Override
+		public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+			this.growTreesNoise(world, rand, progressor, 8, 2.0D, 25.0D, 0.0D, 5);
+		}
+	},
+	DESERT("Desert") {
+		private final Feature FEATURE_CACTI = new FeatureCacti();
+		private final Feature FEATURE_PALM_TREE = new FeaturePalmTree();
+
+		@Override
+		public int getSkyColor() {
+			return 0xffff7f;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0xffffbb;
+		}
+
+		@Override
+		public int getCloudColor() {
+			return 0xddbb66;
+		}
+
+		@Override
+		public Block getSoilBlock() {
+			return Block.sand;
+		}
+
+		@Override
+		public Block getStillFluid() {
+			return null;
+		}
+
+		@Override
+		public Block getDefaultFluid() {
+			return null;
+		}
+
+		@Override
+		public int modifyWaterLevel(int waterLevel, LevelType levelType) {
+			return -1;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return FEATURE_PALM_TREE;
+		}
+
+		@Override
+		public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+			int var2 = world.width * world.length * world.height / 1000;
+
+			for(int var3 = 0; var3 < var2; ++var3) {
+				if(var3 % 100 == 0) {
+					progressor.accept((float)var3 * 100.0F / (float)(var2 - 1));
+				}
+
+				int var4 = rand.nextInt(world.width);
+				int var5 = rand.nextInt(world.height);
+				int var6 = rand.nextInt(world.length);
+
+				if(var4 > 0 && var5 > 0 && var6 > 0 && var4 < world.width && var5 < world.height && var6 < world.length) {
+					FEATURE_CACTI.generate(world, rand, var4, var5, var6);
+				}
+			}
+		}
+	},
+	OASIS("Oasis") {
+		@Override
+		public int getSkyColor() {
+			return 0x7fffdd;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0xffffbb;
+		}
+
+		@Override
+		public Block getSoilBlock() {
+			return Block.sand;
+		}
+
+		@Override
+		public int modifyBeachHeightOffset(int offset) {
+			return offset + 3;
+		}
+
+		@Override
+		public Block getSandBeachBlock() {
+			return Block.grass;
+		}
+
+		@Override
+		public double modifySandBeachThreshold(double threshold) {
+			return -8.0D;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return DESERT.getTreeType(rand);
+		}
+
+		@Override
+		public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+			super.growTrees(world, rand, progressor);
+			DESERT.growTrees(world, rand, progressor);
+		}
+	},
+	INFDEV_415("Infdev 415") {
+		private final Feature FEATURE_BIG_TREE = new FeatureBigTree();
+
+		@Override
+		public boolean canNaturallyGenerate() {
+			return false;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return FEATURE_BIG_TREE;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 11587839;
+		}
+
+		@Override
+		public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+			NoiseGenerator forestNoise = new NoiseGeneratorOctaves(rand, 5);
+			for (int x = 8; x < world.width - 16; x += 16) {
+				progressor.accept((float)x / (float)(world.width / 16 - 1));
+				for (int z = 8; z < world.length - 16; z += 16) {
+					int treeAmount = (int)forestNoise.generateNoise(x * 0.25D, z * 0.25D) << 3;
+					for (int i = 0; i < treeAmount; i++) {
+						int sx = x + rand.nextInt(16);
+						int sz = z + rand.nextInt(16);
+						int sy = world.getHeightValue(sx, sz);
+						this.placeTree(world, rand, sx, sy, sz);
+					}
+				}
+			}
+		}
+	};
+
+	private static final Map<String, LevelTheme> NAME_TO_TYPE = Arrays.stream(values())
+			.collect(Collectors.toMap(LevelTheme::toString, Function.identity()));
+	private static final List<LevelTheme> NATURAL_THEMES = Arrays.stream(values())
+			.filter(LevelTheme::canNaturallyGenerate).collect(Collectors.toList());
+
+	private static final Feature FEATURE_TREE = new FeatureTree();
+
+	public final String name;
+
+	LevelTheme(String name) {
+		this.name = name;
+	}
+
+	public boolean canNaturallyGenerate() {
+		return true;
+	}
+
+	public int getSkyColor() {
+		return 0x99ccff;
+	}
+
+	public int getFogColor() {
+		return 0xffffff;
+	}
+
+	public int getCloudColor() {
+		return 0xffffff;
+	}
+
+	public int getSkylightSubtracted() {
+		return this.getSkyBrightness();
+	}
+
+	public int getSkyBrightness() {
+		return 15;
+	}
+
+	public int modifyCloudHeight(int cloudHeight, int levelHeight, LevelType levelType) {
+		return cloudHeight;
+	}
+
+	public int modifyWaterLevel(int waterLevel, LevelType levelType) {
+		return waterLevel;
+	}
+
+	public double modifySandBeachThreshold(double threshold) {
+		return threshold;
+	}
+
+	public double modifyGravelBeachThreshold(double threshold) {
+		return threshold;
+	}
+
+	public Block getSoilBlock() {
+		return Block.dirt;
+	}
+
+	public Block getStoneBlock() {
+		return Block.stone;
+	}
+
+	public Block getSandBeachBlock() {
+		return Block.sand;
+	}
+
+	public Block getGravelBeachBlock() {
+		return Block.gravel;
+	}
+
+	public int modifyBeachHeightOffset(int offset) {
+		return offset;
+	}
+
+	public Block getStillFluid() {
+		return Block.waterStill;
+	}
+
+	public Block getDefaultFluid() {
+		return Block.waterMoving;
+	}
+
+	public boolean growGrassOnDirt() {
+		return true;
+	}
+
+	public boolean hasSnow() {
+		return false;
+	}
+
+	public int getFlowerCount() {
+		return 100;
+	}
+
+	public int getMushroomCount() {
+		return 50;
+	}
+
+	public int getTreeSpread() {
+		return 80000;
+	}
+
+	public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+		int var2 = world.width * world.length * world.height / this.getTreeSpread();
+
+		for(int var3 = 0; var3 < var2; ++var3) {
+			if(var3 % 100 == 0) {
+				progressor.accept((float)var3 * 100.0F / (float)(var2 - 1));
+			}
+
+			int var4 = rand.nextInt(world.width);
+			int var5 = rand.nextInt(world.height);
+			int var6 = rand.nextInt(world.length);
+
+			for(int var7 = 0; var7 < 25; ++var7) {
+				int var8 = var4;
+				int var9 = var5;
+				int var10 = var6;
+
+				for(int var11 = 0; var11 < 20; ++var11) {
+					var8 += rand.nextInt(12) - rand.nextInt(12);
+					var9 += rand.nextInt(3) - rand.nextInt(6);
+					var10 += rand.nextInt(12) - rand.nextInt(12);
+					if(var8 > 0 && var9 > 0 && var10 > 0 && var8 < world.width && var9 < world.height && var10 < world.length) {
+						this.placeTree(world, rand, var8, var9, var10);
+					}
+				}
+			}
+		}
+	}
+
+	protected void growTreesNoise(World world, Random rand, Consumer<Float> progressor, int octaves, double spread, double density, double noiseBoost, int boost) {
+		NoiseGenerator forestNoise = new NoiseGeneratorOctaves(rand, octaves);
+
+		for (int x = 8; x < world.width - 16; x += 16) {
+			progressor.accept((float)x / (float)(world.width / 16 - 1));
+
+			for (int z = 8; z < world.length - 16; z += 16) {
+				double forestAmount = forestNoise.generateNoiseNormalized(x * spread, z * spread);
+				int treeAmount = (int)((forestAmount + noiseBoost) * density) + rand.nextInt(boost);
+				if (treeAmount <= 0) {
+					while (rand.nextInt(2) == 0) {
+						treeAmount++;
+					}
+				}
+
+				for (int i = 0; i < treeAmount; i++) {
+					int sx = x + rand.nextInt(16);
+					int sz = z + rand.nextInt(16);
+					int sy = world.getHeightValue(sx, sz);
+					this.placeTree(world, rand, sx, sy, sz);
+				}
+			}
+		}
+	}
+
+	public Feature getTreeType(Random rand) {
+		return FEATURE_TREE;
+	}
+
+	protected final void placeTree(World world, Random rand, int x, int y, int z) {
+		this.getTreeType(rand).generate(world, rand, x, y, z);
+	}
+
+	@Override
+	public String toString() {
+		return this.name;
+	}
+
+	public static LevelTheme fromId(int id) {
+		return values()[id];
+	}
+
+	public static LevelTheme fromName(String name) {
+		return NAME_TO_TYPE.getOrDefault(name, NORMAL);
+	}
+
+	public static LevelTheme fromNameNullable(String name) {
+		return NAME_TO_TYPE.get(name);
+	}
+
+	public static LevelTheme getRandomGen() {
+		return NATURAL_THEMES.get(new Random().nextInt(NATURAL_THEMES.size()));
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageMountains.java
@@ -1,0 +1,84 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+
+public class StageMountains extends TerrainGenStage {
+	private StageMountains(Builder properties) {
+		super("Raising..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			NoiseGenerator mountainNoise = new NoiseGeneratorOctaves(rand, properties.noiseOctaves);
+			NoiseGenerator snowNoise = new NoiseGeneratorOctaves(rand, 2);
+
+			for (int x = 0; x < blocks.width; x++) {
+				progressor.accept(x * 100.0F / (float)(blocks.width - 1));
+				for (int z = 0; z < blocks.length; z++) {
+					int snowLine = (int)(properties.snowLine + snowNoise.generateNoiseNormalized(x * 0.15D, z * 0.15D) * properties.snowLineOffset);
+					int height = (int)(mountainNoise.generateNoiseNormalized(x * properties.noiseScale, z * properties.noiseScale) * properties.heightScale + properties.heightOffset);
+					for (int y = heightmap.get(x, z); y < world.groundLevel + height && y < world.height; y++) {
+						int block = properties.block.blockID;
+						if (y > world.groundLevel + snowLine) {
+							block = properties.snowBlock.blockID;
+						}
+						blocks.set(x, y, z, block);
+					}
+				}
+			}
+		});
+	}
+
+	public static class Builder {
+		private int noiseOctaves = 8;
+		private double noiseScale = 1.0D;
+		private double heightScale = 80.0D;
+		private int heightOffset = 0;
+		private int snowLine = 32;
+		private int snowLineOffset = 8;
+		private Block block = Block.stone;
+		private Block snowBlock = Block.blockSnow;
+
+		public Builder noiseOctaves(int noiseOctaves) {
+			this.noiseOctaves = noiseOctaves;
+			return this;
+		}
+
+		public Builder noiseScale(double noiseScale) {
+			this.noiseScale = noiseScale;
+			return this;
+		}
+
+		public Builder heightScale(double heightScale) {
+			this.heightScale = heightScale;
+			return this;
+		}
+
+		public Builder heightOffset(int heightOffset) {
+			this.heightOffset = heightOffset;
+			return this;
+		}
+
+		public Builder snowLine(int snowLine) {
+			this.snowLine = snowLine;
+			return this;
+		}
+
+		public Builder snowLineOffset(int snowLineOffset) {
+			this.snowLineOffset = snowLineOffset;
+			return this;
+		}
+
+		public Builder block(Block block) {
+			this.block = block;
+			return this;
+		}
+
+		public Builder snowBlock(Block snowBlock) {
+			this.snowBlock = snowBlock;
+			return this;
+		}
+
+		public StageMountains build() {
+			return new StageMountains(this);
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageTemplifying.java
@@ -1,0 +1,103 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+
+public class StageTemplifying extends TerrainGenStage {
+	public StageTemplifying() {
+		super("Templifying..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			int templeCount = blocks.width * blocks.length / 1600;
+
+			for (int i = 0; i < templeCount; i++) {
+				progressor.accept(i * 100.0F / templeCount);
+
+				// Location
+				int x = rand.nextInt(blocks.width - 48) + 16;
+				int z = rand.nextInt(blocks.length - 48) + 16;
+				int y = blocks.height - 1;
+				while (y > 0 && blocks.get(x, y, z) == 0) y--;
+				y += rand.nextInt(8) + 2;
+
+				// Dimensions
+				int w = rand.nextInt(11) + 5;
+				int l = rand.nextInt(11) + 5;
+				int h = rand.nextInt(4) + 3;
+				if (y >= blocks.height - h * 3 / 2 || y == 0) continue;
+
+				// Pillars
+				for (int xx = x; xx < x + w; xx++) {
+					for (int zz = z; zz < z + l; zz++) {
+						if ((xx == x || xx == x + w - 1 || zz == z || zz == z + l - 1)) {
+							for (int yy = y; yy < y + h; yy++) {
+								blocks.set(xx, yy, zz, Block.wood.blockID);
+							}
+						}
+
+						if (zz < z + l - 2) {
+							zz++;
+						}
+					}
+
+					if (xx < x + w - 2) {
+						xx++;
+					}
+				}
+
+				// Roof
+				int r = -1;
+				for (int yy = y + h;
+				     yy < blocks.height
+						     && w - r * 2 > 0
+						     && l - r * 2 > 0;
+					 yy++, r++) {
+					for (int xx = x + r; xx < x + w - r; xx++) {
+						for (int zz = z + r; zz < z + l - r; zz++) {
+							if (xx > 0 && xx < blocks.width && zz > 0 && zz < blocks.length) {
+								blocks.set(xx, yy, zz, Block.stairDouble.blockID);
+							}
+						}
+					}
+				}
+
+				// Foundation
+				r = 2;
+				boolean noFoundation = false;
+				for (int yy = y - 1; yy > 0 && !noFoundation; yy--, r++) {
+					noFoundation = true;
+					int minX = x - r / 2;
+					int maxX = x + w + r / 2 - 1;
+					int minZ = z - r / 2;
+					int maxZ = z + l + r / 2 - 1;
+					for (int xx = minX; xx <= maxX; xx++) {
+						for (int zz = minZ; zz <= maxZ; zz++) {
+							if (xx > 0 && xx < blocks.width && zz > 0 && zz < blocks.length) {
+								Block b = Block.blocksList[blocks.get(xx, yy, zz)];
+								if (b == null || !b.isOpaqueCube()) {
+									int block = Block.cobblestone.blockID;
+									if ((r % 2 == 0) == (rand.nextInt(3) == 0)) {
+										block = Block.cobblestoneMossy.blockID;
+									}
+									blocks.set(xx, yy, zz, block);
+									noFoundation = false;
+								}
+							}
+						}
+					}
+				}
+
+				// Chest
+				while (rand.nextInt(5) == 0) {
+					chestPlacer.placeChest(x + 2 + rand.nextInt(w - 3), y, z + 2 + rand.nextInt(l - 3));
+				}
+			}
+		});
+
+		this.setChestSlots(5, 15);
+		this.addChestItem(new ChestItem(Block.brick.blockID, 20));
+		this.addChestItem(new ChestItem(Block.cobblestoneMossy.blockID, 10));
+		this.addChestItem(new ChestItem(Block.brick.blockID, 20));
+		this.addChestItem(new ChestItem(Block.cobblestoneMossy.blockID, 10));
+		this.addChestItem(new ChestItem(Block.brick.blockID, 20));
+		this.addChestItem(new ChestItem(Block.leaves.blockID, 20));
+		this.addChestItem(new ChestItem(Block.obsidian.blockID, 5));
+	}
+}
--- net/minecraft/game/item/ItemPickaxe.java
+++ net/minecraft/game/item/ItemPickaxe.java
@@ -4,7 +4,7 @@
 import net.minecraft.game.level.material.Material;
 
 public final class ItemPickaxe extends ItemTool {
-	private static Block[] blocksEffectiveAgainst = new Block[]{Block.cobblestone, Block.stairDouble, Block.stairSingle, Block.stone, Block.cobblestoneMossy, Block.oreIron, Block.blockSteel, Block.oreCoal, Block.blockGold, Block.oreGold, Block.oreDiamond, Block.blockDiamond};
+	private static Block[] blocksEffectiveAgainst = new Block[]{Block.cobblestone, Block.stairDouble, Block.stairSingle, Block.stone, Block.cobblestoneMossy, Block.oreIron, Block.blockSteel, Block.oreCoal, Block.blockGold, Block.oreGold, Block.oreDiamond, Block.blockDiamond, Block.brick, Block.cog, Block.activator, Block.grate, Block.observer, Block.magneticPlatform};
 	private int harvestLevel;
 
 	public ItemPickaxe(int var1, int var2) {
@@ -13,6 +13,14 @@
 	}
 
 	public final boolean canHarvestBlock(Block var1) {
-		return var1 == Block.obsidian ? this.harvestLevel == 3 : (var1 != Block.blockDiamond && var1 != Block.oreDiamond ? (var1 != Block.blockGold && var1 != Block.oreGold ? (var1 != Block.blockSteel && var1 != Block.oreIron ? (var1.material == Material.rock ? true : var1.material == Material.iron) : this.harvestLevel > 0) : this.harvestLevel >= 2) : this.harvestLevel >= 2);
+		return var1 == Block.obsidian
+				? this.harvestLevel == 3
+				: (var1 != Block.blockDiamond && var1 != Block.oreDiamond
+						? (var1 != Block.blockGold && var1 != Block.oreGold
+								? (var1 != Block.blockSteel && var1 != Block.oreIron
+										? (var1.material == Material.rock || var1.material == Material.iron)
+										: this.harvestLevel > 0)
+								: this.harvestLevel >= 2)
+						: this.harvestLevel >= 2);
 	}
 }
--- net/minecraft/client/model/ModelBiped.java
+++ net/minecraft/client/model/ModelBiped.java
@@ -72,4 +72,10 @@
 		this.bipedRightArm.rotateAngleX += MathHelper.sin(var3 * 0.067F) * 0.05F;
 		this.bipedLeftArm.rotateAngleX -= MathHelper.sin(var3 * 0.067F) * 0.05F;
 	}
+
+	public void setFirstPersonHandAngles() {
+		this.bipedRightArm.rotateAngleX = 0.0F;
+		this.bipedRightArm.rotateAngleY = 0.0F;
+		this.bipedRightArm.rotateAngleZ = 0.0F;
+	}
 }
--- net/minecraft/game/item/ItemBlock.java
+++ net/minecraft/game/item/ItemBlock.java
@@ -15,28 +15,32 @@
 	}
 
 	public final boolean onItemUse(ItemStack var1, World var2, int var3, int var4, int var5, int var6) {
-		if(var6 == 0) {
-			--var4;
-		}
-
-		if(var6 == 1) {
-			++var4;
-		}
-
-		if(var6 == 2) {
-			--var5;
-		}
-
-		if(var6 == 3) {
-			++var5;
-		}
-
-		if(var6 == 4) {
-			--var3;
-		}
-
-		if(var6 == 5) {
-			++var3;
+		if (var2.getBlockId(var3, var4, var5) == Block.snow.blockID) {
+			var6 = 1;
+		} else {
+			if(var6 == 0) {
+				--var4;
+			}
+
+			if(var6 == 1) {
+				++var4;
+			}
+
+			if(var6 == 2) {
+				--var5;
+			}
+
+			if(var6 == 3) {
+				++var5;
+			}
+
+			if(var6 == 4) {
+				--var3;
+			}
+
+			if(var6 == 5) {
+				++var3;
+			}
 		}
 
 		if(var1.stackSize == 0) {
@@ -44,9 +48,9 @@
 		} else if(var3 > 0 && var4 > 0 && var5 > 0 && var3 < var2.width - 1 && var4 < var2.height - 1 && var5 < var2.length - 1) {
 			int var7 = var2.getBlockId(var3, var4, var5);
 			Block var10 = Block.blocksList[var7];
-			if(this.blockID > 0 && var10 == null || var10 == Block.waterMoving || var10 == Block.waterStill || var10 == Block.lavaMoving || var10 == Block.lavaStill || var10 == Block.fire) {
+			if(this.blockID > 0 && var10 == null || var10 == Block.waterMoving || var10 == Block.waterStill || var10 == Block.lavaMoving || var10 == Block.lavaStill || var10 == Block.fire || var10 == Block.snow) {
 				var10 = Block.blocksList[this.blockID];
-				AxisAlignedBB var8 = var10.getCollisionBoundingBoxFromPool(var3, var4, var5);
+				AxisAlignedBB var8 = var10.getCollisionBoundingBoxFromPool(var2, var3, var4, var5);
 				if(var2.checkIfAABBIsClear(var8) && var10.canPlaceBlockAt(var2, var3, var4, var5) && var2.setBlockWithNotify(var3, var4, var5, this.blockID)) {
 					Block.blocksList[this.blockID].onBlockPlaced(var2, var3, var4, var5, var6);
 					float var10001 = (float)var3 + 0.5F;
@@ -57,7 +61,9 @@
 					float var10005 = (var9.soundVolume + 1.0F) / 2.0F;
 					var9 = var10.stepSound;
 					var2.playSoundAtPlayer(var10001, var10002, var10003, var10004, var10005, var9.soundPitch * 0.8F);
-					--var1.stackSize;
+					if (var2.survivalWorld) {
+						--var1.stackSize;
+					}
 				}
 			}
 
--- net/minecraft/game/entity/animal/EntityAnimal.java
+++ net/minecraft/game/entity/animal/EntityAnimal.java
@@ -8,6 +8,7 @@
 public abstract class EntityAnimal extends EntityCreature {
 	public EntityAnimal(World var1) {
 		super(var1);
+		this.scoreValue = 10;
 	}
 
 	protected final float getBlockPathWeight(int var1, int var2, int var3) {
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageCaving.java
@@ -1,0 +1,74 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+import util.DoubleArray3D;
+
+public class StageCaving extends TerrainGenStage {
+	public StageCaving() {
+		super("Caving..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			int chunkSize = 16;
+			int resHorizontal = 4;
+			int resVertical = 4;
+			int noiseWidth = chunkSize / resHorizontal + 1;
+			int noiseLength = chunkSize / resHorizontal + 1;
+			int noiseHeight = blocks.height / resVertical + 1;
+
+			NoiseGenerator caveNoise = new NoiseGeneratorOctaves(rand, 8);
+
+			for (int cx = 0; cx < blocks.width / chunkSize; cx++) {
+				progressor.accept(cx * 100.0F / (blocks.width / chunkSize - 1));
+
+				for (int cz = 0; cz < blocks.length / chunkSize; cz++) {
+					int cbx = cx * chunkSize;
+					int cbz = cz * chunkSize;
+					int cnx = cbx / resHorizontal;
+					int cnz = cbz / resHorizontal;
+
+					DoubleArray3D samples = new DoubleArray3D(noiseWidth, noiseLength, noiseHeight);
+					for (int y = 0; y < noiseHeight; y++) {
+						for (int z = 0; z < noiseLength; z++) {
+							for (int x = 0; x < noiseWidth; x++) {
+								samples.set(x, y, z, caveNoise.generateNoiseNormalized(
+										(x + cnx) * 8.0D,
+										y * 24.0D,
+										(z + cnz) * 8.0D
+								));
+							}
+						}
+					}
+
+					DoubleArray3D lerpedSamples = new DoubleArray3D(chunkSize, chunkSize, blocks.height);
+					for (int y = 0; y < blocks.height; y++) {
+						for (int z = 0; z < chunkSize; z++) {
+							for (int x = 0; x < chunkSize; x++) {
+								lerpedSamples.set(x, y, z, StageRaising3D.lerp3DPoints(samples, x, y, z, resHorizontal, resVertical));
+							}
+						}
+					}
+
+					for (int y = 0; y < blocks.height - 2; y++) {
+						for (int z = 0; z < chunkSize && z + cbz < blocks.length; z++) {
+							for (int x = 0; x < chunkSize && x + cbx < blocks.length; x++) {
+								double sample = lerpedSamples.get(x, y, z);
+
+								double threshold = 0.0D;
+								if (y < 8) {
+									threshold += (8 - y) / 8.0D;
+								}
+								if (y > world.groundLevel - 8) {
+									threshold += (y - world.groundLevel + 8) / 8.0D;
+								}
+								threshold = threshold * 0.75D + 0.25D;
+
+								if (sample > threshold) {
+									blocks.set(x + cbx, y, z + cbz, 0);
+								}
+							}
+						}
+					}
+				}
+			}
+		});
+	}
+}
--- net/minecraft/game/item/recipe/RecipesWeapons.java
+++ net/minecraft/game/item/recipe/RecipesWeapons.java
@@ -19,6 +19,6 @@
 		}
 
 		var1.addRecipe(new ItemStack(Item.bow, 1), new Object[]{" #X", "# X", " #X", Character.valueOf('X'), Item.silk, Character.valueOf('#'), Item.stick});
-		var1.addRecipe(new ItemStack(Item.arrow, 4), new Object[]{"X", "#", "Y", Character.valueOf('Y'), Item.feather, Character.valueOf('X'), Item.ingotIron, Character.valueOf('#'), Item.stick});
+		var1.addRecipe(new ItemStack(Item.arrow, 4), new Object[]{"X", "#", "Y", Character.valueOf('Y'), Item.feather, Character.valueOf('X'), Item.flint, Character.valueOf('#'), Item.stick});
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/EnumSkyBlock.java
@@ -1,0 +1,12 @@
+package net.minecraft.game.level;
+
+public enum EnumSkyBlock {
+	Sky(15),
+	Block(0);
+
+	public final int defaultLightValue;
+
+	private EnumSkyBlock(int var3) {
+		this.defaultLightValue = var3;
+	}
+}
--- /dev/null
+++ util/ByteArray3D.java
@@ -1,0 +1,35 @@
+package util;
+
+public class ByteArray3D {
+	private final byte[] array;
+	public final int width, length, height;
+
+	public ByteArray3D(int width, int length, int height) {
+		this(null, width, length, height);
+	}
+
+	public ByteArray3D(byte[] array, int width, int length, int height) {
+		if (array == null) {
+			array = new byte[width * length * height];
+		} else if (array.length < width * length * height) {
+			throw new IllegalArgumentException("Array is too small!");
+		}
+
+		this.array = array;
+		this.width = width;
+		this.length = length;
+		this.height = height;
+	}
+
+	public int get(int x, int y, int z) {
+		return this.array[(y * this.length + z) * this.width + x] & 255;
+	}
+
+	public void set(int x, int y, int z, int value) {
+		this.array[(y * this.length + z) * this.width + x] = (byte)value;
+	}
+
+	public byte[] getArray() {
+		return array;
+	}
+}
--- net/minecraft/game/level/block/BlockLeavesBase.java
+++ net/minecraft/game/level/block/BlockLeavesBase.java
@@ -6,7 +6,7 @@
 public class BlockLeavesBase extends Block {
 	private boolean graphicsLevel = true;
 
-	protected BlockLeavesBase(int var1, int var2, Material var3, boolean var4) {
+	public BlockLeavesBase(int var1, int var2, Material var3, boolean var4) {
 		super(var1, var2, var3);
 	}
 
--- /dev/null
+++ net/minecraft/client/gui/GuiLoadWorld.java
@@ -1,0 +1,92 @@
+package net.minecraft.client.gui;
+
+import java.io.File;
+import java.io.IOException;
+
+public class GuiLoadWorld extends GuiScreen {
+	private final GuiScreen parent;
+	private int action;
+	private int actionState;
+
+	public GuiLoadWorld(GuiScreen parent) {
+		this.parent = parent;
+	}
+
+	public void initGui() {
+		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 2 - 36, "Create new world..."));
+		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 2 - 12, "Load existing world..."));
+		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 2 + 12, "Delete world..."));
+		this.controlList.add(new GuiButton(3, this.width / 2 - 100, this.height / 2 + 48, "Back to title"));
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		this.drawDefaultBackground();
+		super.drawScreen(var1, var2, var3);
+		drawCenteredString(this.fontRenderer, "Select world", this.width / 2, 60, 16777215);
+	}
+
+	public void updateScreen() {
+		if (this.actionState == 2) {
+			switch (this.action) {
+				case 0:
+					File[] files = this.mc.worldDir.listFiles();
+					if (files != null && files.length != 0) {
+						this.mc.worldDir = null;
+						break;
+					}
+
+					this.mc.adventureMode = true;
+					this.mc.displayGuiScreen(new GuiNewLevel(this));
+					break;
+
+				case 1:
+					try {
+						this.mc.adventureMode = true;
+						this.mc.loadWorld();
+					} catch (IOException e) {
+						this.mc.adventureMode = false;
+						this.mc.worldDir = null;
+					}
+					break;
+
+				case 2:
+					this.mc.adventureMode = true;
+					this.mc.displayGuiScreen(new GuiDeleteWorld(this));
+					break;
+			}
+			this.actionState = 0;
+		}
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		if (this.actionState == 0) {
+			if (var1.id < 3) {
+				this.action = var1.id;
+				this.actionState = 1;
+				GuiWorldDialog var2 = new GuiWorldDialog(this);
+				var2.setDaemon(true);
+				var2.start();
+			}
+
+			if (var1.id == 3) {
+				this.mc.displayGuiScreen(this.parent);
+			}
+		}
+	}
+
+	protected String getDialogTitle() {
+		return this.action == 0 ? "Select new directory"
+				: this.action == 1 ? "Load world directory"
+				: this.action == 2 ? "Delete world directory"
+				: "uhhhh this wasn't supposed to happen";
+	}
+
+	public void selectFile(File file) {
+		this.mc.worldDir = file;
+		this.actionState = 2;
+	}
+
+	public void unfreeze() {
+		this.actionState = 0;
+	}
+}
--- /dev/null
+++ net/minecraft/client/gui/GuiSelectBlock.java
@@ -1,0 +1,161 @@
+package net.minecraft.client.gui;
+
+import net.minecraft.client.RenderHelper;
+import net.minecraft.client.Session;
+import net.minecraft.client.controller.PlayerControllerCreative;
+import net.minecraft.client.gui.container.GuiInventory;
+import net.minecraft.client.render.entity.RenderItem;
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.ItemStack;
+import net.minecraft.game.level.block.Block;
+import org.lwjgl.input.Keyboard;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL12;
+
+public class GuiSelectBlock extends GuiScreen {
+	private static final RenderItem itemRenderer = new RenderItem();
+	private int page = 0;
+
+	public void initGui() {
+		if (this.mc.options.showFPS) {
+			this.controlList.add(new GuiButton(0, 8, this.height - 100, 60, 20, "Morning").withBg(1));
+			this.controlList.add(new GuiButton(1, 8, this.height - 76, 60, 20, "Noon").withBg(1));
+			this.controlList.add(new GuiButton(2, 8, this.height - 52, 60, 20, "Afternoon").withBg(1));
+			this.controlList.add(new GuiButton(3, 8, this.height - 28, 60, 20, "Night").withBg(1));
+		}
+	}
+
+	public boolean doesGuiPauseGame() {
+		return false;
+	}
+
+	private int getTileAtSlot(int x, int y) {
+		for (int i = 0; i < Math.min(Session.registeredBlocksList.size() - this.page * 9, 45); i++) {
+			int ix = this.width / 2 + i % 9 * 24 - 111;
+			int iy = this.height / 2 + i / 9 * 24 - 57;
+			if (x < ix || x > ix + 24 || y < iy - 12 || y > iy + 12) continue;
+			return i;
+		}
+		return -1;
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		int tile = this.getTileAtSlot(var1, var2);
+		drawGradientRect(this.width / 2 - 120, this.height / 2 - 90, this.width / 2 + 120, this.height / 2 + 60, -1878719232, -1070583712);
+
+		if (tile >= 0) {
+            int tx = this.width / 2 + tile % 9 * 24 - 108;
+            int ty = this.height / 2 + tile / 9 * 24 - 60;
+            drawGradientRect(tx - 3, ty - 8, tx + 23, ty + 18, -1862270977, -1056964609);
+		}
+
+		drawCenteredString(this.fontRenderer, "Select block", this.width / 2, this.height / 2 - 80, 16777215);
+
+		GL11.glPushMatrix();
+		GL11.glRotatef(180.0F, 1.0F, 0.0F, 0.0F);
+		RenderHelper.enableStandardItemLighting();
+		GL11.glPopMatrix();
+		GL11.glPushMatrix();
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		GL11.glEnable(GL12.GL_RESCALE_NORMAL);
+
+		for (int i = 0; i < Math.min(Session.registeredBlocksList.size() - this.page * 9, 45); i++) {
+			int tx = this.width / 2 + i % 9 * 24 - 108;
+            int ty = this.height / 2 + i / 9 * 24 - 60;
+			Object registry = Session.registeredBlocksList.get(i + this.page * 9);
+			int id = 0;
+
+			if (registry instanceof Block) {
+				id = ((Block)registry).blockID;
+			} else if (registry instanceof Item) {
+				id = ((Item)registry).shiftedIndex;
+			}
+
+			if (id > 0) {
+				if (tile == i) {
+					GL11.glPushMatrix();
+					GL11.glTranslatef(tx + 8, ty + 8, 0.0F);
+					GL11.glScalef(1.6F, 1.6F, 1.6F);
+					GL11.glTranslatef(-tx - 8, -ty - 8, 0.0F);
+				}
+
+				itemRenderer.renderItemIntoGUI(this.mc.renderEngine, new ItemStack(id), tx + 1, ty - 2);
+
+				if (tile == i) {
+					GL11.glPopMatrix();
+				}
+			}
+		}
+
+		GL11.glDisable(GL12.GL_RESCALE_NORMAL);
+		RenderHelper.disableStandardItemLighting();
+		GL11.glDisable(GL11.GL_LIGHTING);
+		GL11.glDisable(GL11.GL_DEPTH_TEST);
+		GL11.glPopMatrix();
+		super.drawScreen(var1, var2, var3);
+		if (this.mc.options.showFPS) {
+			drawCenteredString(this.fontRenderer, "Change time", 38, this.height - 116, 0xFFFFFF);
+		}
+	}
+
+	protected void drawSlotInventory(int var1, int var2, int var3) {
+		super.drawSlotInventory(var1, var2, var3);
+
+		if (var3 == 0) {
+			int tile = this.getTileAtSlot(var1, var2);
+
+			if (tile >= 0) {
+				Object registry = Session.registeredBlocksList.get(tile + this.page * 9);
+				int id = 0;
+
+				if (registry instanceof Block) {
+					id = ((Block)registry).blockID;
+				} else if (registry instanceof Item) {
+					id = ((Item)registry).shiftedIndex;
+				}
+
+				for (int i = 0; i < 9; i++) {
+					ItemStack hotbarItem = this.mc.thePlayer.inventory.getStackInSlot(i);
+					if (hotbarItem != null && hotbarItem.itemID == id) {
+						ItemStack oldItem = this.mc.thePlayer.inventory.getCurrentItem();
+						this.mc.thePlayer.inventory.setInventorySlotContents(this.mc.thePlayer.inventory.currentItem, hotbarItem);
+						this.mc.thePlayer.inventory.setInventorySlotContents(i, oldItem);
+						this.mc.displayGuiScreen(null);
+						return;
+					}
+				}
+
+				int slot = this.mc.thePlayer.inventory.currentItem;
+				this.mc.thePlayer.inventory.setInventorySlotContents(slot, new ItemStack(id));
+			}
+		}
+
+		this.mc.displayGuiScreen(null);
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		if (var1.id < 4) {
+			this.mc.theWorld.worldTime = var1.id * 4500 - 1000;
+		}
+	}
+
+	protected void mouseScrolled(int var1) {
+		int maxPages = (Session.registeredBlocksList.size() - 1) / 9 - 3;
+		page += var1 / -120;
+		if (page < 0) {
+			page = 0;
+		} else if (page >= maxPages) {
+			page = maxPages - 1;
+		}
+	}
+
+	protected void keyTyped(char var1, int var2) {
+		super.keyTyped(var1, var2);
+
+		for(int i = 0; i < 9; ++i) {
+			if(var1 == i + '1') {
+				this.mc.thePlayer.inventory.currentItem = i;
+			}
+		}
+	}
+}
--- net/minecraft/client/gui/GuiIngame.java
+++ net/minecraft/client/gui/GuiIngame.java
@@ -6,11 +6,13 @@
 import net.minecraft.client.ChatLine;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.RenderHelper;
+import net.minecraft.client.controller.PlayerControllerSP;
 import net.minecraft.client.player.EntityPlayerSP;
 import net.minecraft.client.render.entity.RenderItem;
 import net.minecraft.game.entity.player.InventoryPlayer;
 import net.minecraft.game.item.ItemStack;
 import org.lwjgl.opengl.GL11;
+import util.MathHelper;
 
 public final class GuiIngame extends Gui {
 	private static RenderItem itemRenderer = new RenderItem();
@@ -24,6 +26,11 @@
 	}
 
 	public final void renderGameOverlay(float var1) {
+		if (!this.mc.options.showHUD) {
+			this.mc.entityRenderer.setupOverlayRendering();
+			return;
+		}
+
 		ScaledResolution var2 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight);
 		int var3 = var2.getScaledWidth();
 		int var19 = var2.getScaledHeight();
@@ -110,12 +117,18 @@
 
 				for(var13 = 0; var13 < var11 + var12; ++var13) {
 					if(var13 < var11) {
-						this.drawTexturedModalRect(var3 / 2 - 91 + (var13 << 3), var19 - 32 - 9, 16, 18, 9, 9);
+						this.drawTexturedModalRect(var3 / 2 - 91 + (var13 << 3), var19 - 32 - 10, 16, 18, 9, 9);
 					} else {
-						this.drawTexturedModalRect(var3 / 2 - 91 + (var13 << 3), var19 - 32 - 9, 25, 18, 9, 9);
+						this.drawTexturedModalRect(var3 / 2 - 91 + (var13 << 3), var19 - 32 - 10, 25, 18, 9, 9);
 					}
 				}
 			}
+		}
+
+
+		if (this.mc.playerController instanceof PlayerControllerSP) {
+			String text = "Score: &e" + this.mc.thePlayer.getScore;
+			var4.drawStringWithShadow(text, var3 - var4.getStringWidth(text) - 2, 2, 0xFFFFFF);
 		}
 
 		GL11.glDisable(GL11.GL_BLEND);
@@ -151,7 +164,7 @@
 		RenderHelper.disableStandardItemLighting();
 		GL11.glDisable(GL11.GL_NORMALIZE);
 		if(this.mc.options.showFPS) {
-			var4.drawStringWithShadow("Minecraft Indev (" + this.mc.debug + ")", 2, 2, 16777215);
+			var4.drawStringWithShadow("Indev Adventure 1.0 (" + this.mc.debug + ")", 2, 2, 16777215);
 			Minecraft var23 = this.mc;
 			var4.drawStringWithShadow(var23.renderGlobal.getDebugInfoRenders(), 2, 12, 16777215);
 			var23 = this.mc;
@@ -166,8 +179,30 @@
 			drawString(var4, var18, var3 - var4.getStringWidth(var18) - 2, 2, 14737632);
 			var18 = "Allocated memory: " + var27 * 100L / var24 + "% (" + var27 / 1024L / 1024L + "MB)";
 			drawString(var4, var18, var3 - var4.getStringWidth(var18) - 2, 12, 14737632);
+
+			String x = String.format("%.2f", this.mc.thePlayer.posX);
+			String y = String.format("%.2f", this.mc.thePlayer.boundingBox.minY);
+			String z = String.format("%.2f", this.mc.thePlayer.posZ);
+			drawString(var4, "x: ", 2, 50, 16777215);
+			drawString(var4, "y: ", 2, 60, 16777215);
+			drawString(var4, "z: ", 2, 70, 16777215);
+			drawString(var4, x, 50 - var4.getStringWidth(x), 50, 16777215);
+			drawString(var4, y, 50 - var4.getStringWidth(y), 60, 16777215);
+			drawString(var4, z, 50 - var4.getStringWidth(z), 70, 16777215);
+			if (this.mc.adventureMode) {
+				drawString(var4, " @ " + this.mc.worldInfo.levelX, 50, 50, 16777215);
+				drawString(var4, " @ " + this.mc.worldInfo.levelZ, 50, 70, 16777215);
+			}
+			drawString(var4, "dim: ", 2, 85, 16777215);
+			drawString(var4, this.mc.theWorld.width + "x" + this.mc.theWorld.height + "x" + this.mc.theWorld.length, 60, 85, 16777215);
+			drawString(var4, "type: ", 2, 95, 16777215);
+			drawString(var4, String.valueOf(this.mc.theWorld.levelType), 60, 95, 16777215);
+			drawString(var4, "theme: ", 2, 105, 16777215);
+			drawString(var4, String.valueOf(this.mc.theWorld.levelTheme), 60, 105, 16777215);
+			drawString(var4, "structure: ", 2, 115, 16777215);
+			drawString(var4, String.valueOf(this.mc.theWorld.levelStructure), 60, 115, 16777215);
 		} else {
-			var4.drawStringWithShadow("Minecraft Indev", 2, 2, 16777215);
+//			var4.drawStringWithShadow("Minecraft Indev", 2, 2, 16777215);
 		}
 
 		for(var12 = 0; var12 < this.chatMessageList.size() && var12 < 10; ++var12) {
--- net/minecraft/client/GameSettings.java
+++ net/minecraft/client/GameSettings.java
@@ -8,31 +8,35 @@
 import org.lwjgl.input.Keyboard;
 
 public final class GameSettings {
-	private static final String[] RENDER_DISTANCES = new String[]{"FAR", "NORMAL", "SHORT", "TINY"};
+	private static final String[] RENDER_DISTANCES = new String[]{"VERY FAR", "FAR", "NORMAL", "SHORT", "TINY"};
 	private static final String[] DIFFICULTIES = new String[]{"Peaceful", "Easy", "Normal", "Hard"};
 	public boolean music = true;
 	public boolean sound = true;
 	public boolean invertMouse = false;
 	public boolean showFPS = false;
+	public boolean showHUD = true;
 	public int renderDistance = 0;
 	public boolean fancyGraphics = true;
 	public boolean anaglyph = false;
 	public boolean limitFramerate = false;
+	public boolean advancedOpenGL = true;
 	public KeyBinding keyBindForward = new KeyBinding("Forward", 17);
 	public KeyBinding keyBindLeft = new KeyBinding("Left", 30);
 	public KeyBinding keyBindBack = new KeyBinding("Back", 31);
 	public KeyBinding keyBindRight = new KeyBinding("Right", 32);
 	public KeyBinding keyBindJump = new KeyBinding("Jump", 57);
-	public KeyBinding keyBindInventory = new KeyBinding("Inventory", 23);
+	public KeyBinding keyBindInventory = new KeyBinding("Inventory", 18);
 	public KeyBinding keyBindDrop = new KeyBinding("Drop", 16);
 	private KeyBinding keyBindChat = new KeyBinding("Chat", 20);
 	public KeyBinding keyBindToggleFog = new KeyBinding("Toggle fog", 33);
 	public KeyBinding keyBindSave = new KeyBinding("Save location", 28);
 	public KeyBinding keyBindLoad = new KeyBinding("Load location", 19);
-	public KeyBinding[] keyBindings = new KeyBinding[]{this.keyBindForward, this.keyBindLeft, this.keyBindBack, this.keyBindRight, this.keyBindJump, this.keyBindDrop, this.keyBindInventory, this.keyBindChat, this.keyBindToggleFog, this.keyBindSave, this.keyBindLoad};
+	public KeyBinding keyBindFlyUp = new KeyBinding("Fly up", 57);
+	public KeyBinding keyBindFlyDown = new KeyBinding("Fly down", 42);
+	public KeyBinding[] keyBindings = new KeyBinding[]{this.keyBindForward, this.keyBindLeft, this.keyBindBack, this.keyBindRight, this.keyBindJump, this.keyBindDrop, this.keyBindInventory, this.keyBindToggleFog, this.keyBindSave, this.keyBindLoad, this.keyBindFlyUp, this.keyBindFlyDown};
 	private Minecraft mc;
 	private File optionsFile;
-	public int numberOfOptions = 9;
+	public int numberOfOptions = 10;
 	public int difficulty = 2;
 	public boolean thirdPersonView = false;
 
@@ -71,7 +75,9 @@
 		}
 
 		if(var1 == 4) {
-			this.renderDistance = this.renderDistance + var2 & 3;
+			this.renderDistance = Math.floorMod(this.renderDistance + var2, 5);
+			this.mc.renderGlobal.changeWorld(this.mc.theWorld);
+			this.mc.renderGlobal.loadRenderers();
 		}
 
 		if(var1 == 5) {
@@ -91,11 +97,26 @@
 			this.difficulty = this.difficulty + var2 & 3;
 		}
 
+		if(var1 == 9) {
+			this.advancedOpenGL = !this.advancedOpenGL;
+			this.mc.renderGlobal.loadRenderers();
+		}
+
 		this.saveOptions();
 	}
 
 	public final String setOptionString(int var1) {
-		return var1 == 0 ? "Music: " + (this.music ? "ON" : "OFF") : (var1 == 1 ? "Sound: " + (this.sound ? "ON" : "OFF") : (var1 == 2 ? "Invert mouse: " + (this.invertMouse ? "ON" : "OFF") : (var1 == 3 ? "Show FPS: " + (this.showFPS ? "ON" : "OFF") : (var1 == 4 ? "Render distance: " + RENDER_DISTANCES[this.renderDistance] : (var1 == 5 ? "View bobbing: " + (this.fancyGraphics ? "ON" : "OFF") : (var1 == 6 ? "3d anaglyph: " + (this.anaglyph ? "ON" : "OFF") : (var1 == 7 ? "Limit framerate: " + (this.limitFramerate ? "ON" : "OFF") : (var1 == 8 ? "Difficulty: " + DIFFICULTIES[this.difficulty] : ""))))))));
+		return var1 == 0 ? "Music: " + (this.music ? "ON" : "OFF")
+				: var1 == 1 ? "Sound: " + (this.sound ? "ON" : "OFF")
+				: var1 == 2 ? "Invert mouse: " + (this.invertMouse ? "ON" : "OFF")
+				: var1 == 3 ? "Show FPS: " + (this.showFPS ? "ON" : "OFF")
+				: var1 == 4 ? "Render distance: " + RENDER_DISTANCES[this.renderDistance]
+				: var1 == 5 ? "View bobbing: " + (this.fancyGraphics ? "ON" : "OFF")
+				: var1 == 6 ? "3d anaglyph: " + (this.anaglyph ? "ON" : "OFF")
+				: var1 == 7 ? "Limit framerate: " + (this.limitFramerate ? "ON" : "OFF")
+				: var1 == 8 ? "Difficulty: " + DIFFICULTIES[this.difficulty]
+				: var1 == 9 ? "Advanced OpenGL: " + (this.advancedOpenGL ? "ON" : "OFF")
+				: "";
 	}
 
 	private void loadOptions() {
@@ -147,6 +168,10 @@
 						this.difficulty = Integer.parseInt(var5[1]);
 					}
 
+					if(var5[0].equals("advancedOpenGL")) {
+						this.advancedOpenGL = var5[1].equals("true");
+					}
+
 					for(int var3 = 0; var3 < this.keyBindings.length; ++var3) {
 						if(var5[0].equals("key_" + this.keyBindings[var3].keyDescription)) {
 							this.keyBindings[var3].keyCode = Integer.parseInt(var5[1]);
@@ -172,6 +197,7 @@
 			var1.println("anaglyph3d:" + this.anaglyph);
 			var1.println("limitFramerate:" + this.limitFramerate);
 			var1.println("difficulty:" + this.difficulty);
+			var1.println("advancedOpenGL:" + this.advancedOpenGL);
 
 			for(int var2 = 0; var2 < this.keyBindings.length; ++var2) {
 				var1.println("key_" + this.keyBindings[var2].keyDescription + ":" + this.keyBindings[var2].keyCode);
@@ -182,5 +208,9 @@
 			System.out.println("Failed to save options");
 			var3.printStackTrace();
 		}
+	}
+
+	public int getRenderDistance() {
+		return 512 >> this.renderDistance;
 	}
 }
--- net/minecraft/game/level/block/BlockFlower.java
+++ net/minecraft/game/level/block/BlockFlower.java
@@ -6,7 +6,7 @@
 import net.minecraft.game.physics.AxisAlignedBB;
 
 public class BlockFlower extends Block {
-	protected BlockFlower(int var1, int var2) {
+	public BlockFlower(int var1, int var2) {
 		super(var1, Material.plants);
 		this.blockIndexInTexture = var2;
 		this.setTickOnLoad(true);
@@ -42,7 +42,7 @@
 		return (var1.getBlockLightValue(var2, var3, var4) >= 8 || var1.getBlockLightValue(var2, var3, var4) >= 4 && var1.canBlockSeeTheSky(var2, var3, var4)) && this.canThisPlantGrowOnThisBlockID(var1.getBlockId(var2, var3 - 1, var4));
 	}
 
-	public final AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
+	public final AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
 		return null;
 	}
 
--- net/minecraft/game/level/block/BlockSapling.java
+++ net/minecraft/game/level/block/BlockSapling.java
@@ -4,7 +4,7 @@
 import net.minecraft.game.level.World;
 
 public final class BlockSapling extends BlockFlower {
-	protected BlockSapling(int var1, int var2) {
+	public BlockSapling(int var1, int var2) {
 		super(6, 15);
 		this.setBlockBounds(10.0F * 0.01F, 0.0F, 10.0F * 0.01F, 0.9F, 0.8F, 0.9F);
 	}
--- net/minecraft/game/level/block/BlockFurnace.java
+++ net/minecraft/game/level/block/BlockFurnace.java
@@ -10,7 +10,7 @@
 public final class BlockFurnace extends BlockContainer {
 	private final boolean isActive;
 
-	protected BlockFurnace(int var1, boolean var2) {
+	public BlockFurnace(int var1, boolean var2) {
 		super(var1, Material.rock);
 		this.isActive = var2;
 		this.blockIndexInTexture = 45;
@@ -89,10 +89,11 @@
 	}
 
 	public final int getBlockTextureFromSide(int var1) {
-		return var1 == 1 ? Block.stone.blockID : (var1 == 0 ? Block.stone.blockID : (var1 == 3 ? this.blockIndexInTexture - 1 : this.blockIndexInTexture));
+		return var1 == 1 ? Block.stone.blockID : (var1 == 0 ? Block.stone.blockID : (var1 == 3 ? (this.isActive ? this.blockIndexInTexture + 16 : this.blockIndexInTexture - 1) : this.blockIndexInTexture));
 	}
 
 	public final boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+		if (!var1.survivalWorld) return false;
 		TileEntityFurnace var6 = (TileEntityFurnace)var1.getBlockTileEntity(var2, var3, var4);
 		var5.displayGUIFurnace(var6);
 		return true;
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageRaising3D.java
@@ -1,0 +1,226 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+import util.DoubleArray3D;
+
+public class StageRaising3D extends TerrainGenStage {
+	private StageRaising3D(Builder properties) {
+		super("Raising..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			int chunkSize = 16;
+			int resHorizontal = properties.resHorizontal;
+			int resVertical = properties.resVertical;
+			int noiseWidth = chunkSize / resHorizontal + 1;
+			int noiseLength = chunkSize / resHorizontal + 1;
+			int noiseHeight = blocks.height / resVertical + 1;
+			int thresholdHeight = properties.heightOffset - world.waterLevel;
+
+			NoiseGenerator minTargetNoise = new NoiseGeneratorOctaves(rand, 8);
+			NoiseGenerator maxTargetNoise = new NoiseGeneratorOctaves(rand, 8);
+			NoiseGenerator selectorNoise = new NoiseGeneratorOctaves(rand, 4);
+
+			for (int cx = 0; cx < blocks.width / chunkSize; cx++) {
+				progressor.accept(cx * 100.0F / (blocks.width / chunkSize - 1));
+
+				for (int cz = 0; cz < blocks.length / chunkSize; cz++) {
+					int cbx = cx * chunkSize;
+					int cbz = cz * chunkSize;
+					int cnx = cbx / resHorizontal;
+					int cnz = cbz / resHorizontal;
+
+					DoubleArray3D minSamples = new DoubleArray3D(noiseWidth, noiseLength, noiseHeight);
+					DoubleArray3D maxSamples = new DoubleArray3D(noiseWidth, noiseLength, noiseHeight);
+					DoubleArray3D selectionSamples = new DoubleArray3D(noiseWidth, noiseLength, noiseHeight);
+
+					for (int y = 0; y < noiseHeight; y++) {
+						for (int z = 0; z < noiseLength; z++) {
+							for (int x = 0; x < noiseWidth; x++) {
+								double min = minTargetNoise.generateNoiseNormalized(
+										(x + cnx) * properties.noiseScaleHorizontal,
+										y * properties.noiseScaleVertical,
+										(z + cnz) * properties.noiseScaleHorizontal
+								);
+								double max = maxTargetNoise.generateNoiseNormalized(
+										(x + cnx) * properties.noiseScaleHorizontal,
+										y * properties.noiseScaleVertical,
+										(z + cnz) * properties.noiseScaleHorizontal
+								);
+								double selection = selectorNoise.generateNoiseNormalized(
+										(x + cnx) * properties.selectorScaleHorizontal,
+										y * properties.selectorScaleVertical,
+										(z + cnz) * properties.selectorScaleHorizontal
+								);
+
+								minSamples.set(x, y, z, min);
+								maxSamples.set(x, y, z, max);
+								selectionSamples.set(x, y, z, selection);
+							}
+						}
+					}
+
+					DoubleArray3D lerpedMinSamples = new DoubleArray3D(chunkSize, chunkSize, blocks.height);
+					DoubleArray3D lerpedMaxSamples = new DoubleArray3D(chunkSize, chunkSize, blocks.height);
+					DoubleArray3D lerpedSelectionSamples = new DoubleArray3D(chunkSize, chunkSize, blocks.height);
+
+					for (int y = 0; y < blocks.height; y++) {
+						for (int z = 0; z < chunkSize; z++) {
+							for (int x = 0; x < chunkSize; x++) {
+								lerpedMinSamples.set(x, y, z, lerp3DPoints(minSamples, x, y, z, resHorizontal, resVertical));
+								lerpedMaxSamples.set(x, y, z, lerp3DPoints(maxSamples, x, y, z, resHorizontal, resVertical));
+								lerpedSelectionSamples.set(x, y, z, lerp3DPoints(selectionSamples, x, y, z, resHorizontal, resVertical));
+							}
+						}
+					}
+
+					for (int y = 0; y < blocks.height - 2; y++) {
+						for (int z = 0; z < chunkSize && z + cbz < blocks.length; z++) {
+							for (int x = 0; x < chunkSize && x + cbx < blocks.length; x++) {
+								double min = lerpedMinSamples.get(x, y, z);
+								double max = lerpedMaxSamples.get(x, y, z);
+								double selection = lerpedSelectionSamples.get(x, y, z);
+
+								double target = lerp(min, max, Math.min(Math.max(
+										selection / properties.selectorThreshold + 0.5D, 0.0D), 1.0D));
+
+								double threshold = (y - world.waterLevel + properties.heightOffset) / properties.noiseStretch;
+								if (threshold < 0.0D) {
+									threshold *= properties.noiseUnderDamp;
+								}
+								target -= threshold;
+
+								if (target > 0.0D && y > blocks.height - properties.heightRoundoff) {
+									target -= 1.0F - (blocks.height - y) / (double)properties.heightRoundoff;
+								}
+
+								if (target > 0.0D) {
+									if (properties.cliffBlocks
+											&& Math.abs(selection) < properties.selectorThreshold
+											&& Math.abs(min - max) > properties.cliffThreshold) {
+										blocks.set(x + cbx, y, z + cbz, Block.clothRed.blockID);
+									} else {
+										blocks.set(x + cbx, y, z + cbz, Block.clothGreen.blockID);
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		});
+	}
+
+	public static double lerp(double a, double b, double t) {
+		return a + (b - a) * t;
+	}
+
+	public static double lerp3DPoints(DoubleArray3D samples, int x, int y, int z, int resHorizontal, int resVertical) {
+		int nx = x / resHorizontal;
+		int ny = y / resVertical;
+		int nz = z / resHorizontal;
+
+		double n000 = samples.get(nx + 0, ny + 0, nz + 0);
+		double n001 = samples.get(nx + 0, ny + 0, nz + 1);
+		double n010 = samples.get(nx + 0, ny + 1, nz + 0);
+		double n011 = samples.get(nx + 0, ny + 1, nz + 1);
+		double n100 = samples.get(nx + 1, ny + 0, nz + 0);
+		double n101 = samples.get(nx + 1, ny + 0, nz + 1);
+		double n110 = samples.get(nx + 1, ny + 1, nz + 0);
+		double n111 = samples.get(nx + 1, ny + 1, nz + 1);
+
+		double n00 = lerp(n000, n100, (x % resHorizontal) / (double)resHorizontal);
+		double n01 = lerp(n001, n101, (x % resHorizontal) / (double)resHorizontal);
+		double n10 = lerp(n010, n110, (x % resHorizontal) / (double)resHorizontal);
+		double n11 = lerp(n011, n111, (x % resHorizontal) / (double)resHorizontal);
+
+		double n0 = lerp(n00, n10, (y % resVertical) / (double)resVertical);
+		double n1 = lerp(n01, n11, (y % resVertical) / (double)resVertical);
+
+		return lerp(n0, n1, (z % resHorizontal) / (double)resHorizontal);
+	}
+
+	public static class Builder {
+		private int resHorizontal = 4;
+		private int resVertical = 4;
+		private double noiseScaleHorizontal = 5.0D;
+		private double noiseScaleVertical = 5.0D;
+		private double selectorScaleHorizontal = 0.6D;
+		private double selectorScaleVertical = 0.15D;
+		private double selectorThreshold = 0.1D;
+		private double cliffThreshold = 0.25D;
+		private double noiseStretch = 64.0D;
+		private double noiseUnderDamp = 4.0D;
+		private int heightOffset = 0;
+		private int heightRoundoff = 8;
+		private boolean cliffBlocks = true;
+
+		public Builder resHorizontal(int resHorizontal) {
+			this.resHorizontal = resHorizontal;
+			return this;
+		}
+
+		public Builder resVertical(int resVertical) {
+			this.resVertical = resVertical;
+			return this;
+		}
+
+		public Builder noiseScaleHorizontal(double noiseScaleHorizontal) {
+			this.noiseScaleHorizontal = noiseScaleHorizontal;
+			return this;
+		}
+
+		public Builder noiseScaleVertical(double noiseScaleVertical) {
+			this.noiseScaleVertical = noiseScaleVertical;
+			return this;
+		}
+
+		public Builder selectorScaleHorizontal(double selectorScaleHorizontal) {
+			this.selectorScaleHorizontal = selectorScaleHorizontal;
+			return this;
+		}
+
+		public Builder selectorScaleVertical(double selectorScaleVertical) {
+			this.selectorScaleVertical = selectorScaleVertical;
+			return this;
+		}
+
+		public Builder selectorThreshold(double selectorThreshold) {
+			this.selectorThreshold = selectorThreshold;
+			return this;
+		}
+
+		public Builder cliffThreshold(double cliffThreshold) {
+			this.cliffThreshold = cliffThreshold;
+			return this;
+		}
+
+		public Builder noiseStretch(double noiseStretch) {
+			this.noiseStretch = noiseStretch;
+			return this;
+		}
+
+		public Builder noiseUnderDamp(double noiseUnderDamp) {
+			this.noiseUnderDamp = noiseUnderDamp;
+			return this;
+		}
+
+		public Builder heightOffset(int heightOffset) {
+			this.heightOffset = heightOffset;
+			return this;
+		}
+
+		public Builder heightRoundoff(int heightRoundoff) {
+			this.heightRoundoff = heightRoundoff;
+			return this;
+		}
+
+		public Builder cliffBlocks(boolean cliffBlocks) {
+			this.cliffBlocks = cliffBlocks;
+			return this;
+		}
+
+		public StageRaising3D build() {
+			return new StageRaising3D(this);
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageSoiling3D.java
@@ -1,0 +1,88 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+
+public class StageSoiling3D extends TerrainGenStage {
+	public StageSoiling3D(Builder properties) {
+		super("Soiling..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			NoiseGenerator erosionNoise = new NoiseGeneratorOctaves(rand, 8);
+
+			for (int x = 0; x < blocks.width; x++) {
+				progressor.accept(x * 100.0F / (float)(blocks.width - 1));
+				for (int z = 0; z < blocks.length; z++) {
+					int erosion = (int)(erosionNoise.generateNoise(
+							x * properties.erosionScale, z * properties.erosionScale)
+							/ properties.erosionDamp) + properties.erosionOffset;
+
+					int erosionFactor = erosion;
+					for (int y = blocks.height - 1; y > 0; y--) {
+						if (blocks.get(x, y, z) != 0) {
+							if (heightmap.get(x, z) == 0) {
+								heightmap.set(x, z, y);
+							}
+
+							Block block = properties.stone;
+							if (erosionFactor < 0 && blocks.get(x, y, z) == Block.clothGreen.blockID) {
+								block = properties.soil;
+								if (block == Block.dirt && world.skyBrightness > 7 && (y >= blocks.height || blocks.get(x, y + 1, z) == 0)) {
+									block = Block.grass;
+								}
+							}
+
+							blocks.set(x, y, z, block.blockID);
+							erosionFactor++;
+						} else {
+							erosionFactor = erosion;
+						}
+					}
+				}
+			}
+		});
+	}
+
+	public static class Builder {
+		private double erosionScale = 1.0D;
+		private double erosionDamp = 24.0D;
+		private int erosionOffset = -4;
+		private Block soil = Block.dirt;
+		private Block stone = Block.stone;
+
+		public Builder erosionScale(double erosionScale) {
+			this.erosionScale = erosionScale;
+			return this;
+		}
+
+		public Builder erosionDamp(double erosionDamp) {
+			this.erosionDamp = erosionDamp;
+			return this;
+		}
+
+		public Builder erosionOffset(int erosionOffset) {
+			this.erosionOffset = erosionOffset;
+			return this;
+		}
+
+		public Builder soil(Block soil) {
+			this.soil = soil;
+			return this;
+		}
+
+		public Builder stone(Block stone) {
+			this.stone = stone;
+			return this;
+		}
+
+		public Builder applyTheme(LevelTheme theme) {
+			return this
+					.soil(theme.getSoilBlock())
+					.stone(theme.getStoneBlock());
+		}
+
+		public StageSoiling3D build() {
+			return new StageSoiling3D(this);
+		}
+	}
+}
--- net/minecraft/client/render/RenderGlobal.java
+++ net/minecraft/client/render/RenderGlobal.java
@@ -22,14 +22,12 @@
 import net.minecraft.game.level.IWorldAccess;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.block.BlockFluid;
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.physics.MovingObjectPosition;
 import net.minecraft.game.physics.Vec3D;
 import org.lwjgl.BufferUtils;
-import org.lwjgl.opengl.ARBOcclusionQuery;
-import org.lwjgl.opengl.GL11;
-import org.lwjgl.opengl.GL15;
-import org.lwjgl.opengl.GLContext;
+import org.lwjgl.opengl.*;
 import util.MathHelper;
 
 public final class RenderGlobal implements IWorldAccess {
@@ -67,7 +65,7 @@
 	public RenderGlobal(Minecraft var1, RenderEngine var2) {
 		this.mc = var1;
 		this.renderEngine = var2;
-		this.glGenList = GL11.glGenLists(2);
+		this.glGenList = GL11.glGenLists(3);
 		this.glRenderListBase = GL11.glGenLists(786432);
 		this.occlusionEnabled = GLContext.getCapabilities().GL_ARB_occlusion_query;
 		if(this.occlusionEnabled) {
@@ -124,6 +122,8 @@
 	}
 
 	public final void loadRenderers() {
+		this.occlusionEnabled = this.mc.options.advancedOpenGL;
+
 		int var1;
 		if(this.worldRenderers != null) {
 			for(var1 = 0; var1 < this.worldRenderers.length; ++var1) {
@@ -166,6 +166,9 @@
 		GL11.glNewList(this.glGenList + 1, GL11.GL_COMPILE);
 		this.oobWaterRenderHeight();
 		GL11.glEndList();
+		GL11.glNewList(this.glGenList + 2, GL11.GL_COMPILE);
+		this.oobHorizonRenderHeight();
+		GL11.glEndList();
 		this.markBlocksForUpdate(0, 0, 0, this.worldObj.width, this.worldObj.height, this.worldObj.length);
 	}
 
@@ -175,10 +178,16 @@
 		this.countEntitiesTotal = 0;
 		this.countEntitiesRendered = 0;
 		this.countEntitiesHidden = 0;
+		int dist = this.mc.options.getRenderDistance();
 
 		for(int var5 = 0; var5 < var4.width; ++var5) {
 			for(int var6 = 0; var6 < var4.depth; ++var6) {
 				for(int var7 = 0; var7 < var4.height; ++var7) {
+					int x = var5 * 8;
+					int y = var6 * 8;
+					int z = var7 * 8;
+					if (this.mc.thePlayer.getDistanceSqToBlock(x, y, z) > dist * dist) continue;
+
 					List var8 = var4.entityGrid[(var7 * var4.depth + var6) * var4.width + var5];
 					if(var8.size() != 0) {
 						int var9 = (var5 << 3) + 4;
@@ -238,6 +247,11 @@
 	}
 
 	public final int sortAndRender(EntityPlayer var1, int var2) {
+		boolean occlusion = this.occlusionEnabled && var2 == 0;
+		if (var2 < 0) {
+			var2 = 0;
+		}
+
 		if(var2 == 0) {
 			this.renderersLoaded = 0;
 			this.renderersBeingClipped = 0;
@@ -256,7 +270,7 @@
 		}
 
 		int var8;
-		if(this.occlusionEnabled && var2 == 0) {
+		if(occlusion) {
 			int var10 = 8;
 			this.checkOcclusionQueryResult(0, 8);
 
@@ -265,7 +279,7 @@
 				this.sortedWorldRenderers[var6].isVisible = true;
 			}
 
-			var8 = 0 + this.renderSortedRenderers(0, 8, var2);
+			var8 = this.renderSortedRenderers(0, 8, var2);
 
 			do {
 				int var9 = var10;
@@ -305,7 +319,7 @@
 				var8 += this.renderSortedRenderers(var9, var10, var2);
 			} while(var10 < this.sortedWorldRenderers.length);
 		} else {
-			var8 = 0 + this.renderSortedRenderers(0, this.sortedWorldRenderers.length, var2);
+			var8 = this.renderSortedRenderers(0, this.sortedWorldRenderers.length, var2);
 		}
 
 		return var8;
@@ -371,6 +385,10 @@
 	}
 
 	public final void renderSky(float var1) {
+		float px = this.mc.thePlayer.lastTickPosX + (this.mc.thePlayer.posX - this.mc.thePlayer.lastTickPosX) * var1;
+		float py = this.mc.thePlayer.lastTickPosY + (this.mc.thePlayer.posY - this.mc.thePlayer.lastTickPosY) * var1;
+		float pz = this.mc.thePlayer.lastTickPosZ + (this.mc.thePlayer.posZ - this.mc.thePlayer.lastTickPosZ) * var1;
+
 		GL11.glDisable(GL11.GL_TEXTURE_2D);
 		Vec3D var2 = this.worldObj.getSkyColor(var1);
 		float var3 = var2.xCoord;
@@ -389,7 +407,7 @@
 		Tessellator var12 = Tessellator.instance;
 		var12.startDrawingQuads();
 		var12.setColorOpaque_F(var3, var4, var9);
-		var9 = (float)(this.worldObj.height + 10);
+		var9 = (float)(Math.max(py, this.worldObj.height) + 10);
 
 		int var10;
 		for(var10 = -2048; var10 < this.worldObj.width + 2048; var10 += 512) {
@@ -434,11 +452,16 @@
 		GL11.glColor4f(var9, var9, var9, var9);
 		GL11.glCallList(this.glSkyList);
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+
 		GL11.glEnable(GL11.GL_TEXTURE_2D);
-		GL11.glDisable(GL11.GL_BLEND);
-		GL11.glEnable(GL11.GL_ALPHA_TEST);
-		GL11.glEnable(GL11.GL_FOG);
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glDisable(GL11.GL_DEPTH_TEST);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		GL11.glPopMatrix();
+
+		GL11.glEnable(GL11.GL_FOG);
+		GL11.glEnable(GL11.GL_ALPHA_TEST);
+		GL11.glEnable(GL11.GL_DEPTH_TEST);
 		GL11.glDepthMask(true);
 		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/clouds.png"));
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
@@ -456,13 +479,27 @@
 			var3 = var3;
 		}
 
-		var9 = (float)this.worldObj.cloudHeight;
+		var9 = (float)this.worldObj.cloudHeight + 0.1F;
+		float var9a = var9 + 64.0F * Math.signum(this.worldObj.cloudHeight + 0.5F);
 		var7 = ((float)this.cloudOffsetX + var1) * (0.5F / 1024.0F) * 0.03F;
 		var12.startDrawingQuads();
-		var12.setColorOpaque_F(var4, var6, var3);
 
+		float a = 0.5F - this.mc.options.renderDistance * 0.25F;
 		for(int var8 = -2048; var8 < this.worldObj.width + 2048; var8 += 512) {
 			for(var10 = -2048; var10 < this.worldObj.length + 2048; var10 += 512) {
+				if (a > 0.0F) {
+					var12.setColorRGBA_F(var4, var6, var3, a);
+					var12.addVertexWithUV((float)var8, var9a, (float)(var10 + 512), (float)(var8 + 512) * (0.5F / 2048.0F) + var7, (float)(var10 + 1024) * (0.5F / 2048.0F));
+					var12.addVertexWithUV((float)(var8 + 512), var9a, (float)(var10 + 512), (float)(var8 + 1024) * (0.5F / 2048.0F) + var7, (float)(var10 + 1024) * (0.5F / 2048.0F));
+					var12.addVertexWithUV((float)(var8 + 512), var9a, (float)var10, (float)(var8 + 1024) * (0.5F / 2048.0F) + var7, (float)(var10 + 512) * (0.5F / 2048.0F));
+					var12.addVertexWithUV((float)var8, var9a, (float)var10, (float)(var8 + 512) * (0.5F / 2048.0F) + var7, (float)(var10 + 512) * (0.5F / 2048.0F));
+					var12.addVertexWithUV((float)var8, var9a, (float)var10, (float)(var8 + 512) * (0.5F / 2048.0F) + var7, (float)(var10 + 512) * (0.5F / 2048.0F));
+					var12.addVertexWithUV((float)(var8 + 512), var9a, (float)var10, (float)(var8 + 1024) * (0.5F / 2048.0F) + var7, (float)(var10 + 512) * (0.5F / 2048.0F));
+					var12.addVertexWithUV((float)(var8 + 512), var9a, (float)(var10 + 512), (float)(var8 + 1024) * (0.5F / 2048.0F) + var7, (float)(var10 + 1024) * (0.5F / 2048.0F));
+					var12.addVertexWithUV((float)var8, var9a, (float)(var10 + 512), (float)(var8 + 512) * (0.5F / 2048.0F) + var7, (float)(var10 + 1024) * (0.5F / 2048.0F));
+				}
+
+				var12.setColorRGBA_F(var4, var6, var3, 1.0F);
 				var12.addVertexWithUV((float)var8, var9, (float)(var10 + 512), (float)var8 * (0.5F / 1024.0F) + var7, (float)(var10 + 512) * (0.5F / 1024.0F));
 				var12.addVertexWithUV((float)(var8 + 512), var9, (float)(var10 + 512), (float)(var8 + 512) * (0.5F / 1024.0F) + var7, (float)(var10 + 512) * (0.5F / 1024.0F));
 				var12.addVertexWithUV((float)(var8 + 512), var9, (float)var10, (float)(var8 + 512) * (0.5F / 1024.0F) + var7, (float)var10 * (0.5F / 1024.0F));
@@ -475,14 +512,26 @@
 		}
 
 		var12.draw();
+		GL11.glDisable(GL11.GL_BLEND);
+		GL11.glBlendFunc(GL11.GL_ONE, GL11.GL_ONE);
 	}
 
 	public final void oobGroundRenderer() {
 		float var1 = this.worldObj.getLightBrightness(0, this.worldObj.getGroundLevel(), 0);
-		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/dirt.png"));
-		if(this.worldObj.getGroundLevel() > this.worldObj.getWaterLevel() && this.worldObj.defaultFluid == Block.waterMoving.blockID) {
-			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/grass.png"));
+		String texture;
+		if (this.worldObj.levelTheme.getSoilBlock() == Block.sand) {
+			texture = "/sand.png";
+		} else {
+			texture = "/dirt.png";
+			if(this.worldObj.getGroundLevel() > this.worldObj.getWaterLevel() && this.worldObj.defaultFluid == Block.waterMoving.blockID) {
+				if (this.worldObj.levelTheme.hasSnow()) {
+					texture = "/snow.png";
+				} else {
+					texture = "/grass.png";
+				}
+			}
 		}
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture(texture));
 
 		GL11.glColor4f(var1, var1, var1, 1.0F);
 		GL11.glEnable(GL11.GL_TEXTURE_2D);
@@ -492,23 +541,30 @@
 	private void oobGroundRenderHeight() {
 		Tessellator var1 = Tessellator.instance;
 		float var2 = (float)this.worldObj.getGroundLevel();
+		if (this.worldObj.levelTheme.hasSnow() && var2 > 0.0F && var2 > this.worldObj.getWaterLevel()) {
+			var2 += Block.snow.maxY;
+		}
+
 		int var3 = 128;
+		int var3a = 128;
 		if(128 > this.worldObj.width) {
 			var3 = this.worldObj.width;
 		}
 
-		if(var3 > this.worldObj.length) {
-			var3 = this.worldObj.length;
+		if(128 > this.worldObj.length) {
+			var3a = this.worldObj.length;
 		}
 
 		int var4 = 2048 / var3;
+		int var4a = 2048 / var3a;
 		var1.startDrawingQuads();
 
 		for(int var5 = -var3 * var4; var5 < this.worldObj.width + var3 * var4; var5 += var3) {
-			for(int var6 = -var3 * var4; var6 < this.worldObj.length + var3 * var4; var6 += var3) {
+			for(int var6 = -var3a * var4a; var6 < this.worldObj.length + var3a * var4a; var6 += var3a) {
+				float f;
 				if(var2 < 0.0F || var5 < 0 || var6 < 0 || var5 >= this.worldObj.width || var6 >= this.worldObj.length) {
-					var1.addVertexWithUV((float)var5, var2, (float)(var6 + var3), 0.0F, (float)var3);
-					var1.addVertexWithUV((float)(var5 + var3), var2, (float)(var6 + var3), (float)var3, (float)var3);
+					var1.addVertexWithUV((float)var5, var2, (float)(var6 + var3a), 0.0F, (float)var3a);
+					var1.addVertexWithUV((float)(var5 + var3), var2, (float)(var6 + var3a), (float)var3, (float)var3a);
 					var1.addVertexWithUV((float)(var5 + var3), var2, (float)var6, (float)var3, 0.0F);
 					var1.addVertexWithUV((float)var5, var2, (float)var6, 0.0F, 0.0F);
 				}
@@ -521,8 +577,16 @@
 	public final void oobWaterRenderer() {
 		GL11.glEnable(GL11.GL_TEXTURE_2D);
 		GL11.glEnable(GL11.GL_BLEND);
-		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/water.png"));
-		float var1 = this.worldObj.getLightBrightness(0, this.worldObj.getWaterLevel(), 0);
+		if (this.worldObj.levelTheme.hasSnow()) {
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/ice.png"));
+		} else {
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/water.png"));
+		}
+
+		float var1 = 1.0F;
+		if (this.worldObj.defaultFluid != Block.lavaMoving.blockID) {
+			var1 = this.worldObj.getLightBrightness(0, this.worldObj.getWaterLevel(), 0);
+		}
 		GL11.glColor4f(var1, var1, var1, 1.0F);
 		GL11.glCallList(this.glGenList + 1);
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
@@ -534,31 +598,33 @@
 		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		Tessellator var2 = Tessellator.instance;
 		int var3 = 128;
+		int var3a = 128;
 		if(128 > this.worldObj.width) {
 			var3 = this.worldObj.width;
 		}
 
-		if(var3 > this.worldObj.length) {
-			var3 = this.worldObj.length;
+		if(128 > this.worldObj.length) {
+			var3a = this.worldObj.length;
 		}
 
 		int var4 = 2048 / var3;
+		int var4a = 2048 / var3a;
 		var2.startDrawingQuads();
 		float var5 = Block.waterMoving.minX;
 		float var6 = Block.waterMoving.minZ;
 
 		for(int var7 = -var3 * var4; var7 < this.worldObj.width + var3 * var4; var7 += var3) {
-			for(int var8 = -var3 * var4; var8 < this.worldObj.length + var3 * var4; var8 += var3) {
-				float var9 = var1 + Block.waterMoving.minY;
+			for(int var8 = -var3a * var4a; var8 < this.worldObj.length + var3a * var4a; var8 += var3a) {
+				float var9 = this.worldObj.levelTheme.hasSnow() ? var1 : var1 - BlockFluid.getFluidHeightPercent(0);
 				if(var1 < 0.0F || var7 < 0 || var8 < 0 || var7 >= this.worldObj.width || var8 >= this.worldObj.length) {
-					var2.addVertexWithUV((float)var7 + var5, var9, (float)(var8 + var3) + var6, 0.0F, (float)var3);
-					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)(var8 + var3) + var6, (float)var3, (float)var3);
-					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)var8 + var6, (float)var3, 0.0F);
-					var2.addVertexWithUV((float)var7 + var5, var9, (float)var8 + var6, 0.0F, 0.0F);
-					var2.addVertexWithUV((float)var7 + var5, var9, (float)var8 + var6, 0.0F, 0.0F);
-					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)var8 + var6, (float)var3, 0.0F);
-					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)(var8 + var3) + var6, (float)var3, (float)var3);
-					var2.addVertexWithUV((float)var7 + var5, var9, (float)(var8 + var3) + var6, 0.0F, (float)var3);
+					var2.addVertexWithUV((float)var7 + var5, var9, (float)(var8 + var3a) + var6, 0.0F, (float)var3a);
+					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)(var8 + var3a) + var6, (float)var3, (float)var3a);
+					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)var8 + var6, (float)var3, 0.0F);
+					var2.addVertexWithUV((float)var7 + var5, var9, (float)var8 + var6, 0.0F, 0.0F);
+					var2.addVertexWithUV((float)var7 + var5, var9, (float)var8 + var6, 0.0F, 0.0F);
+					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)var8 + var6, (float)var3, 0.0F);
+					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)(var8 + var3a) + var6, (float)var3, (float)var3a);
+					var2.addVertexWithUV((float)var7 + var5, var9, (float)(var8 + var3a) + var6, 0.0F, (float)var3a);
 				}
 			}
 		}
@@ -567,6 +633,75 @@
 		GL11.glDisable(GL11.GL_BLEND);
 	}
 
+	public final void oobHorizonRender(float var1) {
+//		if (true) return;
+
+		float alpha = 1.0F - this.mc.options.renderDistance / 3.0F;
+		if (alpha < 0.1F) {
+			return;
+		}
+
+		String horizonType = this.worldObj.levelType.getHorizonType();
+		if (horizonType == null) {
+			return;
+		}
+
+		float px = this.mc.thePlayer.lastTickPosX + (this.mc.thePlayer.posX - this.mc.thePlayer.lastTickPosX) * var1;
+		float py = this.mc.thePlayer.lastTickPosY + (this.mc.thePlayer.posY - this.mc.thePlayer.lastTickPosY) * var1;
+		float pz = this.mc.thePlayer.lastTickPosZ + (this.mc.thePlayer.posZ - this.mc.thePlayer.lastTickPosZ) * var1;
+		float opy = (py - Math.max(this.worldObj.waterLevel, this.worldObj.groundLevel)) / 96.0F;
+		float yOffset = (py - Math.max(this.worldObj.waterLevel, this.worldObj.groundLevel)) * (1.0F - this.mc.options.getRenderDistance() / 512.0F);
+		Vec3D color = this.worldObj.getSkyColor(var1);
+		GL11.glColor4f(color.xCoord, color.yCoord, color.zCoord, alpha * (1.0F - opy * opy));
+		GL13.glActiveTexture(GL13.GL_TEXTURE1);
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("$$/terrain/horizonmask.png"));
+		GL13.glActiveTexture(GL13.GL_TEXTURE0);
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/horizon/" + horizonType + ".png"));
+		GL11.glTranslatef(px, yOffset, pz);
+		HorizonShader.start();
+		GL11.glCallList(this.glGenList + 2);
+		HorizonShader.stop();
+		GL11.glTranslatef(-px, -yOffset, -pz);
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+	}
+
+	private void oobHorizonRenderHeight() {
+		Tessellator t = Tessellator.instance;
+		t.startDrawingQuads();
+
+		int segments = 32;
+		float pi = (float)Math.PI;
+		float pi2 = pi * 2.0F;
+		float d = this.mc.options.getRenderDistance() * 0.99F;
+
+		float minY = Math.max(this.mc.theWorld.waterLevel, this.mc.theWorld.groundLevel);
+		float maxY = minY + d / pi;
+
+		float[] x = new float[segments];
+		float[] z = new float[segments];
+
+		for (int i = 0; i < segments; i++) {
+			float s = MathHelper.sin(i / (float)segments * pi2);
+			float c = MathHelper.cos(i / (float)segments * pi2);
+			x[i] = d * s;
+			z[i] = d * c;
+		}
+
+		for (int i = 0; i < segments; i++) {
+			float minX = x[i];
+			float minZ = z[i];
+			float maxX = x[(i + 1) % segments];
+			float maxZ = z[(i + 1) % segments];
+
+			t.addVertexWithUV(minX, minY, minZ, (float)-i / segments, 1.0F);
+			t.addVertexWithUV(minX, maxY, minZ, (float)-i / segments, 0.0F);
+			t.addVertexWithUV(maxX, maxY, maxZ, (float)-(i + 1) / segments, 0.0F);
+			t.addVertexWithUV(maxX, minY, maxZ, (float)-(i + 1) / segments, 1.0F);
+		}
+
+		t.draw();
+	}
+
 	public final void updateRenderers(EntityPlayer var1) {
 		Collections.sort(this.worldRenderersToUpdate, new RenderSorter(var1));
 		int var2 = this.worldRenderersToUpdate.size() - 1;
@@ -574,13 +709,16 @@
 
 		for(int var4 = 0; var4 < var3; ++var4) {
 			WorldRenderer var5 = (WorldRenderer)this.worldRenderersToUpdate.get(var2 - var4);
-			if(var5.distanceToEntitySquared(var1) > 2500.0F && var4 > 4) {
+			float wrDist = var5.distanceToEntitySquared(var1);
+			if(wrDist > 2500.0F && var4 > 4) {
 				return;
 			}
 
-			this.worldRenderersToUpdate.remove(var5);
-			var5.updateRenderer();
-			var5.needsUpdate = false;
+			if (var5.isInFrustrum) {
+				this.worldRenderersToUpdate.remove(var5);
+				var5.updateRenderer();
+				var5.needsUpdate = false;
+			}
 		}
 
 	}
@@ -618,6 +756,8 @@
 	}
 
 	public final void drawSelectionBox(MovingObjectPosition var1, int var2) {
+		if (!this.mc.options.showHUD) return;
+
 		GL11.glEnable(GL11.GL_BLEND);
 		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		GL11.glColor4f(0.0F, 0.0F, 0.0F, 0.4F);
@@ -714,7 +854,7 @@
 
 	public final void clipRenderersByFrustrum(ICamera var1) {
 		for(int var2 = 0; var2 < this.worldRenderers.length; ++var2) {
-			this.worldRenderers[var2].updateInFrustrum(var1);
+			this.worldRenderers[var2].updateInFrustrum(var1, this.worldObj.playerEntity, this.mc.options.getRenderDistance() + 16);
 		}
 
 	}
@@ -774,5 +914,20 @@
 		GL11.glNewList(this.glGenList + 1, GL11.GL_COMPILE);
 		this.oobWaterRenderHeight();
 		GL11.glEndList();
+
+		for (WorldRenderer wr : this.worldRenderers) {
+			if (!wr.needsUpdate) {
+				wr.needsUpdate = true;
+				this.worldRenderersToUpdate.add(wr);
+			}
+		}
+	}
+
+	public void renderAllRenderers() {
+		for (WorldRenderer wr : (List<WorldRenderer>)this.worldRenderersToUpdate) {
+			wr.updateRenderer();
+			wr.isInFrustrum = true;
+			wr.needsUpdate = false;
+		}
 	}
 }
--- /dev/null
+++ net/minecraft/client/render/HorizonShader.java
@@ -1,0 +1,76 @@
+package net.minecraft.client.render;
+
+import org.lwjgl.opengl.GL20;
+import org.lwjgl.opengl.GLContext;
+
+public class HorizonShader {
+	private static final String fs = String.join("\n",
+			"uniform sampler2D tex, mask;",
+			"void main() {",
+			"   vec4 color = texture2D(tex, gl_TexCoord[0].xy);",
+			"   color *= gl_Color;",
+			"   float alpha = texture2D(mask, gl_TexCoord[0].xy).a;",
+			"   gl_FragColor = vec4(color.xyz, color.a * alpha);",
+			"   gl_FragDepth = 1.0;",
+			"}"
+	);
+	private static final String vs = String.join("\n",
+			"void main() {",
+			"   gl_Position = ftransform();",
+			"   gl_FrontColor = gl_Color;",
+			"   gl_TexCoord[0] = gl_MultiTexCoord0;",
+			"}"
+	);
+
+	private static final boolean GL20_SUPPORTED = GLContext.getCapabilities().OpenGL20;
+	private static final int ID;
+
+	static {
+		if (!GL20_SUPPORTED) {
+			ID = 0;
+		} else {
+			int f = GL20.glCreateShader(GL20.GL_FRAGMENT_SHADER);
+			GL20.glShaderSource(f, fs);
+			GL20.glCompileShader(f);
+			if (GL20.glGetShaderi(f, GL20.GL_COMPILE_STATUS) == 0) {
+				String log = GL20.glGetShaderInfoLog(f, 1000);
+				System.err.println("Fragment failure\n" + log);
+			}
+
+			int v = GL20.glCreateShader(GL20.GL_VERTEX_SHADER);
+			GL20.glShaderSource(v, vs);
+			GL20.glCompileShader(v);
+			if (GL20.glGetShaderi(v, GL20.GL_COMPILE_STATUS) == 0) {
+				String log = GL20.glGetShaderInfoLog(v, 1000);
+				System.err.println("Vertex failure\n" + log);
+			}
+
+			ID = GL20.glCreateProgram();
+			GL20.glAttachShader(ID, f);
+			GL20.glAttachShader(ID, v);
+			GL20.glLinkProgram(ID);
+			if (GL20.glGetProgrami(ID, GL20.GL_LINK_STATUS) == 0) {
+				String log = GL20.glGetProgramInfoLog(ID, 1000);
+				System.err.println("Program failure\n" + log);
+			}
+
+			GL20.glDeleteShader(f);
+			GL20.glDeleteShader(v);
+			GL20.glUseProgram(ID);
+
+			GL20.glUniform1i(GL20.glGetUniformLocation(ID, "tex"), 0);
+			GL20.glUniform1i(GL20.glGetUniformLocation(ID, "mask"), 1);
+			GL20.glUseProgram(0);
+		}
+	}
+
+	public static void start() {
+		if (!GL20_SUPPORTED) return;
+		GL20.glUseProgram(ID);
+	}
+
+	public static void stop() {
+		if (!GL20_SUPPORTED) return;
+		GL20.glUseProgram(0);
+	}
+}
--- net/minecraft/client/sound/SoundManager.java
+++ net/minecraft/client/sound/SoundManager.java
@@ -76,9 +76,11 @@
 	public final void playRandomMusicIfReady(float var1, float var2, float var3) {
 		if(this.loaded && this.options.music) {
 			if(!this.sndSystem.playing("BgMusic")) {
-				SoundPoolEntry var4 = this.soundPoolMusic.getRandomSoundFromSoundPool("calm");
-				this.sndSystem.newStreamingSource(true, "BgMusic", var4.soundUrl, var4.soundName, false, var1, var2, var3, 2, 32.0F);
-				this.sndSystem.play("BgMusic");
+				SoundPoolEntry var4 = this.soundPoolMusic.getRandomSound();
+				if (var4 != null) {
+					this.sndSystem.backgroundMusic("BgMusic", var4.soundUrl, var4.soundName, false);
+					this.sndSystem.play("BgMusic");
+				}
 			}
 
 		}
--- net/minecraft/client/gui/GuiIngameMenu.java
+++ net/minecraft/client/gui/GuiIngameMenu.java
@@ -1,13 +1,23 @@
 package net.minecraft.client.gui;
 
+import java.io.IOException;
+
 public final class GuiIngameMenu extends GuiScreen {
 	public final void initGui() {
 		this.controlList.clear();
-		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4, "Options..."));
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 24, "Generate new level..."));
-		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 48, "Save level.."));
-		this.controlList.add(new GuiButton(3, this.width / 2 - 100, this.height / 4 + 72, "Load level.."));
-		this.controlList.add(new GuiButton(4, this.width / 2 - 100, this.height / 4 + 120, "Back to game"));
+		if (this.mc.theWorld != null && this.mc.adventureMode) {
+			this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 12, "Options..."));
+			this.controlList.add(new GuiButton(4, this.width / 2 - 100, this.height / 4 + 36, "Back to game"));
+			this.controlList.add(new GuiButton(5, this.width / 2 - 100, this.height / 4 + 84, "Save world"));
+			this.controlList.add(new GuiButton(6, this.width / 2 - 100, this.height / 4 + 108, "Quit to title"));
+		} else {
+			this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 - 4, "Options..."));
+			this.controlList.add(new GuiButton(4, this.width / 2 - 100, this.height / 4 + 20, "Back to game"));
+			this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 52, "Generate new level..."));
+			this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 76, "Save level..."));
+			this.controlList.add(new GuiButton(3, this.width / 2 - 100, this.height / 4 + 100, "Load level..."));
+			this.controlList.add(new GuiButton(6, this.width / 2 - 100, this.height / 4 + 132, "Quit to title"));
+		}
 		if(this.mc.session == null) {
 			((GuiButton)this.controlList.get(2)).enabled = false;
 			((GuiButton)this.controlList.get(3)).enabled = false;
@@ -37,6 +47,24 @@
 		if(var1.id == 4) {
 			this.mc.displayGuiScreen((GuiScreen)null);
 			this.mc.setIngameFocus();
+		}
+
+		if(var1.id == 5) {
+			try {
+				this.mc.saveWorld();
+			} catch (IOException e) {
+			}
+		}
+
+		if(var1.id == 6) {
+			if (this.mc.adventureMode) {
+				try {
+					this.mc.saveWorld();
+				} catch (IOException e) {
+				}
+			}
+			this.mc.setLevel(null);
+			this.mc.displayGuiScreen(null);
 		}
 
 	}
--- net/minecraft/game/item/recipe/CraftingManager.java
+++ net/minecraft/game/item/recipe/CraftingManager.java
@@ -20,24 +20,54 @@
 		(new RecipesTools()).addRecipes(this);
 		(new RecipesWeapons()).addRecipes(this);
 		(new RecipesIngots()).addRecipes(this);
-		new RecipesFood();
+		(new RecipesMechanics()).addRecipes(this);
+		this.addRecipe(new ItemStack(Block.blockCopper), "##", "##", '#', Item.ingotCopper);
+		this.addRecipe(new ItemStack(Item.ingotCopper, 4), "#", '#', Block.blockCopper);
 		this.addRecipe(new ItemStack(Item.bowlSoup), new Object[]{"Y", "X", "#", Character.valueOf('X'), Block.mushroomBrown, Character.valueOf('Y'), Block.mushroomRed, Character.valueOf('#'), Item.bowlEmpty});
 		this.addRecipe(new ItemStack(Item.bowlSoup), new Object[]{"Y", "X", "#", Character.valueOf('X'), Block.mushroomRed, Character.valueOf('Y'), Block.mushroomBrown, Character.valueOf('#'), Item.bowlEmpty});
-		new RecipesCrafting();
 		this.addRecipe(new ItemStack(Block.crate), new Object[]{"###", "# #", "###", Character.valueOf('#'), Block.planks});
 		this.addRecipe(new ItemStack(Block.stoneOvenIdle), new Object[]{"###", "# #", "###", Character.valueOf('#'), Block.cobblestone});
 		this.addRecipe(new ItemStack(Block.workbench), new Object[]{"##", "##", Character.valueOf('#'), Block.planks});
 		(new RecipesArmor()).addRecipes(this);
-		this.addRecipe(new ItemStack(Block.clothGray, 1), new Object[]{"###", "###", "###", Character.valueOf('#'), Item.silk});
+		this.addRecipe(new ItemStack(Block.clothWhite, 1), new Object[]{"##", "##", Character.valueOf('#'), Item.silk});
 		this.addRecipe(new ItemStack(Block.tnt, 1), new Object[]{"X#X", "#X#", "X#X", Character.valueOf('X'), Item.gunpowder, Character.valueOf('#'), Block.sand});
-		this.addRecipe(new ItemStack(Block.stairSingle, 3), new Object[]{"###", Character.valueOf('#'), Block.cobblestone});
+		this.addRecipe(new ItemStack(Block.stairSingle, 6), new Object[]{"###", Character.valueOf('#'), Block.cobblestone});
+		this.addRecipe(new ItemStack(Block.woodStairSingle, 6), new Object[]{"###", Character.valueOf('#'), Block.planks});
 		this.addRecipe(new ItemStack(Block.planks, 4), new Object[]{"#", Character.valueOf('#'), Block.wood});
 		this.addRecipe(new ItemStack(Item.stick, 4), new Object[]{"#", "#", Character.valueOf('#'), Block.planks});
 		this.addRecipe(new ItemStack(Block.torch, 4), new Object[]{"X", "#", Character.valueOf('X'), Item.coal, Character.valueOf('#'), Item.stick});
 		this.addRecipe(new ItemStack(Item.bowlEmpty, 4), new Object[]{"# #", " # ", Character.valueOf('#'), Block.planks});
 		this.addRecipe(new ItemStack(Item.striker, 1), new Object[]{"A ", " B", Character.valueOf('A'), Item.ingotIron, Character.valueOf('B'), Item.flint});
 		this.addRecipe(new ItemStack(Item.bread, 1), new Object[]{"###", Character.valueOf('#'), Item.wheat});
-		this.addRecipe(new ItemStack(Item.painting, 1), new Object[]{"###", "#X#", "###", Character.valueOf('#'), Block.planks, Character.valueOf('X'), Block.clothGray});
+		this.addRecipe(new ItemStack(Item.painting, 1), new Object[]{"###", "#X#", "###", Character.valueOf('#'), Block.planks, Character.valueOf('X'), Block.clothWhite});
+		this.addRecipe(new ItemStack(Block.blockSnow, 1), new Object[]{"##", "##", Character.valueOf('#'), Item.snowball});
+
+		for (int i = 0; i < 15; i++) {
+			this.addRecipe(new ItemStack(Block.clothRed.blockID + i, 8), "###", "#X#", "###", '#', Block.clothWhite, 'X', Item.itemsList[Item.dyeRed.shiftedIndex + i]);
+			this.addRecipe(new ItemStack(Block.clothWhite.blockID, 8), "###", "#X#", "###", '#', Block.blocksList[Block.clothRed.blockID + i], 'X', Item.dyeWhite);
+		}
+
+		this.addRecipe(new ItemStack(Item.dyeRed, 1), "X", 'X', Block.plantRed);
+		this.addRecipe(new ItemStack(Item.dyeYellow, 1), "X", 'X', Block.plantYellow);
+		this.addRecipe(new ItemStack(Item.dyeCapri, 1), "X", 'X', Block.plantBlue);
+		this.addRecipe(new ItemStack(Item.dyeWhite, 1), "X", 'X', Block.mushroomRed);
+		this.addRecipe(new ItemStack(Item.dyeWhite, 1), "X", 'X', Block.mushroomBrown);
+		this.addRecipe(new ItemStack(Item.dyeDarkGray, 1), "X", 'X', Item.coal);
+
+		for (String order : new String[] { "AB", "BA" }) {
+			this.addRecipe(new ItemStack(Item.dyeOrange, 2), order, 'A', Item.dyeRed, 'B', Item.dyeYellow);
+			this.addRecipe(new ItemStack(Item.dyeYellow, 2), order, 'A', Item.dyeRed, 'B', Item.dyeGreen);
+			this.addRecipe(new ItemStack(Item.dyeChartreuse, 2), order, 'A', Item.dyeYellow, 'B', Item.dyeGreen);
+			this.addRecipe(new ItemStack(Item.dyeGreen, 2), order, 'A', Item.dyeYellow, 'B', Item.dyeCyan);
+			this.addRecipe(new ItemStack(Item.dyeSpringGreen, 2), order, 'A', Item.dyeGreen, 'B', Item.dyeCyan);
+			this.addRecipe(new ItemStack(Item.dyeCyan, 2), order, 'A', Item.dyeYellow, 'B', Item.dyeCapri);
+			this.addRecipe(new ItemStack(Item.dyeUltramarine, 2), order, 'A', Item.dyeCapri, 'B', Item.dyeViolet);
+			this.addRecipe(new ItemStack(Item.dyeViolet, 2), order, 'A', Item.dyeCapri, 'B', Item.dyeRed);
+			this.addRecipe(new ItemStack(Item.dyeRose, 2), order, 'A', Item.dyeMagenta, 'B', Item.dyeRed);
+			this.addRecipe(new ItemStack(Item.dyeGray, 2), order, 'A', Item.dyeWhite, 'B', Item.dyeDarkGray);
+			this.addRecipe(new ItemStack(Item.dyeMagenta, 2), order, 'A', Item.dyeViolet, 'B', Item.dyeRed);
+			this.addRecipe(new ItemStack(Item.dyePurple, 2), order, 'A', Item.dyeCapri, 'B', Item.dyeRed);
+		}
 		Collections.sort(this.recipes, new RecipeSorter(this));
 		System.out.println(this.recipes.size() + " recipes");
 	}
--- net/minecraft/client/controller/PlayerControllerCreative.java
+++ net/minecraft/client/controller/PlayerControllerCreative.java
@@ -2,17 +2,18 @@
 
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.Session;
+import net.minecraft.client.sound.SoundManager;
 import net.minecraft.game.entity.player.EntityPlayer;
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.level.MobSpawner;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.block.StepSound;
 
 public final class PlayerControllerCreative extends PlayerController {
-	private MobSpawner mobSpawner;
-
-	private PlayerControllerCreative(Minecraft var1) {
+	public PlayerControllerCreative(Minecraft var1) {
 		super(var1);
+		this.isInTestMode = true;
 	}
 
 	public final void onRespawn(EntityPlayer var1) {
@@ -33,10 +34,8 @@
 	public final void onWorldChange(World var1) {
 		super.onWorldChange(var1);
 		var1.survivalWorld = false;
-		this.mobSpawner = new MobSpawner(var1);
 	}
 
-	public final void onUpdate() {
-		this.mobSpawner.performSpawning();
+	public void onBlockDestroyed(int var1, int var2, int var3, World var4, Block var5, int var6) {
 	}
 }
--- /dev/null
+++ net/minecraft/client/GameWindowListener.java
@@ -1,0 +1,26 @@
+package net.minecraft.client;
+
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+
+public final class GameWindowListener extends WindowAdapter {
+	final Minecraft mc;
+	final Thread thread;
+
+	public GameWindowListener(Minecraft var1, Thread var2) {
+		this.mc = var1;
+		this.thread = var2;
+	}
+
+	public void windowClosing(WindowEvent var1) {
+		this.mc.shutdown();
+
+		try {
+			this.thread.join();
+		} catch (InterruptedException var3) {
+			var3.printStackTrace();
+		}
+
+		System.exit(0);
+	}
+}
--- net/minecraft/game/level/block/BlockGrass.java
+++ net/minecraft/game/level/block/BlockGrass.java
@@ -5,10 +5,21 @@
 import net.minecraft.game.level.material.Material;
 
 public final class BlockGrass extends Block {
-	protected BlockGrass(int var1) {
+	public BlockGrass(int var1) {
 		super(2, Material.ground);
 		this.blockIndexInTexture = 3;
 		this.setTickOnLoad(true);
+	}
+
+	@Override
+	public int getBlockTexture(World var1, int var2, int var3, int var4, int var5) {
+		if (var5 > 1) {
+			Material material = var1.getBlockMaterial(var2, var3 + 1, var4);
+			if (material == Material.snow || material == Material.craftedSnow) {
+				return 97;
+			}
+		}
+		return super.getBlockTexture(var1, var2, var3, var4, var5);
 	}
 
 	public final int getBlockTextureFromSide(int var1) {
--- net/minecraft/client/render/entity/RenderManager.java
+++ net/minecraft/client/render/entity/RenderManager.java
@@ -82,6 +82,10 @@
 	}
 
 	public final void renderEntity(Entity var1, float var2) {
+		if (var1.notUpdating) {
+			var2 = 1.0F;
+		}
+
 		float var3 = var1.lastTickPosX + (var1.posX - var1.lastTickPosX) * var2;
 		float var4 = var1.lastTickPosY + (var1.posY - var1.lastTickPosY) * var2;
 		float var5 = var1.lastTickPosZ + (var1.posZ - var1.lastTickPosZ) * var2;
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageShafting.java
@@ -1,0 +1,252 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.level.block.Block;
+
+import java.util.*;
+
+public class StageShafting extends TerrainGenStage {
+	public StageShafting() {
+		super("Shafting..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			// Strips (Tunnels along Z)
+			int stripCount = blocks.width * blocks.length * blocks.height / 5000;
+			Set<Tunnel> strips = new TreeSet<>(Comparator.comparingInt(strip -> strip.z));
+			for (int i = 0; i < stripCount; i++) {
+				Tunnel newStrip = null;
+				boolean stripSuitable = false;
+				while (!stripSuitable) {
+					int x = rand.nextInt(world.width - 2) + 1;
+					int y = rand.nextInt(world.groundLevel - 8) + 4;
+					int z = rand.nextInt(world.length - 2) + 1;
+					int length = rand.nextInt(100 - 16) + 16;
+					final Tunnel finalStrip = newStrip = new Tunnel(x, y, z, length);
+					stripSuitable = strips.stream().noneMatch(strip -> strip.stripDistance(finalStrip) < 6);
+				};
+				strips.add(newStrip);
+			}
+
+			// Branches (Tunnels along X)
+			Set<Tunnel> branches = new HashSet<>();
+			Tunnel stripToConnect = null;
+			for (Tunnel strip : strips) {
+				if (stripToConnect == null) {
+					stripToConnect = strip;
+				} else {
+					Tunnel stripA = stripToConnect;
+					Tunnel stripB = strip;
+
+					if (stripA.x > stripB.x) {
+						Tunnel swap = stripA;
+						stripA = stripB;
+						stripB = swap;
+					}
+
+					int length = stripB.x - stripA.x;
+					int skew = stripB.y - stripA.y;
+
+					int minZ = Math.max(stripA.z, stripB.z);
+					int maxZ = Math.min(stripA.z + stripA.length, stripB.z + stripB.length);
+					if (minZ > maxZ) {
+						int swap = minZ;
+						minZ = maxZ;
+						maxZ = swap;
+					}
+
+					if (maxZ - minZ < stripA.length) {
+						minZ = stripA.z;
+						maxZ = stripA.z + stripA.length;
+					}
+
+					int branchCount = rand.nextInt(2);
+					for (int i = 0; i < branchCount; i++) {
+						int x = stripA.x;
+						int y = stripA.y;
+						int z = rand.nextInt(maxZ - minZ) + minZ;
+						branches.add(new Tunnel(x, y, z, length, skew));
+					}
+
+					stripToConnect = null;
+				}
+			}
+
+			// Shafts (Tunnels along Y)
+			Set<Tunnel> shafts = new HashSet<>();
+			for (Tunnel strip : strips) {
+				int shaftCount = rand.nextInt(5) - 3;
+				int x = strip.x;
+				int y = strip.y + 2;
+				for (int i = 0; i < shaftCount; i++) {
+					int z = strip.z + rand.nextInt(strip.length);
+					shafts.add(new Tunnel(x, y, z));
+				}
+			}
+
+			// Place shafts
+			for (Tunnel shaft : shafts) {
+				int sx = shaft.x;
+				int sz = shaft.z;
+				int y;
+				for (y = shaft.y; y < blocks.height && blocks.get(shaft.x, y, shaft.z) != 0; y++) {
+					if (rand.nextInt(5) == 0) {
+						sx += rand.nextInt(3) - 1;
+						sz += rand.nextInt(3) - 1;
+					}
+
+					boolean beam = (y - shaft.y) % 2 == 0;
+					for (int x = sx - 2; x <= sx + 2; x++) {
+						for (int z = sz - 2; z <= sz + 2; z++) {
+							if (x < sx - 1 || x > sx + 1 || z < sz - 1 || z > sz + 1) {
+								int block = Block.planks.blockID;
+								if (((x - sx + 2) + (z - sz + 2)) % 2 == 0) {
+									block = Block.wood.blockID;
+								} else if (beam) {
+									block = Block.cobblestone.blockID;
+								}
+								blocks.set(x, y, z, block);
+							} else {
+								blocks.set(x, y, z, 0);
+							}
+						}
+					}
+				}
+
+				// Entrance hut
+				for (int oy = 0; oy < 7; oy++) {
+					if (oy < 3) {
+						blocks.set(sx - 2, y + oy, sz - 2, Block.wood.blockID);
+						blocks.set(sx - 2, y + oy, sz + 2, Block.wood.blockID);
+						blocks.set(sx + 2, y + oy, sz - 2, Block.wood.blockID);
+						blocks.set(sx + 2, y + oy, sz + 2, Block.wood.blockID);
+					} else {
+						int range = 6 - oy;
+						for (int ox = -range; ox <= range; ox++) {
+							for (int oz = -range; oz <= range; oz++) {
+								int x = sx + ox;
+								int z = sz + oz;
+								blocks.set(x, y + oy, z, Block.stairDouble.blockID);
+							}
+						}
+					}
+				}
+			}
+
+			// Place branches
+			for (Tunnel branch : branches) {
+				for (int x = branch.x; x < branch.x + branch.length; x++) {
+					int skewedY = branch.y + (x - branch.x) * branch.skew / branch.length;
+
+					for (int z = branch.z - 2; z <= branch.z + 2; z++) {
+						for (int y = skewedY - 2; y <= skewedY + 2; y++) {
+							boolean beam = (x - branch.x) % 3 == 2;
+							if (z == branch.z - 2 || z == branch.z + 2) {
+								if (beam) {
+									blocks.set(x, y, z, Block.wood.blockID);
+								} else if (y == skewedY && blocks.get(x, y, z) == Block.stone.blockID) {
+									blocks.set(x, y, z, Block.cobblestone.blockID);
+								}
+							} else if (y == skewedY - 2 || y == skewedY + 2) {
+								if (beam) {
+									blocks.set(x, y, z, Block.planks.blockID);
+								} else if ((z == branch.z - 1 || z == branch.z + 1) && blocks.get(x, y, z) == Block.stone.blockID) {
+									blocks.set(x, y, z, Block.cobblestone.blockID);
+								}
+							} else {
+								blocks.set(x, y, z, 0);
+							}
+						}
+					}
+
+					if (rand.nextInt(200) == 0) {
+						chestPlacer.placeChest(x, skewedY - 1, branch.z - 1 + rand.nextInt(2) * 2);
+					}
+				}
+			}
+
+			// Place strips
+			for (Tunnel strip : strips) {
+				for (int z = strip.z; z < strip.z + strip.length; z++) {
+					for (int x = strip.x - 2; x <= strip.x + 2; x++) {
+						for (int y = strip.y - 2; y <= strip.y + 2; y++) {
+							boolean beam = (z - strip.z) % 3 == 2;
+							if (x == strip.x - 2 || x == strip.x + 2) {
+								if (beam) {
+									blocks.set(x, y, z, Block.wood.blockID);
+								} else if (y == strip.y && blocks.get(x, y, z) == Block.stone.blockID) {
+									blocks.set(x, y, z, Block.cobblestone.blockID);
+								}
+							} else if (y == strip.y - 2 || y == strip.y + 2) {
+								if (beam) {
+									blocks.set(x, y, z, Block.planks.blockID);
+								} else if ((x == strip.x - 1 || x == strip.x + 1) && blocks.get(x, y, z) == Block.stone.blockID) {
+									blocks.set(x, y, z, Block.cobblestone.blockID);
+								}
+							} else {
+								blocks.set(x, y, z, 0);
+							}
+						}
+					}
+
+					if (rand.nextInt(300) == 0) {
+						chestPlacer.placeChest(strip.x - 1 + rand.nextInt(2) * 2, strip.y - 1, z);
+					}
+				}
+			}
+		});
+
+		this.setChestSlots(3, 10);
+		for (int i = 0; i < 3; i++) {
+			this.addChestItem(new ChestItem(Item.pickaxeStone.shiftedIndex, 1, true));
+			this.addChestItem(new ChestItem(Item.pickaxeSteel.shiftedIndex, 1, true));
+			this.addChestItem(new ChestItem(Item.pickaxeStone.shiftedIndex, 1, true));
+			this.addChestItem(new ChestItem(Block.torch.blockID, 16));
+			this.addChestItem(new ChestItem(Block.torch.blockID, 16));
+			this.addChestItem(new ChestItem(Block.torch.blockID, 16));
+			this.addChestItem(new ChestItem(Item.wheat.shiftedIndex, 16));
+			this.addChestItem(new ChestItem(Item.coal.shiftedIndex, 16));
+			this.addChestItem(new ChestItem(Item.coal.shiftedIndex, 16));
+			this.addChestItem(new ChestItem(Item.ingotIron.shiftedIndex, 8));
+			if (i == 1) {
+				this.addChestItem(new ChestItem(Item.diamond.shiftedIndex, 3));
+			}
+		}
+	}
+
+	private static class Tunnel { // Tunnel object
+		final int x, y, z;
+		final int length;
+		final int skew;
+
+		Tunnel(int x, int y, int z) {
+			this(x, y, z, 0, 0);
+		}
+
+		Tunnel(int x, int y, int z, int length) {
+			this(x, y, z, length, 0);
+		}
+
+		Tunnel(int x, int y, int z, int length, int skew) {
+			this.x = x;
+			this.y = y;
+			this.z = z;
+			this.length = length;
+			this.skew = skew;
+		}
+
+		int stripDistance(Tunnel strip) {
+			return Math.abs(this.x - strip.x) + Math.abs(this.y - strip.y);
+		}
+
+		@Override
+		public boolean equals(Object o) {
+			if (this == o) return true;
+			if (o == null || getClass() != o.getClass()) return false;
+			Tunnel tunnel = (Tunnel) o;
+			return x == tunnel.x && y == tunnel.y && z == tunnel.z && length == tunnel.length;
+		}
+
+		@Override
+		public int hashCode() {
+			return Objects.hash(x, y, z, length);
+		}
+	}
+}
--- net/minecraft/game/level/generator/noise/NoiseGeneratorOctaves.java
+++ net/minecraft/game/level/generator/noise/NoiseGeneratorOctaves.java
@@ -5,6 +5,7 @@
 public final class NoiseGeneratorOctaves extends NoiseGenerator {
 	private NoiseGeneratorPerlin[] generatorCollection;
 	private int octaves;
+	private double totFreq = 0.5D;
 
 	public NoiseGeneratorOctaves(Random var1, int var2) {
 		this.octaves = var2;
@@ -12,11 +13,12 @@
 
 		for(int var3 = 0; var3 < var2; ++var3) {
 			this.generatorCollection[var3] = new NoiseGeneratorPerlin(var1);
+			this.totFreq *= 2.0D;
 		}
 
 	}
 
-	public final double generateNoise(double var1, double var3) {
+	public double generateNoise(double var1, double var3) {
 		double var5 = 0.0D;
 		double var7 = 1.0D;
 
@@ -26,5 +28,25 @@
 		}
 
 		return var5;
+	}
+
+	public double generateNoise(double var1, double var3, double var5) {
+		double var7 = 0.0D;
+		double var9 = 1.0D;
+
+		for(int var11 = 0; var11 < this.octaves; ++var11) {
+			var7 += this.generatorCollection[var11].generateNoise(var1 / var9, var3 / var9, var5 / var9) * var9;
+			var9 *= 2.0D;
+		}
+
+		return var7;
+	}
+
+	public double generateNoiseNormalized(double var1, double var3) {
+		return this.generateNoise(var1, var3) / this.totFreq;
+	}
+
+	public double generateNoiseNormalized(double var1, double var3, double var5) {
+		return this.generateNoise(var1, var3, var5) / this.totFreq;
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/block/BlockLogicGate.java
@@ -1,0 +1,89 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.entity.player.EntityPlayer;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+import java.util.function.Predicate;
+
+public class BlockLogicGate extends Block {
+	private static final List<Boolean> lampList = new ArrayList<>();
+
+	public BlockLogicGate(int var1) {
+		super(var1, 84, Material.iron);
+	}
+
+	public int tickRate() {
+		return 0;
+	}
+
+	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
+		if (var5 == 1) {
+			int dir = Math.floorMod(Math.floorDiv((int)var1.playerEntity.rotationYaw - 45, 90), 4);
+			var5 = dir == 0 ? 5 : dir == 1 ? 3 : dir == 2 ? 4 : dir == 3 ? 2 : 2 + var1.random.nextInt(4);
+		}
+		var1.setBlockMetadata(var2, var3, var4, var5);
+	}
+
+	public int getBlockTextureFromSide(int var1) {
+		return var1 == 0 ? 84 : var1 == 1 ? 53 : var1 == 3 ? 118 : 121;
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
+		return var1 == (var2 & 7) ? 118 : var1 == 0 ? 84 : var1 == 1 ? 53 : 121 + (var2 >>> 3 & 7);
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		lampList.clear();
+		int y = var3 + 1;
+		int b;
+		while (var3 < var1.height && ((b = var1.getBlockId(var2, y, var4)) == Block.lampInactive.blockID || b == Block.lampActive.blockID)) {
+			lampList.add(b == Block.lampActive.blockID);
+			y++;
+		}
+
+		if (!lampList.isEmpty()) {
+			int meta = var1.getBlockMetadata(var2, var3, var4);
+			int dir = meta & 7;
+			int mode = (meta >>> 3) & 3;
+			boolean prevCondition = (meta & 128) != 0;
+
+			boolean condition = false;
+			switch (mode) {
+				case 0: condition = !lampList.contains(false); break;
+				case 1: condition = lampList.contains(true); break;
+				case 2: {
+					boolean i = false;
+					for (boolean lamp : lampList) {
+						if (lamp) {
+							condition = true;
+							if (i) {
+								condition = false;
+								break;
+							}
+							i = true;
+						}
+					}
+				}
+			}
+
+			if (prevCondition != condition) {
+				var1.setBlockMetadata(var2, var3, var4, (meta & 127) | (condition ? 128 : 0));
+				var1.transmitPowerInDirection(var2, var3, var4, dir);
+			}
+		}
+	}
+
+	public boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+		int dir = var1.getBlockMetadata(var2, var3, var4) & 7;
+		int mode = (var1.getBlockMetadata(var2, var3, var4) >>> 3) & 7;
+		boolean active = (var1.getBlockMetadata(var2, var3, var4) & 128) != 0;
+		mode = (mode + 1) % 3;
+		var1.setBlockMetadata(var2, var3, var4, dir | mode << 3 | (active ? 128 : 0));
+		this.updateTick(var1, var2, var3, var4, var1.random);
+		return true;
+	}
+}
--- net/minecraft/client/player/MovementInputFromOptions.java
+++ net/minecraft/client/player/MovementInputFromOptions.java
@@ -11,31 +11,13 @@
 	}
 
 	public final void checkKeyForMovementInput(int var1, boolean var2) {
-		byte var3 = -1;
-		if(var1 == this.gameSettings.keyBindForward.keyCode) {
-			var3 = 0;
-		}
-
-		if(var1 == this.gameSettings.keyBindBack.keyCode) {
-			var3 = 1;
-		}
-
-		if(var1 == this.gameSettings.keyBindLeft.keyCode) {
-			var3 = 2;
-		}
-
-		if(var1 == this.gameSettings.keyBindRight.keyCode) {
-			var3 = 3;
-		}
-
-		if(var1 == this.gameSettings.keyBindJump.keyCode) {
-			var3 = 4;
-		}
-
-		if(var3 >= 0) {
-			this.movementKeyStates[var3] = var2;
-		}
-
+		if(var1 == this.gameSettings.keyBindForward.keyCode) this.movementKeyStates[0] = var2;
+		if(var1 == this.gameSettings.keyBindBack.keyCode) this.movementKeyStates[1] = var2;
+		if(var1 == this.gameSettings.keyBindLeft.keyCode) this.movementKeyStates[2] = var2;
+		if(var1 == this.gameSettings.keyBindRight.keyCode) this.movementKeyStates[3] = var2;
+		if(var1 == this.gameSettings.keyBindJump.keyCode) this.movementKeyStates[4] = var2;
+		if(var1 == this.gameSettings.keyBindFlyUp.keyCode) this.movementKeyStates[5] = var2;
+		if(var1 == this.gameSettings.keyBindFlyDown.keyCode) this.movementKeyStates[6] = var2;
 	}
 
 	public final void resetKeyState() {
@@ -65,5 +47,7 @@
 		}
 
 		this.jump = this.movementKeyStates[4];
+		this.flyUp = this.movementKeyStates[5];
+		this.flyDown = this.movementKeyStates[6];
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/block/BlockDiode.java
@@ -1,0 +1,58 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.entity.player.EntityPlayer;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+import java.util.HashSet;
+import java.util.Random;
+
+public class BlockDiode extends Block {
+	private static final int[] tickDurations = { 1, 2, 5, 10, 20 };
+
+	public BlockDiode(int var1) {
+		super(var1, 84, Material.iron);
+	}
+
+	private static int getTickDuration(int meta) {
+		return tickDurations[(meta >> 3)];
+	}
+
+	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
+		var1.setBlockMetadata(var2, var3, var4, var5);
+	}
+
+	public int getBlockTextureFromSide(int var1) {
+		return var1 == 3 ? 118 : var1 == 2 ? 53 : var1 < 2 ? 84 : 119;
+	}
+
+	public int getBlockTexture(World var1, int var2, int var3, int var4, int var5) {
+		int dir = var1.getBlockMetadata(var2, var3, var4) & 7;
+		int tick = var1.getBlockMetadata(var2, var3, var4) >>> 3;
+		return var5 == dir ? 118 : var5 == dir / 2 * 2 + 1 - (dir % 2) ? 53 : var5 == 0 ? 84 : 112 + tick;
+	}
+
+	public boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+		int dir = var1.getBlockMetadata(var2, var3, var4) & 7;
+		int tick = var1.getBlockMetadata(var2, var3, var4) >>> 3;
+		tick = (tick + 1) % tickDurations.length;
+		var1.setBlockMetadata(var2, var3, var4, dir | tick << 3);
+		return true;
+	}
+
+	public boolean canReceivePower(World var1, int var2, int var3, int var4, int var5) {
+		return var5 >= 0 && var5 != (var1.getBlockMetadata(var2, var3, var4) & 7);
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+		world.scheduleBlockUpdate(x, y, z, this.blockID, getTickDuration(world.getBlockMetadata(x, y, z)) - 1);
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		int mdir = var1.getBlockMetadata(var2, var3, var4) & 7;
+		var2 += mdir == 4 ? -1 : mdir == 5 ? 1 : 0;
+		var3 += mdir == 0 ? -1 : mdir == 1 ? 1 : 0;
+		var4 += mdir == 2 ? -1 : mdir == 3 ? 1 : 0;
+		var1.transmitPower(new HashSet<>(), var2, var3, var4, mdir);
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/LevelStructure.java
@@ -1,0 +1,93 @@
+package net.minecraft.game.level.generator;
+
+import net.minecraft.game.level.generator.terrain.StageFortifying;
+import net.minecraft.game.level.generator.terrain.StageShafting;
+import net.minecraft.game.level.generator.terrain.StageTemplifying;
+import net.minecraft.game.level.generator.terrain.TerrainGenStage;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+public enum LevelStructure {
+	NONE("None") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[0];
+		}
+
+		@Override
+		public boolean canNaturallyGenerate() {
+			return false;
+		}
+	},
+	FORT("Fort") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageFortifying()
+			};
+		}
+	},
+	MINESHAFT("Mineshaft") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageShafting()
+			};
+		}
+	},
+	TEMPLES("Temples") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageTemplifying()
+			};
+		}
+	};
+
+	private static final Map<String, LevelStructure> NAME_TO_TYPE = Arrays.stream(values())
+			.collect(Collectors.toMap(LevelStructure::toString, Function.identity()));
+	private static final List<LevelStructure> NATURAL_STRUCTURES = Arrays.stream(values())
+			.filter(LevelStructure::canNaturallyGenerate).collect(Collectors.toList());
+
+	public final String name;
+
+	LevelStructure(String name) {
+		this.name = name;
+	}
+
+	public boolean canNaturallyGenerate() {
+		return true;
+	}
+
+	public abstract TerrainGenStage[] getTerrainGenStages(LevelTheme theme);
+
+	@Override
+	public String toString() {
+		return this.name;
+	}
+
+	public static LevelStructure fromId(int id) {
+		return values()[id];
+	}
+
+	public static LevelStructure fromName(String name) {
+		return NAME_TO_TYPE.getOrDefault(name, NONE);
+	}
+
+	public static LevelStructure fromNameNullable(String name) {
+		return NAME_TO_TYPE.get(name);
+	}
+
+	public static LevelStructure getRandomGen() {
+		Random random = new Random();
+		if (random.nextInt(6) != 0) {
+			return NONE;
+		}
+		return NATURAL_STRUCTURES.get(random.nextInt(NATURAL_STRUCTURES.size()));
+	}
+}
--- net/minecraft/game/level/generator/noise/NoiseGeneratorDistort.java
+++ net/minecraft/game/level/generator/noise/NoiseGeneratorDistort.java
@@ -9,7 +9,11 @@
 		this.distort = var2;
 	}
 
-	public final double generateNoise(double var1, double var3) {
+	public double generateNoise(double var1, double var3) {
 		return this.source.generateNoise(var1 + this.distort.generateNoise(var1, var3), var3);
+	}
+
+	public double generateNoise(double var1, double var3, double var5) {
+		return this.source.generateNoise(var1 + this.distort.generateNoise(var1, var3, var5), var3, var5);
 	}
 }
--- net/minecraft/game/level/block/BlockLeaves.java
+++ net/minecraft/game/level/block/BlockLeaves.java
@@ -5,16 +5,16 @@
 import net.minecraft.game.level.material.Material;
 
 public final class BlockLeaves extends BlockLeavesBase {
-	protected BlockLeaves(int var1, int var2) {
+	public BlockLeaves(int var1, int var2) {
 		super(18, 52, Material.leaves, true);
 		this.setTickOnLoad(true);
 	}
 
 	public final void updateTick(World var1, int var2, int var3, int var4, Random var5) {
 		if(!var1.getBlockMaterial(var2, var3 - 1, var4).isSolid()) {
-			for(int var8 = var2 - 2; var8 <= var2 + 2; ++var8) {
-				for(int var6 = var3 - 1; var6 <= var3; ++var6) {
-					for(int var7 = var4 - 2; var7 <= var4 + 2; ++var7) {
+			for(int var8 = var2 - 4; var8 <= var2 + 4; ++var8) {
+				for(int var6 = var3 - 4; var6 <= var3 + 4; ++var6) {
+					for(int var7 = var4 - 4; var7 <= var4 + 4; ++var7) {
 						if(var1.getBlockId(var8, var6, var7) == Block.wood.blockID) {
 							return;
 						}
--- net/minecraft/client/render/WorldRenderer.java
+++ net/minecraft/client/render/WorldRenderer.java
@@ -2,6 +2,7 @@
 
 import net.minecraft.client.render.camera.ICamera;
 import net.minecraft.client.render.entity.RenderItem;
+import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.EntityLiving;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.block.Block;
@@ -137,8 +138,13 @@
 		}
 	}
 
-	public final void updateInFrustrum(ICamera var1) {
-		this.isInFrustrum = var1.isBoundingBoxInFrustrum(this.rendererBoundingBox);
+	public final void updateInFrustrum(ICamera var1, EntityLiving player, int dist) {
+		this.isInFrustrum = this.posX + this.sizeWidth >= player.posX - dist && this.posX <= player.posX + dist
+				&& this.posY + this.sizeHeight >= player.posY - dist && this.posY <= player.posY + dist
+				&& this.posZ + this.sizeDepth >= player.posZ - dist && this.posZ <= player.posZ + dist;
+		if (this.isInFrustrum) {
+			this.isInFrustrum = var1.isBoundingBoxInFrustrum(this.rendererBoundingBox);
+		}
 	}
 
 	public final void callOcclusionQueryList() {
--- net/minecraft/game/level/MetadataChunkBlock.java
+++ net/minecraft/game/level/MetadataChunkBlock.java
@@ -1,6 +1,9 @@
 package net.minecraft.game.level;
 
+import net.minecraft.game.level.block.Block;
+
 final class MetadataChunkBlock {
+	public final EnumSkyBlock skyBlock;
 	public int x;
 	public int y;
 	public int z;
@@ -8,12 +11,165 @@
 	public int maxY;
 	public int maxZ;
 
-	public MetadataChunkBlock(Light var1, int var2, int var3, int var4, int var5, int var6, int var7) {
+	public MetadataChunkBlock(EnumSkyBlock var1, int var2, int var3, int var4, int var5, int var6, int var7) {
+		this.skyBlock = var1;
 		this.x = var2;
 		this.y = var3;
 		this.z = var4;
 		this.maxX = var5;
 		this.maxY = var6;
 		this.maxZ = var7;
+	}
+
+	public void updateLight(World var1) {
+		int var2 = this.maxX - this.x;
+		int var3 = this.maxY - this.y;
+		int var4 = this.maxZ - this.z;
+		int var5 = var2 * var3 * var4;
+		if(true) {
+			for(int var6 = this.x; var6 <= this.maxX; ++var6) {
+				for(int var7 = this.z; var7 <= this.maxZ; ++var7) {
+					for(int var8 = this.y; var8 <= this.maxY; ++var8) {
+						if(var6 >= 0 && var6 < var1.width && var7 >= 0 && var7 < var1.length && var8 >= 0 && var8 < var1.height) {
+							int var9 = var1.getSavedLightValue(this.skyBlock, var6, var8, var7);
+							boolean var10 = false;
+							int var11 = var1.getBlockId(var6, var8, var7);
+							int var12 = Block.lightOpacity[var11];
+							if(var12 == 0) {
+								var12 = 1;
+							}
+
+							int var13 = 0;
+							if(this.skyBlock == EnumSkyBlock.Sky) {
+								if(var1.canBlockSeeTheSky(var6, var8, var7)) {
+									var13 = 15;
+								}
+							} else if(this.skyBlock == EnumSkyBlock.Block) {
+								var13 = Block.lightValue[var11];
+							}
+
+							int var14;
+							int var20;
+							if(var12 >= 15 && var13 == 0) {
+								var20 = 0;
+							} else {
+								var14 = var1.getSavedLightValue(this.skyBlock, var6 - 1, var8, var7);
+								int var15 = var1.getSavedLightValue(this.skyBlock, var6 + 1, var8, var7);
+								int var16 = var1.getSavedLightValue(this.skyBlock, var6, var8 - 1, var7);
+								int var17 = var1.getSavedLightValue(this.skyBlock, var6, var8 + 1, var7);
+								int var18 = var1.getSavedLightValue(this.skyBlock, var6, var8, var7 - 1);
+								int var19 = var1.getSavedLightValue(this.skyBlock, var6, var8, var7 + 1);
+								var20 = var14;
+								if(var15 > var14) {
+									var20 = var15;
+								}
+
+								if(var16 > var20) {
+									var20 = var16;
+								}
+
+								if(var17 > var20) {
+									var20 = var17;
+								}
+
+								if(var18 > var20) {
+									var20 = var18;
+								}
+
+								if(var19 > var20) {
+									var20 = var19;
+								}
+
+								var20 -= var12;
+								if(var20 < 0) {
+									var20 = 0;
+								}
+
+								if(var13 > var20) {
+									var20 = var13;
+								}
+							}
+
+							if(var9 != var20) {
+								var1.setSavedLightValue(this.skyBlock, var6, var8, var7, var20);
+								var14 = var20 - 1;
+								if(var14 < 0) {
+									var14 = 0;
+								}
+
+								var1.neighborLightPropagationChanged(this.skyBlock, var6 - 1, var8, var7, var14);
+								var1.neighborLightPropagationChanged(this.skyBlock, var6, var8 - 1, var7, var14);
+								var1.neighborLightPropagationChanged(this.skyBlock, var6, var8, var7 - 1, var14);
+								if(var6 + 1 >= this.maxX) {
+									var1.neighborLightPropagationChanged(this.skyBlock, var6 + 1, var8, var7, var14);
+								}
+
+								if(var8 + 1 >= this.maxY) {
+									var1.neighborLightPropagationChanged(this.skyBlock, var6, var8 + 1, var7, var14);
+								}
+
+								if(var7 + 1 >= this.maxZ) {
+									var1.neighborLightPropagationChanged(this.skyBlock, var6, var8, var7 + 1, var14);
+								}
+							}
+						}
+					}
+				}
+			}
+
+		}
+	}
+
+	public boolean getLightUpdated(int var1, int var2, int var3, int var4, int var5, int var6) {
+		if(var1 >= this.x && var2 >= this.y && var3 >= this.z && var4 <= this.maxX && var5 <= this.maxY && var6 <= this.maxZ) {
+			return true;
+		} else {
+			byte var7 = 1;
+			if(var1 >= this.x - var7 && var2 >= this.y - var7 && var3 >= this.z - var7 && var4 <= this.maxX + var7 && var5 <= this.maxY + var7 && var6 <= this.maxZ + var7) {
+				int var8 = this.maxX - this.x;
+				int var9 = this.maxY - this.y;
+				int var10 = this.maxZ - this.z;
+				if(var1 > this.x) {
+					var1 = this.x;
+				}
+
+				if(var2 > this.y) {
+					var2 = this.y;
+				}
+
+				if(var3 > this.z) {
+					var3 = this.z;
+				}
+
+				if(var4 < this.maxX) {
+					var4 = this.maxX;
+				}
+
+				if(var5 < this.maxY) {
+					var5 = this.maxY;
+				}
+
+				if(var6 < this.maxZ) {
+					var6 = this.maxZ;
+				}
+
+				int var11 = var4 - var1;
+				int var12 = var5 - var2;
+				int var13 = var6 - var3;
+				int var14 = var8 * var9 * var10;
+				int var15 = var11 * var12 * var13;
+				if(var15 - var14 <= 2) {
+					this.x = var1;
+					this.y = var2;
+					this.z = var3;
+					this.maxX = var4;
+					this.maxY = var5;
+					this.maxZ = var6;
+					return true;
+				}
+			}
+
+			return false;
+		}
 	}
 }
--- net/minecraft/client/effect/EffectRenderer.java
+++ net/minecraft/client/effect/EffectRenderer.java
@@ -16,6 +16,7 @@
 	private List[] fxLayers = new List[3];
 	private RenderEngine renderEngine;
 	private Random rand = new Random();
+	private EntityFX horizonFX;
 
 	public EffectRenderer(World var1, RenderEngine var2) {
 		if(var1 != null) {
@@ -27,7 +28,6 @@
 		for(int var3 = 0; var3 < 3; ++var3) {
 			this.fxLayers[var3] = new ArrayList();
 		}
-
 	}
 
 	public final void addEffect(EntityFX var1) {
@@ -78,7 +78,6 @@
 				var12.draw();
 			}
 		}
-
 	}
 
 	public final void renderLitParticles(float var1) {
--- net/minecraft/game/level/block/BlockOreBlock.java
+++ net/minecraft/game/level/block/BlockOreBlock.java
@@ -11,4 +11,12 @@
 	public final int getBlockTextureFromSide(int var1) {
 		return var1 == 1 ? this.blockIndexInTexture - 16 : (var1 == 0 ? this.blockIndexInTexture + 16 : this.blockIndexInTexture);
 	}
+
+	public boolean isConductive() {
+		return true;
+	}
+
+	public boolean conductWithBlock(Block block) {
+		return !(block instanceof BlockOreBlock) || block == this;
+	}
 }
--- net/minecraft/client/render/EntityRenderer.java
+++ net/minecraft/client/render/EntityRenderer.java
@@ -65,7 +65,7 @@
 	public final void updateRenderer() {
 		this.prevFogColor = this.fogColor;
 		float var1 = this.mc.theWorld.getLightBrightness((int)this.mc.thePlayer.posX, (int)this.mc.thePlayer.posY, (int)this.mc.thePlayer.posZ);
-		float var2 = (float)(3 - this.mc.options.renderDistance) / 3.0F;
+		float var2 = Math.min((float)(4 - this.mc.options.renderDistance) / 3.0F, 1.0F);
 		var1 = var1 * (1.0F - var2) + var2;
 		this.fogColor += (var1 - this.fogColor) * 0.1F;
 		++this.rendererUpdateCount;
@@ -243,7 +243,7 @@
 							this.updateFogColor(0.0F);
 							GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT | GL11.GL_COLOR_BUFFER_BIT);
 							GL11.glEnable(GL11.GL_CULL_FACE);
-							this.farPlaneDistance = (float)(512 >> (this.mc.options.renderDistance << 1));
+							this.farPlaneDistance = (float)(this.mc.options.getRenderDistance());
 							GL11.glMatrixMode(GL11.GL_PROJECTION);
 							GL11.glLoadIdentity();
 							GL11.glOrtho(0.0D, (double)this.mc.displayWidth, 0.0D, (double)this.mc.displayHeight, 10.0D, 10000.0D);
@@ -279,7 +279,7 @@
 							IsomCamera var24 = new IsomCamera();
 							this.mc.renderGlobal.clipRenderersByFrustrum(var24);
 							this.mc.renderGlobal.updateRenderers(var15);
-							this.setupFog();
+							this.setupFog(1.0F);
 							GL11.glEnable(GL11.GL_FOG);
 							GL11.glFogi(GL11.GL_FOG_MODE, GL11.GL_LINEAR);
 							float var23 = (float)var16.height * 8.0F;
@@ -304,7 +304,7 @@
 								var17.renderAllRenderLists();
 							}
 
-							if(var16.getGroundLevel() >= 0) {
+							if(var16.getGroundLevel() >= 0 && var16.defaultFluid > 0) {
 								var17.oobWaterRenderer();
 							}
 
@@ -424,7 +424,7 @@
 			GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT | GL11.GL_COLOR_BUFFER_BIT);
 			GL11.glEnable(GL11.GL_CULL_FACE);
 			float var27 = var1;
-			this.farPlaneDistance = (float)(512 >> (this.mc.options.renderDistance << 1));
+			this.farPlaneDistance = (float)(this.mc.options.getRenderDistance());
 			GL11.glMatrixMode(GL11.GL_PROJECTION);
 			GL11.glLoadIdentity();
 			if(this.mc.options.anaglyph) {
@@ -490,14 +490,14 @@
 			GL11.glRotatef(var34.prevRotationYaw + (var34.rotationYaw - var34.prevRotationYaw) * var27 + 180.0F, 0.0F, 1.0F, 0.0F);
 			GL11.glTranslatef(-var13, -var14, -var15);
 			ClippingHelperImplementation.init();
-			this.setupFog();
+			this.setupFog(var1);
 			GL11.glEnable(GL11.GL_FOG);
 			var5.renderSky(var1);
-			this.setupFog();
+			this.setupFog(var1);
 			Frustrum var26 = new Frustrum();
 			this.mc.renderGlobal.clipRenderersByFrustrum(var26);
 			this.mc.renderGlobal.updateRenderers(var3);
-			this.setupFog();
+			this.setupFog(var1);
 			GL11.glEnable(GL11.GL_FOG);
 			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/terrain.png"));
 			RenderHelper.disableStandardItemLighting();
@@ -525,7 +525,7 @@
 			var5.renderEntities(this.orientCamera(var1), var26, var1);
 			var6.renderLitParticles(var1);
 			RenderHelper.disableStandardItemLighting();
-			this.setupFog();
+			this.setupFog(var1);
 			var6.renderParticles(var3, var1);
 			var5.oobGroundRenderer();
 			if(this.mc.objectMouseOver != null && var3.isInsideOfWater()) {
@@ -536,8 +536,10 @@
 			}
 
 			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
-			this.setupFog();
-			var5.oobWaterRenderer();
+			this.setupFog(var1);
+			if(this.mc.theWorld.defaultFluid > 0) {
+				var5.oobWaterRenderer();
+			}
 			GL11.glEnable(GL11.GL_BLEND);
 			GL11.glDisable(GL11.GL_CULL_FACE);
 			GL11.glColorMask(false, false, false, false);
@@ -555,6 +557,15 @@
 				var5.renderAllRenderLists();
 			}
 
+			GL11.glDisable(GL11.GL_ALPHA_TEST);
+			GL11.glEnable(GL11.GL_BLEND);
+			GL11.glDisable(GL11.GL_FOG);
+			var5.oobHorizonRender(var1);
+			GL11.glDisable(GL11.GL_BLEND);
+			GL11.glEnable(GL11.GL_FOG);
+			this.setupFog(var1);
+			GL11.glEnable(GL11.GL_ALPHA_TEST);
+
 			GL11.glDepthMask(true);
 			GL11.glEnable(GL11.GL_CULL_FACE);
 			GL11.glDisable(GL11.GL_BLEND);
@@ -578,7 +589,7 @@
 				this.setupViewBobbing(var1);
 			}
 
-			if(!this.mc.options.thirdPersonView) {
+			if(!this.mc.options.thirdPersonView && this.mc.options.showHUD) {
 				this.itemRenderer.renderItemInFirstPerson(var1);
 			}
 
@@ -616,7 +627,7 @@
 	private void updateFogColor(float var1) {
 		World var2 = this.mc.theWorld;
 		EntityPlayerSP var3 = this.mc.thePlayer;
-		float var4 = 1.0F / (float)(4 - this.mc.options.renderDistance);
+		float var4 = 1.0F / (float)(5 - this.mc.options.renderDistance);
 		var4 = 1.0F - (float)Math.pow((double)var4, 0.25D);
 		Vec3D var5 = var2.getSkyColor(var1);
 		float var6 = var5.xCoord;
@@ -659,7 +670,7 @@
 		GL11.glClearColor(this.fogColorRed, this.fogColorGreen, this.fogColorBlue, 0.0F);
 	}
 
-	private void setupFog() {
+	private void setupFog(float f) {
 		World var1 = this.mc.theWorld;
 		EntityPlayerSP var2 = this.mc.thePlayer;
 		int var10000 = GL11.GL_FOG_COLOR;
@@ -683,9 +694,11 @@
 				GL11.glFogf(GL11.GL_FOG_DENSITY, 2.0F);
 			}
 		} else {
+			float dist = this.farPlaneDistance;
+			dist *= 1.0F - this.mc.thePlayer.getTravelDistance(f);
 			GL11.glFogi(GL11.GL_FOG_MODE, GL11.GL_LINEAR);
-			GL11.glFogf(GL11.GL_FOG_START, this.farPlaneDistance / 4.0F);
-			GL11.glFogf(GL11.GL_FOG_END, this.farPlaneDistance);
+			GL11.glFogf(GL11.GL_FOG_START, dist / 4.0F);
+			GL11.glFogf(GL11.GL_FOG_END, dist);
 		}
 
 		GL11.glEnable(GL11.GL_COLOR_MATERIAL);
--- /dev/null
+++ net/minecraft/game/level/block/BlockIce.java
@@ -1,0 +1,44 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.EnumSkyBlock;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+import java.util.Random;
+
+public class BlockIce extends BlockBreakable {
+	public BlockIce(int var1, int var2) {
+		super(var1, var2, Material.ice, false);
+		this.setTickOnLoad(true);
+	}
+
+	public int getRenderBlockPass() {
+		return 1;
+	}
+
+	public boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
+		return super.shouldSideBeRendered(var1, var2, var3, var4, 1 - var5);
+	}
+
+	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
+		Material var5 = var1.getBlockMaterial(var2, var3 - 1, var4);
+		if(var5.getIsSolid() || var5.getIsLiquid()) {
+			var1.setBlockWithNotify(var2, var3, var4, Block.waterMoving.blockID);
+			var1.scheduleBlockUpdate(var2, var3, var4, Block.waterMoving.blockID);
+		}
+
+	}
+
+	public int quantityDropped(Random var1) {
+		return 0;
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		if(var1.getSavedLightValue(EnumSkyBlock.Block, var2, var3, var4) > 11 - Block.lightOpacity[this.blockID]) {
+			this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+			var1.setBlockWithNotify(var2, var3, var4, Block.waterMoving.blockID);
+			var1.scheduleBlockUpdate(var2, var3, var4, Block.waterMoving.blockID);
+		}
+
+	}
+}
--- net/minecraft/client/render/entity/RenderItem.java
+++ net/minecraft/client/render/entity/RenderItem.java
@@ -139,9 +139,6 @@
 			GL11.glRotatef(var6, 0.0F, 1.0F, 0.0F);
 			this.loadTexture("/terrain.png");
 			var2 = 0.25F;
-			if(!Block.blocksList[var7.itemID].renderAsNormalBlock() && var7.itemID != Block.stairSingle.blockID) {
-				var2 = 0.5F;
-			}
 
 			GL11.glScalef(var2, var2, var2);
 
--- net/minecraft/client/gui/GuiButton.java
+++ net/minecraft/client/gui/GuiButton.java
@@ -4,50 +4,69 @@
 import org.lwjgl.opengl.GL11;
 
 public class GuiButton extends Gui {
-	private int width;
-	private int height;
-	private int xPosition;
-	private int yPosition;
+	protected int width;
+	protected int height;
+	protected int xPosition;
+	protected int yPosition;
 	public String displayString;
 	public int id;
 	public boolean enabled;
 	public boolean visible;
+	public int bg;
 
 	public GuiButton(int var1, int var2, int var3, String var4) {
 		this(var1, var2, var3, 200, 20, var4);
 	}
 
-	protected GuiButton(int var1, int var2, int var3, int var4, int var5, String var6) {
-		this.width = 200;
-		this.height = 20;
+	public GuiButton(int var1, int var2, int var3, int var4, int var5, String var6) {
 		this.enabled = true;
 		this.visible = true;
 		this.id = var1;
 		this.xPosition = var2;
 		this.yPosition = var3;
 		this.width = var4;
-		this.height = 20;
+		this.height = var5;
 		this.displayString = var6;
 	}
 
-	public final void drawButton(Minecraft var1, int var2, int var3) {
+	public GuiButton withBg(int bg) {
+		this.bg = bg;
+		return this;
+	}
+
+	protected byte getHoverState(boolean var1) {
+		byte var2 = 1;
+		if(!this.enabled) {
+			var2 = 0;
+		} else if(var1) {
+			var2 = 2;
+		}
+
+		return var2;
+	}
+
+	public void drawButton(Minecraft var1, int var2, int var3) {
 		if(this.visible) {
 			FontRenderer var4 = var1.fontRenderer;
-			GL11.glBindTexture(GL11.GL_TEXTURE_2D, var1.renderEngine.getTexture("/gui/gui.png"));
-			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-			byte var5 = 1;
-			boolean var6 = var2 >= this.xPosition && var3 >= this.yPosition && var2 < this.xPosition + this.width && var3 < this.yPosition + this.height;
-			if(!this.enabled) {
-				var5 = 0;
-			} else if(var6) {
-				var5 = 2;
-			}
-
-			this.drawTexturedModalRect(this.xPosition, this.yPosition, 0, 46 + var5 * 20, this.width / 2, this.height);
-			this.drawTexturedModalRect(this.xPosition + this.width / 2, this.yPosition, 200 - this.width / 2, 46 + var5 * 20, this.width / 2, this.height);
+			boolean var5 = var2 >= this.xPosition && var3 >= this.yPosition && var2 < this.xPosition + this.width && var3 < this.yPosition + this.height;
+			byte var6 = this.getHoverState(var5);
+			if (this.bg != 2) {
+				if (this.bg == 1 || var1.theWorld == null) {
+					GL11.glEnable(GL11.GL_BLEND);
+					GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+				}
+				GL11.glBindTexture(GL11.GL_TEXTURE_2D, var1.renderEngine.getTexture(var1.theWorld == null || this.bg == 1 ? "/gui/guimenu.png" : "/gui/gui.png"));
+				GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+				this.drawTexturedModalRect(this.xPosition, this.yPosition, 0, 46 + var6 * 20, this.width / 2, this.height);
+				this.drawTexturedModalRect(this.xPosition + this.width / 2, this.yPosition, 200 - this.width / 2, 46 + var6 * 20, this.width / 2, this.height);
+			}
+			if (var1.theWorld != null) {
+				GL11.glDisable(GL11.GL_BLEND);
+			}
+			this.mouseDragged(var1, var2, var3);
 			if(!this.enabled) {
 				drawCenteredString(var4, this.displayString, this.xPosition + this.width / 2, this.yPosition + (this.height - 8) / 2, -6250336);
-			} else if(var6) {
+			} else if(var5) {
 				drawCenteredString(var4, this.displayString, this.xPosition + this.width / 2, this.yPosition + (this.height - 8) / 2, 16777120);
 			} else {
 				drawCenteredString(var4, this.displayString, this.xPosition + this.width / 2, this.yPosition + (this.height - 8) / 2, 14737632);
@@ -55,7 +74,13 @@
 		}
 	}
 
-	public final boolean mousePressed(int var1, int var2) {
+	public boolean mousePressed(int var1, int var2) {
 		return this.enabled && var1 >= this.xPosition && var2 >= this.yPosition && var1 < this.xPosition + this.width && var2 < this.yPosition + this.height;
+	}
+
+	public void mouseReleased(int var1, int var2) {
+	}
+
+	protected void mouseDragged(Minecraft var1, int var2, int var3) {
 	}
 }
--- net/minecraft/game/item/ItemAxe.java
+++ net/minecraft/game/item/ItemAxe.java
@@ -3,7 +3,7 @@
 import net.minecraft.game.level.block.Block;
 
 public final class ItemAxe extends ItemTool {
-	private static Block[] blocksEffectiveAgainst = new Block[]{Block.planks, Block.bookShelf, Block.wood, Block.crate};
+	private static Block[] blocksEffectiveAgainst = new Block[]{Block.planks, Block.bookShelf, Block.wood, Block.crate, Block.workbench, Block.woodStairDouble, Block.woodStairSingle};
 
 	public ItemAxe(int var1, int var2) {
 		super(var1, 3, var2, blocksEffectiveAgainst);
--- net/minecraft/game/level/block/BlockTNT.java
+++ net/minecraft/game/level/block/BlockTNT.java
@@ -1,6 +1,7 @@
 package net.minecraft.game.level.block;
 
 import java.util.Random;
+
 import net.minecraft.game.entity.misc.EntityTNTPrimed;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.material.Material;
@@ -28,5 +29,10 @@
 		EntityTNTPrimed var6 = new EntityTNTPrimed(var1, (float)var2 + 0.5F, (float)var3 + 0.5F, (float)var4 + 0.5F);
 		var1.spawnEntityInWorld(var6);
 		var1.playSoundAtEntity(var6, "random.fuse", 1.0F, 1.0F);
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+		world.setBlockWithNotify(x, y, z, 0);
+		this.onBlockDestroyedByPlayer(world, x, y, z, 0);
 	}
 }
--- net/minecraft/game/level/block/BlockGravel.java
+++ net/minecraft/game/level/block/BlockGravel.java
@@ -8,6 +8,10 @@
 		super(13, 19);
 	}
 
+	public int tickRate() {
+		return 2;
+	}
+
 	public final int idDropped(int var1, Random var2) {
 		return var2.nextInt(10) == 0 ? Item.flint.shiftedIndex : this.blockID;
 	}
--- net/minecraft/game/level/World.java
+++ net/minecraft/game/level/World.java
@@ -1,18 +1,14 @@
 package net.minecraft.game.level;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.TreeSet;
+import java.util.*;
+
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.EntityLiving;
-import net.minecraft.game.level.block.Block;
-import net.minecraft.game.level.block.BlockContainer;
+import net.minecraft.game.level.block.*;
 import net.minecraft.game.level.block.tileentity.TileEntity;
+import net.minecraft.game.level.generator.LevelStructure;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.LevelType;
 import net.minecraft.game.level.material.Material;
 import net.minecraft.game.level.path.Pathfinder;
 import net.minecraft.game.physics.AxisAlignedBB;
@@ -22,11 +18,17 @@
 
 public final class World {
 	private static float[] lightBrightnessTable = new float[16];
+	private static int lightingUpdatesScheduled = 0;
+	private List lightingToUpdate = new ArrayList();
+	public LevelType levelType;
+	public LevelTheme levelTheme;
+	public LevelStructure levelStructure;
 	public int width;
 	public int length;
 	public int height;
 	public byte[] blocks;
 	public byte[] data;
+	public byte[] light;
 	public String name;
 	public String authorName;
 	public long createTime;
@@ -40,6 +42,8 @@
 	public Map map = new HashMap();
 	private List list = new ArrayList();
 	int[] heightMap;
+	private int minHeight;
+	private int lightingUpdatesCounter;
 	public Random random = new Random();
 	private Random rand = new Random();
 	private int randId = this.random.nextInt();
@@ -53,6 +57,7 @@
 	private int updateLCG = 0;
 	private int playTime = 0;
 	public EntityLiving playerEntity;
+	public int renderDistance;
 	public boolean survivalWorld = true;
 	public int skyBrightness = 15;
 	public int skylightSubtracted = 15;
@@ -70,9 +75,6 @@
 			throw new RuntimeException("The level is corrupt!");
 		} else {
 			this.worldAccesses = new ArrayList();
-			this.heightMap = new int[this.width * this.length];
-			Arrays.fill(this.heightMap, this.height);
-			this.lightUpdates.updateSkylight(0, 0, this.width, this.length);
 			this.random = new Random();
 			this.randId = this.random.nextInt();
 			this.tickList = new ArrayList();
@@ -83,10 +85,10 @@
 		}
 	}
 
-	public final void generate(int var1, int var2, int var3, byte[] var4, byte[] var5) {
-		if(var5 != null && var5.length == 0) {
-			var5 = null;
-		}
+	public final void generate(int var1, int var2, int var3, byte[] var4, byte[] var5, byte[] var5a, int[] var5b) {
+		if(var5 != null && var5.length == 0) var5 = null;
+		if(var5a != null && var5a.length == 0) var5a = null;
+		if(var5b != null && var5b.length == 0) var5b = null;
 
 		this.width = var1;
 		this.length = var3;
@@ -104,13 +106,18 @@
 					} else if(var7 < this.groundLevel - 1) {
 						var8 = Block.bedrock.blockID;
 					} else if(var7 < this.groundLevel) {
-						if(this.groundLevel > this.waterLevel && this.defaultFluid == Block.waterMoving.blockID) {
+						var8 = this.levelTheme.getSoilBlock().blockID;
+						if(var8 == Block.dirt.blockID && this.groundLevel > this.waterLevel && this.defaultFluid == Block.waterMoving.blockID) {
 							var8 = Block.grass.blockID;
-						} else {
-							var8 = Block.dirt.blockID;
 						}
 					} else if(var7 < this.waterLevel) {
-						var8 = this.defaultFluid;
+						if (var7 == this.waterLevel - 1 && this.levelTheme.hasSnow()) {
+							var8 = Block.ice.blockID;
+						} else {
+							var8 = this.defaultFluid;
+						}
+					} else if(var7 < this.groundLevel + 1 && this.levelTheme.hasSnow()) {
+						var8 = Block.snow.blockID;
 					}
 
 					var4[(var7 * this.length + var6) * this.width + var2] = (byte)var8;
@@ -121,41 +128,28 @@
 			}
 		}
 
-		this.heightMap = new int[var1 * var3];
-		Arrays.fill(this.heightMap, this.height);
-		if(var5 == null) {
+		if (var5 == null) {
 			this.data = new byte[var4.length];
-			this.lightUpdates = new Light(this);
-			boolean var10 = true;
-			World var11 = this;
-			var2 = this.skylightSubtracted;
-
-			for(var3 = 0; var3 < var11.width; ++var3) {
-				for(int var12 = 0; var12 < var11.length; ++var12) {
-					int var13;
-					for(var13 = var11.height - 1; var13 > 0 && Block.lightOpacity[var11.getBlockId(var3, var13, var12)] == 0; --var13) {
-					}
-
-					var11.heightMap[var3 + var12 * var11.width] = var13 + 1;
-
-					for(var13 = 0; var13 < var11.height; ++var13) {
-						var6 = (var13 * var11.length + var12) * var11.width + var3;
-						var7 = var11.heightMap[var3 + var12 * var11.width];
-						var7 = var13 >= var7 ? var2 : 0;
-						byte var14 = var11.blocks[var6];
-						if(var7 < Block.lightValue[var14]) {
-							var7 = Block.lightValue[var14];
-						}
-
-						var11.data[var6] = (byte)((var11.data[var6] & 240) + var7);
-					}
-				}
-			}
-
-			var11.lightUpdates.updateBlockLight(0, 0, 0, var11.width, var11.height, var11.length);
 		} else {
 			this.data = var5;
-			this.lightUpdates = new Light(this);
+		}
+
+		if (var5a == null) {
+			this.light = new byte[var4.length];
+		} else {
+			this.light = var5a;
+		}
+
+		if (var5b == null) {
+			this.heightMap = new int[var1 * var3];
+			Arrays.fill(this.heightMap, this.height);
+			this.initLighting();
+		} else {
+			this.heightMap = var5b;
+		}
+
+		if (var5a != null) {
+			this.lightingToUpdate.clear();
 		}
 
 		for(var2 = 0; var2 < this.worldAccesses.size(); ++var2) {
@@ -163,13 +157,12 @@
 		}
 
 		this.tickList.clear();
-		this.findSpawn();
+		this.findSpawn(new Random());
 		this.load();
 		System.gc();
 	}
 
-	public final void findSpawn() {
-		Random var1 = new Random();
+	public final void findSpawn(Random var1) {
 		int var2 = 0;
 
 		while(true) {
@@ -186,7 +179,7 @@
 						var5 = this.getFirstUncoveredBlock(var3, var4) + 1;
 						if(var2 == 1000000) {
 							this.xSpawn = var3;
-							this.ySpawn = this.height + 100;
+							this.ySpawn = var5;
 							this.zSpawn = var4;
 							this.rotSpawn = 180.0F;
 							return;
@@ -267,12 +260,12 @@
 					Block var11 = Block.blocksList[this.getBlockId(var3, var9, var10)];
 					AxisAlignedBB var12;
 					if(var11 != null) {
-						var12 = var11.getCollisionBoundingBoxFromPool(var3, var9, var10);
+						var12 = var11.getCollisionBoundingBoxFromPool(this, var3, var9, var10);
 						if(var12 != null && var1.intersectsWith(var12)) {
 							var2.add(var12);
 						}
 					} else if(this.groundLevel < 0 && (var9 < this.groundLevel || var9 < this.waterLevel)) {
-						var12 = Block.bedrock.getCollisionBoundingBoxFromPool(var3, var9, var10);
+						var12 = Block.bedrock.getCollisionBoundingBoxFromPool(this, var3, var9, var10);
 						if(var12 != null && var1.intersectsWith(var12)) {
 							var2.add(var12);
 						}
@@ -286,9 +279,13 @@
 
 	public final void swap(int var1, int var2, int var3, int var4, int var5, int var6) {
 		int var7 = this.getBlockId(var1, var2, var3);
+		int var7a = this.getBlockMetadata(var1, var2, var3);
 		int var8 = this.getBlockId(var4, var5, var6);
-		this.setBlock(var1, var2, var3, var8);
-		this.setBlock(var4, var5, var6, var7);
+		int var8a = this.getBlockMetadata(var4, var5, var6);
+		this.setBlock(var1, var2, var3, 0);
+		this.setBlock(var4, var5, var6, 0);
+		this.setBlockAndMetadata(var1, var2, var3, var8, var8a);
+		this.setBlockAndMetadata(var4, var5, var6, var7, var7a);
 		this.notifyBlocksOfNeighborChange(var1, var2, var3, var8);
 		this.notifyBlocksOfNeighborChange(var4, var5, var6, var7);
 	}
@@ -298,6 +295,7 @@
 			if(var4 == this.blocks[(var2 * this.length + var3) * this.width + var1]) {
 				return false;
 			} else {
+				int var7 = this.getHeightValue(var1, var3);
 				if(var4 == 0 && (var1 == 0 || var3 == 0 || var1 == this.width - 1 || var3 == this.length - 1) && var2 >= this.groundLevel && var2 < this.waterLevel) {
 					var4 = Block.waterMoving.blockID;
 				}
@@ -309,15 +307,22 @@
 					Block.blocksList[var5].onBlockRemoval(this, var1, var2, var3);
 				}
 
+				if (Block.lightOpacity[var4] != 0) {
+					if (var2 >= var7) {
+						this.relightBlock(var1, var2 + 1, var3);
+					}
+				} else if (var2 == var7 - 1) {
+					this.relightBlock(var1, var2, var3);
+				}
+
+				this.scheduleLightingUpdate(EnumSkyBlock.Sky, var1, var2, var3, var1, var2, var3);
+				this.scheduleLightingUpdate(EnumSkyBlock.Block, var1, var2, var3, var1, var2, var3);
+				this.updateSkylight_do(var1, var3);
+
 				if(var4 != 0) {
 					Block.blocksList[var4].onBlockAdded(this, var1, var2, var3);
 				}
 
-				if(Block.lightOpacity[var5] != Block.lightOpacity[var4] || Block.lightValue[var5] != 0 || Block.lightValue[var4] != 0) {
-					this.lightUpdates.updateSkylight(var1, var3, 1, 1);
-					this.lightUpdates.updateBlockLight(var1, var2, var3, var1 + 1, var2 + 1, var3 + 1);
-				}
-
 				for(var4 = 0; var4 < this.worldAccesses.size(); ++var4) {
 					((IWorldAccess)this.worldAccesses.get(var4)).markBlockAndNeighborsNeedsUpdate(var1, var2, var3);
 				}
@@ -338,13 +343,27 @@
 		}
 	}
 
+	public final void setBlockAndMetadata(int var1, int var2, int var3, int var4, int var5) {
+		this.setBlock(var1, var2, var3, var4);
+		this.setBlockMetadata(var1, var2, var3, var5);
+	}
+
+	public final boolean setBlockAndMetadataWithNotify(int var1, int var2, int var3, int var4, int var5) {
+		boolean notify = this.setBlock(var1, var2, var3, var4);
+		this.setBlockMetadata(var1, var2, var3, var5);
+		if (notify) {
+			this.notifyBlocksOfNeighborChange(var1, var2, var3, var4);
+		}
+		return notify;
+	}
+
 	public final void notifyBlocksOfNeighborChange(int var1, int var2, int var3, int var4) {
-		this.notifyBlockOfNeighborChange(var1 - 1, var2, var3, var4);
-		this.notifyBlockOfNeighborChange(var1 + 1, var2, var3, var4);
-		this.notifyBlockOfNeighborChange(var1, var2 - 1, var3, var4);
-		this.notifyBlockOfNeighborChange(var1, var2 + 1, var3, var4);
-		this.notifyBlockOfNeighborChange(var1, var2, var3 - 1, var4);
-		this.notifyBlockOfNeighborChange(var1, var2, var3 + 1, var4);
+		this.notifyBlockOfNeighborChange(var1 - 1, var2, var3, 5);
+		this.notifyBlockOfNeighborChange(var1 + 1, var2, var3, 4);
+		this.notifyBlockOfNeighborChange(var1, var2 - 1, var3, 1);
+		this.notifyBlockOfNeighborChange(var1, var2 + 1, var3, 0);
+		this.notifyBlockOfNeighborChange(var1, var2, var3 - 1, 3);
+		this.notifyBlockOfNeighborChange(var1, var2, var3 + 1, 2);
 	}
 
 	public final boolean setTileNoUpdate(int var1, int var2, int var3, int var4) {
@@ -353,7 +372,6 @@
 				return false;
 			} else {
 				this.blocks[(var2 * this.length + var3) * this.width + var1] = (byte)var4;
-				this.lightUpdates.updateBlockLight(var1, var2, var3, var1 + 1, var2 + 1, var3 + 1);
 				return true;
 			}
 		} else {
@@ -399,7 +417,10 @@
 	}
 
 	public final void updateEntities() {
-		this.entityMap.updateEntities();
+		int x = MathHelper.floor_double(this.playerEntity.posX);
+		int y = MathHelper.floor_double(this.playerEntity.posY);
+		int z = MathHelper.floor_double(this.playerEntity.posZ);
+		this.entityMap.updateEntities(x, y, z, 256, this.playerEntity);
 
 		for(int var1 = 0; var1 < this.list.size(); ++var1) {
 			TileEntity var2 = (TileEntity)this.list.get(var1);
@@ -409,7 +430,235 @@
 	}
 
 	public final void updateLighting() {
-		this.lightUpdates.updateLight();
+		updatingLighting();
+	}
+
+	public final void scheduleLightingUpdate(EnumSkyBlock var1, int var2, int var3, int var4, int var5, int var6, int var7) {
+		++lightingUpdatesScheduled;
+
+		try {
+			if(lightingUpdatesScheduled == 50) {
+				return;
+			}
+
+			int var9 = (var5 + var2) / 2;
+			int var10 = (var7 + var4) / 2;
+
+			int var11 = this.lightingToUpdate.size();
+			int var12;
+			var12 = 5;
+			if(var12 > var11) {
+				var12 = var11;
+			}
+
+			for(int var13 = 0; var13 < var12; ++var13) {
+				MetadataChunkBlock var14 = (MetadataChunkBlock)this.lightingToUpdate.get(this.lightingToUpdate.size() - var13 - 1);
+				if(var14.skyBlock == var1 && var14.getLightUpdated(var2, var3, var4, var5, var6, var7)) {
+					return;
+				}
+			}
+
+			this.lightingToUpdate.add(new MetadataChunkBlock(var1, var2, var3, var4, var5, var6, var7));
+			var12 = 1000000;
+			if(this.lightingToUpdate.size() > 1000000) {
+//				System.out.println("More than " + var12 + " updates, aborting lighting updates");
+//				this.lightingToUpdate.clear();
+			}
+		} finally {
+			--lightingUpdatesScheduled;
+		}
+
+	}
+
+	public void initLighting() {
+		Arrays.fill(this.heightMap, 0);
+		int minHeight = this.height - 1;
+		this.lightingToUpdate.clear();
+
+		for (int x = 0; x < this.width; x++) {
+			for (int z = 0; z < this.length; z++) {
+				this.setHeightValue(x, z, this.height - 1);
+				this.relightBlock(x, this.height - 1, z);
+				minHeight = Math.min(this.minHeight, this.getHeightValue(x, z));
+			}
+		}
+
+		this.minHeight = minHeight;
+
+		for (int x = 0; x < this.width; x++) {
+			for (int z = 0; z < this.length; z++) {
+				this.updateSkylight_do(x, z);
+			}
+		}
+	}
+
+	public int getHeightValue(int var1, int var2) {
+		return this.heightMap[var1 + var2 * this.width];
+	}
+
+	public void setHeightValue(int var1, int var2, int var3) {
+		this.heightMap[var1 + var2 * this.width] = var3;
+	}
+
+	private void updateSkylight_do(int var1, int var2) {
+		if (var1 < 0 || var1 >= this.width || var2 < 0 || var2 >= this.length) return;
+
+		int var3 = this.getHeightValue(var1, var2);
+		this.checkSkylightNeighborHeight(var1 - 1, var2, var3);
+		this.checkSkylightNeighborHeight(var1 + 1, var2, var3);
+		this.checkSkylightNeighborHeight(var1, var2 - 1, var3);
+		this.checkSkylightNeighborHeight(var1, var2 + 1, var3);
+	}
+
+	private void checkSkylightNeighborHeight(int var1, int var2, int var3) {
+		if (var1 < 0 || var1 >= this.width || var2 < 0 || var2 >= this.length || var3 < 0 || var3 >= this.height) return;
+
+		int var4 = this.getHeightValue(var1, var2);
+		if(var4 > var3) {
+			this.scheduleLightingUpdate(EnumSkyBlock.Sky, var1, var3, var2, var1, var4, var2);
+		} else if(var4 < var3) {
+			this.scheduleLightingUpdate(EnumSkyBlock.Sky, var1, var4, var2, var1, var3, var2);
+		}
+	}
+
+	private void relightBlock(int var1, int var2, int var3) {
+		int var4 = this.getHeightValue(var1, var3);
+		int var5 = var4;
+		if(var2 > var4) {
+			var5 = var2;
+		}
+
+		while(var5 > 0 && Block.lightOpacity[this.getBlockId(var1, var5 - 1, var3)] == 0) {
+			var5--;
+		}
+
+		if(var5 != var4) {
+			int dirtyMin = var5;
+			int dirtyMax = var4;
+			if (dirtyMin > dirtyMax) {
+				int dirtySwap = dirtyMax;
+				dirtyMax = dirtyMin;
+				dirtyMin = dirtySwap;
+			}
+
+			for(int j = 0; j < this.worldAccesses.size(); ++j) {
+				((IWorldAccess)this.worldAccesses.get(j)).markBlockRangeNeedsUpdate(var1, dirtyMin, var3, var1, dirtyMax, var3);
+			}
+
+			this.setHeightValue(var1, var3, var5);
+			int var7;
+			int var8;
+			int var9;
+			if(var5 < this.minHeight) {
+				this.minHeight = var5;
+			} else {
+				var7 = this.height - 1;
+
+				for(var8 = 0; var8 < 16; ++var8) {
+					for(var9 = 0; var9 < 16; ++var9) {
+						if(this.getHeightValue(var8, var9) < var7) {
+							var7 = getHeightValue(var8, var9);
+						}
+					}
+				}
+
+				this.minHeight = var7;
+			}
+
+			var7 = var1;
+			var8 = var3;
+			if(var5 < var4) {
+				for(var9 = var5; var9 < var4; ++var9) {
+					this.setSavedLightValue(EnumSkyBlock.Sky, var1, var9, var3, 15);
+				}
+			} else {
+				this.scheduleLightingUpdate(EnumSkyBlock.Sky, var7, var4, var8, var7, var5, var8);
+
+				for(var9 = var4; var9 < var5; ++var9) {
+					this.setSavedLightValue(EnumSkyBlock.Sky, var1, var9, var3, 0);
+				}
+			}
+
+			var9 = 15;
+
+			int var10;
+			for(var10 = var5; var5 > 0 && var9 > 0; this.setSavedLightValue(EnumSkyBlock.Sky, var1, var5, var3, var9)) {
+				--var5;
+				int var11 = Block.lightOpacity[this.getBlockId(var1, var5, var3)];
+				if(var11 == 0) {
+					var11 = 1;
+				}
+
+				var9 -= var11;
+				if(var9 < 0) {
+					var9 = 0;
+				}
+			}
+
+			while(var5 > 0 && Block.lightOpacity[this.getBlockId(var1, var5 - 1, var3)] == 0) {
+				--var5;
+			}
+
+			if(var5 != var10) {
+				if (var5 > var10) {
+					int swap = var5;
+					var5 = var10;
+					var10 = swap;
+				}
+
+				if (var5 > dirtyMin) {
+					var5 = dirtyMin;
+				}
+
+				if (var10 < dirtyMax) {
+					var10 = dirtyMax;
+				}
+
+				this.scheduleLightingUpdate(EnumSkyBlock.Sky, var7 - 1, var5, var8 - 1, var7 + 1, var10, var8 + 1);
+			}
+		}
+	}
+
+	public final boolean updatingLighting() {
+		if(this.lightingUpdatesCounter >= 50) {
+			return false;
+		}
+		++this.lightingUpdatesCounter;
+
+		int var1 = 500;
+
+		while(!this.lightingToUpdate.isEmpty()) {
+			--var1;
+			if(var1 <= 0) {
+				--this.lightingUpdatesCounter;
+				return true;
+			}
+
+			((MetadataChunkBlock)this.lightingToUpdate.remove(this.lightingToUpdate.size() - 1)).updateLight(this);
+		}
+
+		--this.lightingUpdatesCounter;
+		return false;
+	}
+
+	public final void neighborLightPropagationChanged(EnumSkyBlock var1, int var2, int var3, int var4, int var5) {
+		if(var2 >= 0 && var2 < this.width && var3 >= 0 && var3 < this.height && var4 >= 0 && var4 < this.length) {
+			if(var1 == EnumSkyBlock.Sky) {
+				if(this.canBlockSeeTheSky(var2, var3, var4)) {
+					var5 = 15;
+				}
+			} else if(var1 == EnumSkyBlock.Block) {
+				int var6 = this.getBlockId(var2, var3, var4);
+				if(Block.lightValue[var6] > var5) {
+					var5 = Block.lightValue[var6];
+				}
+			}
+
+			if(this.getSavedLightValue(var1, var2, var3, var4) != var5) {
+				this.scheduleLightingUpdate(var1, var2, var3, var4, var2, var3, var4);
+			}
+
+		}
 	}
 
 	public final float getStarBrightness(float var1) {
@@ -497,7 +746,7 @@
 
 	public final int getSkyBrightness() {
 		float var1 = this.getCelestialAngle(1.0F);
-		var1 = MathHelper.cos(var1 * (float)Math.PI * 2.0F) * 1.5F + 0.5F;
+		var1 = MathHelper.cos(var1 * (float)Math.PI * 2.0F) * 2.0F + 0.5F;
 		if(var1 < 0.0F) {
 			var1 = 0.0F;
 		}
@@ -525,12 +774,8 @@
 		}
 
 		int var1 = this.getSkyBrightness();
-		if(this.skylightSubtracted > var1) {
-			this.updateChunkLight(this.skylightSubtracted - 1);
-		}
-
-		if(this.skylightSubtracted < var1) {
-			this.updateChunkLight(this.skylightSubtracted + 1);
+		if(this.skylightSubtracted != var1) {
+			this.updateChunkLight(var1);
 		}
 
 		++this.playTime;
@@ -548,9 +793,9 @@
 		int var4 = this.width - 1;
 		int var5 = this.height - 1;
 		int var6 = this.tickList.size();
-		if(var6 > 200) {
-			var6 = 200;
-		}
+//		if(var6 > 1000) {
+//			var6 = 1000;
+//		}
 
 		int var7;
 		int var10;
@@ -572,20 +817,44 @@
 			}
 		}
 
-		this.updateLCG += this.width * this.length * this.height;
-		var6 = this.updateLCG / 200;
-		this.updateLCG -= var6 * 200;
+		this.updateLCG += Math.min(this.width * this.length * this.height, 16777216);
+		var6 = this.updateLCG / 500;
+		this.updateLCG -= var6 * 500;
 
 		for(var7 = 0; var7 < var6; ++var7) {
 			this.randId = this.randId * 3 + 1013904223;
 			int var13 = this.randId >> 2;
-			int var14 = var13 & var4;
-			var10 = var13 >> var1 & var3;
-			var13 = var13 >> var1 + var2 & var5;
+			int var14 = Math.floorMod(var13, this.width);
+			var10 = Math.floorMod(var13 / this.width, this.length);
+			var13 = Math.floorMod(var13 / this.width / this.length, this.height);
 			byte var15 = this.blocks[(var13 * this.length + var10) * this.width + var14];
 			if(Block.tickOnLoad[var15]) {
 				Block.blocksList[var15].updateTick(this, var14, var13, var10, this.random);
 			}
+
+			if(this.levelTheme.hasSnow() && this.rand.nextInt(4) == 0) {
+				this.randId = this.randId * 3 + 1013904223;
+				var6 = this.randId >> 2;
+				int var7a = Math.floorMod(var13, this.width);
+				int var8 = Math.floorMod(var13 / this.width, this.length);
+				int var9 = this.height - 1;
+				Block b;
+				while (var9 > 0 && ((b = Block.blocksList[this.getBlockId(var7a, var9 - 1, var8)]) == null
+						|| (!b.material.getIsSolid() && !b.material.getIsLiquid()))) {
+					var9--;
+				}
+
+				if(var9 >= 0 && var9 < this.height && this.getSavedLightValue(EnumSkyBlock.Block, var7a, var9, var8) < 10) {
+					var10 = this.getBlockId(var7a, var9 - 1, var8);
+					if(this.getBlockId(var7a, var9, var8) == 0 && Block.snow.canPlaceBlockAt(this, var7a, var9, var8)) {
+						this.setBlockWithNotify(var7a, var9, var8, Block.snow.blockID);
+					}
+
+					if(var10 == Block.waterStill.blockID && this.getBlockMetadata(var7a, var9 - 1, var8) == 0) {
+						this.setBlockWithNotify(var7a, var9 - 1, var8, Block.ice.blockID);
+					}
+				}
+			}
 		}
 
 	}
@@ -690,35 +959,48 @@
 		return false;
 	}
 
-	public final boolean handleMaterialAcceleration(AxisAlignedBB var1, Material var2) {
+	public final boolean handleMaterialAcceleration(AxisAlignedBB var1, Material var2, Entity var2a) {
 		int var3 = (int)var1.minX;
 		int var4 = (int)var1.maxX + 1;
 		int var5 = (int)var1.minY;
 		int var6 = (int)var1.maxY + 1;
 		int var7 = (int)var1.minZ;
 		int var11 = (int)var1.maxZ + 1;
+		boolean var9a = false;
+		Vec3D var10 = new Vec3D(0.0F, 0.0F, 0.0F);
 
 		for(var3 = var3; var3 < var4; ++var3) {
 			for(int var8 = var5; var8 < var6; ++var8) {
 				for(int var9 = var7; var9 < var11; ++var9) {
-					Block var10 = Block.blocksList[this.getBlockId(var3, var8, var9)];
-					if(var10 != null && var10.material == var2) {
-						return true;
+					Block var10a = Block.blocksList[this.getBlockId(var3, var8, var9)];
+					if(var10a != null && var10a.material == var2) {
+						float var16 = (float)(var8 + 1) - BlockFluid.getFluidHeightPercent(this.getBlockMetadata(var3, var8, var9));
+						if(var6 >= var16) {
+							var9a = true;
+							var10a.velocityToAddToEntity(this, var3, var8, var9, var10);
+						}
 					}
 				}
 			}
 		}
 
-		return false;
+		if(var10.xCoord * var10.xCoord + var10.yCoord * var10.yCoord + var10.zCoord * var10.yCoord > 0.0F) {
+			var10 = var10.normalize();
+			var2a.motionX += var10.xCoord * 0.004F;
+			var2a.motionY += var10.yCoord * 0.004F;
+			var2a.motionZ += var10.zCoord * 0.004F;
+		}
+
+		return var9a;
 	}
 
 	public final void scheduleBlockUpdate(int var1, int var2, int var3, int var4) {
+		this.scheduleBlockUpdate(var1, var2, var3, var4, var4 > 0 ? Block.blocksList[var4].tickRate() : 0);
+	}
+
+	public final void scheduleBlockUpdate(int var1, int var2, int var3, int var4, int var4a) {
 		NextTickListEntry var5 = new NextTickListEntry(var1, var2, var3, var4);
-		if(var4 > 0) {
-			var3 = Block.blocksList[var4].tickRate();
-			var5.scheduledTime = var3;
-		}
-
+		var5.scheduledTime = var4a;
 		this.tickList.add(var5);
 	}
 
@@ -790,7 +1072,60 @@
 			var3 = this.length - 1;
 		}
 
-		return this.blocks[(var2 * this.length + var3) * this.width + var1] == Block.stairSingle.blockID ? (var2 < this.height - 1 ? (byte)(this.data[((var2 + 1) * this.length + var3) * this.width + var1] & 15) : 15) : (byte)(this.data[(var2 * this.length + var3) * this.width + var1] & 15);
+		if (Block.blocksList[this.getBlockId(var1, var2, var3)] instanceof BlockStep) {
+			if (var2 < this.height - 1) {
+				var2 += 1;
+			} else {
+				return (byte)(15 - this.skylightSubtracted);
+			}
+		}
+
+		return (byte)Math.max(this.getSavedLightValue(EnumSkyBlock.Sky, var1, var2, var3) - (15 - this.skylightSubtracted), this.getSavedLightValue(EnumSkyBlock.Block, var1, var2, var3));
+	}
+
+	public final int getSavedLightValue(EnumSkyBlock var1, int var2, int var3, int var4) {
+		if(var2 < 0) {
+			var2 = 0;
+		} else if(var2 >= this.width) {
+			var2 = this.width - 1;
+		}
+
+		if(var3 < 0) {
+			var3 = 0;
+		} else if(var3 >= this.height) {
+			var3 = this.height - 1;
+		}
+
+		if(var4 < 0) {
+			var4 = 0;
+		} else if(var4 >= this.length) {
+			var4 = this.length - 1;
+		}
+
+		byte light = this.light[(var3 * this.length + var4) * this.width + var2];
+		if (var1 == EnumSkyBlock.Sky) {
+			light >>>= 4;
+		}
+
+		return light & 15;
+	}
+
+	public final void setSavedLightValue(EnumSkyBlock var1, int var2, int var3, int var4, int value) {
+		int i = (var3 * this.length + var4) * this.width + var2;
+		byte light = this.light[i];
+		if (var1 == EnumSkyBlock.Sky) {
+			light &= (byte) 15;
+			light |= (byte) (value << 4);
+		} else {
+			light &= (byte) 240;
+			light |= (byte) (value & 15);
+		}
+
+		this.light[i] = light;
+
+		for(int var7 = 0; var7 < this.worldAccesses.size(); ++var7) {
+			((IWorldAccess)this.worldAccesses.get(var7)).markBlockAndNeighborsNeedsUpdate(var2, var3, var4);
+		}
 	}
 
 	public final byte getBlockMetadata(int var1, int var2, int var3) {
@@ -812,7 +1147,7 @@
 			var3 = this.length - 1;
 		}
 
-		return (byte)(this.data[(var2 * this.length + var3) * this.width + var1] >>> 4 & 15);
+		return this.data[(var2 * this.length + var3) * this.width + var1];
 	}
 
 	public final void setBlockMetadata(int var1, int var2, int var3, int var4) {
@@ -834,7 +1169,7 @@
 			var3 = this.length - 1;
 		}
 
-		this.data[(var2 * this.length + var3) * this.width + var1] = (byte)((this.data[(var2 * this.length + var3) * this.width + var1] & 15) + (var4 << 4));
+		this.data[(var2 * this.length + var3) * this.width + var1] = (byte)var4;
 
 		for(var4 = 0; var4 < this.worldAccesses.size(); ++var4) {
 			((IWorldAccess)this.worldAccesses.get(var4)).markBlockAndNeighborsNeedsUpdate(var1, var2, var3);
@@ -853,6 +1188,10 @@
 	}
 
 	public final MovingObjectPosition rayTraceBlocks(Vec3D var1, Vec3D var2) {
+		return this.rayTraceBlocks(var1, var2, false);
+	}
+
+	public final MovingObjectPosition rayTraceBlocks(Vec3D var1, Vec3D var2, boolean var2a) {
 		if(!Float.isNaN(var1.xCoord) && !Float.isNaN(var1.yCoord) && !Float.isNaN(var1.zCoord)) {
 			if(!Float.isNaN(var2.xCoord) && !Float.isNaN(var2.yCoord) && !Float.isNaN(var2.zCoord)) {
 				int var3 = MathHelper.floor_float(var2.xCoord);
@@ -971,7 +1310,7 @@
 
 					int var21 = this.getBlockId(var6, var7, var8);
 					Block var23 = Block.blocksList[var21];
-					if(var21 > 0 && var23.isCollidable()) {
+					if(var21 > 0 && (var23.isCollidable() || var2a && var23 instanceof BlockFluid && this.getBlockMetadata(var6, var7, var8) == 0)) {
 						MovingObjectPosition var22 = var23.collisionRayTrace(this, var6, var7, var8, var1, var2);
 						if(var22 != null) {
 							return var22;
@@ -989,75 +1328,7 @@
 	}
 
 	public final boolean growTrees(int var1, int var2, int var3) {
-		int var4 = this.random.nextInt(3) + 4;
-		boolean var5 = true;
-		if(var2 > 0 && var2 + var4 + 1 <= this.height) {
-			int var6;
-			int var8;
-			int var9;
-			int var10;
-			for(var6 = var2; var6 <= var2 + 1 + var4; ++var6) {
-				byte var7 = 1;
-				if(var6 == var2) {
-					var7 = 0;
-				}
-
-				if(var6 >= var2 + 1 + var4 - 2) {
-					var7 = 2;
-				}
-
-				for(var8 = var1 - var7; var8 <= var1 + var7 && var5; ++var8) {
-					for(var9 = var3 - var7; var9 <= var3 + var7 && var5; ++var9) {
-						if(var8 >= 0 && var6 >= 0 && var9 >= 0 && var8 < this.width && var6 < this.height && var9 < this.length) {
-							var10 = this.blocks[(var6 * this.length + var9) * this.width + var8] & 255;
-							if(var10 != 0) {
-								var5 = false;
-							}
-						} else {
-							var5 = false;
-						}
-					}
-				}
-			}
-
-			if(!var5) {
-				return false;
-			} else {
-				var6 = this.blocks[((var2 - 1) * this.length + var3) * this.width + var1] & 255;
-				if((var6 == Block.grass.blockID || var6 == Block.dirt.blockID) && var2 < this.height - var4 - 1) {
-					this.setBlockWithNotify(var1, var2 - 1, var3, Block.dirt.blockID);
-
-					int var13;
-					for(var13 = var2 - 3 + var4; var13 <= var2 + var4; ++var13) {
-						var8 = var13 - (var2 + var4);
-						var9 = 1 - var8 / 2;
-
-						for(var10 = var1 - var9; var10 <= var1 + var9; ++var10) {
-							int var12 = var10 - var1;
-
-							for(var6 = var3 - var9; var6 <= var3 + var9; ++var6) {
-								int var11 = var6 - var3;
-								if((Math.abs(var12) != var9 || Math.abs(var11) != var9 || this.random.nextInt(2) != 0 && var8 != 0) && !Block.opaqueCubeLookup[this.getBlockId(var10, var13, var6)]) {
-									this.setBlockWithNotify(var10, var13, var6, Block.leaves.blockID);
-								}
-							}
-						}
-					}
-
-					for(var13 = 0; var13 < var4; ++var13) {
-						if(!Block.opaqueCubeLookup[this.getBlockId(var1, var2 + var13, var3)]) {
-							this.setBlockWithNotify(var1, var2 + var13, var3, Block.wood.blockID);
-						}
-					}
-
-					return true;
-				} else {
-					return false;
-				}
-			}
-		} else {
-			return false;
-		}
+		return this.levelTheme.getTreeType(this.random).generate(this, this.random, var1, var2, var3);
 	}
 
 	public final Entity getPlayerEntity() {
@@ -1587,7 +1858,11 @@
 	}
 
 	public final String debugSkylightUpdates() {
-		return "" + this.tickList.size() + ". L: " + this.lightUpdates.debugLightUpdates();
+		return "" + this.tickList.size() + ". L: " + this.lightingToUpdate.size();
+	}
+
+	public final int getLightingQueue() {
+		return this.lightingToUpdate.size();
 	}
 
 	public final void setLevel() {
@@ -1602,22 +1877,124 @@
 	}
 
 	private void updateChunkLight(int var1) {
-		this.lightUpdates.updateDaylightCycle(var1);
+		this.skylightSubtracted = var1;
+		for(int var5 = 0; var5 < this.worldAccesses.size(); ++var5) {
+			((IWorldAccess)this.worldAccesses.get(var5)).updateAllRenderers();
+		}
 	}
 
 	public final boolean canBlockSeeTheSky(int var1, int var2, int var3) {
-		if(this.heightMap[var1 + var3 * this.width] <= var2) {
-			return true;
-		} else {
-			while(var2 < this.height) {
-				if(Block.opaqueCubeLookup[this.getBlockId(var1, var2, var3)]) {
-					return false;
-				}
-
-				++var2;
-			}
-
-			return true;
+		return var2 >= this.getHeightValue(var1, var3);
+	}
+
+	public final void markBlocksDirty(int var1, int var2, int var3, int var4, int var5, int var6) {
+		for(int var7 = 0; var7 < this.worldAccesses.size(); ++var7) {
+			((IWorldAccess)this.worldAccesses.get(var7)).markBlockRangeNeedsUpdate(var1, var2, var3, var4, var5, var6);
+		}
+
+	}
+
+	public static long powerCoord(int var1, int var2, int var3, int var4) {
+		return (long)((short)var4) << 48 | (long)var1 << 32 | (long)var2 << 16 | (long)var3;
+	}
+
+	public static int powerDir(int x, int y, int z) {
+		int dir = -1;
+		if (y == 0) {
+			if (x == 0) {
+				dir = 3 - ((z + 1) >> 1);
+			} else if (z == 0) {
+				dir = 5 - ((x + 1) >> 1);
+			}
+		} else if (x == 0 && z == 0) {
+			dir = 1 - ((y + 1) >> 1);
+		}
+		return dir;
+	}
+
+	public boolean canPowerTransmit(int x, int y, int z, int xx, int yy, int zz, int dir, boolean gear) {
+		boolean ex = xx == x;
+		boolean ey = yy == y;
+		boolean ez = zz == z;
+		return dir != -1 || gear && this.getBlockId(xx, yy, zz) == Block.cog.blockID &&
+				  (this.isBlockNormalCube(x - 1, y, z) && (!ez || !ey) && xx <= x && !(!ez && !ey)
+				|| this.isBlockNormalCube(x + 1, y, z) && (!ez || !ey) && xx >= x && !(!ez && !ey)
+				|| this.isBlockNormalCube(x, y - 1, z) && (!ex || !ez) && yy <= y && !(!ex && !ez)
+				|| this.isBlockNormalCube(x, y + 1, z) && (!ex || !ez) && yy >= y && !(!ex && !ez)
+				|| this.isBlockNormalCube(x, y, z - 1) && (!ex || !ey) && zz <= z && !(!ex && !ey)
+				|| this.isBlockNormalCube(x, y, z + 1) && (!ex || !ey) && zz >= z && !(!ex && !ey));
+	}
+
+	public void transmitPowerToNeighbors(int x, int y, int z) {
+		Set<Long> poweredBlocks = new HashSet<>();
+		for (int xx = x - 1; xx <= x + 1; xx++) {
+			for (int yy = y - 1; yy <= y + 1; yy++) {
+				for (int zz = z - 1; zz <= z + 1; zz++) {
+					if ((xx != x || yy != y || zz != z)
+							&& (xx == x || yy == y || zz == z)) {
+						int dir = powerDir(xx - x, yy - y, zz - z);
+						if (canPowerTransmit(x, y, z, xx, yy, zz, dir, this.getBlockId(xx, yy, zz) == Block.cog.blockID)) {
+							this.transmitPower(poweredBlocks, xx, yy, zz, dir);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	public void transmitPowerInDirection(int x, int y, int z, int dir) {
+		x += dir == 4 ? -1 : dir == 5 ? 1 : 0;
+		y += dir == 0 ? -1 : dir == 1 ? 1 : 0;
+		z += dir == 2 ? -1 : dir == 3 ? 1 : 0;
+		this.transmitPower(new HashSet<>(), x, y, z, dir);
+	}
+
+	public void transmitPower(Set<Long> poweredBlocks, int startX, int startY, int startZ, int startDir) {
+		Stack<Long> blocksToPower = new Stack<>();
+		blocksToPower.push(powerCoord(startX, startY, startZ, startDir));
+
+		long coordMask = (1L << 16) - 1;
+		long xyzMask = (1L << 48) - 1;
+
+		while (!blocksToPower.isEmpty()) {
+			long coord = blocksToPower.pop();
+			int x = (int)((coord >> 32) & coordMask);
+			int y = (int)((coord >> 16) & coordMask);
+			int z = (int)(coord & coordMask);
+			int dir = (short)((coord >> 48) & coordMask);
+
+			int block = this.getBlockId(x, y, z);
+			if (poweredBlocks.contains(coord & xyzMask)) continue;
+			if (Block.blocksList[block] != null && (Block.blocksList[block].canReceivePower(this, x, y, z, dir) || Block.conductive[block])) {
+				poweredBlocks.add(coord & xyzMask);
+				Block.blocksList[block].onPowerReceived(this, x, y, z, dir);
+			}
+			if (!Block.conductive[block]) continue;
+
+			for (int i = 0; i < 5; i++) {
+				this.spawnParticle("smoke",
+						x + this.random.nextFloat() * 1.5F - 0.25F,
+						y + this.random.nextFloat() * 1.5F - 0.25F,
+						z + this.random.nextFloat() * 1.5F - 0.25F,
+						0.0F, 0.0F, 0.0F);
+			}
+
+			boolean gear = block == Block.cog.blockID;
+
+			for (int xx = x - 1; xx <= x + 1; xx++) {
+				for (int yy = y - 1; yy <= y + 1; yy++) {
+					for (int zz = z - 1; zz <= z + 1; zz++) {
+						if ((xx != x || yy != y || zz != z)
+								&& (xx == x || yy == y || zz == z)) {
+							int pdir = powerDir(xx - x, yy - y, zz - z);
+							if (Block.blocksList[block].conductWithBlock(Block.blocksList[this.getBlockId(xx, yy, zz)])
+									&& canPowerTransmit(x, y, z, xx, yy, zz, pdir, gear)) {
+								blocksToPower.push(powerCoord(xx, yy, zz, pdir));
+							}
+						}
+					}
+				}
+			}
 		}
 	}
 
--- net/minecraft/client/controller/PlayerController.java
+++ net/minecraft/client/controller/PlayerController.java
@@ -38,10 +38,14 @@
 			float var10005 = (var8.soundVolume + 1.0F) / 2.0F;
 			var8 = var5.stepSound;
 			var10000.playSound(var10001, var10002, var10003, var10004, var10005, var8.soundPitch * 0.8F);
-			var5.onBlockDestroyedByPlayer(var4, var1, var2, var3, var6);
+			this.onBlockDestroyed(var1, var2, var3, var4, var5, var6);
 		}
 
 		return var7;
+	}
+
+	public void onBlockDestroyed(int var1, int var2, int var3, World var4, Block var5, int var6) {
+		var5.onBlockDestroyedByPlayer(var4, var1, var2, var3, var6);
 	}
 
 	public void sendBlockRemoving(int var1, int var2, int var3, int var4) {
--- /dev/null
+++ net/minecraft/game/item/ItemBucket.java
@@ -1,0 +1,87 @@
+package net.minecraft.game.item;
+
+import net.minecraft.game.entity.player.EntityPlayer;
+import net.minecraft.game.physics.MovingObjectPosition;
+import net.minecraft.game.physics.Vec3D;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+import util.MathHelper;
+
+public final class ItemBucket extends Item {
+	private int isFull;
+
+	public ItemBucket(int var1, int var2) {
+		super(var1);
+		this.maxStackSize = 1;
+		this.maxDamage = 64;
+		this.isFull = var2;
+	}
+
+	public final ItemStack onItemRightClick(ItemStack var1, World var2, EntityPlayer var3) {
+		float var4 = var3.prevRotationPitch + (var3.rotationPitch - var3.prevRotationPitch);
+		float var5 = var3.prevRotationYaw + (var3.rotationYaw - var3.prevRotationYaw);
+		float var6 = var3.prevPosX + (var3.posX - var3.prevPosX);
+		float var8 = var3.prevPosY + (var3.posY - var3.prevPosY);
+		float var10 = var3.prevPosZ + (var3.posZ - var3.prevPosZ);
+		Vec3D var12 = new Vec3D(var6, var8, var10);
+		float var17 = MathHelper.cos(-var5 * ((float)Math.PI / 180.0F) - (float)Math.PI);
+		var5 = MathHelper.sin(-var5 * ((float)Math.PI / 180.0F) - (float)Math.PI);
+		float var7 = -MathHelper.cos(-var4 * ((float)Math.PI / 180.0F));
+		var4 = MathHelper.sin(-var4 * ((float)Math.PI / 180.0F));
+		var5 *= var7;
+		var17 *= var7;
+		Vec3D var14 = var12.addVector((float)var5 * 5.0F, (float)var4 * 5.0F, (float)var17 * 5.0F);
+		MovingObjectPosition var13 = var2.rayTraceBlocks(var12, var14, this.isFull == 0);
+		if(var13 == null) {
+			return var1;
+		} else {
+			if(var13.typeOfHit == 0) {
+				int var15 = var13.blockX;
+				int var16 = var13.blockY;
+				int var18 = var13.blockZ;
+				if(this.isFull == 0) {
+					if(var2.getBlockMaterial(var15, var16, var18) == Material.water && var2.getBlockMetadata(var15, var16, var18) == 0) {
+						var2.setBlockWithNotify(var15, var16, var18, 0);
+						return new ItemStack(Item.bucketWater);
+					}
+
+					if(var2.getBlockMaterial(var15, var16, var18) == Material.lava && var2.getBlockMetadata(var15, var16, var18) == 0) {
+						var2.setBlockWithNotify(var15, var16, var18, 0);
+						return new ItemStack(Item.bucketLava);
+					}
+				} else {
+					if(var13.sideHit == 0) {
+						--var16;
+					}
+
+					if(var13.sideHit == 1) {
+						++var16;
+					}
+
+					if(var13.sideHit == 2) {
+						--var18;
+					}
+
+					if(var13.sideHit == 3) {
+						++var18;
+					}
+
+					if(var13.sideHit == 4) {
+						--var15;
+					}
+
+					if(var13.sideHit == 5) {
+						++var15;
+					}
+
+					if(var2.getBlockId(var15, var16, var18) == 0 || !var2.getBlockMaterial(var15, var16, var18).isSolid()) {
+						var2.setBlockAndMetadataWithNotify(var15, var16, var18, this.isFull, 0);
+						return new ItemStack(Item.bucketEmpty);
+					}
+				}
+			}
+
+			return var1;
+		}
+	}
+}
--- net/minecraft/client/gui/container/GuiContainer.java
+++ net/minecraft/client/gui/container/GuiContainer.java
@@ -78,8 +78,8 @@
 		GL11.glDisable(GL11.GL_LIGHTING);
 		GL11.glDisable(GL11.GL_DEPTH_TEST);
 		this.drawGuiContainerForegroundLayer();
-		GL11.glEnable(GL11.GL_LIGHTING);
-		GL11.glEnable(GL11.GL_DEPTH_TEST);
+//		GL11.glDisable(GL11.GL_LIGHTING);
+//		GL11.glEnable(GL11.GL_DEPTH_TEST);
 		GL11.glPopMatrix();
 	}
 
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeatureTree.java
@@ -1,0 +1,83 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+
+import java.util.Random;
+
+public class FeatureTree implements Feature {
+	@Override
+	public boolean generate(World world, Random random, int var1, int var2, int var3) {
+		int var4 = random.nextInt(3) + 4;
+		boolean var5 = true;
+		if(var2 > 0 && var2 + var4 + 1 <= world.height
+				&& var1 > 0 && var1 < world.width - 1
+				&& var3 > 0 && var3 < world.length - 1) {
+			int var6;
+			int var8;
+			int var9;
+			int var10;
+			for(var6 = var2; var6 <= var2 + 1 + var4; ++var6) {
+				byte var7 = 1;
+				if(var6 == var2) {
+					var7 = 0;
+				}
+
+				if(var6 >= var2 + 1 + var4 - 2) {
+					var7 = 2;
+				}
+
+				for(var8 = var1 - var7; var8 <= var1 + var7 && var5; ++var8) {
+					for(var9 = var3 - var7; var9 <= var3 + var7 && var5; ++var9) {
+						if(var8 >= 0 && var6 >= 0 && var9 >= 0 && var8 < world.width && var6 < world.height && var9 < world.length) {
+							var10 = world.getBlockId(var8, var6, var9);
+							if(var10 != 0 && var10 != Block.snow.blockID) {
+								var5 = false;
+							}
+						} else {
+							var5 = false;
+						}
+					}
+				}
+			}
+
+			if(!var5) {
+				return false;
+			} else {
+				var6 = world.getBlockId(var1, var2 - 1, var3);
+				if((var6 == Block.grass.blockID || var6 == Block.dirt.blockID) && var2 < world.height - var4 - 1) {
+					world.setBlockWithNotify(var1, var2 - 1, var3, Block.dirt.blockID);
+
+					int var13;
+					for(var13 = var2 - 3 + var4; var13 <= var2 + var4; ++var13) {
+						var8 = var13 - (var2 + var4);
+						var9 = 1 - var8 / 2;
+
+						for(var10 = var1 - var9; var10 <= var1 + var9; ++var10) {
+							int var12 = var10 - var1;
+
+							for(var6 = var3 - var9; var6 <= var3 + var9; ++var6) {
+								int var11 = var6 - var3;
+								if((Math.abs(var12) != var9 || Math.abs(var11) != var9 || random.nextInt(2) != 0 && var8 != 0) && !Block.opaqueCubeLookup[world.getBlockId(var10, var13, var6)]) {
+									world.setBlockWithNotify(var10, var13, var6, Block.leaves.blockID);
+								}
+							}
+						}
+					}
+
+					for(var13 = 0; var13 < var4; ++var13) {
+						if(!Block.opaqueCubeLookup[world.getBlockId(var1, var2 + var13, var3)]) {
+							world.setBlockWithNotify(var1, var2 + var13, var3, Block.wood.blockID);
+						}
+					}
+
+					return true;
+				} else {
+					return false;
+				}
+			}
+		} else {
+			return false;
+		}
+	}
+}
--- net/minecraft/client/ThreadDownloadResources.java
+++ net/minecraft/client/ThreadDownloadResources.java
@@ -1,13 +1,9 @@
 package net.minecraft.client;
 
-import java.io.BufferedReader;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
+import java.io.*;
 import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.StandardCopyOption;
 import java.util.ArrayList;
 
 public final class ThreadDownloadResources extends Thread {
@@ -27,6 +23,8 @@
 
 	public final void run() {
         try {
+			this.loadAllPackedResources();
+
             ArrayList<String> list = new ArrayList<String>();
             URL url = new URL("http://www.minecraft.net/resources/");
             BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(url.openStream()));
@@ -64,13 +62,9 @@
                         int index = s4.indexOf("/");
                         String substring = s4.substring(0, index);
                         String substring2 = s4.substring(index + 1);
-                        if (substring.equalsIgnoreCase("sound")) {
-                            minecraft.sndManager.addSound(substring2, file2);
-                        }
-                        else if (substring.equalsIgnoreCase("newsound")) {
-                            minecraft.sndManager.addSound(substring2, file2);
-                        }
-                        else if (substring.equalsIgnoreCase("music")) {
+                        if (substring.equalsIgnoreCase("sound") || substring.equalsIgnoreCase("newsound")) {
+                            minecraft.sndManager.addSound(substring2, file2);
+                        } else if (substring.equalsIgnoreCase("music") || substring.equalsIgnoreCase("newmusic")) {
                             minecraft.sndManager.addMusic(substring2, file2);
                         }
                     }
@@ -86,6 +80,41 @@
         catch (IOException ex) {
             ex.printStackTrace();
         }
+	}
+
+	private void loadAllPackedResources() throws IOException {
+		try (InputStream resourceListStream = this.getClass().getResourceAsStream("/resources.txt")) {
+			if (resourceListStream == null) {
+				return;
+			}
+
+			try (BufferedReader reader = new BufferedReader(new InputStreamReader(resourceListStream))) {
+				String line;
+				while ((line = reader.readLine()) != null) {
+					loadPackedResource(line, line.replaceFirst("/resources/", ""));
+				}
+			}
+		}
+	}
+
+	private void loadPackedResource(String inPath, String outPath) throws IOException {
+		try (InputStream stream = this.getClass().getResourceAsStream(inPath)) {
+			if (stream == null) {
+				throw new IOException("Resource " + inPath + " is invalid.");
+			}
+
+			File file = new File(this.resourcesFolder, outPath);
+			file.mkdirs();
+			Files.copy(stream, file.toPath(), StandardCopyOption.REPLACE_EXISTING);
+			int index = outPath.indexOf("/");
+            String substring = outPath.substring(0, index);
+            String substring2 = outPath.substring(index + 1);
+			if (substring.equalsIgnoreCase("sound") || substring.equalsIgnoreCase("newsound")) {
+                this.mc.sndManager.addSound(substring2, file);
+            } else if (substring.equalsIgnoreCase("music") || substring.equalsIgnoreCase("newmusic")) {
+                this.mc.sndManager.addMusic(substring2, file);
+            }
+		}
 	}
 
 	private void downloadResource(URL var1, File var2) throws IOException {
--- net/minecraft/client/Timer.java
+++ net/minecraft/client/Timer.java
@@ -51,5 +51,6 @@
 		}
 
 		this.renderPartialTicks = this.elapsedPartialTicks;
+		this.timerSpeed = 1.0F;
 	}
 }
--- net/minecraft/game/level/block/BlockWorkbench.java
+++ net/minecraft/game/level/block/BlockWorkbench.java
@@ -5,7 +5,7 @@
 import net.minecraft.game.level.material.Material;
 
 public final class BlockWorkbench extends Block {
-	protected BlockWorkbench(int var1) {
+	public BlockWorkbench(int var1) {
 		super(58, Material.wood);
 		this.blockIndexInTexture = 59;
 	}
@@ -15,6 +15,7 @@
 	}
 
 	public final boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+		if (!var1.survivalWorld) return false;
 		var5.displayWorkbenchGUI();
 		return true;
 	}
--- net/minecraft/game/level/block/BlockTorch.java
+++ net/minecraft/game/level/block/BlockTorch.java
@@ -8,12 +8,12 @@
 import net.minecraft.game.physics.Vec3D;
 
 public final class BlockTorch extends Block {
-	protected BlockTorch(int var1, int var2) {
+	public BlockTorch(int var1, int var2) {
 		super(50, 80, Material.circuits);
 		this.setTickOnLoad(true);
 	}
 
-	public final AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
+	public final AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
 		return null;
 	}
 
--- /dev/null
+++ net/minecraft/client/gui/GuiWorldDialog.java
@@ -1,0 +1,38 @@
+package net.minecraft.client.gui;
+
+import javax.swing.*;
+import java.awt.*;
+import java.io.File;
+
+final class GuiWorldDialog extends Thread {
+	private GuiLoadWorld screen;
+
+	GuiWorldDialog(GuiLoadWorld var1) {
+		this.screen = var1;
+	}
+
+	public final void run() {
+		try {
+			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
+		} catch (Exception ignored) {
+		}
+
+		try {
+			File var2 = new File(this.screen.mc.mcDataDir, "saves");
+			var2.mkdir();
+			JFileChooser var1 = new JFileChooser(var2);
+
+			var1.setDialogTitle(this.screen.getDialogTitle());
+			var1.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
+			var1.setVisible(true);
+			if(var1.showOpenDialog(this.screen.mc.mcCanvas) == JFileChooser.APPROVE_OPTION) {
+				this.screen.selectFile(var1.getSelectedFile());
+			} else {
+				this.screen.unfreeze();
+			}
+		} catch (Exception e) {
+			this.screen.unfreeze();
+		}
+
+	}
+}
--- net/minecraft/game/level/block/BlockBreakable.java
+++ net/minecraft/game/level/block/BlockBreakable.java
@@ -6,7 +6,7 @@
 public class BlockBreakable extends Block {
 	private boolean localFlag;
 
-	protected BlockBreakable(int var1, int var2, Material var3, boolean var4) {
+	public BlockBreakable(int var1, int var2, Material var3, boolean var4) {
 		super(var1, var2, var3);
 		this.localFlag = var4;
 	}
@@ -15,7 +15,7 @@
 		return false;
 	}
 
-	public final boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
+	public boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
 		int var6 = var1.getBlockId(var2, var3, var4);
 		return !this.localFlag && var6 == this.blockID ? false : super.shouldSideBeRendered(var1, var2, var3, var4, var5);
 	}
--- /dev/null
+++ net/minecraft/game/level/block/BlockLamp.java
@@ -1,0 +1,29 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+import java.util.Random;
+
+public class BlockLamp extends Block {
+	private final int nextState;
+
+	public BlockLamp(int var1, int var2, int var3) {
+		super(var1, var2, Material.glass);
+		this.nextState = var3;
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+		world.setBlockWithNotify(x, y, z, this.nextState);
+
+		int b = 0;
+		while (--y > 0 && (b = world.getBlockId(x, y, z)) == Block.lampInactive.blockID || b == Block.lampActive.blockID);
+		if (b == Block.logicGate.blockID) {
+			world.scheduleBlockUpdate(x, y, z, b);
+		}
+	}
+
+	public int idDropped(int var1, Random var2) {
+		return Block.lampInactive.blockID;
+	}
+}
--- net/minecraft/game/item/recipe/RecipesArmor.java
+++ net/minecraft/game/item/recipe/RecipesArmor.java
@@ -6,7 +6,7 @@
 
 public final class RecipesArmor {
 	private String[][] recipePatterns = new String[][]{{"XXX", "X X"}, {"X X", "XXX", "XXX"}, {"XXX", "X X", "X X"}, {"X X", "X X"}};
-	private Object[][] recipeItems = new Object[][]{{Block.clothGray, Block.fire, Item.ingotIron, Item.diamond, Item.ingotGold}, {Item.helmetLeather, Item.helmetChain, Item.helmetSteel, Item.helmetDiamond, Item.helmetGold}, {Item.plateLeather, Item.plateChain, Item.plateSteel, Item.plateDiamond, Item.plateGold}, {Item.legsLeather, Item.legsChain, Item.legsSteel, Item.legsDiamond, Item.legsGold}, {Item.bootsLeather, Item.bootsChain, Item.bootsSteel, Item.bootsDiamond, Item.bootsGold}};
+	private Object[][] recipeItems = new Object[][]{{Block.clothWhite, Block.fire, Item.ingotIron, Item.diamond, Item.ingotGold}, {Item.helmetLeather, Item.helmetChain, Item.helmetSteel, Item.helmetDiamond, Item.helmetGold}, {Item.plateLeather, Item.plateChain, Item.plateSteel, Item.plateDiamond, Item.plateGold}, {Item.legsLeather, Item.legsChain, Item.legsSteel, Item.legsDiamond, Item.legsGold}, {Item.bootsLeather, Item.bootsChain, Item.bootsSteel, Item.bootsDiamond, Item.bootsGold}};
 
 	public final void addRecipes(CraftingManager var1) {
 		for(int var2 = 0; var2 < this.recipeItems[0].length; ++var2) {
--- net/minecraft/client/player/EntityPlayerSP.java
+++ net/minecraft/client/player/EntityPlayerSP.java
@@ -36,7 +36,18 @@
 	}
 
 	public final void onLivingUpdate() {
+		boolean prevJump = this.movementInput.jump;
 		this.movementInput.updatePlayerMoveState();
+
+		if(!this.worldObj.survivalWorld && this.movementInput.jump && !prevJump) {
+			if(this.flyToggleTimer == 0) {
+				this.flyToggleTimer = 7;
+			} else {
+				this.flying = !this.flying;
+				this.flyToggleTimer = 0;
+			}
+		}
+
 		super.onLivingUpdate();
 	}
 
@@ -91,6 +102,8 @@
 			}
 		}
 
+		this.mc.worldInfo.readFromNBT(var1.getCompoundTag("WorldInfo"));
+
 	}
 
 	protected final String getEntityString() {
@@ -115,5 +128,34 @@
 
 	public final void onItemPickup(Entity var1) {
 		this.mc.effectRenderer.addEffect(new EntityPickupFX(this.mc.theWorld, var1, this, -0.5F));
+	}
+
+	protected boolean flyUp() {
+		return this.movementInput.flyUp;
+	}
+
+	protected boolean flyDown() {
+		return this.movementInput.flyDown;
+	}
+
+	public final float getTravelDistance(float var1) {
+		if (!this.mc.adventureMode) return 0.0F;
+		float d = 12.0F;
+		float o = 1.0F + 8.0F / d;
+		float x = this.lastTickPosX + (this.posX - this.lastTickPosX) * var1;
+		float z = this.lastTickPosZ + (this.posZ - this.lastTickPosZ) * var1;
+		x = Math.abs(x - this.worldObj.width / 2.0F);
+		z = Math.abs(z - this.worldObj.length / 2.0F);
+		x = this.worldObj.width / 2.0F - x;
+		z = this.worldObj.width / 2.0F - z;
+		x /= d;
+		z /= d;
+		x += o;
+		z += o;
+		if (x < 0.0F) x = 0.0F; if (x > 1.0F) x = 1.0F;
+		if (z < 0.0F) z = 0.0F; if (z > 1.0F) z = 1.0F;
+		x = 1.0F - x;
+		z = 1.0F - z;
+		return Math.max(x, z);
 	}
 }
--- net/minecraft/game/level/block/BlockDirt.java
+++ net/minecraft/game/level/block/BlockDirt.java
@@ -3,7 +3,7 @@
 import net.minecraft.game.level.material.Material;
 
 public final class BlockDirt extends Block {
-	protected BlockDirt(int var1, int var2) {
+	public BlockDirt(int var1, int var2) {
 		super(3, 2, Material.ground);
 	}
 }
--- com/mojang/nbt/NBTTagCompound.java
+++ com/mojang/nbt/NBTTagCompound.java
@@ -70,6 +70,10 @@
 		this.tagMap.put(var1, (new NBTTagByteArray(var2)).setKey(var1));
 	}
 
+	public final void setIntArray(String var1, int[] var2) {
+		this.tagMap.put(var1, (new NBTTagIntArray(var2)).setKey(var1));
+	}
+
 	public final void setCompoundTag(String var1, NBTTagCompound var2) {
 		this.tagMap.put(var1, var2.setKey(var1));
 	}
@@ -108,6 +112,10 @@
 
 	public final byte[] getByteArray(String var1) {
 		return !this.tagMap.containsKey(var1) ? new byte[0] : ((NBTTagByteArray)this.tagMap.get(var1)).byteArray;
+	}
+
+	public final int[] getIntArray(String var1) {
+		return !this.tagMap.containsKey(var1) ? new int[0] : ((NBTTagIntArray)this.tagMap.get(var1)).intArray;
 	}
 
 	public final NBTTagCompound getCompoundTag(String var1) {
--- net/minecraft/game/level/block/BlockGears.java
+++ net/minecraft/game/level/block/BlockGears.java
@@ -1,15 +1,24 @@
 package net.minecraft.game.level.block;
 
 import java.util.Random;
+
+import net.minecraft.game.level.World;
 import net.minecraft.game.level.material.Material;
 import net.minecraft.game.physics.AxisAlignedBB;
 
 public final class BlockGears extends Block {
-	protected BlockGears(int var1, int var2) {
+	public BlockGears(int var1, int var2) {
 		super(55, 62, Material.circuits);
 	}
 
-	public final AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
+	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
+		if (!this.canPlaceBlockAt(var1, var2, var3, var4)) {
+			this.dropBlockAsItem(var1, var2, var3, var4, 0);
+			var1.setBlockWithNotify(var2, var3, var4, 0);
+		}
+	}
+
+	public final AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
 		return null;
 	}
 
@@ -30,6 +39,31 @@
 	}
 
 	public final boolean isCollidable() {
-		return false;
+		return true;
+	}
+
+	public boolean isConductive() {
+		return true;
+	}
+
+	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
+		return var1.isBlockNormalCube(var2 - 1, var3, var4)
+				|| var1.isBlockNormalCube(var2 + 1, var3, var4)
+				|| var1.isBlockNormalCube(var2, var3 - 1, var4)
+				|| var1.isBlockNormalCube(var2, var3 + 1, var4)
+				|| var1.isBlockNormalCube(var2, var3, var4 - 1)
+				|| var1.isBlockNormalCube(var2, var3, var4 + 1);
+	}
+
+	private static boolean isFloorOnlyGear(World var1, int var2, int var3, int var4) {
+		return (var1.getBlockId(var2, var3, var4) == Block.cog.blockID
+				&& !var1.isBlockNormalCube(var2 - 1, var3, var4)
+				&& !var1.isBlockNormalCube(var2 + 1, var3, var4)
+				&& !var1.isBlockNormalCube(var2, var3, var4 - 1)
+				&& !var1.isBlockNormalCube(var2, var3, var4 + 1));
+	}
+
+	public static boolean showFloorGear(World world, int x, int y, int z, int offset) {
+		return true;
 	}
 }
--- net/minecraft/game/level/generator/noise/NoiseGeneratorPerlin.java
+++ net/minecraft/game/level/generator/noise/NoiseGeneratorPerlin.java
@@ -42,24 +42,26 @@
 		return ((var0 & 1) == 0 ? var8 : -var8) + ((var0 & 2) == 0 ? var10 : -var10);
 	}
 
-	public final double generateNoise(double var1, double var3) {
-		double var10 = 0.0D;
-		double var8 = var3;
+	public double generateNoise(double var1, double var3) {
+		return this.generateNoise(var1, var3, 0.0D);
+	}
+
+	public double generateNoise(double var1, double var3, double var5) {
 		int var2 = MathHelper.floor_double(var1) & 255;
 		int var21 = MathHelper.floor_double(var3) & 255;
-		int var4 = MathHelper.floor_double(0.0D) & 255;
-		double var6 = var1 - (double)MathHelper.floor_double(var1);
-		var8 -= (double)MathHelper.floor_double(var8);
-		var10 = 0.0D - (double)MathHelper.floor_double(0.0D);
+		int var4 = MathHelper.floor_double(var5) & 255;
+		double var6 = var1 - MathHelper.floor_double(var1);
+		double var8 = var3 - MathHelper.floor_double(var3);
+		double var10 = var5 - MathHelper.floor_double(var5);
 		double var15 = generateNoise(var6);
 		double var17 = generateNoise(var8);
 		double var19 = generateNoise(var10);
-		int var5 = this.permutations[var2] + var21;
-		int var12 = this.permutations[var5] + var4;
-		var5 = this.permutations[var5 + 1] + var4;
+		int var0 = this.permutations[var2] + var21;
+		int var12 = this.permutations[var0] + var4;
+		var0 = this.permutations[var0 + 1] + var4;
 		var2 = this.permutations[var2 + 1] + var21;
 		var21 = this.permutations[var2] + var4;
 		var2 = this.permutations[var2 + 1] + var4;
-		return lerp(var19, lerp(var17, lerp(var15, grad(this.permutations[var12], var6, var8, var10), grad(this.permutations[var21], var6 - 1.0D, var8, var10)), lerp(var15, grad(this.permutations[var5], var6, var8 - 1.0D, var10), grad(this.permutations[var2], var6 - 1.0D, var8 - 1.0D, var10))), lerp(var17, lerp(var15, grad(this.permutations[var12 + 1], var6, var8, var10 - 1.0D), grad(this.permutations[var21 + 1], var6 - 1.0D, var8, var10 - 1.0D)), lerp(var15, grad(this.permutations[var5 + 1], var6, var8 - 1.0D, var10 - 1.0D), grad(this.permutations[var2 + 1], var6 - 1.0D, var8 - 1.0D, var10 - 1.0D))));
+		return lerp(var19, lerp(var17, lerp(var15, grad(this.permutations[var12], var6, var8, var10), grad(this.permutations[var21], var6 - 1.0D, var8, var10)), lerp(var15, grad(this.permutations[var0], var6, var8 - 1.0D, var10), grad(this.permutations[var2], var6 - 1.0D, var8 - 1.0D, var10))), lerp(var17, lerp(var15, grad(this.permutations[var12 + 1], var6, var8, var10 - 1.0D), grad(this.permutations[var21 + 1], var6 - 1.0D, var8, var10 - 1.0D)), lerp(var15, grad(this.permutations[var0 + 1], var6, var8 - 1.0D, var10 - 1.0D), grad(this.permutations[var2 + 1], var6 - 1.0D, var8 - 1.0D, var10 - 1.0D))));
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/block/BlockGrate.java
@@ -1,0 +1,39 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+import net.minecraft.game.physics.AxisAlignedBB;
+
+public class BlockGrate extends Block {
+	public BlockGrate(int var1, int var2, Material var3) {
+		super(var1, var2, var3);
+	}
+
+	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
+		if ((var0.getBlockMetadata(var1, var2, var3) & 1) == 1) {
+			return null;
+		}
+		return super.getCollisionBoundingBoxFromPool(var0, var1, var2, var3);
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
+		return (var2 & 1) == 1 ? this.blockIndexInTexture + 16 : this.blockIndexInTexture;
+	}
+
+	public boolean isOpaqueCube() {
+		return false;
+	}
+
+	public boolean isConductive() {
+		return this.material == Material.iron;
+	}
+
+	public boolean canReceivePower(World var1, int var2, int var3, int var4, int var5) {
+		return this.isConductive();
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+		world.setBlockMetadata(x, y, z, ~world.getBlockMetadata(x, y, z) & 1);
+		world.notifyBlocksOfNeighborChange(x, y, z, this.blockID);
+	}
+}
--- /dev/null
+++ net/minecraft/game/item/recipe/RecipesMechanics.java
@@ -1,0 +1,23 @@
+package net.minecraft.game.item.recipe;
+
+import net.minecraft.game.item.ItemStack;
+import static net.minecraft.game.level.block.Block.*;
+import static net.minecraft.game.item.Item.*;
+
+public class RecipesMechanics {
+	public final void addRecipes(CraftingManager cm) {
+		cm.addRecipe(new ItemStack(wrench), "C C", "C|C", " | ", 'C', ingotIron, '|', ingotCopper);
+		cm.addRecipe(new ItemStack(cog, 16), " X ", "XXX", " X ", 'X', ingotIron);
+		cm.addRecipe(new ItemStack(activator), "###", "#X#", "###", '#', cobblestone, 'X', ingotCopper);
+		cm.addRecipe(new ItemStack(grate, 4), "X X", " X ", "X X", 'X', ingotIron);
+		cm.addRecipe(new ItemStack(observer), "## ", "XXO", "## ", '#', cobblestone, 'X', ingotCopper, 'O', glass);
+		cm.addRecipe(new ItemStack(lampInactive, 4), " O ", "OXO", " O ", 'O', glass, 'X', ingotCopper);
+		cm.addRecipe(new ItemStack(piston), "###", "|C|", "|C|", '#', wood, '|', cobblestone, 'C', ingotCopper);
+		cm.addRecipe(new ItemStack(pistonCopper), "###", "|C|", "|C|", '#', ingotCopper, '|', cobblestone, 'C', ingotCopper);
+		cm.addRecipe(new ItemStack(pistonGold), "###", "|C|", "|C|", '#', ingotGold, '|', cobblestone, 'C', ingotCopper);
+		cm.addRecipe(new ItemStack(diode), " # ", "XOX", " # ", '#', cobblestone, 'X', ingotCopper, 'O', ingotGold);
+		cm.addRecipe(new ItemStack(magneticPlatform, 4), "###", "XXX", "###", '#', cobblestone, 'X', diamond);
+		cm.addRecipe(new ItemStack(woodenGrate, 4), "X X", " X ", "X X", 'X', stick);
+		cm.addRecipe(new ItemStack(logicGate), "#X#", "XOX", "#X#", '#', cobblestone, 'X', ingotCopper, 'O', ingotGold);
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/WorldInfo.java
@@ -1,0 +1,45 @@
+package net.minecraft.game.level;
+
+import com.mojang.nbt.NBTTagCompound;
+import net.minecraft.game.level.generator.LevelStructure;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.LevelType;
+
+public class WorldInfo {
+	public long levelX;
+	public long levelZ;
+	public int levelWidth;
+	public int levelLength;
+	public int levelHeight;
+	public LevelType levelType;
+	public LevelTheme levelTheme;
+	public LevelStructure levelStructure;
+	public int worldTime;
+	public int playerScore;
+	public boolean creative;
+
+	public void readFromNBT(NBTTagCompound nbt) {
+		this.levelX = nbt.getLong("LevelX");
+		this.levelZ = nbt.getLong("LevelZ");
+		this.levelWidth = nbt.getInteger("LevelWidth");
+		this.levelLength = nbt.getInteger("LevelLength");
+		this.levelHeight = nbt.getInteger("LevelHeight");
+		this.levelType = LevelType.fromNameNullable(nbt.getString("LevelType"));
+		this.levelTheme = LevelTheme.fromNameNullable(nbt.getString("LevelTheme"));
+		this.levelStructure = LevelStructure.fromNameNullable(nbt.getString("LevelStructure"));
+		this.worldTime = nbt.getInteger("WorldTime");
+		this.playerScore = nbt.getInteger("PlayerScore");
+		this.creative = nbt.getBoolean("Creative");
+	}
+
+	public void writeToNBT(NBTTagCompound nbt) {
+		nbt.setLong("LevelX", this.levelX);
+		nbt.setLong("LevelZ", this.levelZ);
+		nbt.setInteger("LevelWidth", this.levelWidth);
+		nbt.setInteger("LevelLength", this.levelLength);
+		nbt.setInteger("LevelHeight", this.levelHeight);
+		nbt.setInteger("WorldTime", this.worldTime);
+		nbt.setInteger("PlayerScore", this.playerScore);
+		nbt.setBoolean("Creative", this.creative);
+	}
+}
--- net/minecraft/game/level/LevelLoader.java
+++ net/minecraft/game/level/LevelLoader.java
@@ -21,10 +21,14 @@
 import net.minecraft.game.entity.monster.EntitySkeleton;
 import net.minecraft.game.entity.monster.EntitySpider;
 import net.minecraft.game.entity.monster.EntityZombie;
+import net.minecraft.game.entity.player.EntityPlayer;
 import net.minecraft.game.level.block.Block;
 import net.minecraft.game.level.block.tileentity.TileEntity;
 import net.minecraft.game.level.block.tileentity.TileEntityChest;
 import net.minecraft.game.level.block.tileentity.TileEntityFurnace;
+import net.minecraft.game.level.generator.LevelStructure;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.LevelType;
 import util.IProgressUpdate;
 
 public abstract class LevelLoader {
@@ -63,6 +67,7 @@
 		var9.authorName = var2.getString("Author");
 		var9.name = var2.getString("Name");
 		var9.createTime = var2.getLong("CreatedOn");
+		var9.survivalWorld = !var2.getBoolean("Creative");
 		var9.cloudColor = var4.getInteger("CloudColor");
 		var9.skyColor = var4.getInteger("SkyColor");
 		var9.fogColor = var4.getInteger("FogColor");
@@ -81,7 +86,10 @@
 		var9.defaultFluid = var4.getByte("SurroundingWaterType");
 		var9.worldTime = var4.getShort("TimeOfDay");
 		var9.skylightSubtracted = var9.getSkyBrightness();
-		var9.generate(var6, var8, var7, var3.getByteArray("Blocks"), var3.getByteArray("Data"));
+		var9.levelType = LevelType.fromName(var4.getString("LevelType"));
+		var9.levelTheme = LevelTheme.fromName(var4.getString("LevelTheme"));
+		var9.levelStructure = LevelStructure.fromName(var4.getString("LevelStructure"));
+		var9.generate(var6, var8, var7, var3.getByteArray("Blocks"), var3.getByteArray("Data"), var3.getByteArray("Light"), var3.getIntArray("Heightmap"));
 		if(this.guiLoading != null) {
 			this.guiLoading.displayLoadingString("Preparing entities..");
 		}
@@ -153,12 +161,17 @@
 		var3.setByte("SurroundingGroundType", (byte)Block.grass.blockID);
 		var3.setByte("SurroundingWaterType", (byte)var1.defaultFluid);
 		var3.setShort("TimeOfDay", (short)var1.worldTime);
+		var3.setString("LevelType", var1.levelType.toString());
+		var3.setString("LevelTheme", var1.levelTheme.toString());
+		var3.setString("LevelStructure", var1.levelStructure.toString());
 		NBTTagCompound var4 = new NBTTagCompound();
 		var4.setShort("Width", (short)var1.width);
 		var4.setShort("Length", (short)var1.length);
 		var4.setShort("Height", (short)var1.height);
 		var4.setByteArray("Blocks", var1.blocks);
 		var4.setByteArray("Data", var1.data);
+		var4.setByteArray("Light", var1.light);
+		var4.setIntArray("Heightmap", var1.heightMap);
 		NBTTagList var5 = new NBTTagList();
 		var5.setTag(new NBTTagShort((short)var1.xSpawn));
 		var5.setTag(new NBTTagShort((short)var1.ySpawn));
@@ -168,6 +181,7 @@
 		var15.setString("Author", var1.authorName);
 		var15.setString("Name", var1.name);
 		var15.setLong("CreatedOn", var1.createTime);
+		var15.setBoolean("Creative", !var1.survivalWorld);
 		if(this.guiLoading != null) {
 			this.guiLoading.displayLoadingString("Preparing entities..");
 		}
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeatureTaiga2.java
@@ -1,0 +1,100 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+
+import java.util.Random;
+
+public class FeatureTaiga2 implements Feature {
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		int var6 = var2.nextInt(4) + 6;
+		int var7 = 1 + var2.nextInt(2);
+		int var8 = var6 - var7;
+		int var9 = 2 + var2.nextInt(2);
+		boolean var10 = true;
+		if(var4 >= 1 && var4 + var6 + 1 <= var1.height
+				&& var3 > 0 && var3 < var1.width - 1
+				&& var5 > 0 && var5 < var1.length - 1) {
+			int var11;
+			int var13;
+			int var15;
+			int var21;
+			for(var11 = var4; var11 <= var4 + 1 + var6 && var10; ++var11) {
+				boolean var12 = true;
+				if(var11 - var4 < var7) {
+					var21 = 0;
+				} else {
+					var21 = var9;
+				}
+
+				for(var13 = var3 - var21; var13 <= var3 + var21 && var10; ++var13) {
+					for(int var14 = var5 - var21; var14 <= var5 + var21 && var10; ++var14) {
+						if(var11 >= 0 && var11 < var1.height) {
+							var15 = var1.getBlockId(var13, var11, var14);
+							if(var15 != 0 && var15 != Block.leaves.blockID && var15 != Block.snow.blockID) {
+								var10 = false;
+							}
+						} else {
+							var10 = false;
+						}
+					}
+				}
+			}
+
+			if(!var10) {
+				return false;
+			} else {
+				var11 = var1.getBlockId(var3, var4 - 1, var5);
+				if((var11 == Block.grass.blockID || var11 == Block.dirt.blockID) && var4 < var1.height - var6 - 1) {
+					var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
+					var21 = var2.nextInt(2);
+					var13 = 1;
+					byte var22 = 0;
+
+					int var16;
+					int var17;
+					for(var15 = 0; var15 <= var8; ++var15) {
+						var16 = var4 + var6 - var15;
+
+						for(var17 = var3 - var21; var17 <= var3 + var21; ++var17) {
+							int var18 = var17 - var3;
+
+							for(int var19 = var5 - var21; var19 <= var5 + var21; ++var19) {
+								int var20 = var19 - var5;
+								if((Math.abs(var18) != var21 || Math.abs(var20) != var21 || var21 <= 0) && !Block.opaqueCubeLookup[var1.getBlockId(var17, var16, var19)]) {
+									var1.setBlock(var17, var16, var19, Block.leaves.blockID);
+								}
+							}
+						}
+
+						if(var21 >= var13) {
+							var21 = var22;
+							var22 = 1;
+							++var13;
+							if(var13 > var9) {
+								var13 = var9;
+							}
+						} else {
+							++var21;
+						}
+					}
+
+					var15 = var2.nextInt(3);
+
+					for(var16 = 0; var16 < var6 - var15; ++var16) {
+						var17 = var1.getBlockId(var3, var4 + var16, var5);
+						if(var17 == 0 || var17 == Block.leaves.blockID || var17 == Block.snow.blockID) {
+							var1.setBlock(var3, var4 + var16, var5, Block.wood.blockID);
+						}
+					}
+
+					return true;
+				} else {
+					return false;
+				}
+			}
+		} else {
+			return false;
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/block/BlockMagnetPlatform.java
@@ -1,0 +1,36 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.World;
+
+public class BlockMagnetPlatform extends BlockSand {
+	public BlockMagnetPlatform(int var1, int var2) {
+		super(var1, var2);
+	}
+
+	public int tickRate() {
+		return 6;
+	}
+
+	public int getBlockTextureFromSide(int var1) {
+		return var1 < 2 ? 84 : this.blockIndexInTexture;
+	}
+
+	protected int fallDirection(World var1, int var2, int var3, int var4) {
+		return (var1.getBlockMetadata(var2, var3, var4) & 1) == 0 ? -1 : 1;
+	}
+
+	protected boolean passGrates() {
+		return false;
+	}
+
+	public boolean isConductive() {
+		return true;
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+		int meta = world.getBlockMetadata(x, y, z) & 255;
+		meta ^= 1;
+		world.setBlockMetadata(x, y, z, meta);
+		world.scheduleBlockUpdate(x, y, z, this.blockID);
+	}
+}
--- net/minecraft/game/level/generator/noise/NoiseGenerator.java
+++ net/minecraft/game/level/generator/noise/NoiseGenerator.java
@@ -2,4 +2,14 @@
 
 public abstract class NoiseGenerator {
 	public abstract double generateNoise(double var1, double var3);
+
+	public abstract double generateNoise(double var1, double var3, double var5);
+
+	public double generateNoiseNormalized(double var1, double var3) {
+		return this.generateNoise(var1, var3);
+	}
+
+	public double generateNoiseNormalized(double var1, double var3, double var5) {
+		return this.generateNoise(var1, var3, var5);
+	}
 }
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageRaising.java
@@ -1,0 +1,177 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorDistort;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+
+public final class StageRaising extends TerrainGenStage {
+	private StageRaising(Builder properties) {
+		super("Raising..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			NoiseGenerator minTargetNoise = new NoiseGeneratorDistort(new NoiseGeneratorOctaves(rand, 8), new NoiseGeneratorOctaves(rand, 8));
+			NoiseGenerator maxTargetNoise = new NoiseGeneratorDistort(new NoiseGeneratorOctaves(rand, 8), new NoiseGeneratorOctaves(rand, 8));
+			NoiseGenerator selectorNoise = new NoiseGeneratorOctaves(rand, 6);
+			NoiseGenerator islandOffsetNoise = new NoiseGeneratorOctaves(rand, 2);
+			NoiseGenerator selectionSmoothnessNoise = new NoiseGeneratorOctaves(rand, 8);
+			NoiseGenerator archipelagoNoise = new NoiseGeneratorOctaves(rand, 4);
+
+			for (int x = 0; x < blocks.width; x++) {
+				double centreDistX = Math.abs(((double)x / (blocks.width - 1.0D) - 0.5D) * 2.0D);
+				double centreSmoothX = (Math.abs(x - blocks.width / 2) - blocks.width / 2 + 16) / 16.0D;
+				progressor.accept(x * 100.0F / (float)(blocks.width - 1));
+
+				for (int z = 0; z < blocks.length; z++) {
+					double centreDistZ = Math.abs(((double)z / (blocks.length - 1.0D) - 0.5D) * 2.0D);
+					double centreSmoothZ = (Math.abs(z - blocks.length / 2) - blocks.length / 2 + 16) / 16.0D;
+					double centreSmooth = Math.max(centreSmoothX, centreSmoothZ);
+
+					double height;
+					if (properties.doSelection) {
+						double minTarget = minTargetNoise.generateNoise(x * properties.noiseScale, z * properties.noiseScale) / properties.minDamp + properties.minBoost;
+						double maxTarget = maxTargetNoise.generateNoise(x * properties.noiseScale, z * properties.noiseScale) / properties.maxDamp + properties.maxBoost;
+
+						double selectionSmoothness = properties.selectionSmoothness.getValue(x, z, selectionSmoothnessNoise);
+						double selection = selectorNoise.generateNoise(x * properties.selectorScale, z * properties.selectorScale) / 8.0D;
+
+						double target = selectionSmoothness <= 0.0D
+								? selection > properties.selectionThreshold ? minTarget : maxTarget
+								: maxTarget + (minTarget - maxTarget) * Math.min(Math.max(
+										(selection - properties.selectionThreshold - selectionSmoothness / 2.0D) / selectionSmoothness, 0.0D), 1.0D);
+						height = Math.max(minTarget, target) / 2.0D;
+					} else {
+						height = minTargetNoise.generateNoise(x * properties.noiseScale, z * properties.noiseScale) / properties.minDamp + properties.minBoost;
+					}
+
+					if (centreSmooth > 0.0D && centreSmooth < 1.0D && !properties.island) {
+						height *= 1.0D - centreSmooth;
+					}
+
+					if (properties.island) {
+						double islandDist;
+						if (properties.archipelago) {
+							islandDist = archipelagoNoise.generateNoise(x * 0.1D, z * 0.1D) / 8.0D + 0.75D;
+
+							if (islandDist > 1.0D) {
+								islandDist = 1.0D;
+							}
+
+							if (islandDist < 0.0D) {
+								islandDist = 0.0D;
+							}
+						} else {
+							islandDist = Math.sqrt(centreDistX * centreDistX + centreDistZ * centreDistZ) * 1.2D;
+							double islandOffset = islandOffsetNoise.generateNoise(x * 0.05D, z * 0.05D) / 4.0D + 1.0D;
+							islandDist = Math.min(islandDist, islandOffset);
+							islandDist = Math.max(islandDist, Math.max(centreDistX, centreDistZ));
+							if (islandDist > 1.0D) {
+								islandDist = 1.0D;
+							}
+
+							if (islandDist < 0.0D) {
+								islandDist = 0.0D;
+							}
+
+							islandDist *= islandOffset;
+						}
+						height = height * (1.0D - islandDist) - islandDist * 10.0D + 5.0D;
+						if (height < 0.0D) {
+							height -= height * height * 0.2D;
+						}
+					} else if (height < 0.0D) {
+						height /= properties.underDamp;
+					}
+
+					heightmap.set(x, z, heightmap.get(x, z) + (int)height);
+				}
+			}
+		});
+	}
+
+	public static class Builder {
+		private boolean island;
+		private boolean archipelago;
+		private double noiseScale = 1.3D;
+		private double selectorScale = 1.0D;
+		private double minDamp = 6.0D;
+		private double minBoost = -4.0D;
+		private double maxDamp = 6.0D;
+		private double maxBoost = 6.0D;
+		private double selectionThreshold = 0.0D;
+		private NoiseModifierAccess selectionSmoothness = NoiseModifierAccess.constant(0.0D);
+		private boolean doSelection = true;
+		private double underDamp = 1.25D;
+
+		public Builder island(boolean island) {
+			this.island = island;
+			return this;
+		}
+
+		public Builder archipelago(boolean archipelago) {
+			this.archipelago = archipelago;
+			return this;
+		}
+
+		public Builder noiseScale(double noiseScale) {
+			this.noiseScale = noiseScale;
+			return this;
+		}
+
+		public Builder selectorScale(double selectorScale) {
+			this.selectorScale = selectorScale;
+			return this;
+		}
+
+		public Builder minDamp(double minDamp) {
+			this.minDamp = minDamp;
+			return this;
+		}
+
+		public Builder minBoost(double minBoost) {
+			this.minBoost = minBoost;
+			return this;
+		}
+
+		public Builder maxDamp(double maxDamp) {
+			this.maxDamp = maxDamp;
+			return this;
+		}
+
+		public Builder maxBoost(double maxBoost) {
+			this.maxBoost = maxBoost;
+			return this;
+		}
+
+		public Builder selectionThreshold(double selectionThreshold) {
+			this.selectionThreshold = selectionThreshold;
+			return this;
+		}
+
+		public Builder selectionSmoothness(double selectionSmoothness) {
+			this.selectionSmoothness = NoiseModifierAccess.constant(selectionSmoothness);
+			return this;
+		}
+
+		public Builder selectionSmoothness(NoiseModifierAccess selectionSmoothness) {
+			this.selectionSmoothness = selectionSmoothness;
+			return this;
+		}
+
+		public Builder enableSelection() {
+			this.doSelection = true;
+			return this;
+		}
+
+		public Builder disableSelection() {
+			this.doSelection = false;
+			return this;
+		}
+
+		public Builder underDamp(double underDamp) {
+			this.underDamp = underDamp;
+			return this;
+		}
+
+		public StageRaising build() {
+			return new StageRaising(this);
+		}
+	}
+}
--- net/minecraft/game/entity/player/InventoryPlayer.java
+++ net/minecraft/game/entity/player/InventoryPlayer.java
@@ -14,6 +14,13 @@
 		this.player = var1;
 	}
 
+	public InventoryPlayer(EntityPlayer var1, InventoryPlayer var2) {
+		this.player = var1;
+		this.mainInventory = var2.mainInventory;
+		this.armorInventory = var2.armorInventory;
+		this.currentItem = var2.currentItem;
+	}
+
 	public final ItemStack getCurrentItem() {
 		return this.mainInventory[this.currentItem];
 	}
--- com/mojang/nbt/NBTBase.java
+++ com/mojang/nbt/NBTBase.java
@@ -71,6 +71,8 @@
 			return new NBTTagList();
 		case 10:
 			return new NBTTagCompound();
+		case 11:
+			return new NBTTagIntArray();
 		default:
 			return null;
 		}
--- net/minecraft/game/level/block/BlockCrops.java
+++ net/minecraft/game/level/block/BlockCrops.java
@@ -7,7 +7,7 @@
 import net.minecraft.game.level.World;
 
 public final class BlockCrops extends BlockFlower {
-	protected BlockCrops(int var1, int var2) {
+	public BlockCrops(int var1, int var2) {
 		super(59, 88);
 		this.blockIndexInTexture = 88;
 		this.setTickOnLoad(true);
--- net/minecraft/client/render/RenderBlocks.java
+++ net/minecraft/client/render/RenderBlocks.java
@@ -2,6 +2,7 @@
 
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.block.BlockGears;
 import net.minecraft.game.level.material.Material;
 import org.lwjgl.opengl.GL11;
 
@@ -31,6 +32,7 @@
 
 	public final boolean renderBlockByRenderType(Block var1, int var2, int var3, int var4) {
 		int var5 = var1.getRenderType();
+		var1.setBoundsForRender(this.blockAccess, var2, var3, var4);
 		Tessellator var6;
 		float var10;
 		boolean var26;
@@ -423,6 +425,20 @@
 							var6.addVertexWithUV((float)(var3 + 1) - 0.05F, (float)var4 - 2.0F / 16.0F, (float)var5 - 2.0F / 16.0F, var10, var20);
 						}
 
+						if(this.blockAccess.isBlockNormalCube(var3, var4 - 1, var5) && BlockGears.showFloorGear(this.blockAccess, var3, var4, var5, -1)) {
+							var6.addVertexWithUV((float)var3 - 2.0F / 16.0F, (float)var4 + 0.05F, (float)(var5 + 1) + 2.0F / 16.0F, var11, var22);
+							var6.addVertexWithUV((float)(var3 + 1) + 2.0F / 16.0F, (float)var4 + 0.05F, (float)(var5 + 1) + 2.0F / 16.0F, var11, var20);
+							var6.addVertexWithUV((float)(var3 + 1) + 2.0F / 16.0F, (float)var4 + 0.05F, (float)var5 - 2.0F / 16.0F, var10, var20);
+							var6.addVertexWithUV((float)var3 - 2.0F / 16.0F, (float)var4 + 0.05F, (float)var5 - 2.0F / 16.0F, var10, var22);
+						}
+
+						if(this.blockAccess.isBlockNormalCube(var3, var4 + 1, var5) && BlockGears.showFloorGear(this.blockAccess, var3, var4, var5, 1)) {
+							var6.addVertexWithUV((float)(var3 + 1) + 2.0F / 16.0F, (float)(var4 + 1) - 0.05F, (float)(var5 + 1) + 2.0F / 16.0F, var10, var22);
+							var6.addVertexWithUV((float)var3 - 2.0F / 16.0F, (float)(var4 + 1) - 0.05F, (float)(var5 + 1) + 2.0F / 16.0F, var10, var20);
+							var6.addVertexWithUV((float)var3 - 2.0F / 16.0F, (float)(var4 + 1) - 0.05F, (float)var5 - 2.0F / 16.0F, var11, var20);
+							var6.addVertexWithUV((float)(var3 + 1) + 2.0F / 16.0F, (float)(var4 + 1) - 0.05F, (float)var5 - 2.0F / 16.0F, var11, var22);
+						}
+
 						if(this.blockAccess.isBlockNormalCube(var3, var4, var5 - 1)) {
 							var6.addVertexWithUV((float)(var3 + 1) + 2.0F / 16.0F, (float)var4 - 2.0F / 16.0F, (float)var5 + 0.05F, var13, var15);
 							var6.addVertexWithUV((float)(var3 + 1) + 2.0F / 16.0F, (float)(var4 + 1) + 2.0F / 16.0F, (float)var5 + 0.05F, var13, var14);
@@ -758,6 +774,7 @@
 	public final void renderBlockOnInventory(Block var1) {
 		Tessellator var2 = Tessellator.instance;
 		int var3 = var1.getRenderType();
+		var1.resetBlockBounds();
 		if(var3 == 0) {
 			GL11.glTranslatef(-0.5F, -0.5F, -0.5F);
 			var2.startDrawingQuads();
--- net/minecraft/game/item/Item.java
+++ net/minecraft/game/item/Item.java
@@ -7,6 +7,7 @@
 
 public class Item {
 	protected static Random rand = new Random();
+
 	public static Item[] itemsList = new Item[1024];
 	public static Item shovel;
 	public static Item pickaxeSteel;
@@ -73,12 +74,34 @@
 	public static Item porkRaw;
 	public static Item porkCooked;
 	public static Item painting;
+	public static Item snowball = (new Item(66)).setIconIndex(56);
+	public static Item dyeRed = (new Item(67)).setIconIndex(240);
+	public static Item dyeOrange = (new Item(68)).setIconIndex(241);
+	public static Item dyeYellow = (new Item(69)).setIconIndex(242);
+	public static Item dyeChartreuse = (new Item(70)).setIconIndex(243);
+	public static Item dyeGreen = (new Item(71)).setIconIndex(244);
+	public static Item dyeSpringGreen = (new Item(72)).setIconIndex(245);
+	public static Item dyeCyan = (new Item(73)).setIconIndex(246);
+	public static Item dyeCapri = (new Item(74)).setIconIndex(247);
+	public static Item dyeUltramarine = (new Item(75)).setIconIndex(248);
+	public static Item dyeViolet = (new Item(76)).setIconIndex(249);
+	public static Item dyePurple = (new Item(77)).setIconIndex(250);
+	public static Item dyeMagenta = (new Item(78)).setIconIndex(251);
+	public static Item dyeRose = (new Item(79)).setIconIndex(252);
+	public static Item dyeDarkGray = (new Item(80)).setIconIndex(253);
+	public static Item dyeGray = (new Item(81)).setIconIndex(254);
+	public static Item dyeWhite = (new Item(82)).setIconIndex(255);
+	public static Item ingotCopper = (new Item(83)).setIconIndex(22);
+	public static Item bucketEmpty = (new ItemBucket(84, 0)).setIconIndex(57);
+	public static Item bucketWater = (new ItemBucket(85, Block.waterMoving.blockID)).setIconIndex(73);
+	public static Item bucketLava = (new ItemBucket(86, Block.lavaMoving.blockID)).setIconIndex(89);
+	public static Item wrench = (new ItemWrench(87)).setIconIndex(54);
 	public final int shiftedIndex;
 	protected int maxStackSize = 64;
 	protected int maxDamage = 32;
 	protected int iconIndex;
 
-	protected Item(int var1) {
+	public Item(int var1) {
 		this.shiftedIndex = var1 + 256;
 		if(itemsList[var1 + 256] != null) {
 			System.out.println("CONFLICT @ " + var1);
@@ -136,325 +159,390 @@
 		ItemSpade var0 = var10000;
 		var0.iconIndex = var1;
 		shovel = var0;
+
 		ItemPickaxe var15 = new ItemPickaxe(1, 2);
 		var1 = 98;
 		ItemPickaxe var2 = var15;
 		var2.iconIndex = var1;
 		pickaxeSteel = var2;
+
 		ItemAxe var16 = new ItemAxe(2, 2);
 		var1 = 114;
 		ItemAxe var3 = var16;
 		var3.iconIndex = var1;
 		axeSteel = var3;
+
 		ItemFlintAndSteel var17 = new ItemFlintAndSteel(3);
 		var1 = 5;
 		ItemFlintAndSteel var4 = var17;
 		var4.iconIndex = var1;
 		striker = var4;
+
 		ItemFood var18 = new ItemFood(4, 4);
 		var1 = 4;
 		ItemFood var5 = var18;
 		var5.iconIndex = var1;
+
 		ItemBow var19 = new ItemBow(5);
 		var1 = 21;
 		ItemBow var6 = var19;
 		var6.iconIndex = var1;
 		bow = var6;
+
 		Item var20 = new Item(6);
 		var1 = 37;
 		Item var7 = var20;
 		var7.iconIndex = var1;
 		arrow = var7;
+
 		var20 = new Item(7);
 		var1 = 7;
 		var7 = var20;
 		var7.iconIndex = var1;
 		coal = var7;
+
 		var20 = new Item(8);
 		var1 = 55;
 		var7 = var20;
 		var7.iconIndex = var1;
 		diamond = var7;
+
 		var20 = new Item(9);
 		var1 = 23;
 		var7 = var20;
 		var7.iconIndex = var1;
 		ingotIron = var7;
+
 		var20 = new Item(10);
 		var1 = 39;
 		var7 = var20;
 		var7.iconIndex = var1;
 		ingotGold = var7;
+
 		ItemSword var21 = new ItemSword(11, 2);
 		var1 = 66;
 		ItemSword var8 = var21;
 		var8.iconIndex = var1;
 		swordSteel = var8;
+
 		var21 = new ItemSword(12, 0);
 		var1 = 64;
 		var8 = var21;
 		var8.iconIndex = var1;
 		swordWood = var8;
+
 		var10000 = new ItemSpade(13, 0);
 		var1 = 80;
 		var0 = var10000;
 		var0.iconIndex = var1;
 		shovelWood = var0;
+
 		var15 = new ItemPickaxe(14, 0);
 		var1 = 96;
 		var2 = var15;
 		var2.iconIndex = var1;
 		pickaxeWood = var2;
+
 		var16 = new ItemAxe(15, 0);
 		var1 = 112;
 		var3 = var16;
 		var3.iconIndex = var1;
 		axeWood = var3;
+
 		var21 = new ItemSword(16, 1);
 		var1 = 65;
 		var8 = var21;
 		var8.iconIndex = var1;
 		swordStone = var8;
+
 		var10000 = new ItemSpade(17, 1);
 		var1 = 81;
 		var0 = var10000;
 		var0.iconIndex = var1;
 		shovelStone = var0;
+
 		var15 = new ItemPickaxe(18, 1);
 		var1 = 97;
 		var2 = var15;
 		var2.iconIndex = var1;
 		pickaxeStone = var2;
+
 		var16 = new ItemAxe(19, 1);
 		var1 = 113;
 		var3 = var16;
 		var3.iconIndex = var1;
 		axeStone = var3;
+
 		var21 = new ItemSword(20, 3);
 		var1 = 67;
 		var8 = var21;
 		var8.iconIndex = var1;
 		swordDiamond = var8;
+
 		var10000 = new ItemSpade(21, 3);
 		var1 = 83;
 		var0 = var10000;
 		var0.iconIndex = var1;
 		shovelDiamond = var0;
+
 		var15 = new ItemPickaxe(22, 3);
 		var1 = 99;
 		var2 = var15;
 		var2.iconIndex = var1;
 		pickaxeDiamond = var2;
+
 		var16 = new ItemAxe(23, 3);
 		var1 = 115;
 		var3 = var16;
 		var3.iconIndex = var1;
 		axeDiamond = var3;
+
 		var20 = new Item(24);
 		var1 = 53;
 		var7 = var20;
 		var7.iconIndex = var1;
 		stick = var7;
+
 		var20 = new Item(25);
 		var1 = 71;
 		var7 = var20;
 		var7.iconIndex = var1;
 		bowlEmpty = var7;
+
 		ItemSoup var22 = new ItemSoup(26, 10);
 		var1 = 72;
 		ItemSoup var9 = var22;
 		var9.iconIndex = var1;
 		bowlSoup = var9;
-		var21 = new ItemSword(27, 0);
+
+		var21 = new ItemSword(27, 2);
 		var1 = 68;
 		var8 = var21;
 		var8.iconIndex = var1;
 		swordGold = var8;
-		var10000 = new ItemSpade(28, 0);
+
+		var10000 = new ItemSpade(28, 2);
 		var1 = 84;
 		var0 = var10000;
 		var0.iconIndex = var1;
 		shovelGold = var0;
-		var15 = new ItemPickaxe(29, 0);
+
+		var15 = new ItemPickaxe(29, 2);
 		var1 = 100;
 		var2 = var15;
 		var2.iconIndex = var1;
 		pickaxeGold = var2;
-		var16 = new ItemAxe(30, 0);
+
+		var16 = new ItemAxe(30, 2);
 		var1 = 116;
 		var3 = var16;
 		var3.iconIndex = var1;
 		axeGold = var3;
+
 		var20 = new Item(31);
 		var1 = 8;
 		var7 = var20;
 		var7.iconIndex = var1;
 		silk = var7;
+
 		var20 = new Item(32);
 		var1 = 24;
 		var7 = var20;
 		var7.iconIndex = var1;
 		feather = var7;
+
 		var20 = new Item(33);
 		var1 = 40;
 		var7 = var20;
 		var7.iconIndex = var1;
 		gunpowder = var7;
+
 		ItemHoe var23 = new ItemHoe(34, 0);
 		short var11 = 128;
 		ItemHoe var10 = var23;
 		var10.iconIndex = var11;
 		hoeWood = var10;
+
 		var23 = new ItemHoe(35, 1);
 		var11 = 129;
 		var10 = var23;
 		var10.iconIndex = var11;
 		hoeStone = var10;
+
 		var23 = new ItemHoe(36, 2);
 		var11 = 130;
 		var10 = var23;
 		var10.iconIndex = var11;
 		hoeSteel = var10;
+
 		var23 = new ItemHoe(37, 3);
 		var11 = 131;
 		var10 = var23;
 		var10.iconIndex = var11;
 		hoeDiamond = var10;
+
 		var23 = new ItemHoe(38, 4);
 		var11 = 132;
 		var10 = var23;
 		var10.iconIndex = var11;
 		hoeGold = var10;
+
 		ItemSeeds var24 = new ItemSeeds(39, Block.crops.blockID);
 		var1 = 9;
 		ItemSeeds var12 = var24;
 		var12.iconIndex = var1;
 		seeds = var12;
+
 		var20 = new Item(40);
 		var1 = 25;
 		var7 = var20;
 		var7.iconIndex = var1;
 		wheat = var7;
+
 		var18 = new ItemFood(41, 5);
 		var1 = 41;
 		var5 = var18;
 		var5.iconIndex = var1;
 		bread = var5;
+
 		ItemArmor var25 = new ItemArmor(42, 0, 0, 0);
 		var1 = 0;
 		ItemArmor var13 = var25;
 		var13.iconIndex = var1;
 		helmetLeather = var13;
+
 		var25 = new ItemArmor(43, 0, 0, 1);
 		var1 = 16;
 		var13 = var25;
 		var13.iconIndex = var1;
 		plateLeather = var13;
+
 		var25 = new ItemArmor(44, 0, 0, 2);
 		var1 = 32;
 		var13 = var25;
 		var13.iconIndex = var1;
 		legsLeather = var13;
+
 		var25 = new ItemArmor(45, 0, 0, 3);
 		var1 = 48;
 		var13 = var25;
 		var13.iconIndex = var1;
 		bootsLeather = var13;
+
 		var25 = new ItemArmor(46, 1, 1, 0);
 		var1 = 1;
 		var13 = var25;
 		var13.iconIndex = var1;
 		helmetChain = var13;
+
 		var25 = new ItemArmor(47, 1, 1, 1);
 		var1 = 17;
 		var13 = var25;
 		var13.iconIndex = var1;
 		plateChain = var13;
+
 		var25 = new ItemArmor(48, 1, 1, 2);
 		var1 = 33;
 		var13 = var25;
 		var13.iconIndex = var1;
 		legsChain = var13;
+
 		var25 = new ItemArmor(49, 1, 1, 3);
 		var1 = 49;
 		var13 = var25;
 		var13.iconIndex = var1;
 		bootsChain = var13;
+
 		var25 = new ItemArmor(50, 2, 2, 0);
 		var1 = 2;
 		var13 = var25;
 		var13.iconIndex = var1;
 		helmetSteel = var13;
+
 		var25 = new ItemArmor(51, 2, 2, 1);
 		var1 = 18;
 		var13 = var25;
 		var13.iconIndex = var1;
 		plateSteel = var13;
+
 		var25 = new ItemArmor(52, 2, 2, 2);
 		var1 = 34;
 		var13 = var25;
 		var13.iconIndex = var1;
 		legsSteel = var13;
+
 		var25 = new ItemArmor(53, 2, 2, 3);
 		var1 = 50;
 		var13 = var25;
 		var13.iconIndex = var1;
 		bootsSteel = var13;
+
 		var25 = new ItemArmor(54, 3, 3, 0);
 		var1 = 3;
 		var13 = var25;
 		var13.iconIndex = var1;
 		helmetDiamond = var13;
+
 		var25 = new ItemArmor(55, 3, 3, 1);
 		var1 = 19;
 		var13 = var25;
 		var13.iconIndex = var1;
 		plateDiamond = var13;
+
 		var25 = new ItemArmor(56, 3, 3, 2);
 		var1 = 35;
 		var13 = var25;
 		var13.iconIndex = var1;
 		legsDiamond = var13;
+
 		var25 = new ItemArmor(57, 3, 3, 3);
 		var1 = 51;
 		var13 = var25;
 		var13.iconIndex = var1;
 		bootsDiamond = var13;
+
 		var25 = new ItemArmor(58, 1, 4, 0);
 		var1 = 4;
 		var13 = var25;
 		var13.iconIndex = var1;
 		helmetGold = var13;
+
 		var25 = new ItemArmor(59, 1, 4, 1);
 		var1 = 20;
 		var13 = var25;
 		var13.iconIndex = var1;
 		plateGold = var13;
+
 		var25 = new ItemArmor(60, 1, 4, 2);
 		var1 = 36;
 		var13 = var25;
 		var13.iconIndex = var1;
 		legsGold = var13;
+
 		var25 = new ItemArmor(61, 1, 4, 3);
 		var1 = 52;
 		var13 = var25;
 		var13.iconIndex = var1;
 		bootsGold = var13;
+
 		var20 = new Item(62);
 		var1 = 6;
 		var7 = var20;
 		var7.iconIndex = var1;
 		flint = var7;
+
 		var18 = new ItemFood(63, 3);
 		var1 = 87;
 		var5 = var18;
 		var5.iconIndex = var1;
 		porkRaw = var5;
+
 		var18 = new ItemFood(64, 8);
 		var1 = 88;
 		var5 = var18;
 		var5.iconIndex = var1;
 		porkCooked = var5;
+
 		ItemPainting var26 = new ItemPainting(65);
 		var1 = 26;
 		ItemPainting var14 = var26;
--- /dev/null
+++ net/minecraft/game/level/block/BlockPiston.java
@@ -1,0 +1,116 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+public class BlockPiston extends Block {
+	private final int pullType;
+
+	public BlockPiston(int var1, int var2, int var3) {
+		super(var1, var2, Material.iron);
+		this.pullType = var3;
+	}
+
+	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
+		var1.setBlockMetadata(var2, var3, var4, var5);
+	}
+
+	public int getBlockTextureFromSide(int var1) {
+		return var1 == 3 ? this.blockIndexInTexture - 1 : this.blockIndexInTexture;
+	}
+
+	public int getBlockTexture(World var1, int var2, int var3, int var4, int var5) {
+		return var5 == var1.getBlockMetadata(var2, var3, var4) ? this.blockIndexInTexture - 1 : this.blockIndexInTexture;
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+		int pushStatus = this.tryPush(world, x, y, z);
+		float pitch = 0.6F + this.pullType * 0.2F + world.random.nextFloat() * 0.1F;
+		if (pushStatus == 0 && this.tryPull(world, x, y, z)) {
+			world.playSoundAtPlayer(x + 0.5F, y + 0.5F, z + 0.5F, "tile.piston.in", 0.5F, pitch);
+		} else if (pushStatus >= 0) {
+			world.playSoundAtPlayer(x + 0.5F, y + 0.5F, z + 0.5F, "tile.piston.out", 0.5F, pitch);
+		}
+	}
+
+	private int tryPush(World var1, int var2, int var3, int var4) {
+		int dir = var1.getBlockMetadata(var2, var3, var4);
+		int dx = dir == 4 ? -1 : dir == 5 ? 1 : 0;
+		int dy = dir == 0 ? -1 : dir == 1 ? 1 : 0;
+		int dz = dir == 2 ? -1 : dir == 3 ? 1 : 0;
+		int bx = var2 + dx;
+		int by = var3 + dy;
+		int bz = var4 + dz;
+		Block b = null;
+		int pushCount = 0;
+
+		while (bx > 0 && by > 0 && bz > 0 && bx < var1.width - 1 && by < var1.height - 1 && bz < var1.length - 1
+				&& (b = Block.blocksList[var1.getBlockId(bx, by, bz)]) != null
+				&& !(b instanceof BlockContainer)
+				&& b.getCollisionBoundingBoxFromPool(var1, bx, by, bz) != null
+				&& b.getExplosionResistance() < 1000.0F) {
+			bx += dx;
+			by += dy;
+			bz += dz;
+			pushCount++;
+
+			if (pushCount > 12) {
+				return -1;
+			}
+		}
+
+		if (b != null) {
+			if (b.getExplosionResistance() >= 1000.0F || b instanceof BlockContainer) {
+				return -1;
+			}
+			b.dropBlockAsItem(var1, bx, by, bz, var1.getBlockMetadata(bx, by, bz));
+		}
+
+		if (pushCount > 0) {
+			var1.setTileNoUpdate(bx, by, bz, 0);
+			while (bx - dx != var2 || by - dy != var3 || bz - dz != var4) {
+				var1.swap(bx, by, bz, bx - dx, by - dy, bz - dz);
+				bx -= dx;
+				by -= dy;
+				bz -= dz;
+			}
+		}
+
+		return pushCount > 0 ? 1 : 0;
+	}
+
+	private boolean tryPull(World var1, int var2, int var3, int var4) {
+		if (this.pullType <= 0) return false;
+
+		int dir = var1.getBlockMetadata(var2, var3, var4);
+		int dx = dir == 4 ? -1 : dir == 5 ? 1 : 0;
+		int dy = dir == 0 ? -1 : dir == 1 ? 1 : 0;
+		int dz = dir == 2 ? -1 : dir == 3 ? 1 : 0;
+		int bx = var2 + dx;
+		int by = var3 + dy;
+		int bz = var4 + dz;
+		Block b = Block.blocksList[var1.getBlockId(bx, by, bz)];
+		if (b != null) {
+			var1.setTileNoUpdate(bx, by, bz, 0);
+			b.dropBlockAsItem(var1, bx, by, bz, var1.getBlockMetadata(bx, by, bz));
+		}
+		boolean hasPulled = false;
+		int pullLimit = 12;
+
+		while (bx > 0 && by > 0 && bz > 0 && bx < var1.width - 1 && by < var1.height - 1 && bz < var1.length - 1
+				&& (b = Block.blocksList[var1.getBlockId(bx + dx, by + dy, bz + dz)]) != null
+				&& !(b instanceof BlockContainer)
+				&& b.getCollisionBoundingBoxFromPool(var1, bx + dx, by + dy, bz + dz) != null
+				&& b.getExplosionResistance() < 1000.0F) {
+			var1.swap(bx, by, bz, bx + dx, by + dy, bz + dz);
+			bx += dx;
+			by += dy;
+			bz += dz;
+			hasPulled = true;
+
+			if (this.pullType < 2 || --pullLimit <= 0) break;
+		}
+
+		return hasPulled;
+	}
+}
--- net/minecraft/client/LoadingScreenRenderer.java
+++ net/minecraft/client/LoadingScreenRenderer.java
@@ -27,7 +27,7 @@
 
 	public final void displayProgressMessage(String var1) {
 		if(!this.mc.running) {
-			throw new MinecraftError();
+			return;
 		} else {
 			this.title = var1;
 			ScaledResolution var3 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight);
@@ -45,7 +45,7 @@
 
 	public final void displayLoadingString(String var1) {
 		if(!this.mc.running) {
-			throw new MinecraftError();
+			return;
 		} else {
 			this.start = 0L;
 			this.text = var1;
@@ -56,7 +56,7 @@
 
 	public final void setLoadingProgress(int var1) {
 		if(!this.mc.running) {
-			throw new MinecraftError();
+			return;
 		} else {
 			long var2 = System.currentTimeMillis();
 			if(var2 - this.start >= 20L) {
--- /dev/null
+++ net/minecraft/game/level/block/BlockSnowBlock.java
@@ -1,0 +1,31 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.level.EnumSkyBlock;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+import java.util.Random;
+
+public class BlockSnowBlock extends Block {
+	public BlockSnowBlock(int var1, int var2) {
+		super(var1, var2, Material.craftedSnow);
+		this.setTickOnLoad(true);
+	}
+
+	public int idDropped(int var1, Random var2) {
+		return Item.snowball.shiftedIndex;
+	}
+
+	public int quantityDropped(Random var1) {
+		return 4;
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		if(var1.getSavedLightValue(EnumSkyBlock.Block, var2, var3, var4) > 11) {
+			this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+			var1.setBlockWithNotify(var2, var3, var4, 0);
+		}
+
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/feature/Feature.java
@@ -1,0 +1,9 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+
+import java.util.Random;
+
+public interface Feature {
+	boolean generate(World world, Random rand, int x, int y, int z);
+}
--- net/minecraft/client/sound/SoundPool.java
+++ net/minecraft/client/sound/SoundPool.java
@@ -11,6 +11,7 @@
 public final class SoundPool {
 	private Random rand = new Random();
 	private Map nameToSoundPoolEntriesMapping = new HashMap();
+	private List allSoundPoolEntries = new ArrayList();
 	private int numberOfSoundPoolEntries = 0;
 
 	public final SoundPoolEntry addSound(String var1, File var2) {
@@ -27,6 +28,7 @@
 
 			SoundPoolEntry var5 = new SoundPoolEntry(var3, var2.toURI().toURL());
 			((List)this.nameToSoundPoolEntriesMapping.get(var1)).add(var5);
+			this.allSoundPoolEntries.add(var5);
 			++this.numberOfSoundPoolEntries;
 			return var5;
 		} catch (MalformedURLException var4) {
@@ -38,5 +40,9 @@
 	public final SoundPoolEntry getRandomSoundFromSoundPool(String var1) {
 		List var2 = (List)this.nameToSoundPoolEntriesMapping.get(var1);
 		return var2 == null ? null : (SoundPoolEntry)var2.get(this.rand.nextInt(var2.size()));
+	}
+
+	public SoundPoolEntry getRandomSound() {
+		return this.allSoundPoolEntries.size() == 0 ? null : (SoundPoolEntry)this.allSoundPoolEntries.get(this.rand.nextInt(this.allSoundPoolEntries.size()));
 	}
 }
--- net/minecraft/client/render/entity/Render.java
+++ net/minecraft/client/render/entity/Render.java
@@ -94,6 +94,7 @@
 				float var6 = var2;
 				Render var27 = this;
 				GL11.glEnable(GL11.GL_BLEND);
+				GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 				RenderEngine var10 = this.renderManager.renderEngine;
 				RenderEngine.bindTexture(var10.getTexture("%%/shadow.png"));
 				World var11 = this.renderManager.worldObj;
@@ -104,7 +105,7 @@
 					for(int var13 = (int)(var7 - 2.0F); var13 <= (int)var7; ++var13) {
 						for(int var14 = (int)(var8 - var12); var14 <= (int)(var8 + var12); ++var14) {
 							int var15 = var11.getBlockId(var29, var13 - 1, var14);
-							if(var15 > 0 && var11.getBlockLightValue(var29, var13, var14) > 3) {
+							if(var15 > 0 && var11.getBlockLightValue(var29, var13, var14) > 3 && Block.blocksList[var15].material.isSolid()) {
 								Block var16 = Block.blocksList[var15];
 								Tessellator var25 = Tessellator.instance;
 								var34 = (var9 - (var7 - (float)var13) / 2.0F) * 0.5F * var27.renderManager.worldObj.getLightBrightness(var29, var13, var14);
--- net/minecraft/client/gui/GuiLoadLevel.java
+++ net/minecraft/client/gui/GuiLoadLevel.java
@@ -81,6 +81,13 @@
 		this.controlList.add(new GuiButton(5, this.width / 2 - 100, this.height / 6 + 120 + 12, "Load file..."));
 		this.controlList.add(new GuiButton(6, this.width / 2 - 100, this.height / 6 + 168, "Cancel"));
 		((GuiButton)this.controlList.get(5)).visible = false;
+
+		if (!this.frozen) {
+			this.frozen = true;
+			GuiLevelDialog var2 = new GuiLevelDialog(this);
+			var2.setDaemon(true);
+			var2.start();
+		}
 	}
 
 	protected final void actionPerformed(GuiButton var1) {
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageEroding.java
@@ -1,0 +1,27 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorDistort;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+
+public final class StageEroding extends TerrainGenStage {
+	public StageEroding() {
+		super("Eroding..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			NoiseGenerator selectorNoise = new NoiseGeneratorDistort(new NoiseGeneratorOctaves(rand, 8), new NoiseGeneratorOctaves(rand, 8));
+			NoiseGenerator heightNoise = new NoiseGeneratorDistort(new NoiseGeneratorOctaves(rand, 8), new NoiseGeneratorOctaves(rand, 8));
+
+			for (int x = 0; x < blocks.width; x++) {
+				progressor.accept(x * 100.0F / (float)(blocks.width - 1));
+
+				for (int z = 0; z < blocks.length; z++) {
+					double selection = selectorNoise.generateNoise(x << 1, z << 1) / 8.0D;
+					int height = heightNoise.generateNoise(x << 1, z << 1) > 0.0D ? 1 : 0;
+
+					if (selection > 2.0D) {
+						heightmap.set(x, z, ((heightmap.get(x, z) - height) / 2 << 1) + height);
+					}
+				}
+			}
+		});
+	}
+}
--- net/minecraft/game/level/block/BlockFire.java
+++ net/minecraft/game/level/block/BlockFire.java
@@ -9,13 +9,15 @@
 	private int[] chanceToEncourageFire = new int[256];
 	private int[] abilityToCatchFire = new int[256];
 
-	protected BlockFire(int var1, int var2) {
+	public BlockFire(int var1, int var2) {
 		super(51, 31, Material.fire);
 		this.setBurnRate(Block.planks.blockID, 5, 20);
 		this.setBurnRate(Block.wood.blockID, 5, 5);
 		this.setBurnRate(Block.leaves.blockID, 30, 60);
 		this.setBurnRate(Block.bookShelf.blockID, 30, 20);
 		this.setBurnRate(Block.tnt.blockID, 15, 100);
+		this.setBurnRate(Block.woodStairSingle.blockID, 5, 20);
+		this.setBurnRate(Block.woodStairDouble.blockID, 5, 20);
 
 		for(var1 = 0; var1 < 16; ++var1) {
 			this.setBurnRate(Block.clothRed.blockID + var1, 30, 60);
@@ -29,7 +31,7 @@
 		this.abilityToCatchFire[var1] = var3;
 	}
 
-	public final AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
+	public final AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
 		return null;
 	}
 
--- net/minecraft/game/level/block/tileentity/TileEntityFurnace.java
+++ net/minecraft/game/level/block/tileentity/TileEntityFurnace.java
@@ -3,6 +3,7 @@
 import com.mojang.nbt.NBTTagCompound;
 import com.mojang.nbt.NBTTagList;
 import net.minecraft.game.IInventory;
+import net.minecraft.game.entity.player.EntityPlayer;
 import net.minecraft.game.item.Item;
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.level.World;
@@ -137,6 +138,14 @@
 						++this.furnaceItemStacks[2].stackSize;
 					}
 
+					int smeltValue = var3 == Item.porkCooked.shiftedIndex ? 10
+							: var3 == Item.ingotIron.shiftedIndex ? 15
+							: var3 == Item.ingotGold.shiftedIndex ? 25
+							: var3 == Item.diamond.shiftedIndex ? 50
+							: 0;
+
+					((EntityPlayer)this.worldObj.playerEntity).getScore += smeltValue;
+
 					--this.furnaceItemStacks[0].stackSize;
 					if(this.furnaceItemStacks[0].stackSize <= 0) {
 						this.furnaceItemStacks[0] = null;
@@ -173,12 +182,20 @@
 			return false;
 		} else {
 			int var1 = smeltItem(this.furnaceItemStacks[0].getItem().shiftedIndex);
-			return var1 < 0 ? false : (this.furnaceItemStacks[2] == null ? true : (this.furnaceItemStacks[2].itemID != var1 ? false : (this.furnaceItemStacks[2].stackSize < 64 ? true : this.furnaceItemStacks[2].stackSize < Item.itemsList[var1].getItemStackLimit())));
+			return var1 >= 0 && this.furnaceItemStacks[2] == null || var1 >= 0 && this.furnaceItemStacks[2].itemID == var1 && this.furnaceItemStacks[2].stackSize < Item.itemsList[var1].getItemStackLimit();
 		}
 	}
 
 	private static int smeltItem(int var0) {
-		return var0 == Block.oreIron.blockID ? Item.ingotIron.shiftedIndex : (var0 == Block.oreGold.blockID ? Item.ingotGold.shiftedIndex : (var0 == Block.oreDiamond.blockID ? Item.diamond.shiftedIndex : (var0 == Block.sand.blockID ? Block.glass.blockID : (var0 == Item.porkRaw.shiftedIndex ? Item.porkCooked.shiftedIndex : (var0 == Block.cobblestone.blockID ? Block.stone.blockID : -1)))));
+		return var0 == Block.oreIron.blockID ? Item.ingotIron.shiftedIndex
+				: var0 == Block.oreCopper.blockID ? Item.ingotCopper.shiftedIndex
+				: var0 == Block.oreGold.blockID ? Item.ingotGold.shiftedIndex
+				: var0 == Block.oreDiamond.blockID ? Item.diamond.shiftedIndex
+				: var0 == Block.sand.blockID ? Block.glass.blockID
+				: var0 == Item.porkRaw.shiftedIndex ? Item.porkCooked.shiftedIndex
+				: var0 == Block.cobblestone.blockID ? Block.stone.blockID
+				: var0 == Block.cactus.blockID ? Item.dyeGreen.shiftedIndex
+				: -1;
 	}
 
 	private static int getItemBurnTime(ItemStack var0) {
--- /dev/null
+++ net/minecraft/game/item/ItemWrench.java
@@ -1,0 +1,20 @@
+package net.minecraft.game.item;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+
+public class ItemWrench extends Item {
+	public ItemWrench(int var1) {
+		super(var1);
+	}
+
+	public boolean onItemUse(ItemStack var1, World var2, int var3, int var4, int var5, int var6) {
+		Block block = Block.blocksList[var2.getBlockId(var3, var4, var5)];
+		if (block != null) {
+			var2.playSoundAtPlayer(var3 + 0.5F, var4 + 0.5F, var5 + 0.5F, "random.wrench", 0.5F, 0.9F + rand.nextFloat() * 0.2F);
+			block.onPowerReceived(var2, var3, var4, var5, var6);
+			return true;
+		}
+		return false;
+	}
+}
--- /dev/null
+++ net/minecraft/client/ScreenShotHelper.java
@@ -1,0 +1,81 @@
+package net.minecraft.client;
+
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.nio.ByteBuffer;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import javax.imageio.ImageIO;
+import org.lwjgl.BufferUtils;
+import org.lwjgl.opengl.GL11;
+
+public class ScreenShotHelper {
+	private static DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss");
+	private static ByteBuffer buffer;
+	private static byte[] pixelData;
+	private static int[] imageData;
+
+	public static String saveScreenshot(File var0, int var1, int var2) {
+		return func_35879_a(var0, (String)null, var1, var2);
+	}
+
+	public static String func_35879_a(File var0, String var1, int var2, int var3) {
+		try {
+			File var4 = new File(var0, "screenshots");
+			var4.mkdir();
+			if(buffer == null || buffer.capacity() < var2 * var3 * 3) {
+				buffer = BufferUtils.createByteBuffer(var2 * var3 * 3);
+			}
+
+			if(imageData == null || imageData.length < var2 * var3 * 3) {
+				pixelData = new byte[var2 * var3 * 3];
+				imageData = new int[var2 * var3];
+			}
+
+			GL11.glPixelStorei(GL11.GL_PACK_ALIGNMENT, 1);
+			GL11.glPixelStorei(GL11.GL_UNPACK_ALIGNMENT, 1);
+			buffer.clear();
+			GL11.glReadPixels(0, 0, var2, var3, GL11.GL_RGB, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)buffer);
+			buffer.clear();
+			String var5 = "" + dateFormat.format(new Date());
+			File var6;
+			int var7;
+			if(var1 == null) {
+				var7 = 1;
+
+				while(true) {
+					var6 = new File(var4, var5 + (var7 == 1 ? "" : "_" + var7) + ".png");
+					if(!var6.exists()) {
+						break;
+					}
+
+					++var7;
+				}
+			} else {
+				var6 = new File(var4, var1);
+			}
+
+			buffer.get(pixelData);
+
+			for(var7 = 0; var7 < var2; ++var7) {
+				for(int var8 = 0; var8 < var3; ++var8) {
+					int var9 = var7 + (var3 - var8 - 1) * var2;
+					int var10 = pixelData[var9 * 3 + 0] & 255;
+					int var11 = pixelData[var9 * 3 + 1] & 255;
+					int var12 = pixelData[var9 * 3 + 2] & 255;
+					int var13 = -16777216 | var10 << 16 | var11 << 8 | var12;
+					imageData[var7 + var8 * var2] = var13;
+				}
+			}
+
+			BufferedImage var15 = new BufferedImage(var2, var3, 1);
+			var15.setRGB(0, 0, var2, var3, imageData, 0, var2);
+			ImageIO.write(var15, "png", var6);
+			return "Saved screenshot as " + var6.getName();
+		} catch (Exception var14) {
+			var14.printStackTrace();
+			return "Failed to save: " + var14;
+		}
+	}
+}
--- net/minecraft/client/gui/FontRenderer.java
+++ net/minecraft/client/gui/FontRenderer.java
@@ -11,6 +11,30 @@
 import org.lwjgl.opengl.GL11;
 
 public final class FontRenderer {
+	private static final float OO = 0.0F;
+	private static final float VV = 1.0F / 3.0F;
+	private static final float AA = 2.0F / 3.0F;
+	private static final float FF = 1.0F;
+
+	private static final float[][] COLORS = {
+			{ OO, OO, OO },
+			{ OO, OO, AA },
+			{ OO, AA, OO },
+			{ OO, AA, AA },
+			{ AA, OO, OO },
+			{ AA, OO, AA },
+			{ AA, AA, OO },
+			{ AA, AA, AA },
+			{ VV, VV, VV },
+			{ VV, VV, FF },
+			{ VV, FF, VV },
+			{ VV, FF, FF },
+			{ FF, VV, VV },
+			{ FF, VV, FF },
+			{ FF, FF, VV },
+			{ FF, FF, FF },
+	};
+
 	private int[] charWidth = new int[256];
 	private int fontTextureName = 0;
 	private int fontDisplayLists;
@@ -115,6 +139,7 @@
 
 	private void renderString(String var1, int var2, int var3, int var4, boolean var5) {
 		if(var1 != null) {
+			boolean colorMod = false;
 			char[] var8 = var1.toCharArray();
 			if(var5) {
 				var4 = (var4 & 16579836) >> 2;
@@ -136,12 +161,13 @@
 						var11 = 15;
 					}
 
-					this.buffer.put(this.fontDisplayLists + 256 + var11 + (var5 ? 16 : 0));
-					if(this.buffer.remaining() == 0) {
-						this.buffer.flip();
-						GL11.glCallLists(this.buffer);
-						this.buffer.clear();
-					}
+					this.buffer.flip();
+					GL11.glCallLists(this.buffer);
+					this.buffer.clear();
+
+					float[] color = COLORS[var11];
+					GL11.glColor4f(var6 * color[0], var7 * color[1], var9 * color[2], 1.0F);
+					colorMod = true;
 				}
 
 				this.buffer.put(this.fontDisplayLists + var8[var10]);
@@ -155,6 +181,7 @@
 			this.buffer.flip();
 			GL11.glCallLists(this.buffer);
 			GL11.glPopMatrix();
+			if (colorMod) GL11.glColor3f(1.0F, 1.0F, 1.0F);
 		}
 	}
 
--- /dev/null
+++ net/minecraft/game/level/block/BlockSnow.java
@@ -1,0 +1,83 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.entity.misc.EntityItem;
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.ItemStack;
+import net.minecraft.game.level.EnumSkyBlock;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+import net.minecraft.game.physics.AxisAlignedBB;
+
+import java.util.Random;
+
+public class BlockSnow extends Block {
+	public BlockSnow(int var1, int var2) {
+		super(var1, var2, Material.snow);
+		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 2.0F / 16.0F, 1.0F);
+		this.setTickOnLoad(true);
+	}
+
+	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
+		return null;
+	}
+
+	public boolean isOpaqueCube() {
+		return false;
+	}
+
+	public boolean renderAsNormalBlock() {
+		return false;
+	}
+
+	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
+		int var5 = var1.getBlockId(var2, var3 - 1, var4);
+		return var5 != 0 && Block.blocksList[var5].isOpaqueCube() ? var1.getBlockMaterial(var2, var3 - 1, var4).getIsSolid() : false;
+	}
+
+	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
+		this.canSnowStay(var1, var2, var3, var4);
+	}
+
+	private boolean canSnowStay(World var1, int var2, int var3, int var4) {
+		if(!this.canPlaceBlockAt(var1, var2, var3, var4)) {
+			this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+			var1.setBlockWithNotify(var2, var3, var4, 0);
+			return false;
+		} else {
+			return true;
+		}
+	}
+
+	public void harvestBlock(World var1, int var2, int var3, int var4, int var5) {
+		int var6 = Item.snowball.shiftedIndex;
+		float var7 = 0.7F;
+		float var8 = (var1.random.nextFloat() * var7) + (1.0F - var7) * 0.5F;
+		float var10 = (var1.random.nextFloat() * var7) + (1.0F - var7) * 0.5F;
+		float var12 = (var1.random.nextFloat() * var7) + (1.0F - var7) * 0.5F;
+		EntityItem var14 = new EntityItem(var1, var2 + var8, var3 + var10, var4 + var12, new ItemStack(var6));
+		var14.delayBeforeCanPickup = 10;
+		var1.spawnEntityInWorld(var14);
+		var1.setBlockWithNotify(var2, var3, var4, 0);
+	}
+
+	public int idDropped(int var1, Random var2) {
+		return Item.snowball.shiftedIndex;
+	}
+
+	public int quantityDropped(Random var1) {
+		return 0;
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		if(var1.getSavedLightValue(EnumSkyBlock.Block, var2, var3, var4) > 11) {
+			this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+			var1.setBlockWithNotify(var2, var3, var4, 0);
+		}
+
+	}
+
+	public boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
+		Material var6 = var1.getBlockMaterial(var2, var3, var4);
+		return var5 == 1 ? true : (var6 == this.material ? false : super.shouldSideBeRendered(var1, var2, var3, var4, var5));
+	}
+}
--- net/minecraft/client/PlayerLoader.java
+++ net/minecraft/client/PlayerLoader.java
@@ -15,6 +15,6 @@
 	}
 
 	protected final Entity loadEntity(World var1, String var2) {
-		return (Entity)(var2.equals("LocalPlayer") ? new EntityPlayerSP(this.mc, var1, this.mc.session) : super.loadEntity(var1, var2));
+		return var2.equals("LocalPlayer") && !this.mc.adventureMode ? new EntityPlayerSP(this.mc, var1, this.mc.session) : super.loadEntity(var1, var2);
 	}
 }
--- /dev/null
+++ net/minecraft/client/gui/GuiDeleteWorld.java
@@ -1,0 +1,32 @@
+package net.minecraft.client.gui;
+
+public class GuiDeleteWorld extends GuiScreen {
+	private final GuiScreen parentScreen;
+
+	public GuiDeleteWorld(GuiScreen parent) {
+		this.parentScreen = parent;
+	}
+
+	public void initGui() {
+		this.controlList.add(new GuiButton(0, this.width / 2 + 5, this.height / 2, 100, 20, "No"));
+		this.controlList.add(new GuiButton(1, this.width / 2 - 105, this.height / 2, 100, 20, "Yes"));
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		this.drawDefaultBackground();
+		drawCenteredString(this.fontRenderer, "Are you sure you want to delete your world?", this.width / 2, this.height / 2 - 32, 0xFFFFFF);
+		drawCenteredString(this.fontRenderer, "It will be gone forever!", this.width / 2, this.height / 2 - 20, 0xFFFFFF);
+		super.drawScreen(var1, var2, var3);
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		if (var1.id == 1) {
+			this.mc.deleteWorld();
+			this.mc.setLevel(null);
+			this.mc.displayGuiScreen(null);
+			return;
+		}
+
+		this.mc.displayGuiScreen(this.parentScreen);
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeaturePalmTree.java
@@ -1,0 +1,72 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+
+import java.util.Random;
+
+public class FeaturePalmTree implements Feature {
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		int ground = var1.getBlockId(var3, var4 - 1, var5);
+		if (ground != Block.grass.blockID) {
+			return false;
+		}
+
+		int height = var2.nextInt(3) + 2;
+		int height2 = var2.nextInt(3) + 1;
+		int height3 = var2.nextInt(3);
+		int heightTotal = height + height2 + height3;
+
+		for (int y = var4; y < var4 + heightTotal; y++) {
+			int range = y < var4 + heightTotal - 2 ? 1 : 2;
+			for (int x = var3 - range; x <= var3 + range; x++) {
+				for (int z = var5 - range; z <= var5 + range; z++) {
+					if (x <= 0 || y <= 0 || z <= 0
+							|| x > var1.width || y > var1.height || z > var1.length
+							|| var1.getBlockId(x, y, z) != 0) {
+						return false;
+					}
+				}
+			}
+		}
+
+		var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
+
+		{
+			int dir = var2.nextInt(4);
+			int dirX = dir == 0 ? 1 : dir == 2 ? -1 : 0;
+			int dirZ = dir == 1 ? 1 : dir == 3 ? -1 : 0;
+
+			for (int y = 0; y < heightTotal; y++) {
+				if (y == height || y == height + height2) {
+					var3 += dirX;
+					var5 += dirZ;
+				}
+				var1.setBlock(var3, var4 + y, var5, Block.wood.blockID);
+			}
+		}
+
+		var4 += heightTotal;
+		if (var1.getBlockId(var3, var4, var5) == 0) {
+			var1.setBlock(var3, var4, var5, Block.leaves.blockID);
+		}
+
+		for (int dirX = -1; dirX <= 1; dirX++) {
+			for (int dirZ = -1; dirZ <= 1; dirZ++) {
+				if (dirX == 0 && dirZ == 0) continue;
+				int length = dirX != 0 && dirZ != 0 ? 4 : 5;
+
+				for (int i = 1; i < length; i++) {
+					if (i <= 2 && var1.getBlockId(var3 + dirX * i, var4, var5 + dirZ * i) == 0) {
+						var1.setBlock(var3 + dirX * i, var4, var5 + dirZ * i, Block.leaves.blockID);
+					}
+					if (i >= 2 && var1.getBlockId(var3 + dirX * i, var4 - 1, var5 + dirZ * i) == 0) {
+						var1.setBlock(var3 + dirX * i, var4 - 1, var5 + dirZ * i, Block.leaves.blockID);
+					}
+				}
+			}
+		}
+
+		return true;
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeatureSwampTree.java
@@ -1,0 +1,145 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.material.Material;
+
+import java.util.Random;
+
+public class FeatureSwampTree implements Feature {
+	private final int minHeight;
+	private final int heightVariance;
+
+	public FeatureSwampTree() {
+		this(5, 4);
+	}
+
+	public FeatureSwampTree(int minHeight, int heightVariance) {
+		this.minHeight = minHeight;
+		this.heightVariance = heightVariance;
+	}
+
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		int var6;
+		for(var6 = var2.nextInt(this.heightVariance) + this.minHeight; var1.getBlockMaterial(var3, var4 - 1, var5) == Material.water; --var4) {
+		}
+
+		boolean var7 = true;
+		if(var4 >= 1) {
+			int var10000 = var4 + var6 + 1;
+			if(var10000 <= var1.height) {
+				int var8;
+				int var10;
+				int var11;
+				int var12;
+				for(var8 = var4; var8 <= var4 + 1 + var6; ++var8) {
+					byte var9 = 1;
+					if(var8 == var4) {
+						var9 = 0;
+					}
+
+					if(var8 >= var4 + 1 + var6 - 2) {
+						var9 = 3;
+					}
+
+					for(var10 = var3 - var9; var10 <= var3 + var9 && var7; ++var10) {
+						for(var11 = var5 - var9; var11 <= var5 + var9 && var7; ++var11) {
+							if(var8 >= 0) {
+								if(var8 < var1.height) {
+									var12 = var1.getBlockId(var10, var8, var11);
+									if(var12 == 0 || var12 == Block.leaves.blockID) {
+										continue;
+									}
+
+									if(var12 != Block.waterStill.blockID && var12 != Block.waterMoving.blockID) {
+										var7 = false;
+										continue;
+									}
+
+									if(var8 > var4) {
+										var7 = false;
+									}
+									continue;
+								}
+							}
+
+							var7 = false;
+						}
+					}
+				}
+
+				if(!var7) {
+					return false;
+				}
+
+				var8 = var1.getBlockId(var3, var4 - 1, var5);
+				if(var8 == Block.grass.blockID || var8 == Block.dirt.blockID) {
+					if(var4 < var1.height - var6 - 1) {
+						var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
+
+						int var13;
+						int var16;
+						for(var16 = var4 - 3 + var6; var16 <= var4 + var6; ++var16) {
+							var10 = var16 - (var4 + var6);
+							var11 = 2 - var10 / 2;
+
+							for(var12 = var3 - var11; var12 <= var3 + var11; ++var12) {
+								var13 = var12 - var3;
+
+								for(int var14 = var5 - var11; var14 <= var5 + var11; ++var14) {
+									int var15 = var14 - var5;
+									if((Math.abs(var13) != var11 || Math.abs(var15) != var11 || var2.nextInt(2) != 0 && var10 != 0) && !Block.opaqueCubeLookup[var1.getBlockId(var12, var16, var14)]) {
+										var1.setBlock(var12, var16, var14, Block.leaves.blockID);
+									}
+								}
+							}
+						}
+
+						for(var16 = 0; var16 < var6; ++var16) {
+							var10 = var1.getBlockId(var3, var4 + var16, var5);
+							if(var10 == 0 || var10 == Block.leaves.blockID || var10 == Block.waterMoving.blockID || var10 == Block.waterStill.blockID) {
+								var1.setBlock(var3, var4 + var16, var5, Block.wood.blockID);
+							}
+						}
+
+						for(var16 = var4 - 3 + var6; var16 <= var4 + var6; ++var16) {
+							var10 = var16 - (var4 + var6);
+							var11 = 2 - var10 / 2;
+
+							for(var12 = var3 - var11; var12 <= var3 + var11; ++var12) {
+								for(var13 = var5 - var11; var13 <= var5 + var11; ++var13) {
+									if(var1.getBlockId(var12, var16, var13) == Block.leaves.blockID) {
+										if(var2.nextInt(4) == 0 && var1.getBlockId(var12 - 1, var16, var13) == 0) {
+											this.func_35265_a(var1, var12 - 1, var16, var13, 8);
+										}
+
+										if(var2.nextInt(4) == 0 && var1.getBlockId(var12 + 1, var16, var13) == 0) {
+											this.func_35265_a(var1, var12 + 1, var16, var13, 2);
+										}
+
+										if(var2.nextInt(4) == 0 && var1.getBlockId(var12, var16, var13 - 1) == 0) {
+											this.func_35265_a(var1, var12, var16, var13 - 1, 1);
+										}
+
+										if(var2.nextInt(4) == 0 && var1.getBlockId(var12, var16, var13 + 1) == 0) {
+											this.func_35265_a(var1, var12, var16, var13 + 1, 4);
+										}
+									}
+								}
+							}
+						}
+
+						return true;
+					}
+				}
+
+				return false;
+			}
+		}
+
+		return false;
+	}
+
+	private void func_35265_a(World var1, int var2, int var3, int var4, int var5) {
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/LevelType.java
@@ -1,0 +1,590 @@
+package net.minecraft.game.level.generator;
+
+import net.minecraft.game.level.generator.terrain.*;
+
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+public enum LevelType {
+	ISLAND("Island") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder()
+							.island(true)
+							.build(),
+					new StageEroding(),
+					new StageSoiling.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.sandBeachThreshold(-8.0D)
+							.applyTheme(theme)
+							.build()
+			};
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return waterLevel - 9;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return waterLevel;
+		}
+	},
+	FLOATING("Floating") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder().build(),
+					new StageEroding(),
+					new StageSoiling.Builder()
+							.floating(true)
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.applyTheme(theme)
+							.build()
+			};
+		}
+
+		@Override
+		public int getLayerCount(int height) {
+			return (height - 64) / 48 + 1;
+		}
+
+		@Override
+		public int getCloudHeight(int levelHeight, int waterLevel) {
+			return -16;
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return -128;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return groundLevel + 1;
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return null;
+		}
+
+		@Override
+		public boolean canNaturallyGenerate() {
+			return false;
+		}
+	},
+	FLAT("Flat") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageSoiling.Builder().applyTheme(theme).build(),
+					new StageGrowing.Builder().applyTheme(theme).build()
+			};
+		}
+
+		@Override
+		public int getGenHeight(int levelHeight, int layer) {
+			return 8;
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return 8;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return 0;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return null;
+		}
+
+		@Override
+		public boolean canNaturallyGenerate() {
+			return false;
+		}
+	},
+	INLAND("Inland") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder().build(),
+					new StageEroding(),
+					new StageSoiling.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.applyTheme(theme)
+							.build()
+			};
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "hills";
+		}
+	},
+	MOUNTAINS("Mountains") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder()
+							.noiseScale(0.5D)
+							.selectorScale(1.0D)
+							.minDamp(3.0D)
+							.minBoost(0.0D)
+							.maxDamp(1.0D)
+							.maxBoost(10.0D)
+							.selectionSmoothness(NoiseModifierAccess.variation(1.0D, 1.5D, 0.75D))
+							.selectionThreshold(0.0D)
+							.build(),
+					new StageSoiling.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.applyTheme(theme)
+							.build()
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public boolean doFloodFillToEdge() {
+			return true;
+		}
+
+		@Override
+		public long getMaxLakeSize() {
+			return 0L;
+		}
+
+		@Override
+		public int getLakeRarity() {
+			return 10000;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "mountains";
+		}
+	},
+	MARSH("Marsh") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder()
+							.noiseScale(1.7D)
+							.minDamp(10.0D)
+							.minBoost(-7.0D)
+							.maxDamp(5.0D)
+							.maxBoost(-3.0D)
+							.selectionThreshold(1.0D)
+							.build(),
+					new StageEroding(),
+					new StageSoiling.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.beachHeightOffset(-2)
+							.applyTheme(theme)
+							.build(),
+					new StageFlooding(theme.getStillFluid())
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return waterLevel - 2;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return waterLevel;
+		}
+
+		@Override
+		public int getLakeRarity() {
+			return 0;
+		}
+	},
+	CLIFFS("Cliffs") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising3D.Builder()
+							.noiseScaleHorizontal(2.0D)
+							.noiseScaleVertical(2.0D)
+							.selectorScaleHorizontal(0.25D)
+							.selectorScaleVertical(0.05D)
+							.build(),
+					new StageSoiling3D.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.beachHeightOffset(1)
+							.applyTheme(theme)
+							.build(),
+					new StageFlooding(theme.getStillFluid())
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return waterLevel - 2;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return waterLevel;
+		}
+
+		@Override
+		public int getLakeRarity() {
+			return 0;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "hills";
+		}
+	},
+	WILD_CLIFFS("Wild Cliffs") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising3D.Builder()
+							.build(),
+					new StageSoiling3D.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.beachHeightOffset(1)
+							.applyTheme(theme)
+							.build(),
+					new StageFlooding(theme.getStillFluid())
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return waterLevel - 2;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return waterLevel;
+		}
+
+		@Override
+		public int getLakeRarity() {
+			return 0;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "mountains";
+		}
+	},
+	VALLEY("Valley") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder()
+							.noiseScale(0.8D)
+							.minDamp(10.0D)
+							.minBoost(-4.0D)
+							.disableSelection()
+							.build(),
+					new StageSoiling.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageMountains.Builder()
+							.build(),
+					new StageGrowing.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageFlooding(theme.getStillFluid())
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return waterLevel - 2;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return waterLevel;
+		}
+
+		@Override
+		public int getLakeRarity() {
+			return 0;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "mountains";
+		}
+	},
+	EXTREME_HILLS("Extreme Hills") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising3D.Builder()
+							.cliffBlocks(false)
+							.noiseScaleHorizontal(4.0D)
+							.noiseScaleVertical(4.0D)
+							.selectorScaleHorizontal(0.5D)
+							.selectorScaleVertical(0.15D)
+							.noiseStretch(100.0D)
+							.heightOffset(-8)
+							.heightRoundoff(24)
+							.build(),
+					new StageSoiling3D.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.beachHeightOffset(1)
+							.applyTheme(theme)
+							.build(),
+					new StageFlooding(theme.getStillFluid())
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public int getLakeRarity() {
+			return 0;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "mountains";
+		}
+	},
+	PLAINS("Plains") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising3D.Builder()
+							.cliffBlocks(false)
+							.noiseScaleHorizontal(3.5D)
+							.noiseScaleVertical(0.5D)
+							.selectorScaleHorizontal(0.35D)
+							.selectorScaleVertical(0.0D)
+							.selectorThreshold(0.25D)
+							.noiseStretch(24.0D)
+							.heightOffset(-4)
+							.build(),
+					new StageSoiling3D.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.beachHeightOffset(1)
+							.applyTheme(theme)
+							.build(),
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "hills";
+		}
+	},
+	ARCHIPELAGO("Archipelago") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder()
+							.island(true)
+							.archipelago(true)
+							.build(),
+					new StageEroding(),
+					new StageSoiling.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.sandBeachThreshold(-8.0D)
+							.applyTheme(theme)
+							.build()
+			};
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return waterLevel - 9;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return waterLevel;
+		}
+	},
+	CAVERNS("Caverns") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder()
+							.minDamp(8.0D)
+							.maxDamp(8.0D)
+							.build(),
+					new StageEroding(),
+					new StageSoiling.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageCaving()
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "hills";
+		}
+
+		@Override
+		public int getGenHeight(int levelHeight, int layer) {
+			return levelHeight - 16;
+		}
+
+		@Override
+		public int getCloudHeight(int levelHeight, int waterLevel) {
+			return levelHeight;
+		}
+	};
+
+	private static final Map<String, LevelType> NAME_TO_TYPE = Arrays.stream(values())
+			.collect(Collectors.toMap(LevelType::toString, Function.identity()));
+	private static final List<LevelType> NATURAL_TYPES = Arrays.stream(values())
+			.filter(LevelType::canNaturallyGenerate).collect(Collectors.toList());
+
+	public final String name;
+
+	LevelType(String name) {
+		this.name = name;
+	}
+
+	public boolean canNaturallyGenerate() {
+		return true;
+	}
+
+	public abstract TerrainGenStage[] getTerrainGenStages(LevelTheme theme);
+
+	public int getLayerCount(int height) {
+		return 1;
+	}
+
+	public int getGenHeight(int levelHeight, int layer) {
+		return levelHeight / 2 - (layer * 2 - (getLayerCount(levelHeight) - 1)) * 24;
+	}
+
+	public int getCloudHeight(int levelHeight, int waterLevel) {
+		return waterLevel + 64;
+	}
+
+	public int modifyGroundLevel(int groundLevel, int waterLevel) {
+		return waterLevel + 1;
+	}
+
+	public int modifyWaterLevel(int groundLevel, int waterLevel) {
+		return groundLevel - 16;
+	}
+
+	public boolean doEdgeFloodFill() {
+		return true;
+	}
+
+	public boolean doFloodFillToEdge() {
+		return false;
+	}
+
+	public long getMaxLakeSize() {
+		return 640L;
+	}
+
+	public int getLakeRarity() {
+		return 1000;
+	}
+
+	public String getHorizonType() {
+		return "islands";
+	}
+
+	@Override
+	public String toString() {
+		return this.name;
+	}
+
+	public static LevelType fromId(int id) {
+		return values()[id];
+	}
+
+	public static LevelType fromName(String name) {
+		return NAME_TO_TYPE.getOrDefault(name, ISLAND);
+	}
+
+	public static LevelType fromNameNullable(String name) {
+		return NAME_TO_TYPE.get(name);
+	}
+
+	public static LevelType getRandomGen() {
+		return NATURAL_TYPES.get(new Random().nextInt(NATURAL_TYPES.size()));
+	}
+}
--- net/minecraft/client/Minecraft.java
+++ net/minecraft/client/Minecraft.java
@@ -1,26 +1,23 @@
 package net.minecraft.client;
 
-import java.awt.Canvas;
-import java.awt.Component;
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.InputStreamReader;
+import java.awt.*;
+import java.io.*;
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.IntBuffer;
-import javax.swing.JOptionPane;
+import java.nio.file.Files;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+import javax.swing.*;
+
+import com.mojang.nbt.NBTBase;
+import com.mojang.nbt.NBTTagCompound;
 import net.minecraft.client.controller.PlayerController;
 import net.minecraft.client.controller.PlayerControllerCreative;
 import net.minecraft.client.controller.PlayerControllerSP;
 import net.minecraft.client.effect.EffectRenderer;
-import net.minecraft.client.gui.FontRenderer;
-import net.minecraft.client.gui.GuiErrorScreen;
-import net.minecraft.client.gui.GuiGameOver;
-import net.minecraft.client.gui.GuiIngame;
-import net.minecraft.client.gui.GuiIngameMenu;
-import net.minecraft.client.gui.GuiScreen;
-import net.minecraft.client.gui.ScaledResolution;
+import net.minecraft.client.gui.*;
 import net.minecraft.client.gui.container.GuiInventory;
 import net.minecraft.client.model.ModelBiped;
 import net.minecraft.client.player.EntityPlayerSP;
@@ -41,8 +38,12 @@
 import net.minecraft.game.item.Item;
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.level.World;
+import net.minecraft.game.level.WorldInfo;
 import net.minecraft.game.level.block.Block;
 import net.minecraft.game.level.generator.LevelGenerator;
+import net.minecraft.game.level.generator.LevelStructure;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.LevelType;
 import net.minecraft.game.physics.MovingObjectPosition;
 import org.lwjgl.BufferUtils;
 import org.lwjgl.LWJGLException;
@@ -57,7 +58,7 @@
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GLContext;
 
-public final class Minecraft implements Runnable {
+public class Minecraft implements Runnable {
 	public PlayerController playerController = new PlayerControllerSP(this);
 	private boolean fullscreen = false;
 	public int displayWidth;
@@ -93,6 +94,7 @@
 	public SoundManager sndManager;
 	public MouseHelper mouseHelper;
 	public File mcDataDir;
+	public File worldDir;
 	private String server;
 	private TextureWaterFX textureWaterFX;
 	private TextureLavaFX textureLavaFX;
@@ -101,9 +103,11 @@
 	public boolean inventoryScreen;
 	private int prevFrameTime;
 	public boolean inGameHasFocus;
+	public WorldInfo worldInfo = new WorldInfo();
+	public boolean adventureMode;
+	private boolean isTakingScreenshot;
 
 	public Minecraft(Canvas var1, MinecraftApplet var2, int var3, int var4, boolean var5) {
-		new ModelBiped(0.0F);
 		this.objectMouseOver = null;
 		this.sndManager = new SoundManager();
 		this.server = null;
@@ -156,6 +160,13 @@
 	}
 
 	public final void shutdownMinecraftApplet() {
+		if (this.theWorld != null && this.adventureMode) {
+			try {
+				this.saveWorld();
+			} catch (IOException e) {
+			}
+		}
+
 		try {
 			if(this.downloadResourcesThread != null) {
 				this.downloadResourcesThread.closeMinecraft();
@@ -273,6 +284,7 @@
 			}
 
 			this.mcDataDir = var27;
+			this.worldDir = new File(var27, "inadv-world");
 			this.options = new GameSettings(this, this.mcDataDir);
 			this.sndManager.loadSoundSettings(this.options);
 			this.renderEngine = new RenderEngine(this.options);
@@ -290,7 +302,7 @@
 			GL11.glViewport(0, 0, this.displayWidth, this.displayHeight);
 			if(this.server != null && this.session != null) {
 				World var31 = new World();
-				var31.generate(8, 8, 8, new byte[512], new byte[512]);
+				var31.generate(8, 8, 8, new byte[512], new byte[512], new byte[512], new int[512]);
 				this.setLevel(var31);
 			} else if(this.theWorld == null) {
 				this.displayGuiScreen(new GuiMainMenu());
@@ -317,7 +329,7 @@
 		try {
 			while(this.running) {
 				if(this.theWorld != null) {
-					this.theWorld.updateLighting();
+					this.theWorld.updatingLighting();
 				}
 
 				if(this.mcCanvas == null && Display.isCloseRequested()) {
@@ -347,9 +359,10 @@
 							this.toggleFullscreen();
 						}
 
-						Thread.sleep(10L);
+						if (!this.options.limitFramerate) Display.sync(60);
 					}
 
+					this.screenshotListener();
 					if(this.mcCanvas != null && !this.fullscreen && (this.mcCanvas.getWidth() != this.displayWidth || this.mcCanvas.getHeight() != this.displayHeight)) {
 						this.displayWidth = this.mcCanvas.getWidth();
 						this.displayHeight = this.mcCanvas.getHeight();
@@ -357,7 +370,7 @@
 					}
 
 					if(this.options.limitFramerate) {
-						Thread.sleep(5L);
+						Display.sync(60);
 					}
 
 					++var28;
@@ -378,7 +391,7 @@
 
 			return;
 		} catch (MinecraftError var19) {
-		} catch (Exception var20) {
+		} catch (Throwable var20) {
 			var20.printStackTrace();
 			return;
 		} finally {
@@ -451,7 +464,6 @@
 				if(var1 == 0 && !(this.playerController instanceof PlayerControllerCreative)) {
 					this.leftClickCounter = 10;
 				}
-
 			} else {
 				ItemStack var9;
 				if(this.objectMouseOver.typeOfHit == 1) {
@@ -462,7 +474,9 @@
 						var9 = var11.getStackInSlot(var11.currentItem);
 						int var17 = var9 != null ? Item.itemsList[var9.itemID].getDamageVsEntity() : 1;
 						if(var17 > 0) {
-							var14.attackEntityFrom(var12, var17);
+							if (var14.attackEntityFrom(var12, var17) && var14 instanceof EntityLiving && ((EntityLiving) var14).health <= 0) {
+								this.thePlayer.getScore += var14.scoreValue;
+							}
 							var2 = var12.inventory.getCurrentItem();
 							if(var2 != null && var14 instanceof EntityLiving) {
 								EntityLiving var8 = (EntityLiving)var14;
@@ -490,7 +504,9 @@
 					} else {
 						var9 = this.thePlayer.inventory.getCurrentItem();
 						int var16 = this.theWorld.getBlockId(var10, var3, var13);
-						if(var16 > 0 && Block.blocksList[var16].blockActivated(this.theWorld, var10, var3, var13, this.thePlayer)) {
+						if(!Keyboard.isKeyDown(this.options.keyBindFlyDown.keyCode)
+								&& var16 > 0 && Block.blocksList[var16].blockActivated(this.theWorld, var10, var3, var13, this.thePlayer)) {
+							this.entityRenderer.itemRenderer.equippedItemRender();
 							return;
 						}
 
@@ -629,19 +645,29 @@
 
 								if(Mouse.getEventButton() == 2 && Mouse.getEventButtonState() && this.objectMouseOver != null) {
 									var2 = this.theWorld.getBlockId(this.objectMouseOver.blockX, this.objectMouseOver.blockY, this.objectMouseOver.blockZ);
-									if(var2 == Block.grass.blockID) {
-										var2 = Block.dirt.blockID;
-									}
-
-									if(var2 == Block.stairDouble.blockID) {
-										var2 = Block.stairSingle.blockID;
+									if(!this.playerController.isInTestMode) {
+										if(var2 == Block.grass.blockID) {
+											var2 = Block.dirt.blockID;
+										}
+
+										if(var2 == Block.stairDouble.blockID) {
+											var2 = Block.stairSingle.blockID;
+										}
+
+										if(var2 == Block.woodStairDouble.blockID) {
+											var2 = Block.woodStairSingle.blockID;
+										}
 									}
 
 									if(var2 == Block.bedrock.blockID) {
 										var2 = Block.stone.blockID;
 									}
 
+									int prevItem = this.thePlayer.inventory.currentItem;
 									this.thePlayer.inventory.getFirstEmptyStack(var2);
+									if (this.thePlayer.inventory.currentItem == prevItem && this.playerController.isInTestMode) {
+										this.thePlayer.inventory.setInventorySlotContents(prevItem, new ItemStack(var2));
+									}
 								}
 							}
 						} else if(this.currentScreen != null) {
@@ -719,12 +745,21 @@
 										}
 									}
 
+									if(Keyboard.getEventKey() == Keyboard.KEY_F1) {
+										this.options.showHUD = !this.options.showHUD;
+									}
+
+									if(Keyboard.getEventKey() == Keyboard.KEY_F3) {
+										this.options.showFPS = !this.options.showFPS;
+									}
+
 									if(Keyboard.getEventKey() == Keyboard.KEY_F5) {
 										this.options.thirdPersonView = !this.options.thirdPersonView;
 									}
 
 									if(Keyboard.getEventKey() == this.options.keyBindInventory.keyCode) {
-										this.displayGuiScreen(new GuiInventory(this.thePlayer.inventory));
+										this.displayGuiScreen(this.playerController.isInTestMode
+												? new GuiSelectBlock() : new GuiInventory(this.thePlayer.inventory));
 									}
 
 									if(Keyboard.getEventKey() == this.options.keyBindDrop.keyCode) {
@@ -768,57 +803,63 @@
 			}
 		}
 
+		this.sndManager.playRandomMusicIfReady(0, 0, 0);
+
 		if(this.theWorld != null) {
+			this.theWorld.renderDistance = this.options.getRenderDistance();
 			this.theWorld.difficultySetting = this.options.difficulty;
+
 			if(!this.isGamePaused) {
 				this.entityRenderer.updateRenderer();
-			}
-
-			if(!this.isGamePaused) {
 				this.renderGlobal.updateClouds();
-			}
-
-			if(!this.isGamePaused) {
 				this.theWorld.updateEntities();
-			}
-
-			if(!this.isGamePaused) {
 				this.theWorld.tick();
-			}
-
-			if(!this.isGamePaused) {
 				this.theWorld.randomDisplayUpdates((int)this.thePlayer.posX, (int)this.thePlayer.posY, (int)this.thePlayer.posZ);
-			}
-
-			if(!this.isGamePaused) {
 				this.effectRenderer.updateEffects();
+
+				if (this.thePlayer.getTravelDistance(0.0F) >= 1.0F && this.thePlayer.ticksExisted > 20) {
+					this.travel();
+				}
 			}
 		}
 
 	}
 
-	public final void generateLevel(int var1, int var2, int var3, int var4) {
+	public final void startWorld(int width, int length, int height,
+	                             LevelType type, LevelTheme theme, LevelStructure structure) {
+		this.worldInfo.levelX = 0;
+		this.worldInfo.levelZ = 0;
+		this.worldInfo.levelWidth = width;
+		this.worldInfo.levelLength = length;
+		this.worldInfo.levelHeight = height;
+		this.worldInfo.levelType = type;
+		this.worldInfo.levelTheme = theme;
+		this.worldInfo.levelStructure = structure;
+		this.worldInfo.worldTime = 0;
+		this.worldInfo.playerScore = 0;
+		this.generateLevel(width, length, height,
+				type != null ? type : LevelType.getRandomGen(),
+				theme != null ? theme : LevelTheme.getRandomGen(),
+				structure != null ? structure : LevelStructure.getRandomGen());
+		try {
+			this.saveWorld();
+		} catch (IOException e) {
+		}
+	}
+
+	public final void generateLevel(int width, int length, int height,
+	                                LevelType type, LevelTheme theme, LevelStructure structure) {
 		this.setLevel((World)null);
 		System.gc();
 		String var5 = this.session != null ? this.session.username : "anonymous";
 		LevelGenerator var6 = new LevelGenerator(this.loadingScreen);
-		var6.islandGen = var3 == 1;
-		var6.floatingGen = var3 == 2;
-		var6.flatGen = var3 == 3;
-		var6.levelType = var4;
-		var1 = 128 << var1;
-		var3 = var1;
-		short var8 = 64;
-		if(var2 == 1) {
-			var1 /= 2;
-			var3 <<= 1;
-		} else if(var2 == 2) {
-			var1 /= 2;
-			var3 = var1;
-			var8 = 256;
-		}
-
-		World var7 = var6.generate(var5, var1, var3, var8);
+		var6.levelType = type;
+		var6.levelTheme = theme;
+		var6.levelStructure = structure;
+		var6.generateHouse = !this.adventureMode || this.worldInfo.levelX == 0 && this.worldInfo.levelZ == 0;
+		var6.spawnMobs = !this.worldInfo.creative;
+		var6.survivalWorld = !this.worldInfo.creative;
+		World var7 = var6.generate(var5, width, length, height);
 		this.setLevel(var7);
 	}
 
@@ -839,6 +880,8 @@
 
 		if(var1 != null) {
 			var1.load();
+			this.worldInfo.creative = !var1.survivalWorld;
+			this.playerController = var1.survivalWorld ? new PlayerControllerSP(this) : new PlayerControllerCreative(this);
 			this.playerController.onWorldChange(var1);
 			this.thePlayer = (EntityPlayerSP)var1.findSubclassOf(EntityPlayerSP.class);
 			var1.playerEntity = this.thePlayer;
@@ -867,13 +910,286 @@
 			this.textureWaterFX.textureId = 0;
 			this.textureLavaFX.textureId = 0;
 			int var4 = this.renderEngine.getTexture("/water.png");
-			if(var1.defaultFluid == Block.waterMoving.blockID) {
-				this.textureWaterFX.textureId = var4;
-			} else {
+			if(var1.defaultFluid == Block.lavaMoving.blockID) {
 				this.textureLavaFX.textureId = var4;
+			} else {
+				this.textureWaterFX.textureId = var4;
 			}
 		}
 
 		System.gc();
+	}
+
+	public final void saveWorld() throws IOException {
+		this.worldInfo.worldTime = this.theWorld.worldTime;
+		this.worldInfo.playerScore = this.thePlayer.getScore;
+		this.worldDir.mkdirs();
+
+		// Player
+		NBTTagCompound worldInfoCompound = new NBTTagCompound();
+		this.worldInfo.writeToNBT(worldInfoCompound);
+
+		NBTTagCompound playerCompound = new NBTTagCompound();
+		this.thePlayer.writeToNBT(playerCompound);
+		playerCompound.setCompoundTag("WorldInfo", worldInfoCompound);
+
+		File playerFile = new File(this.worldDir, "player.dat");
+		try (OutputStream playerStream = Files.newOutputStream(playerFile.toPath())) {
+			try (DataOutputStream playerDataStream = new DataOutputStream(new GZIPOutputStream(playerStream))) {
+				NBTBase.writeTag(playerCompound, playerDataStream);
+			}
+		}
+
+		// Level
+		File levelFile = new File(this.worldDir, this.worldInfo.levelX + "," + this.worldInfo.levelZ + ".dat");
+		try (OutputStream levelOutputStream = Files.newOutputStream(levelFile.toPath())) {
+			new PlayerLoader(this, this.loadingScreen).save(this.theWorld, levelOutputStream);
+		}
+	}
+
+	public final boolean loadWorld() throws IOException {
+		if (!this.worldDir.exists()) return false;
+
+		// Player
+		File playerFile = new File(this.worldDir, "player.dat");
+		if (!playerFile.exists()) return false;
+
+		NBTTagCompound playerCompound;
+		try (InputStream playerStream = Files.newInputStream(playerFile.toPath())) {
+			try (DataInputStream playerDataStream = new DataInputStream(new GZIPInputStream(playerStream))) {
+				NBTBase playerTag = NBTBase.readTag(playerDataStream);
+				if (!(playerTag instanceof NBTTagCompound)) {
+					return false;
+				}
+				playerCompound = (NBTTagCompound)playerTag;
+			}
+		}
+
+		this.worldInfo.readFromNBT(playerCompound.getCompoundTag("WorldInfo"));
+
+		// Level
+		File levelFile = new File(this.worldDir, this.worldInfo.levelX + "," + this.worldInfo.levelZ + ".dat");
+		if (!levelFile.exists()) return false;
+
+		try (InputStream levelStream = Files.newInputStream(levelFile.toPath())) {
+			World world = new PlayerLoader(this, this.loadingScreen).load(levelStream);
+			this.setLevel(world);
+		}
+
+		if (this.theWorld == null || this.thePlayer == null) return false;
+		this.thePlayer.readFromNBT(playerCompound);
+		this.theWorld.worldTime = this.worldInfo.worldTime;
+		this.thePlayer.getScore = this.worldInfo.playerScore;
+
+		return true;
+	}
+
+	public void travel() {
+		int x = (int)Math.signum(this.thePlayer.posX);
+		int z = (int)Math.signum(this.thePlayer.posZ);
+		if (Math.abs(this.thePlayer.posX - this.theWorld.width / 2.0F)
+				> Math.abs((this.thePlayer.posZ - this.theWorld.length / 2.0F)
+						* this.theWorld.width / this.theWorld.length)) {
+			z = 0;
+		} else {
+			x = 0;
+		}
+
+		try {
+			this.saveWorld();
+		} catch (IOException e) {
+			this.wrapAround(x != 0, z != 0);
+			return;
+		}
+
+		this.worldInfo.worldTime = this.theWorld.worldTime;
+		this.worldInfo.playerScore = this.thePlayer.getScore;
+
+		EntityPlayerSP player = this.thePlayer;
+
+		this.worldInfo.levelX += x;
+		this.worldInfo.levelZ += z;
+
+		boolean levelLoaded = false;
+		File levelFile = new File(this.worldDir, this.worldInfo.levelX + "," + this.worldInfo.levelZ + ".dat");
+		if (levelFile.exists()) {
+			try (InputStream levelStream = Files.newInputStream(levelFile.toPath())) {
+				World world = new PlayerLoader(this, this.loadingScreen).load(levelStream);
+				this.setLevel(world);
+				levelLoaded = true;
+			} catch (IOException e) {
+			}
+		}
+
+		if (!levelLoaded) {
+			this.generateLevel(this.worldInfo.levelWidth, this.worldInfo.levelLength, this.worldInfo.levelHeight,
+					LevelType.getRandomGen(), LevelTheme.getRandomGen(), LevelStructure.getRandomGen());
+		}
+
+		if (this.theWorld.playerEntity != null) {
+			this.theWorld.releaseEntitySkin(this.theWorld.playerEntity);
+			this.theWorld.playerEntity = null;
+		}
+		this.thePlayer = player;
+		this.theWorld.spawnEntityInWorld(this.thePlayer);
+		this.theWorld.playerEntity = this.thePlayer;
+		this.theWorld.worldTime = this.worldInfo.worldTime;
+		this.thePlayer.getScore = this.worldInfo.playerScore;
+		this.wrapAround(x != 0, z != 0);
+		this.playerController.onRespawn(this.thePlayer);
+
+		try {
+			this.saveWorld();
+		} catch (IOException e) {
+		}
+	}
+
+	private void wrapAround(boolean x, boolean z) {
+		if (x) {
+			this.thePlayer.posX -= this.theWorld.width;
+			this.thePlayer.posX *= -1.0F;
+			this.thePlayer.posX -= Math.signum(this.thePlayer.posX);
+			this.thePlayer.prevPosX = this.thePlayer.lastTickPosX = this.thePlayer.posX;
+		}
+		if (z) {
+			this.thePlayer.posZ -= this.theWorld.length;
+			this.thePlayer.posZ *= -1.0F;
+			this.thePlayer.posZ -= Math.signum(this.thePlayer.posZ);
+			this.thePlayer.prevPosZ = this.thePlayer.lastTickPosZ = this.thePlayer.posZ;
+		}
+		this.thePlayer.posY = this.thePlayer.prevPosY = this.thePlayer.lastTickPosY
+				= Math.max(this.theWorld.groundLevel, this.theWorld.waterLevel) + this.thePlayer.height / 2.0F;
+		this.thePlayer.ticksExisted = 0;
+		this.thePlayer.setPositionAndRotation(this.thePlayer.posX, this.thePlayer.posY, this.thePlayer.posZ,
+				this.thePlayer.rotationYaw, this.thePlayer.rotationPitch);
+	}
+
+	public void deleteWorld() {
+		if (!this.worldDir.exists() || !this.worldDir.isDirectory()) return;
+
+		File[] filesToDelete = this.worldDir.listFiles();
+		if (filesToDelete == null) {
+			this.worldDir.delete();
+			return;
+		}
+
+		this.loadingScreen.displayProgressMessage("Deleting world");
+		this.loadingScreen.displayLoadingString("Deleting files..");
+
+		int progress = 0;
+
+		for (File file : filesToDelete) {
+			this.loadingScreen.setLoadingProgress(progress++ * 100 / filesToDelete.length);
+			if (file.getName().endsWith(".dat")) {
+				file.delete();
+			}
+		}
+
+		this.worldDir.delete();
+	}
+
+	public void respawn() {
+		this.thePlayer.getScore = 0;
+
+		if (this.worldInfo.levelX != 0 || this.worldInfo.levelZ != 0) {
+			try {
+				this.saveWorld();
+			} catch (IOException e) {
+			}
+
+			this.worldInfo.levelX = 0;
+			this.worldInfo.levelZ = 0;
+
+			InventoryPlayer inventory = this.thePlayer.inventory;
+			boolean levelLoaded = false;
+			File levelFile = new File(this.worldDir, "0,0.dat");
+			if (levelFile.exists()) {
+				try (InputStream levelStream = Files.newInputStream(levelFile.toPath())) {
+					World world = new PlayerLoader(this, this.loadingScreen).load(levelStream);
+					this.setLevel(world);
+					levelLoaded = true;
+				} catch (IOException e) {
+				}
+			}
+
+			if (!levelLoaded) {
+				this.generateLevel(this.worldInfo.levelWidth, this.worldInfo.levelLength, this.worldInfo.levelHeight,
+						LevelType.getRandomGen(), LevelTheme.getRandomGen(), LevelStructure.getRandomGen());
+			}
+
+			this.thePlayer.inventory = new InventoryPlayer(this.thePlayer, inventory);
+		} else {
+			this.thePlayer.preparePlayerToSpawn();
+			this.thePlayer.isDead = false;
+		}
+
+		try {
+			this.saveWorld();
+		} catch (IOException e) {
+		}
+	}
+
+	private void screenshotListener() {
+		if(Keyboard.isKeyDown(Keyboard.KEY_F2)) {
+			if(!this.isTakingScreenshot) {
+				this.isTakingScreenshot = true;
+				System.out.println(ScreenShotHelper.saveScreenshot(this.mcDataDir, this.displayWidth, this.displayHeight));
+			}
+		} else {
+			this.isTakingScreenshot = false;
+		}
+
+	}
+
+	public void shutdown() {
+		this.running = false;
+	}
+
+	public static void startMainThread(String var0, String var1) {
+		startMainThread(var0, var1, (String)null);
+	}
+
+	public static void startMainThread(String var0, String var1, String var2) {
+		boolean var3 = false;
+		Frame var5 = new Frame("Minecraft");
+		Canvas var6 = new Canvas();
+		var5.setLayout(new BorderLayout());
+		var5.add(var6, "Center");
+		var6.setPreferredSize(new Dimension(854, 480));
+		var5.pack();
+		var5.setLocationRelativeTo((Component)null);
+		MinecraftImpl var7 = new MinecraftImpl(var6, (MinecraftApplet)null, 854, 480, var3, var5);
+		Thread var8 = new Thread(var7, "Minecraft main thread");
+		var8.setPriority(10);
+		var7.appletMode = false;
+		var7.minecraftUri = "www.minecraft.net";
+		if(var0 != null && var1 != null) {
+			var7.session = new Session(var0, var1);
+		} else {
+			var7.session = new Session("Player" + System.currentTimeMillis() % 1000L, "");
+		}
+
+		if(var2 != null) {
+			String[] var9 = var2.split(":");
+			var7.setServer(var9[0], Integer.parseInt(var9[1]));
+		}
+
+		var5.setVisible(true);
+		var5.addWindowListener(new GameWindowListener(var7, var8));
+		var8.start();
+	}
+
+	public static void main(String[] var0) {
+		String var1 = "Player" + System.currentTimeMillis() % 1000L;
+		if(var0.length > 0) {
+			var1 = var0[0];
+		}
+
+		String var2 = "-";
+		if(var0.length > 1) {
+			var2 = var0[1];
+		}
+
+		startMainThread(var1, var2);
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageSoiling.java
@@ -1,0 +1,113 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+
+public final class StageSoiling extends TerrainGenStage {
+	private StageSoiling(Builder properties) {
+		super("Soiling..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			NoiseGenerator erosionNoise = new NoiseGeneratorOctaves(rand, 8);
+			NoiseGenerator floatingFactorNoise = new NoiseGeneratorOctaves(rand, 8);
+
+			for (int x = 0; x < blocks.width; x++) {
+				double centerDistX = Math.abs(((double)x / (blocks.width - 1.0D) - 0.5D) * 2.0D);
+				progressor.accept(x * 100.0F / (float)(blocks.width - 1));
+
+				for (int z = 0; z < blocks.length; z++) {
+					double centerDistZ = Math.abs(((double)z / (blocks.length - 1.0D) - 0.5D) * 2.0D);
+					double centerDist = Math.max(centerDistX, centerDistZ);
+					centerDist = centerDist * centerDist * centerDist;
+
+					int erosion = (int)(erosionNoise.generateNoise(
+							x * properties.erosionScale, z * properties.erosionScale)
+							/ properties.erosionDamp) + properties.erosionOffset;
+					int height = heightmap.get(x, z) + world.waterLevel;
+					int stoneHeight = height + erosion;
+					int finalHeight = Math.max(height, stoneHeight);
+					heightmap.set(x, z, Math.min(Math.max(finalHeight, 1), blocks.height - 2));
+
+					double floatingFactorF = properties.floating ? floatingFactorNoise.generateNoise(
+							x * properties.floatingFactorScale, z * properties.floatingFactorScale) / properties.floatingFactorDamp : 0.0D;
+					int floatingFactor = (int)(Math.sqrt(Math.abs(floatingFactorF)) * Math.signum(floatingFactorF) * 20.0D) + world.waterLevel;
+					floatingFactor = (int)((double)floatingFactor * (1.0D - centerDist) + centerDist * (double)blocks.height);
+					if(floatingFactor > world.waterLevel) {
+						floatingFactor = blocks.height;
+					}
+
+					for (int y = 0; y < blocks.height; y++) {
+						if (blocks.get(x, y, z) == 0 && (!properties.floating || y >= floatingFactor)) {
+							blocks.set(x, y, z,
+									y <= stoneHeight ? properties.stone.blockID
+											: y <= height ? properties.soil.blockID
+											: 0
+							);
+						}
+					}
+				}
+			}
+		});
+	}
+
+	public static class Builder {
+		private boolean floating = false;
+		private double erosionScale = 1.0D;
+		private double erosionDamp = 24.0D;
+		private int erosionOffset = -4;
+		private double floatingFactorScale = 2.3D;
+		private double floatingFactorDamp = 24.0D;
+		private Block soil = Block.dirt;
+		private Block stone = Block.stone;
+
+		public Builder floating(boolean floating) {
+			this.floating = floating;
+			return this;
+		}
+
+		public Builder erosionScale(double erosionScale) {
+			this.erosionScale = erosionScale;
+			return this;
+		}
+
+		public Builder erosionDamp(double erosionDamp) {
+			this.erosionDamp = erosionDamp;
+			return this;
+		}
+
+		public Builder erosionOffset(int erosionOffset) {
+			this.erosionOffset = erosionOffset;
+			return this;
+		}
+
+		public Builder floatingFactorScale(double floatingFactorScale) {
+			this.floatingFactorScale = floatingFactorScale;
+			return this;
+		}
+
+		public Builder floatingFactorDamp(double floatingFactorDamp) {
+			this.floatingFactorDamp = floatingFactorDamp;
+			return this;
+		}
+
+		public Builder soil(Block soil) {
+			this.soil = soil;
+			return this;
+		}
+
+		public Builder stone(Block stone) {
+			this.stone = stone;
+			return this;
+		}
+
+		public Builder applyTheme(LevelTheme theme) {
+			return this
+					.soil(theme.getSoilBlock())
+					.stone(theme.getStoneBlock());
+		}
+
+		public StageSoiling build() {
+			return new StageSoiling(this);
+		}
+	}
+}
--- /dev/null
+++ com/mojang/nbt/NBTTagIntArray.java
@@ -1,0 +1,46 @@
+package com.mojang.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+
+public final class NBTTagIntArray extends NBTBase {
+	public int[] intArray;
+
+	public NBTTagIntArray() {
+	}
+
+	public NBTTagIntArray(int[] var1) {
+		this.intArray = var1;
+	}
+
+	final void writeTagContents(DataOutput var1) throws IOException {
+		var1.writeInt(this.intArray.length);
+		ByteBuffer buffer = ByteBuffer.allocate(this.intArray.length * 4);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asIntBuffer().put(this.intArray);
+		byte[] bytes = buffer.array();
+		var1.write(bytes);
+	}
+
+	final void readTagContents(DataInput var1) throws IOException {
+		int var2 = var1.readInt();
+		this.intArray = new int[var2];
+		byte[] byteArray = new byte[var2 * 4];
+		var1.readFully(byteArray);
+		ByteBuffer buffer = ByteBuffer.wrap(byteArray);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asIntBuffer().get(this.intArray);
+	}
+
+	public final byte getType() {
+		return (byte)11;
+	}
+
+	public final String toString() {
+		return "[" + this.intArray.length + " ints]";
+	}
+}
--- net/minecraft/client/gui/GuiNewLevel.java
+++ net/minecraft/client/gui/GuiNewLevel.java
@@ -1,60 +1,148 @@
 package net.minecraft.client.gui;
 
+import net.minecraft.game.level.generator.LevelStructure;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.LevelType;
+import org.lwjgl.input.Keyboard;
+
+import java.util.Random;
+
 public final class GuiNewLevel extends GuiScreen {
+	private static final Random RANDOM = new Random();
+	private static final String[] SIZE_OPTIONS = {
+			"Tiny (128)",
+			"Small (256)",
+			"Moderate (384)",
+			"Medium (512)",
+			"Large (768)",
+			"Extra Large (864)",
+			"Massive (1024)",
+	};
+	private static final int[] SIZE_VALUES = { 128, 256, 384, 512, 768, 864, 1024 };
+	private static final String[] HEIGHT_OPTIONS = {
+			"Short (64)",
+			"Normal (128)",
+			"Moderate (192)",
+			"Tall (256)",
+			"Very Tall (384)",
+			"Extreme (512)",
+	};
+	private static final int[] HEIGHT_VALUES = { 64, 128, 192, 256, 384, 512 };
+
 	private GuiScreen prevGui;
-	private String[] worldType = new String[]{"Inland", "Island", "Floating", "Flat"};
-	private String[] worldShape = new String[]{"Square", "Long", "Deep"};
-	private String[] worldSize = new String[]{"Small", "Normal", "Huge"};
-	private String[] worldTheme = new String[]{"Normal", "Hell", "Paradise", "Woods"};
-	private int selectedWorldType = 1;
-	private int selectedWorldShape = 0;
-	private int selectedWorldSize = 1;
+	private int selectedWorldType = LevelType.ISLAND.ordinal();
 	private int selectedWorldTheme = 0;
+	private int selectedWorldSize = 3;
+	private int selectedWorldHeight = 1;
+	private int selectedWorldStructure = 0;
+	private GuiSliderGeneric sizeSlider;
+	private GuiSliderGeneric heightSlider;
 
 	public GuiNewLevel(GuiScreen var1) {
 		this.prevGui = var1;
 	}
 
 	public final void initGui() {
-		this.controlList.clear();
-		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4, "Type: "));
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 24, "Shape:"));
-		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 48, "Size: "));
+		if (this.mc.adventureMode) {
+			this.selectedWorldType = -1;
+			this.selectedWorldTheme = -1;
+			this.selectedWorldStructure = -1;
+		}
+
+		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 132, 97, 20, "Survival"));
+		this.controlList.add(new GuiButton(1, this.width / 2 - 50, this.height / 4 + 156, 100, 20, "Cancel"));
+		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4, "Type: "));
 		this.controlList.add(new GuiButton(3, this.width / 2 - 100, this.height / 4 + 72, "Theme: "));
-		this.controlList.add(new GuiButton(4, this.width / 2 - 100, this.height / 4 + 96 + 12, "Create"));
-		this.controlList.add(new GuiButton(5, this.width / 2 - 100, this.height / 4 + 120 + 12, "Cancel"));
+		this.addSizeSlider(this.sizeSlider = new GuiSliderGeneric(4, this.width / 2 - 100, this.height / 4 + 24, 200, 20, "Size"), SIZE_OPTIONS, this.selectedWorldSize);
+		this.addSizeSlider(this.heightSlider = new GuiSliderGeneric(5, this.width / 2 - 100, this.height / 4 + 48, 200, 20, "Height"), HEIGHT_OPTIONS, this.selectedWorldHeight);
+		this.controlList.add(new GuiButton(6, this.width / 2 - 100, this.height / 4 + 96, "Structure: "));
+		this.controlList.add(new GuiButton(7, this.width / 2 + 3, this.height / 4 + 132, 97, 20, "Creative"));
 		this.worldOptions();
+	}
+
+	private void addSizeSlider(GuiSliderGeneric slider, String[] options, int value) {
+		slider.round = true;
+		slider.multiplier = options.length - 1;
+		slider.formatter = s -> s.label + ": " + options[(int)s.getValue()];
+		slider.sliderValue = value / slider.multiplier;
+		slider.updateText();
+		this.controlList.add(slider);
 	}
 
 	private void worldOptions() {
-		((GuiButton)this.controlList.get(0)).displayString = "Type: " + this.worldType[this.selectedWorldType];
-		((GuiButton)this.controlList.get(1)).displayString = "Shape: " + this.worldShape[this.selectedWorldShape];
-		((GuiButton)this.controlList.get(2)).displayString = "Size: " + this.worldSize[this.selectedWorldSize];
-		((GuiButton)this.controlList.get(3)).displayString = "Theme: " + this.worldTheme[this.selectedWorldTheme];
+		String randText = this.mc.adventureMode ? "Varing" : "Random";
+
+		if (this.selectedWorldType >= 0) {
+			((GuiButton)this.controlList.get(2)).displayString = "Type: "
+					+ LevelType.fromId(this.selectedWorldType) + " (" + (this.selectedWorldType + 1)
+					+ "/" + LevelType.values().length + ")";
+		} else {
+			((GuiButton)this.controlList.get(2)).displayString = "Type: " + randText;
+		}
+		if (this.selectedWorldTheme >= 0) {
+			((GuiButton)this.controlList.get(3)).displayString = "Theme: "
+					+ LevelTheme.fromId(this.selectedWorldTheme) + " (" + (this.selectedWorldTheme + 1)
+					+ "/" + LevelTheme.values().length + ")";
+		} else {
+			((GuiButton)this.controlList.get(3)).displayString = "Theme: " + randText;
+		}
+		if (this.selectedWorldStructure >= 0) {
+			((GuiButton)this.controlList.get(6)).displayString = "Structure: "
+					+ LevelStructure.fromId(this.selectedWorldStructure) + " (" + (this.selectedWorldStructure + 1)
+					+ "/" + LevelStructure.values().length + ")";
+		} else {
+			((GuiButton)this.controlList.get(6)).displayString = "Structure: " + randText;
+		}
+		this.selectedWorldSize = (int)this.sizeSlider.getValue();
+		this.selectedWorldHeight = (int)this.heightSlider.getValue();
 	}
 
 	protected final void actionPerformed(GuiButton var1) {
-		if(var1.id == 5) {
+		boolean shift = Keyboard.isKeyDown(Keyboard.KEY_LSHIFT);
+		if(var1.id == 1) {
 			this.mc.displayGuiScreen(this.prevGui);
-		} else if(var1.id == 4) {
-			this.mc.generateLevel(this.selectedWorldSize, this.selectedWorldShape, this.selectedWorldType, this.selectedWorldTheme);
+		} else if(var1.id == 0 || var1.id == 7) {
+			if (this.selectedWorldType < 0 && !this.mc.adventureMode) {
+				this.selectedWorldType = RANDOM.nextInt(LevelType.values().length);
+			}
+			if (this.selectedWorldTheme < 0 && !this.mc.adventureMode) {
+				this.selectedWorldTheme = RANDOM.nextInt(LevelTheme.values().length);
+			}
+			if (this.selectedWorldStructure < 0 && !this.mc.adventureMode) {
+				this.selectedWorldStructure = RANDOM.nextInt(LevelStructure.values().length);
+			}
+
+			int width = SIZE_VALUES[this.selectedWorldSize];
+			int length = SIZE_VALUES[this.selectedWorldSize];
+			int height = HEIGHT_VALUES[this.selectedWorldHeight];
+			this.mc.worldInfo.creative = var1.id == 7;
+			if (this.mc.adventureMode) {
+				this.mc.startWorld(width, length, height,
+						this.selectedWorldType < 0 ? null : LevelType.values()[this.selectedWorldType],
+						this.selectedWorldTheme < 0 ? null : LevelTheme.values()[this.selectedWorldTheme],
+						this.selectedWorldStructure < 0 ? null : LevelStructure.values()[this.selectedWorldStructure]);
+			} else {
+				this.mc.generateLevel(width, length, height, LevelType.values()[this.selectedWorldType], LevelTheme.values()[this.selectedWorldTheme], LevelStructure.values()[this.selectedWorldStructure]);
+			}
 			this.mc.displayGuiScreen((GuiScreen)null);
-		} else if(var1.id == 0) {
-			this.selectedWorldType = (this.selectedWorldType + 1) % this.worldType.length;
-		} else if(var1.id == 1) {
-			this.selectedWorldShape = (this.selectedWorldShape + 1) % this.worldShape.length;
 		} else if(var1.id == 2) {
-			this.selectedWorldSize = (this.selectedWorldSize + 1) % this.worldSize.length;
+			this.selectedWorldType = cycle(this.selectedWorldType, shift, LevelType.values().length);
 		} else if(var1.id == 3) {
-			this.selectedWorldTheme = (this.selectedWorldTheme + 1) % this.worldTheme.length;
+			this.selectedWorldTheme = cycle(this.selectedWorldTheme, shift, LevelTheme.values().length);
+		} else if(var1.id == 6) {
+			this.selectedWorldStructure = cycle(this.selectedWorldStructure, shift, LevelStructure.values().length);
 		}
 
 		this.worldOptions();
+	}
+
+	private static int cycle(int option, boolean back, int wrap) {
+		return Math.floorMod(option + (back ? -1 : 1) + 1, wrap + 1) - 1;
 	}
 
 	public final void drawScreen(int var1, int var2, float var3) {
 		this.drawDefaultBackground();
-		drawCenteredString(this.fontRenderer, "Generate new level", this.width / 2, 40, 16777215);
+		drawCenteredString(this.fontRenderer, this.mc.adventureMode ? "Creating " + this.mc.worldDir.getName() + "..." : "Generate new level", this.width / 2, 40, 16777215);
 		super.drawScreen(var1, var2, var3);
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/block/BlockActivator.java
@@ -1,0 +1,24 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.entity.player.EntityPlayer;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+public class BlockActivator extends Block {
+	public BlockActivator(int var1, int var2, Material var3) {
+		super(var1, var2, var3);
+	}
+
+	public boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+		for (int i = 0; i < 5; i++) {
+			var1.spawnParticle("largesmoke",
+					var2 + var1.random.nextFloat() * 1.5F - 0.25F,
+					var3 + var1.random.nextFloat() * 1.5F - 0.25F,
+					var4 + var1.random.nextFloat() * 1.5F - 0.25F,
+					0.0F, 0.0F, 0.0F);
+		}
+		var1.playSoundAtPlayer((float)var2 + 0.5F, (float)var3 + 0.5F, (float)var4 + 0.5F, "random.wood click", 0.5F, 1.0F);
+		var1.transmitPowerToNeighbors(var2, var3, var4);
+		return true;
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/NoiseModifierAccess.java
@@ -1,0 +1,16 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+
+@FunctionalInterface
+public interface NoiseModifierAccess {
+	double getValue(double x, double z, NoiseGenerator noise);
+
+	static NoiseModifierAccess constant(double value) {
+		return (x, z, noise) -> value;
+	}
+
+	static NoiseModifierAccess variation(double base, double range, double scale) {
+		return (x, z, noise) -> base + noise.generateNoiseNormalized(x * scale, z * scale) * range;
+	}
+}
--- net/minecraft/game/level/block/Block.java
+++ net/minecraft/game/level/block/Block.java
@@ -1,6 +1,8 @@
 package net.minecraft.game.level.block;
 
 import java.util.Random;
+
+import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.misc.EntityItem;
 import net.minecraft.game.entity.player.EntityPlayer;
 import net.minecraft.game.entity.player.InventoryPlayer;
@@ -30,6 +32,7 @@
 	private static boolean[] canBlockGrass = new boolean[256];
 	public static final boolean[] isBlockFluid = new boolean[256];
 	public static final int[] lightValue = new int[256];
+	public static final boolean[] conductive = new boolean[256];
 	public static final Block stone;
 	public static final BlockGrass grass;
 	public static final Block dirt;
@@ -92,6 +95,27 @@
 	public static final Block tilledField;
 	public static final Block stoneOvenIdle;
 	public static final Block stoneOvenActive;
+	public static final Block snow = (new BlockSnow(63, 81)).setHardness(0.1F).setStepSound(soundClothFootstep);
+	public static final Block ice = (new BlockIce(64, 96)).setHardness(0.5F).setLightOpacity(3).setStepSound(soundGlassFootstep);
+	public static final Block blockSnow = (new BlockSnowBlock(65, 81)).setHardness(0.2F).setStepSound(soundClothFootstep);
+	public static final Block cactus = (new BlockCactus(66, 110)).setHardness(0.4F).setStepSound(soundClothFootstep);
+	public static final BlockFlower plantBlue = (BlockFlower)(new BlockFlower(67, 108)).setHardness(0.0F).setStepSound(soundGrassFootstep);
+	public static final Block woodStairDouble = (new BlockStep(68, 4, Material.wood, true)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep);
+	public static final Block woodStairSingle = (new BlockStep(69, 4, Material.wood, false)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep);
+	public static final Block activator = (new BlockActivator(70, 53, Material.iron)).setHardness(3.0F);
+	public static final Block grate = (new BlockGrate(71, 82, Material.iron)).setHardness(1.5F).setStepSound(soundMetalFootstep);
+	public static final Block observer = (new BlockObserver(72)).setHardness(0.3F).setStepSound(soundMetalFootstep);
+	public static final Block oreCopper = (new BlockOre(73, 51)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
+	public static final Block blockCopper = (new BlockOreBlock(74, 101)).setHardness(3.0F).setResistance(10.0F).setStepSound(soundMetalFootstep);
+	public static final Block lampInactive = (new BlockLamp(75, 99, 76)).setHardness(0.3F).setStepSound(soundGlassFootstep);
+	public static final Block lampActive = (new BlockLamp(76, 100, 75)).setHardness(0.3F).setStepSound(soundGlassFootstep).setLightValue(1.0F);
+	public static final Block piston = (new BlockPiston(77, 103, 0)).setHardness(0.3F).setStepSound(soundMetalFootstep);
+	public static final Block pistonCopper = (new BlockPiston(78, 105, 1)).setHardness(0.3F).setStepSound(soundMetalFootstep);
+	public static final Block pistonGold = (new BlockPiston(79, 107, 2)).setHardness(0.3F).setStepSound(soundMetalFootstep);
+	public static final Block diode = (new BlockDiode(80)).setHardness(0.3F).setStepSound(soundMetalFootstep);
+	public static final Block magneticPlatform = (new BlockMagnetPlatform(81, 120)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block woodenGrate = (new BlockGrate(82, 127, Material.wood)).setHardness(1.5F).setStepSound(soundWoodFootstep);
+	public static final Block logicGate = (new BlockLogicGate(83)).setHardness(0.3F).setStepSound(soundMetalFootstep);
 	public int blockIndexInTexture;
 	public final int blockID;
 	private float hardness;
@@ -106,7 +130,7 @@
 	public float blockParticleGravity;
 	public final Material material;
 
-	protected Block(int var1, Material var2) {
+	public Block(int var1, Material var2) {
 		this.stepSound = soundPowderFootstep;
 		this.blockParticleGravity = 1.0F;
 		if(blocksList[var1] != null) {
@@ -120,10 +144,11 @@
 			lightOpacity[var1] = this.isOpaqueCube() ? 255 : 0;
 			canBlockGrass[var1] = this.renderAsNormalBlock();
 			isBlockFluid[var1] = false;
+			conductive[var1] = this.isConductive();
 		}
 	}
 
-	protected Block(int var1, int var2, Material var3) {
+	public Block(int var1, int var2, Material var3) {
 		this(var1, var3);
 		this.blockIndexInTexture = var2;
 	}
@@ -143,6 +168,11 @@
 		return this;
 	}
 
+	protected final Block setStepSound(StepSound var1) {
+		this.stepSound = var1;
+		return this;
+	}
+
 	public boolean renderAsNormalBlock() {
 		return true;
 	}
@@ -193,11 +223,11 @@
 		return this.blockIndexInTexture;
 	}
 
-	public final AxisAlignedBB getSelectedBoundingBoxFromPool(int var1, int var2, int var3) {
+	public AxisAlignedBB getSelectedBoundingBoxFromPool(int var1, int var2, int var3) {
 		return new AxisAlignedBB((float)var1 + this.minX, (float)var2 + this.minY, (float)var3 + this.minZ, (float)var1 + this.maxX, (float)var2 + this.maxY, (float)var3 + this.maxZ);
 	}
 
-	public AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
+	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
 		return new AxisAlignedBB((float)var1 + this.minX, (float)var2 + this.minY, (float)var3 + this.minZ, (float)var1 + this.maxX, (float)var2 + this.maxY, (float)var3 + this.maxZ);
 	}
 
@@ -265,11 +295,11 @@
 		}
 	}
 
-	public final void dropBlockAsItem(World var1, int var2, int var3, int var4, int var5) {
+	public void dropBlockAsItem(World var1, int var2, int var3, int var4, int var5) {
 		this.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, 1.0F);
 	}
 
-	public final void dropBlockAsItemWithChance(World var1, int var2, int var3, int var4, int var5, float var6) {
+	public void dropBlockAsItemWithChance(World var1, int var2, int var3, int var4, int var5, float var6) {
 		int var7 = this.quantityDropped(var1.random);
 
 		for(int var8 = 0; var8 < var7; ++var8) {
@@ -415,6 +445,37 @@
 	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
 	}
 
+	public void onEntityCollidedWithBlock(World var1, int var2, int var3, int var4, Entity var5) {
+	}
+
+	public boolean canBlockStay(World var1, int var2, int var3, int var4) {
+		return true;
+	}
+
+	public void setBoundsForRender(World var1, int var2, int var3, int var4) {
+	}
+
+	public void velocityToAddToEntity(World var1, int var2, int var3, int var4, Vec3D var5) {
+	}
+
+	public void resetBlockBounds() {
+	}
+
+	public boolean isConductive() {
+		return false;
+	}
+
+	public boolean conductWithBlock(Block block) {
+		return true;
+	}
+
+	public boolean canReceivePower(World var1, int var2, int var3, int var4, int var5) {
+		return true;
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+	}
+
 	static {
 		Block var10000 = (new BlockStone(1, 1)).setHardness(1.5F).setResistance(10.0F);
 		StepSound var1 = soundStoneFootstep;
@@ -610,12 +671,12 @@
 		var0 = var10000;
 		var0.stepSound = var1;
 		blockSteel = var0;
-		var10000 = (new BlockStep(43, true)).setHardness(2.0F).setResistance(10.0F);
+		var10000 = (new BlockStep(43, 6, Material.rock, true)).setHardness(2.0F).setResistance(10.0F);
 		var1 = soundStoneFootstep;
 		var0 = var10000;
 		var0.stepSound = var1;
 		stairDouble = var0;
-		var10000 = (new BlockStep(44, false)).setHardness(2.0F).setResistance(10.0F);
+		var10000 = (new BlockStep(44, 6, Material.rock, false)).setHardness(2.0F).setResistance(10.0F);
 		var1 = soundStoneFootstep;
 		var0 = var10000;
 		var0.stepSound = var1;
@@ -640,7 +701,7 @@
 		var0 = var10000;
 		var0.stepSound = var1;
 		cobblestoneMossy = var0;
-		var10000 = (new BlockStone(49, 37)).setHardness(10.0F).setResistance(10.0F);
+		var10000 = (new Block(49, 37, Material.rock)).setHardness(10.0F).setResistance(2000.0F);
 		var1 = soundStoneFootstep;
 		var0 = var10000;
 		var0.stepSound = var1;
--- net/minecraft/game/level/block/BlockChest.java
+++ net/minecraft/game/level/block/BlockChest.java
@@ -14,7 +14,7 @@
 public final class BlockChest extends BlockContainer {
 	private Random random = new Random();
 
-	protected BlockChest(int var1) {
+	public BlockChest(int var1) {
 		super(54, Material.wood);
 		this.blockIndexInTexture = 26;
 	}
@@ -165,6 +165,8 @@
 	}
 
 	public final boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+		if (!var1.survivalWorld) return false;
+
 		Object var6 = (TileEntityChest)var1.getBlockTileEntity(var2, var3, var4);
 		if(var1.isBlockNormalCube(var2, var3 + 1, var4)) {
 			return true;
--- net/minecraft/game/level/block/BlockFlowing.java
+++ net/minecraft/game/level/block/BlockFlowing.java
@@ -1,241 +1,255 @@
 package net.minecraft.game.level.block;
 
 import java.util.Random;
+
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.material.Material;
-import net.minecraft.game.physics.AxisAlignedBB;
 
 public final class BlockFlowing extends BlockFluid {
-	private int stillId1;
-	private int movingId1;
-	private Random rand = new Random();
-	private int[] liquidIntArray = new int[]{0, 1, 2, 3};
+	private int numAdjacentSources = 0;
+	private boolean[] isOptimalFlowDirection = new boolean[4];
+	private int[] flowCost = new int[4];
 
-	protected BlockFlowing(int var1, Material var2) {
+	public BlockFlowing(int var1, Material var2) {
 		super(var1, var2);
-		this.blockIndexInTexture = 14;
-		if(var2 == Material.lava) {
-			this.blockIndexInTexture = 30;
-		}
-
-		Block.isBlockFluid[var1] = true;
-		this.movingId1 = var1;
-		this.stillId1 = var1 + 1;
-		this.setBlockBounds(0.01F, -0.09F, 0.01F, 1.01F, 0.90999997F, 1.01F);
-		this.setTickOnLoad(true);
 	}
 
-	public final void onBlockAdded(World var1, int var2, int var3, int var4) {
-		var1.scheduleBlockUpdate(var2, var3, var4, this.movingId1);
+	private void updateFlow(World var1, int var2, int var3, int var4) {
+		int var5 = var1.getBlockMetadata(var2, var3, var4);
+		var1.setBlockAndMetadata(var2, var3, var4, this.blockID + 1, var5);
+		var1.markBlocksDirty(var2, var3, var4, var2, var3, var4);
 	}
 
 	public final void updateTick(World var1, int var2, int var3, int var4, Random var5) {
-		this.update(var1, var2, var3, var4, 0);
-	}
-
-	public final boolean update(World var1, int var2, int var3, int var4, int var5) {
-		boolean var10 = false;
-		boolean var6 = this.canFlow(var1, var2 - 1, var3, var4) || this.canFlow(var1, var2 + 1, var3, var4) || this.canFlow(var1, var2, var3, var4 - 1) || this.canFlow(var1, var2, var3, var4 + 1);
-		int var7;
+		int var6 = this.getFlowDecay(var1, var2, var3, var4);
+		boolean var7 = true;
 		int var8;
 		int var9;
-		if(var6 && var1.getBlockMaterial(var2, var3 - 1, var4) == this.material) {
-			var5 = var1.floodFill(var2, var3 - 1, var4, this.movingId1, this.stillId1);
-			if(var5 == 1) {
-				var7 = var1.fluidFlowCheck(var2, var3, var4, this.movingId1, this.stillId1);
-				if(var7 != -9999) {
-					if(var7 < 0) {
-						return false;
-					}
-
-					var8 = var7 % 1024;
-					var7 >>= 10;
-					var9 = var7 % 1024;
-					var7 >>= 10;
-					var2 = var7 % 1024;
-					var1.setBlockWithNotify(var8, var2, var9, 0);
-					return false;
-				}
-
-				return false;
-			}
-		}
-
-		var10 = this.liquidSpread2(var1, var2, var3, var4, var2, var3 - 1, var4);
-
-		for(var7 = 0; var7 < 4; ++var7) {
-			var8 = this.rand.nextInt(4 - var7) + var7;
-			var9 = this.liquidIntArray[var7];
-			this.liquidIntArray[var7] = this.liquidIntArray[var8];
-			this.liquidIntArray[var8] = var9;
-			if(this.liquidIntArray[var7] == 0 && !var10) {
-				var10 = this.liquidSpread2(var1, var2, var3, var4, var2 - 1, var3, var4);
-			}
-
-			if(this.liquidIntArray[var7] == 1 && !var10) {
-				var10 = this.liquidSpread2(var1, var2, var3, var4, var2 + 1, var3, var4);
-			}
-
-			if(this.liquidIntArray[var7] == 2 && !var10) {
-				var10 = this.liquidSpread2(var1, var2, var3, var4, var2, var3, var4 - 1);
-			}
-
-			if(this.liquidIntArray[var7] == 3 && !var10) {
-				var10 = this.liquidSpread2(var1, var2, var3, var4, var2, var3, var4 + 1);
-			}
-		}
-
-		if(!var10 && var6) {
-			if(this.rand.nextInt(3) == 0) {
-				if(this.rand.nextInt(3) == 0) {
-					var10 = false;
-
-					for(var7 = 0; var7 < 4; ++var7) {
-						var8 = this.rand.nextInt(4 - var7) + var7;
-						var9 = this.liquidIntArray[var7];
-						this.liquidIntArray[var7] = this.liquidIntArray[var8];
-						this.liquidIntArray[var8] = var9;
-						if(this.liquidIntArray[var7] == 0 && !var10) {
-							var10 = this.liquidSpread(var1, var2, var3, var4, var2 - 1, var3, var4);
-						}
-
-						if(this.liquidIntArray[var7] == 1 && !var10) {
-							var10 = this.liquidSpread(var1, var2, var3, var4, var2 + 1, var3, var4);
-						}
-
-						if(this.liquidIntArray[var7] == 2 && !var10) {
-							var10 = this.liquidSpread(var1, var2, var3, var4, var2, var3, var4 - 1);
-						}
-
-						if(this.liquidIntArray[var7] == 3 && !var10) {
-							var10 = this.liquidSpread(var1, var2, var3, var4, var2, var3, var4 + 1);
-						}
-					}
-				} else if(this.material == Material.lava) {
-					var1.setBlockWithNotify(var2, var3, var4, Block.stone.blockID);
+		if(var6 > 0) {
+			this.numAdjacentSources = 0;
+			var8 = this.getSmallestFlowDecay(var1, var2 - 1, var3, var4, -100);
+			var8 = this.getSmallestFlowDecay(var1, var2 + 1, var3, var4, var8);
+			var8 = this.getSmallestFlowDecay(var1, var2, var3, var4 - 1, var8);
+			var8 = this.getSmallestFlowDecay(var1, var2, var3, var4 + 1, var8);
+			var9 = var8 + this.liquidType;
+			if(var9 >= 8 || var8 < 0) {
+				var9 = -1;
+			}
+
+			if(this.getFlowDecay(var1, var2, var3 + 1, var4) >= 0) {
+				var8 = this.getFlowDecay(var1, var2, var3 + 1, var4);
+				if(var8 >= 8) {
+					var9 = var8;
 				} else {
+					var9 = var8 + 8;
+				}
+			}
+
+			if(this.numAdjacentSources >= 2 && this.material == Material.water) {
+				var9 = 0;
+			}
+
+			if(this.material == Material.lava && var6 < 8 && var9 < 8 && var9 > var6 && var5.nextInt(4) != 0) {
+				var9 = var6;
+				var7 = false;
+			}
+
+			if(var9 != var6) {
+				var6 = var9;
+				if(var9 < 0) {
 					var1.setBlockWithNotify(var2, var3, var4, 0);
+				} else {
+					var1.setBlockMetadata(var2, var3, var4, var9);
+					var1.scheduleBlockUpdate(var2, var3, var4, this.blockID);
+					var1.notifyBlocksOfNeighborChange(var2, var3, var4, this.blockID);
 				}
+			} else if(var7) {
+				this.updateFlow(var1, var2, var3, var4);
 			}
-
-			return false;
 		} else {
-			if(this.material == Material.water) {
-				var10 |= extinguishFireLava(var1, var2 - 1, var3, var4);
-				var10 |= extinguishFireLava(var1, var2 + 1, var3, var4);
-				var10 |= extinguishFireLava(var1, var2, var3, var4 - 1);
-				var10 |= extinguishFireLava(var1, var2, var3, var4 + 1);
-			}
-
-			if(this.material == Material.lava) {
-				var10 |= flow(var1, var2 - 1, var3, var4);
-				var10 |= flow(var1, var2 + 1, var3, var4);
-				var10 |= flow(var1, var2, var3, var4 - 1);
-				var10 |= flow(var1, var2, var3, var4 + 1);
-			}
-
-			if(!var10) {
-				var1.setTileNoUpdate(var2, var3, var4, this.stillId1);
+			this.updateFlow(var1, var2, var3, var4);
+		}
+
+		if(this.liquidCanDisplaceBlock(var1, var2, var3 - 1, var4)) {
+			if(var6 >= 8) {
+				var1.setBlockAndMetadataWithNotify(var2, var3 - 1, var4, this.blockID, var6);
 			} else {
-				var1.scheduleBlockUpdate(var2, var3, var4, this.movingId1);
-			}
-
-			return var10;
-		}
-	}
-
-	private boolean liquidSpread(World var1, int var2, int var3, int var4, int var5, int var6, int var7) {
-		if(this.canFlow(var1, var5, var6, var7)) {
-			var1.setBlockWithNotify(var5, var6, var7, this.blockID);
-			var1.scheduleBlockUpdate(var5, var6, var7, this.blockID);
-			return true;
-		} else {
-			return false;
-		}
-	}
-
-	private boolean liquidSpread2(World var1, int var2, int var3, int var4, int var5, int var6, int var7) {
-		if(!this.canFlow(var1, var5, var6, var7)) {
-			return false;
-		} else {
-			var2 = var1.fluidFlowCheck(var2, var3, var4, this.movingId1, this.stillId1);
-			if(var2 != -9999) {
-				if(var2 < 0) {
-					return false;
-				}
-
-				var3 = var2 % 1024;
-				var2 >>= 10;
-				var4 = var2 % 1024;
-				var2 >>= 10;
-				var2 %= 1024;
-				if((var2 > var6 || !this.canFlow(var1, var5, var6 - 1, var7)) && var2 <= var6 && var3 != 0 && var3 != var1.width - 1 && var4 != 0 && var4 != var1.length - 1) {
-					return false;
-				}
-
-				var1.setBlockWithNotify(var3, var2, var4, 0);
-			}
-
-			var1.setBlockWithNotify(var5, var6, var7, this.blockID);
-			var1.scheduleBlockUpdate(var5, var6, var7, this.blockID);
-			return true;
-		}
-	}
-
-	public final boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
-		if(var2 >= 0 && var3 >= 0 && var4 >= 0 && var2 < var1.width && var4 < var1.length) {
+				var1.setBlockAndMetadataWithNotify(var2, var3 - 1, var4, this.blockID, var6 + 8);
+			}
+		} else {
+			if(var6 >= 0 && (var6 == 0 || blockBlocksFlow(var1, var2, var3 - 1, var4))) {
+				int var10 = var4;
+				var9 = var3;
+				var8 = var2;
+				World var15 = var1;
+
+				int var11;
+				int var12;
+				for(var11 = 0; var11 < 4; ++var11) {
+					this.flowCost[var11] = 1000;
+					var12 = var8;
+					int var13 = var10;
+					if(var11 == 0) {
+						var12 = var8 - 1;
+					}
+
+					if(var11 == 1) {
+						++var12;
+					}
+
+					if(var11 == 2) {
+						var13 = var10 - 1;
+					}
+
+					if(var11 == 3) {
+						++var13;
+					}
+
+					if(!blockBlocksFlow(var15, var12, var9, var13) && (var15.getBlockMaterial(var12, var9, var13) != this.material || var15.getBlockMetadata(var12, var9, var13) != 0)) {
+						if(!blockBlocksFlow(var15, var12, var9 - 1, var13)) {
+							this.flowCost[var11] = 0;
+						} else {
+							this.flowCost[var11] = this.calculateFlowCost(var15, var12, var9, var13, 1, var11);
+						}
+					}
+				}
+
+				var11 = this.flowCost[0];
+
+				for(var12 = 1; var12 < 4; ++var12) {
+					if(this.flowCost[var12] < var11) {
+						var11 = this.flowCost[var12];
+					}
+				}
+
+				for(var12 = 0; var12 < 4; ++var12) {
+					this.isOptimalFlowDirection[var12] = this.flowCost[var12] == var11;
+				}
+
+				boolean[] var16 = this.isOptimalFlowDirection;
+				var9 = var6 + this.liquidType;
+				if(var6 >= 8) {
+					var9 = 1;
+				}
+
+				if(var9 >= 8) {
+					return;
+				}
+
+				if(var16[0]) {
+					this.flowIntoBlock(var1, var2 - 1, var3, var4, var9);
+				}
+
+				if(var16[1]) {
+					this.flowIntoBlock(var1, var2 + 1, var3, var4, var9);
+				}
+
+				if(var16[2]) {
+					this.flowIntoBlock(var1, var2, var3, var4 - 1, var9);
+				}
+
+				if(var16[3]) {
+					this.flowIntoBlock(var1, var2, var3, var4 + 1, var9);
+				}
+			}
+
+		}
+	}
+
+	private void flowIntoBlock(World var1, int var2, int var3, int var4, int var5) {
+		if(this.liquidCanDisplaceBlock(var1, var2, var3, var4)) {
 			int var6 = var1.getBlockId(var2, var3, var4);
-			return var6 != this.movingId1 && var6 != this.stillId1 ? (var5 != 1 || var1.getBlockId(var2 - 1, var3, var4) != 0 && var1.getBlockId(var2 + 1, var3, var4) != 0 && var1.getBlockId(var2, var3, var4 - 1) != 0 && var1.getBlockId(var2, var3, var4 + 1) != 0 ? super.shouldSideBeRendered(var1, var2, var3, var4, var5) : true) : false;
-		} else {
-			return false;
-		}
-	}
-
-	public final boolean isCollidable() {
-		return false;
-	}
-
-	public final AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
-		return null;
-	}
-
-	public final boolean isOpaqueCube() {
-		return false;
-	}
-
-	public final void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
-	}
-
-	public final int tickRate() {
-		return this.material == Material.lava ? 25 : 5;
-	}
-
-	public final int quantityDropped(Random var1) {
-		return 0;
-	}
-
-	public final int getRenderBlockPass() {
-		return this.material == Material.water ? 1 : 0;
-	}
-
-	private static boolean extinguishFireLava(World var0, int var1, int var2, int var3) {
-		if(var0.getBlockId(var1, var2, var3) == Block.fire.blockID) {
-			var0.setBlockWithNotify(var1, var2, var3, 0);
-			return true;
-		} else if(var0.getBlockId(var1, var2, var3) != Block.lavaMoving.blockID && var0.getBlockId(var1, var2, var3) != Block.lavaStill.blockID) {
-			return false;
-		} else {
-			var0.setBlockWithNotify(var1, var2, var3, Block.stone.blockID);
-			return true;
-		}
-	}
-
-	private static boolean flow(World var0, int var1, int var2, int var3) {
-		if(Block.fire.getChanceOfNeighborsEncouragingFire(var0.getBlockId(var1, var2, var3))) {
-			Block.fire.fireSpread(var0, var1, var2, var3);
-			return true;
-		} else {
-			return false;
-		}
+			if(var6 > 0) {
+				if(this.material == Material.lava) {
+					triggerLavaMixEffects(var1, var2, var3, var4);
+				} else {
+					Block.blocksList[var6].dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+				}
+			}
+
+			var1.setBlockAndMetadataWithNotify(var2, var3, var4, this.blockID, var5);
+		}
+
+	}
+
+	private int calculateFlowCost(World var1, int var2, int var3, int var4, int var5, int var6) {
+		int var7 = 1000;
+
+		for(int var8 = 0; var8 < 4; ++var8) {
+			if((var8 != 0 || var6 != 1) && (var8 != 1 || var6 != 0) && (var8 != 2 || var6 != 3) && (var8 != 3 || var6 != 2)) {
+				int var9 = var2;
+				int var10 = var4;
+				if(var8 == 0) {
+					var9 = var2 - 1;
+				}
+
+				if(var8 == 1) {
+					++var9;
+				}
+
+				if(var8 == 2) {
+					var10 = var4 - 1;
+				}
+
+				if(var8 == 3) {
+					++var10;
+				}
+
+				if(!blockBlocksFlow(var1, var9, var3, var10) && (var1.getBlockMaterial(var9, var3, var10) != this.material || var1.getBlockMetadata(var9, var3, var10) != 0)) {
+					if(!blockBlocksFlow(var1, var9, var3 - 1, var10)) {
+						return var5;
+					}
+
+					if(var5 < 4) {
+						var9 = this.calculateFlowCost(var1, var9, var3, var10, var5 + 1, var8);
+						if(var9 < var7) {
+							var7 = var9;
+						}
+					}
+				}
+			}
+		}
+
+		return var7;
+	}
+
+	private static boolean blockBlocksFlow(World var0, int var1, int var2, int var3) {
+		int var4 = var0.getBlockId(var1, var2, var3);
+		if(var4 == 0 || (var4 == Block.grate.blockID && (var0.getBlockMetadata(var1, var2, var3) & 1) == 1)) {
+			return false;
+		} else {
+			Material var5 = Block.blocksList[var4].material;
+			return var5.isSolid();
+		}
+	}
+
+	private int getSmallestFlowDecay(World var1, int var2, int var3, int var4, int var5) {
+		int var6 = this.getFlowDecay(var1, var2, var3, var4);
+		if(var6 < 0) {
+			return var5;
+		} else {
+			if(var6 == 0) {
+				++this.numAdjacentSources;
+			}
+
+			if(var6 >= 8) {
+				var6 = 0;
+			}
+
+			return var5 >= 0 && var6 >= var5 ? var5 : var6;
+		}
+	}
+
+	private boolean liquidCanDisplaceBlock(World var1, int var2, int var3, int var4) {
+		Material var5 = var1.getBlockMaterial(var2, var3, var4);
+		return var5 == this.material ? false : (var5 == Material.lava ? false : !blockBlocksFlow(var1, var2, var3, var4));
+	}
+
+	public final void onBlockAdded(World var1, int var2, int var3, int var4) {
+		super.onBlockAdded(var1, var2, var3, var4);
+		if(var1.getBlockId(var2, var3, var4) == this.blockID) {
+			var1.scheduleBlockUpdate(var2, var3, var4, this.blockID);
+		}
+
 	}
 }
--- /dev/null
+++ net/minecraft/client/MinecraftImpl.java
@@ -1,0 +1,14 @@
+package net.minecraft.client;
+
+import java.awt.Canvas;
+import java.awt.Component;
+import java.awt.Frame;
+
+public final class MinecraftImpl extends Minecraft {
+	final Frame mcFrame;
+
+	public MinecraftImpl(Canvas var2, MinecraftApplet var3, int var4, int var5, boolean var6, Frame var7) {
+		super(var2, var3, var4, var5, var6);
+		this.mcFrame = var7;
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeatureBigTree.java
@@ -1,0 +1,356 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import util.MathHelper;
+
+import java.util.Random;
+
+public class FeatureBigTree implements Feature {
+	static final byte[] otherCoordPairs = new byte[]{(byte)2, (byte)0, (byte)0, (byte)1, (byte)2, (byte)1};
+	Random rand = new Random();
+	World worldObj;
+	int[] basePos = new int[]{0, 0, 0};
+	int heightLimit = 0;
+	int height;
+	double heightAttenuation = 0.618D;
+	double branchDensity = 1.0D;
+	double branchSlope = 0.381D;
+	double scaleWidth = 1.0D;
+	double leafDensity = 1.0D;
+	int trunkSize = 1;
+	int heightLimitLimit = 12;
+	int leafDistanceLimit = 5;
+	int[][] leafNodes;
+
+	void generateLeafNodeList() {
+		this.height = (int)((double)this.heightLimit * this.heightAttenuation);
+		if(this.height >= this.heightLimit) {
+			this.height = this.heightLimit - 1;
+		}
+
+		int var1 = (int)(1.382D + Math.pow(this.leafDensity * (double)this.heightLimit / 13.0D, 2.0D));
+		if(var1 < 1) {
+			var1 = 1;
+		}
+
+		int[][] var2 = new int[var1 * this.heightLimit][4];
+		int var3 = this.basePos[1] + this.heightLimit - this.leafDistanceLimit;
+		int var4 = 1;
+		int var5 = this.basePos[1] + this.height;
+		int var6 = var3 - this.basePos[1];
+		var2[0][0] = this.basePos[0];
+		var2[0][1] = var3;
+		var2[0][2] = this.basePos[2];
+		var2[0][3] = var5;
+		--var3;
+
+		while(true) {
+			while(var6 >= 0) {
+				int var7 = 0;
+				float var8 = this.layerSize(var6);
+				if(var8 < 0.0F) {
+					--var3;
+					--var6;
+				} else {
+					for(double var9 = 0.5D; var7 < var1; ++var7) {
+						double var11 = this.scaleWidth * (double)var8 * ((double)this.rand.nextFloat() + 0.328D);
+						double var13 = (double)this.rand.nextFloat() * 2.0D * 3.14159D;
+						int var15 = (int)(var11 * Math.sin(var13) + (double)this.basePos[0] + var9);
+						int var16 = (int)(var11 * Math.cos(var13) + (double)this.basePos[2] + var9);
+						int[] var17 = new int[]{var15, var3, var16};
+						int[] var18 = new int[]{var15, var3 + this.leafDistanceLimit, var16};
+						if(this.checkBlockLine(var17, var18) == -1) {
+							int[] var19 = new int[]{this.basePos[0], this.basePos[1], this.basePos[2]};
+							double var20 = Math.sqrt(Math.pow((double)Math.abs(this.basePos[0] - var17[0]), 2.0D) + Math.pow((double)Math.abs(this.basePos[2] - var17[2]), 2.0D));
+							double var22 = var20 * this.branchSlope;
+							if((double)var17[1] - var22 > (double)var5) {
+								var19[1] = var5;
+							} else {
+								var19[1] = (int)((double)var17[1] - var22);
+							}
+
+							if(this.checkBlockLine(var19, var17) == -1) {
+								var2[var4][0] = var15;
+								var2[var4][1] = var3;
+								var2[var4][2] = var16;
+								var2[var4][3] = var19[1];
+								++var4;
+							}
+						}
+					}
+
+					--var3;
+					--var6;
+				}
+			}
+
+			this.leafNodes = new int[var4][4];
+			System.arraycopy(var2, 0, this.leafNodes, 0, var4);
+			return;
+		}
+	}
+
+	void genTreeLayer(int var1, int var2, int var3, float var4, byte var5, int var6) {
+		int var7 = (int)((double)var4 + 0.618D);
+		byte var8 = otherCoordPairs[var5];
+		byte var9 = otherCoordPairs[var5 + 3];
+		int[] var10 = new int[]{var1, var2, var3};
+		int[] var11 = new int[]{0, 0, 0};
+		int var12 = -var7;
+		int var13 = -var7;
+
+		label32:
+		for(var11[var5] = var10[var5]; var12 <= var7; ++var12) {
+			var11[var8] = var10[var8] + var12;
+			var13 = -var7;
+
+			while(true) {
+				while(true) {
+					if(var13 > var7) {
+						continue label32;
+					}
+
+					double var15 = Math.sqrt(Math.pow((double)Math.abs(var12) + 0.5D, 2.0D) + Math.pow((double)Math.abs(var13) + 0.5D, 2.0D));
+					if(var15 > (double)var4) {
+						++var13;
+					} else {
+						var11[var9] = var10[var9] + var13;
+						int var14 = this.worldObj.getBlockId(var11[0], var11[1], var11[2]);
+						if(var14 != 0 && var14 != 18) {
+							++var13;
+						} else {
+							this.worldObj.setBlock(var11[0], var11[1], var11[2], var6);
+							++var13;
+						}
+					}
+				}
+			}
+		}
+
+	}
+
+	float layerSize(int var1) {
+		if((double)var1 < (double)((float)this.heightLimit) * 0.3D) {
+			return -1.618F;
+		} else {
+			float var2 = (float)this.heightLimit / 2.0F;
+			float var3 = (float)this.heightLimit / 2.0F - (float)var1;
+			float var4;
+			if(var3 == 0.0F) {
+				var4 = var2;
+			} else if(Math.abs(var3) >= var2) {
+				var4 = 0.0F;
+			} else {
+				var4 = (float)Math.sqrt(Math.pow((double)Math.abs(var2), 2.0D) - Math.pow((double)Math.abs(var3), 2.0D));
+			}
+
+			var4 *= 0.5F;
+			return var4;
+		}
+	}
+
+	float leafSize(int var1) {
+		return var1 >= 0 && var1 < this.leafDistanceLimit ? (var1 != 0 && var1 != this.leafDistanceLimit - 1 ? 3.0F : 2.0F) : -1.0F;
+	}
+
+	void generateLeafNode(int var1, int var2, int var3) {
+		int var4 = var2;
+
+		for(int var5 = var2 + this.leafDistanceLimit; var4 < var5; ++var4) {
+			float var6 = this.leafSize(var4 - var2);
+			this.genTreeLayer(var1, var4, var3, var6, (byte)1, 18);
+		}
+
+	}
+
+	void placeBlockLine(int[] var1, int[] var2, int var3) {
+		int[] var4 = new int[]{0, 0, 0};
+		byte var5 = 0;
+
+		byte var6;
+		for(var6 = 0; var5 < 3; ++var5) {
+			var4[var5] = var2[var5] - var1[var5];
+			if(Math.abs(var4[var5]) > Math.abs(var4[var6])) {
+				var6 = var5;
+			}
+		}
+
+		if(var4[var6] != 0) {
+			byte var7 = otherCoordPairs[var6];
+			byte var8 = otherCoordPairs[var6 + 3];
+			byte var9;
+			if(var4[var6] > 0) {
+				var9 = 1;
+			} else {
+				var9 = -1;
+			}
+
+			double var10 = (double)var4[var7] / (double)var4[var6];
+			double var12 = (double)var4[var8] / (double)var4[var6];
+			int[] var14 = new int[]{0, 0, 0};
+			int var15 = 0;
+
+			for(int var16 = var4[var6] + var9; var15 != var16; var15 += var9) {
+				var14[var6] = MathHelper.floor_double((double)(var1[var6] + var15) + 0.5D);
+				var14[var7] = MathHelper.floor_double((double)var1[var7] + (double)var15 * var10 + 0.5D);
+				var14[var8] = MathHelper.floor_double((double)var1[var8] + (double)var15 * var12 + 0.5D);
+				this.worldObj.setBlock(var14[0], var14[1], var14[2], var3);
+			}
+
+		}
+	}
+
+	void generateLeaves() {
+		int var1 = 0;
+
+		for(int var2 = this.leafNodes.length; var1 < var2; ++var1) {
+			int var3 = this.leafNodes[var1][0];
+			int var4 = this.leafNodes[var1][1];
+			int var5 = this.leafNodes[var1][2];
+			this.generateLeafNode(var3, var4, var5);
+		}
+
+	}
+
+	boolean leafNodeNeedsBase(int var1) {
+		return (double)var1 >= (double)this.heightLimit * 0.2D;
+	}
+
+	void generateTrunk() {
+		int var1 = this.basePos[0];
+		int var2 = this.basePos[1];
+		int var3 = this.basePos[1] + this.height;
+		int var4 = this.basePos[2];
+		int[] var5 = new int[]{var1, var2, var4};
+		int[] var6 = new int[]{var1, var3, var4};
+		this.placeBlockLine(var5, var6, 17);
+		if(this.trunkSize == 2) {
+			++var5[0];
+			++var6[0];
+			this.placeBlockLine(var5, var6, 17);
+			++var5[2];
+			++var6[2];
+			this.placeBlockLine(var5, var6, 17);
+			var5[0] += -1;
+			var6[0] += -1;
+			this.placeBlockLine(var5, var6, 17);
+		}
+
+	}
+
+	void generateLeafNodeBases() {
+		int var1 = 0;
+		int var2 = this.leafNodes.length;
+
+		for(int[] var3 = new int[]{this.basePos[0], this.basePos[1], this.basePos[2]}; var1 < var2; ++var1) {
+			int[] var4 = this.leafNodes[var1];
+			int[] var5 = new int[]{var4[0], var4[1], var4[2]};
+			var3[1] = var4[3];
+			int var6 = var3[1] - this.basePos[1];
+			if(this.leafNodeNeedsBase(var6)) {
+				this.placeBlockLine(var3, var5, 17);
+			}
+		}
+
+	}
+
+	int checkBlockLine(int[] var1, int[] var2) {
+		int[] var3 = new int[]{0, 0, 0};
+		byte var4 = 0;
+
+		byte var5;
+		for(var5 = 0; var4 < 3; ++var4) {
+			var3[var4] = var2[var4] - var1[var4];
+			if(Math.abs(var3[var4]) > Math.abs(var3[var5])) {
+				var5 = var4;
+			}
+		}
+
+		if(var3[var5] == 0) {
+			return -1;
+		} else {
+			byte var6 = otherCoordPairs[var5];
+			byte var7 = otherCoordPairs[var5 + 3];
+			byte var8;
+			if(var3[var5] > 0) {
+				var8 = 1;
+			} else {
+				var8 = -1;
+			}
+
+			double var9 = (double)var3[var6] / (double)var3[var5];
+			double var11 = (double)var3[var7] / (double)var3[var5];
+			int[] var13 = new int[]{0, 0, 0};
+			int var14 = 0;
+
+			int var15;
+			for(var15 = var3[var5] + var8; var14 != var15; var14 += var8) {
+				var13[var5] = var1[var5] + var14;
+				var13[var6] = (int)((double)var1[var6] + (double)var14 * var9);
+				var13[var7] = (int)((double)var1[var7] + (double)var14 * var11);
+				int var16 = this.worldObj.getBlockId(var13[0], var13[1], var13[2]);
+				if(var16 != 0 && var16 != 18) {
+					break;
+				}
+			}
+
+			return var14 == var15 ? -1 : Math.abs(var14);
+		}
+	}
+
+	boolean validTreeLocation() {
+		if (this.basePos[0] <= 0 || this.basePos[1] <= 0 || this.basePos[2] <= 0
+				|| this.basePos[0] >= this.worldObj.width - 1
+				|| this.basePos[1] >= this.worldObj.height - 1
+				|| this.basePos[2] >= this.worldObj.length - 1) {
+			return false;
+		}
+
+		int[] var1 = new int[]{this.basePos[0], this.basePos[1], this.basePos[2]};
+		int[] var2 = new int[]{this.basePos[0], this.basePos[1] + this.heightLimit - 1, this.basePos[2]};
+		int var3 = this.worldObj.getBlockId(this.basePos[0], this.basePos[1] - 1, this.basePos[2]);
+		if(var3 != 2 && var3 != 3) {
+			return false;
+		} else {
+			int var4 = this.checkBlockLine(var1, var2);
+			if(var4 == -1) {
+				return true;
+			} else if(var4 < 6) {
+				return false;
+			} else {
+				this.heightLimit = var4;
+				return true;
+			}
+		}
+	}
+
+	public void setScale(double var1, double var3, double var5) {
+		this.heightLimitLimit = (int)(var1 * 12.0D);
+		if(var1 > 0.5D) {
+			this.leafDistanceLimit = 5;
+		}
+
+		this.scaleWidth = var3;
+		this.leafDensity = var5;
+	}
+
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		this.worldObj = var1;
+		long var6 = var2.nextLong();
+		this.rand.setSeed(var6);
+		this.basePos[0] = var3;
+		this.basePos[1] = var4;
+		this.basePos[2] = var5;
+		this.heightLimit = 5 + this.rand.nextInt(this.heightLimitLimit);
+
+		if(!this.validTreeLocation()) {
+			return false;
+		} else {
+			this.generateLeafNodeList();
+			this.generateLeaves();
+			this.generateTrunk();
+			this.generateLeafNodeBases();
+			return true;
+		}
+	}
+}
--- net/minecraft/game/level/block/BlockSource.java
+++ net/minecraft/game/level/block/BlockSource.java
@@ -7,7 +7,7 @@
 public final class BlockSource extends Block {
 	private int fluid;
 
-	protected BlockSource(int var1, int var2) {
+	public BlockSource(int var1, int var2) {
 		super(var1, Block.blocksList[var2].blockIndexInTexture, Material.water);
 		this.fluid = var2;
 		this.setTickOnLoad(true);
--- net/minecraft/game/level/block/BlockLog.java
+++ net/minecraft/game/level/block/BlockLog.java
@@ -1,10 +1,12 @@
 package net.minecraft.game.level.block;
 
 import java.util.Random;
+
+import net.minecraft.game.level.World;
 import net.minecraft.game.level.material.Material;
 
 public final class BlockLog extends Block {
-	protected BlockLog(int var1) {
+	public BlockLog(int var1) {
 		super(17, Material.wood);
 		this.blockIndexInTexture = 20;
 	}
--- /dev/null
+++ net/minecraft/client/d.java
@@ -1,0 +1,9 @@
+package net.minecraft.client;
+
+import java.awt.*;
+
+public class d extends Minecraft {
+	public d(Canvas var1, MinecraftApplet var2, int var3, int var4, boolean var5) {
+		super(var1, var2, var3, var4, var5);
+	}
+}
--- net/minecraft/game/entity/Entity.java
+++ net/minecraft/game/entity/Entity.java
@@ -36,6 +36,7 @@
 	public boolean isCollidedHorizontally = false;
 	private boolean surfaceCollision = true;
 	public boolean isDead = false;
+	public boolean notUpdating = false;
 	public float yOffset = 0.0F;
 	public float width = 0.6F;
 	public float height = 1.8F;
@@ -60,6 +61,7 @@
 	public int heartsLife = 0;
 	public int air = 300;
 	private boolean isFirstUpdate = true;
+	public int scoreValue = 0;
 	public String skinUrl;
 
 	public Entity(World var1) {
@@ -94,7 +96,7 @@
 		this.height = var2;
 	}
 
-	protected final void setPosition(float var1, float var2, float var3) {
+	public final void setPosition(float var1, float var2, float var3) {
 		this.posX = var1;
 		this.posY = var2;
 		this.posZ = var3;
@@ -157,25 +159,28 @@
 			this.fire = 600;
 		}
 
+		float pushFactor = this.worldObj.waterLevel > this.worldObj.groundLevel && !this.worldObj.levelTheme.hasSnow() ? 0.0005F : 0.005F;
+		if (!this.worldObj.survivalWorld) pushFactor = 0.0F;
+
 		float var5;
 		if(this.posX < -8.0F) {
 			var5 = -(this.posX + 8.0F);
-			this.motionX += var5 * 0.001F;
+			this.motionX += var5 * pushFactor;
 		}
 
 		if(this.posZ < -8.0F) {
 			var5 = -(this.posZ + 8.0F);
-			this.motionZ += var5 * 0.001F;
+			this.motionZ += var5 * pushFactor;
 		}
 
 		if(this.posX > (float)this.worldObj.width + 8.0F) {
-			var5 = this.posX - (float)this.worldObj.width + 8.0F;
-			this.motionX -= var5 * 0.001F;
+			var5 = this.posX - (float)this.worldObj.width - 8.0F;
+			this.motionX -= var5 * pushFactor;
 		}
 
 		if(this.posZ > (float)this.worldObj.length + 8.0F) {
-			var5 = this.posZ - (float)this.worldObj.length + 8.0F;
-			this.motionZ -= var5 * 0.001F;
+			var5 = this.posZ - (float)this.worldObj.length - 8.0F;
+			this.motionZ -= var5 * pushFactor;
 		}
 
 		this.isFirstUpdate = false;
@@ -330,9 +335,12 @@
 			this.distanceWalkedModified = (float)((double)this.distanceWalkedModified + (double)MathHelper.sqrt_float(var20 * var20 + var19 * var19) * 0.6D);
 			if(this.canTriggerWalking) {
 				int var21 = (int)this.posX;
-				int var23 = (int)(this.posY - 0.2F - this.yOffset);
+				int var23 = (int)(this.posY - this.yOffset);
 				var17 = (int)this.posZ;
 				int var16 = this.worldObj.getBlockId(var21, var23, var17);
+				if (var16 == 0) {
+					var16 = this.worldObj.getBlockId(var21, (int)(this.posY - 0.2F - this.yOffset), var17);
+				}
 				if(this.distanceWalkedModified > (float)this.nextStepDistance && var16 > 0) {
 					++this.nextStepDistance;
 					StepSound var15 = Block.blocksList[var16].stepSound;
@@ -344,6 +352,24 @@
 				}
 			}
 
+			int iminX = MathHelper.floor_double(this.boundingBox.minX);
+			int iminY = MathHelper.floor_double(this.boundingBox.minY);
+			int iminZ = MathHelper.floor_double(this.boundingBox.minZ);
+			int imaxX = MathHelper.floor_double(this.boundingBox.maxX);
+			int imaxY = MathHelper.floor_double(this.boundingBox.maxY);
+			int imaxZ = MathHelper.floor_double(this.boundingBox.maxZ);
+
+			for(int var31 = iminX; var31 <= imaxX; ++var31) {
+				for(int var32 = iminY; var32 <= imaxY; ++var32) {
+					for(int var33 = iminZ; var33 <= imaxZ; ++var33) {
+						int var34 = this.worldObj.getBlockId(var31, var32, var33);
+						if(var34 > 0) {
+							Block.blocksList[var34].onEntityCollidedWithBlock(this.worldObj, var31, var32, var33, this);
+						}
+					}
+				}
+			}
+
 			this.ySize *= 0.4F;
 			boolean var22 = this.handleWaterMovement();
 			if(this.worldObj.isBoundingBoxBurning(this.boundingBox)) {
@@ -374,7 +400,7 @@
 	}
 
 	public final boolean handleWaterMovement() {
-		return this.worldObj.handleMaterialAcceleration(this.boundingBox.expand(0.0F, -0.4F, 0.0F), Material.water);
+		return this.worldObj.handleMaterialAcceleration(this.boundingBox.expand(0.0F, -0.4F, 0.0F), Material.water, this);
 	}
 
 	public final boolean isInsideOfWater() {
@@ -387,7 +413,7 @@
 	}
 
 	public final boolean handleLavaMovement() {
-		return this.worldObj.handleMaterialAcceleration(this.boundingBox.expand(0.0F, -0.4F, 0.0F), Material.lava);
+		return this.worldObj.handleMaterialAcceleration(this.boundingBox.expand(0.0F, -0.4F, 0.0F), Material.lava, this);
 	}
 
 	public final void moveFlying(float var1, float var2, float var3) {
@@ -431,6 +457,13 @@
 		float var2 = this.posX - var1.posX;
 		float var3 = this.posY - var1.posY;
 		float var4 = this.posZ - var1.posZ;
+		return var2 * var2 + var3 * var3 + var4 * var4;
+	}
+
+	public final float getDistanceSqToBlock(int x, int y, int z) {
+		float var2 = this.posX - x;
+		float var3 = this.posY - y;
+		float var4 = this.posZ - z;
 		return var2 * var2 + var3 * var3 + var4 * var4;
 	}
 
--- net/minecraft/game/entity/monster/EntityMob.java
+++ net/minecraft/game/entity/monster/EntityMob.java
@@ -11,6 +11,7 @@
 	public EntityMob(World var1) {
 		super(var1);
 		this.health = 20;
+		this.scoreValue = 100;
 	}
 
 	public void onLivingUpdate() {
--- /dev/null
+++ net/minecraft/game/level/block/BlockCactus.java
@@ -1,0 +1,74 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.entity.Entity;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+import net.minecraft.game.physics.AxisAlignedBB;
+
+import java.util.Random;
+
+public class BlockCactus extends Block {
+	public BlockCactus(int var1, int var2) {
+		super(var1, var2, Material.leaves);
+		this.setTickOnLoad(true);
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		if(var1.getBlockId(var2, var3 + 1, var4) == 0) {
+			int var6;
+			for(var6 = 1; var1.getBlockId(var2, var3 - var6, var4) == this.blockID; ++var6) {
+			}
+
+			if(var6 < 3) {
+				int var7 = var1.getBlockMetadata(var2, var3, var4);
+				if(var7 == 15) {
+					var1.setBlockWithNotify(var2, var3 + 1, var4, this.blockID);
+					var1.setBlockMetadata(var2, var3, var4, 0);
+				} else {
+					var1.setBlockMetadata(var2, var3, var4, var7 + 1);
+				}
+			}
+		}
+
+	}
+
+	public int getBlockTextureFromSide(int var1) {
+		return var1 == 1 ? this.blockIndexInTexture - 1 : (var1 == 0 ? this.blockIndexInTexture + 1 : this.blockIndexInTexture);
+	}
+
+	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
+		return super.canPlaceBlockAt(var1, var2, var3, var4) && this.canBlockStay(var1, var2, var3, var4);
+	}
+
+	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
+		float var4 = 1.0F / 16.0F;
+		return new AxisAlignedBB(((float)var1 + var4), var2, ((float)var3 + var4), ((float)(var1 + 1) - var4), ((float)(var2 + 1) - var4), ((float)(var3 + 1) - var4));
+	}
+
+	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
+		if(!this.canBlockStay(var1, var2, var3, var4)) {
+			this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+			var1.setBlockWithNotify(var2, var3, var4, 0);
+		}
+
+	}
+
+	public boolean canBlockStay(World var1, int var2, int var3, int var4) {
+		if(var1.getBlockMaterial(var2 - 1, var3, var4).isSolid()) {
+			return false;
+		} else if(var1.getBlockMaterial(var2 + 1, var3, var4).isSolid()) {
+			return false;
+		} else if(var1.getBlockMaterial(var2, var3, var4 - 1).isSolid()) {
+			return false;
+		} else if(var1.getBlockMaterial(var2, var3, var4 + 1).isSolid()) {
+			return false;
+		} else {
+			int var5 = var1.getBlockId(var2, var3 - 1, var4);
+			return var5 == Block.cactus.blockID || var5 == Block.sand.blockID;
+		}
+	}
+
+	public void onEntityCollidedWithBlock(World var1, int var2, int var3, int var4, Entity var5) {
+		var5.attackEntityFrom(null, 1);
+	}
+}
