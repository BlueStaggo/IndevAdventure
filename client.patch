--- net/minecraft/game/level/material/Material.java
+++ net/minecraft/game/level/material/Material.java
@@ -17,6 +17,9 @@
 	public static final Material circuits = new MaterialLogic();
 	public static final Material glass = new Material();
 	public static final Material tnt = new Material();
+	public static final Material ice = new Material();
+	public static final Material snow = new MaterialLogic();
+	public static final Material craftedSnow = new Material();
 
 	public boolean getIsLiquid() {
 		return false;
--- net/minecraft/game/level/block/BlockContainer.java
+++ net/minecraft/game/level/block/BlockContainer.java
@@ -5,7 +5,7 @@
 import net.minecraft.game.level.material.Material;
 
 public abstract class BlockContainer extends Block {
-	protected BlockContainer(int var1, Material var2) {
+	public BlockContainer(int var1, Material var2) {
 		super(var1, var2);
 	}
 
@@ -14,8 +14,8 @@
 		var1.setBlockTileEntity(var2, var3, var4, this.getBlockEntity());
 	}
 
-	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
-		super.onBlockRemoval(var1, var2, var3, var4);
+	public void onBlockRemoval(World var1, int var2, int var3, int var4, int var4a) {
+		super.onBlockRemoval(var1, var2, var3, var4, var4a);
 		var1.removeBlockTileEntity(var2, var3, var4);
 	}
 
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeatureTaiga1.java
@@ -1,0 +1,88 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+
+import java.util.Random;
+
+public class FeatureTaiga1 implements Feature {
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		int var6 = var2.nextInt(5) + 7;
+		int var7 = var6 - var2.nextInt(2) - 3;
+		int var8 = var6 - var7;
+		int var9 = 1 + var2.nextInt(var8 + 1);
+		boolean var10 = true;
+		if(var4 >= 1 && var4 + var6 + 1 <= var1.height
+				&& var3 > 0 && var3 < var1.width - 1
+				&& var5 > 0 && var5 < var1.length - 1) {
+			int var11;
+			int var13;
+			int var14;
+			int var15;
+			int var18;
+			for(var11 = var4; var11 <= var4 + 1 + var6 && var10; ++var11) {
+				boolean var12 = true;
+				if(var11 - var4 < var7) {
+					var18 = 0;
+				} else {
+					var18 = var9;
+				}
+
+				for(var13 = var3 - var18; var13 <= var3 + var18 && var10; ++var13) {
+					for(var14 = var5 - var18; var14 <= var5 + var18 && var10; ++var14) {
+						if(var11 >= 0 && var11 < var1.height) {
+							var15 = var1.getBlockId(var13, var11, var14);
+							if(var15 != 0 && var15 != Block.leaves.blockID && var15 != Block.snow.blockID) {
+								var10 = false;
+							}
+						} else {
+							var10 = false;
+						}
+					}
+				}
+			}
+
+			if(!var10) {
+				return false;
+			} else {
+				var11 = var1.getBlockId(var3, var4 - 1, var5);
+				if((var11 == Block.grass.blockID || var11 == Block.dirt.blockID) && var4 < var1.height - var6 - 1) {
+					var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
+					var18 = 0;
+
+					for(var13 = var4 + var6; var13 >= var4 + var7; --var13) {
+						for(var14 = var3 - var18; var14 <= var3 + var18; ++var14) {
+							var15 = var14 - var3;
+
+							for(int var16 = var5 - var18; var16 <= var5 + var18; ++var16) {
+								int var17 = var16 - var5;
+								if((Math.abs(var15) != var18 || Math.abs(var17) != var18 || var18 <= 0) && !Block.opaqueCubeLookup[var1.getBlockId(var14, var13, var16)]) {
+									var1.setBlock(var14, var13, var16, Block.leaves.blockID);
+								}
+							}
+						}
+
+						if(var18 >= 1 && var13 == var4 + var7 + 1) {
+							--var18;
+						} else if(var18 < var9) {
+							++var18;
+						}
+					}
+
+					for(var13 = 0; var13 < var6 - 1; ++var13) {
+						var14 = var1.getBlockId(var3, var4 + var13, var5);
+						if(var14 == 0 || var14 == Block.leaves.blockID || var14 == Block.snow.blockID) {
+							var1.setBlock(var3, var4 + var13, var5, Block.wood.blockID);
+						}
+					}
+
+					return true;
+				} else {
+					return false;
+				}
+			}
+		} else {
+			return false;
+		}
+	}
+}
--- net/minecraft/client/gui/GuiLevelDialog.java
+++ net/minecraft/client/gui/GuiLevelDialog.java
@@ -1,5 +1,7 @@
 package net.minecraft.client.gui;
 
+import net.minecraft.client.Minecraft;
+
 import java.awt.FileDialog;
 import java.io.File;
 
@@ -13,7 +15,7 @@
 	public final void run() {
 		try {
 			FileDialog var1 = this.screen.saveFileDialog();
-			File var2 = new File(this.screen.mc.mcDataDir, "saves");
+			File var2 = new File(Minecraft.getAppDir(), "saves");
 			var2.mkdir();
 			String var5 = var2.toString();
 			if(!var5.endsWith(File.separator)) {
@@ -21,10 +23,10 @@
 			}
 
 			var1.setDirectory(var5);
-			FilenameFilterLevel var6 = new FilenameFilterLevel(this);
-			var1.setFilenameFilter(var6);
+			var1.setFilenameFilter((f, s) -> s.toLowerCase().endsWith(".mclevel"));
 			var1.setLocationRelativeTo(this.screen.mc.mcCanvas);
 			var1.setVisible(true);
+			var1.requestFocusInWindow();
 			if(var1.getFile() != null) {
 				var5 = var1.getDirectory();
 				if(!var5.endsWith(File.separator)) {
@@ -32,6 +34,8 @@
 				}
 
 				GuiLoadLevel.a(this.screen, new File(var5 + var1.getFile()));
+			} else {
+				GuiLoadLevel.b(this.screen);
 			}
 		} finally {
 			GuiLoadLevel.unknown(this.screen, false);
--- net/minecraft/client/render/entity/RenderTNTPrimed.java
+++ net/minecraft/client/render/entity/RenderTNTPrimed.java
@@ -39,14 +39,14 @@
 
 		var3 = (1.0F - ((float)var7.fuse - var6 + 1.0F) / 100.0F) * 0.8F;
 		this.loadTexture("/terrain.png");
-		this.blockRenderer.renderBlockOnInventory(Block.tnt);
+		this.blockRenderer.renderBlockOnInventory(Block.tnt, 0);
 		if(var7.fuse / 5 % 2 == 0) {
 			GL11.glDisable(GL11.GL_TEXTURE_2D);
 			GL11.glDisable(GL11.GL_LIGHTING);
 			GL11.glEnable(GL11.GL_BLEND);
 			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_DST_ALPHA);
 			GL11.glColor4f(1.0F, 1.0F, 1.0F, var3);
-			this.blockRenderer.renderBlockOnInventory(Block.tnt);
+			this.blockRenderer.renderBlockOnInventory(Block.tnt, 0);
 			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 			GL11.glDisable(GL11.GL_BLEND);
 			GL11.glEnable(GL11.GL_LIGHTING);
--- net/minecraft/game/level/EntityMap.java
+++ net/minecraft/game/level/EntityMap.java
@@ -3,6 +3,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import net.minecraft.game.entity.Entity;
+import net.minecraft.game.entity.EntityLiving;
 import net.minecraft.game.physics.AxisAlignedBB;
 
 public final class EntityMap {
@@ -94,13 +95,20 @@
 		return var2 == null ? this.entitiesExcludingEntity : this.getEntities(var1, var2.minX, var2.minY, var2.minZ, var2.maxX, var2.maxY, var2.maxZ, this.entitiesExcludingEntity);
 	}
 
-	public final void updateEntities() {
+	public final void updateEntities(int dist, Entity playerEntity) {
 		for(int var1 = 0; var1 < this.entities.size(); ++var1) {
 			Entity var2 = (Entity)this.entities.get(var1);
 			var2.lastTickPosX = var2.posX;
 			var2.lastTickPosY = var2.posY;
 			var2.lastTickPosZ = var2.posZ;
-			var2.onEntityUpdate();
+			float var2dist = var2.getDistanceSqToEntity(playerEntity);
+			var2.notUpdating = var2 != playerEntity && var2dist > dist * dist;
+			if (!var2.notUpdating) {
+				var2.onEntityUpdate();
+			} else if (var2 instanceof EntityLiving && (dist > 32 || var2dist * var2dist > 1024)) {
+				var2.isDead = true;
+			}
+
 			if(var2.isDead) {
 				this.entities.remove(var1--);
 				this.slot.init(var2.lastTickPosX, var2.lastTickPosY, var2.lastTickPosZ).remove(var2);
--- net/minecraft/game/level/block/BlockStone.java
+++ net/minecraft/game/level/block/BlockStone.java
@@ -9,6 +9,9 @@
 	}
 
 	public final int idDropped(int var1, Random var2) {
+		if ((var1 & DROP_FLAG_SILK_TOUCH) != 0) {
+			return super.idDropped(var1, var2);
+		}
 		return Block.cobblestone.blockID;
 	}
 }
--- net/minecraft/client/GuiMainMenu.java
+++ net/minecraft/client/GuiMainMenu.java
@@ -1,61 +1,178 @@
 package net.minecraft.client;
 
-import net.minecraft.client.gui.GuiButton;
-import net.minecraft.client.gui.GuiLoadLevel;
-import net.minecraft.client.gui.GuiNewLevel;
-import net.minecraft.client.gui.GuiOptions;
-import net.minecraft.client.gui.GuiScreen;
+import com.mojang.nbt.NBTBase;
+import com.mojang.nbt.NBTTagCompound;
+import net.minecraft.client.gui.*;
 import net.minecraft.client.render.Tessellator;
+import net.minecraft.game.level.generator.LevelStructure;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.LevelType;
 import org.lwjgl.opengl.GL11;
 import util.MathHelper;
 
+import java.io.*;
+import java.nio.file.Files;
+import java.util.Arrays;
+import java.util.Objects;
+import java.util.function.Function;
+import java.util.zip.GZIPInputStream;
+
 public final class GuiMainMenu extends GuiScreen {
 	private float updateCounter = 0.0F;
-	private String[] splashes = new String[]{"Pre-beta!", "As seen on TV!", "Awesome!", "100% pure!", "May contain nuts!", "Better than Prey!", "More polygons!", "Sexy!", "Limited edition!", "Flashing letters!", "Made by Notch!", "Coming soon!", "Best in class!", "When it\'s finished!", "Absolutely dragon free!", "Excitement!", "More than 5000 sold!", "One of a kind!", "700+ hits on YouTube!", "Indev!", "Spiders everywhere!", "Check it out!", "Holy cow, man!", "It\'s a game!", "Made in Sweden!", "Uses LWJGL!", "Reticulating splines!", "Minecraft!", "Yaaay!", "Alpha version!", "Singleplayer!", "Keyboard compatible!", "Undocumented!", "Ingots!", "Exploding creepers!", "That\'s not a moon!", "l33t!", "Create!", "Survive!", "Dungeon!", "Exclusive!", "The bee\'s knees!", "Down with O.P.P.!", "Closed source!", "Classy!", "Wow!", "Not on steam!", "9.95 euro!", "Half price!", "Oh man!", "Check it out!", "Awesome community!", "Pixels!", "Teetsuuuuoooo!", "Kaaneeeedaaaa!", "Now with difficulty!", "Enhanced!", "90% bug free!", "Pretty!", "12 herbs and spices!", "Fat free!", "Absolutely no memes!", "Free dental!", "Ask your doctor!", "Minors welcome!", "Cloud computing!", "Legal in Finland!", "Hard to label!", "Technically good!", "Bringing home the bacon!", "Indie!", "GOTY!", "Ceci n\'est pas une title screen!", "Euclidian!", "Now in 3D!", "Inspirational!", "Herregud!", "Complex cellular automata!", "Yes, sir!", "Played by cowboys!", "OpenGL 1.1!", "Thousands of colors!", "Try it!", "Age of Wonders is better!", "Try the mushroom stew!", "Sensational!", "Hot tamale, hot hot tamale!", "Play him off, keyboard cat!", "Guaranteed!", "Macroscopic!", "Bring it on!", "Random splash!", "Call your mother!", "Monster infighting!", "Loved by millions!", "Ultimate edition!", "Freaky!", "You\'ve got a brand new key!", "Water proof!", "Uninflammable!", "Whoa, dude!", "All inclusive!", "Tell your friends!", "NP is not in P!", "Notch <3 Ez!", "Music by C418!"};
+	private String[] splashes = new String[]{
+			"Pre-beta!",
+			"As seen on TV!",
+			"Awesome!",
+			"100% pure!",
+			"May contain nuts!",
+			"Better than Prey!",
+			"More polygons!",
+			"Sexy!",
+			"Limited edition!",
+			"Flashing letters!",
+			"Made by Notch!",
+			"Coming soon!",
+			"Best in class!",
+			"When it's finished!",
+			"Absolutely dragon free!",
+			"Excitement!",
+			"More than 5000 sold!",
+			"One of a kind!",
+			"700+ hits on YouTube!",
+			"Indev!",
+			"Spiders everywhere!",
+			"Check it out!",
+			"Holy cow, man!",
+			"It's a game!",
+			"Made in Sweden!",
+			"Uses LWJGL!",
+			"Reticulating splines!",
+			"Minecraft!",
+			"Yaaay!",
+			"Alpha version!",
+			"Singleplayer!",
+			"Keyboard compatible!",
+			"Undocumented!",
+			"Ingots!",
+			"Exploding creepers!",
+			"That's not a moon!",
+			"l33t!",
+			"Create!",
+			"Survive!",
+			"Dungeon!",
+			"Exclusive!",
+			"The bee's knees!",
+			"Down with O.P.P.!",
+			"Closed source!",
+			"Classy!",
+			"Wow!",
+			"Not on steam!",
+			"9.95 euro!",
+			"Half price!",
+			"Oh man!",
+			"Check it out!",
+			"Awesome community!",
+			"Pixels!",
+			"Teetsuuuuoooo!",
+			"Kaaneeeedaaaa!",
+			"Now with difficulty!",
+			"Enhanced!",
+			"90% bug free!",
+			"Pretty!",
+			"12 herbs and spices!",
+			"Fat free!",
+			"Absolutely no memes!",
+			"Free dental!",
+			"Ask your doctor!",
+			"Minors welcome!",
+			"Cloud computing!",
+			"Legal in Finland!",
+			"Hard to label!",
+			"Technically good!",
+			"Bringing home the bacon!",
+			"Indie!",
+			"GOTY!",
+			"Ceci n'est pas une title screen!",
+			"Euclidian!",
+			"Now in 3D!",
+			"Inspirational!",
+			"Herregud!",
+			"Complex cellular automata!",
+			"Yes, sir!",
+			"Played by cowboys!",
+			"OpenGL 1.1!",
+			"Thousands of colors!",
+			"Try it!",
+			"Age of Wonders is better!",
+			"Try the mushroom stew!",
+			"Sensational!",
+			"Hot tamale, hot hot tamale!",
+			"Play him off, keyboard cat!",
+			"Guaranteed!",
+			"Macroscopic!",
+			"Bring it on!",
+			"Random splash!",
+			"Call your mother!",
+			"Monster infighting!",
+			"Loved by millions!",
+			"Ultimate edition!",
+			"Freaky!",
+			"You've got a brand new key!",
+			"Water proof!",
+			"Uninflammable!",
+			"Whoa, dude!",
+			"All inclusive!",
+			"Tell your friends!",
+			"NP is not in P!",
+			"Notch <3 Ez!",
+			"Music by C418!",
+			"Aw yeah! This is happenin'!",
+			"Aw yeah! This could be fun!",
+			"Somethin' buggin' you?",
+			"Hey, there's no time to relax!",
+			"Let's get 'em!",
+			"Teriaaaaa!",
+			"Also try Terraria!",
+			"Also try Diverge!",
+			"Also try Better than Adventure!",
+			"Also try ReIndev!",
+			"Also try NSSS!",
+			"Also try New Frontier Craft!",
+			"Also try Voxels in Time!",
+			"Also try Classicube!",
+			"Also try Authentic Adventure!",
+			"Also try Betaria!",
+			"Also try Tropical Adventure!",
+			"Also try Beta 1.8.X!",
+			"Also try Voxels in Time!"
+	};
 	private String currentSplash = this.splashes[(int)(Math.random() * (double)this.splashes.length)];
 
 	public final void updateScreen() {
 		this.updateCounter += 0.01F;
+		((GuiButton)this.controlList.get(3)).enabled = !ThreadSaveLevel.isBusy();
 	}
 
 	protected final void keyTyped(char var1, int var2) {
 	}
 
 	public final void initGui() {
-		this.controlList.clear();
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 48, "Generate new level..."));
-		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 72, "Load level.."));
-		this.controlList.add(new GuiButton(3, this.width / 2 - 100, this.height / 4 + 96, "Play tutorial level"));
-		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 120 + 12, "Options..."));
-		((GuiButton)this.controlList.get(2)).enabled = false;
-		if(this.mc.session == null) {
-			((GuiButton)this.controlList.get(1)).enabled = false;
-		}
-
-	}
-
-	protected final void actionPerformed(GuiButton var1) {
-		if(var1.id == 0) {
-			this.mc.displayGuiScreen(new GuiOptions(this, this.mc.options));
-		}
-
-		if(var1.id == 1) {
-			this.mc.displayGuiScreen(new GuiNewLevel(this));
-		}
-
-		if(this.mc.session != null && var1.id == 2) {
-			this.mc.displayGuiScreen(new GuiLoadLevel(this));
-		}
-
+		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 96, "Options..."));
+		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 48, "Play world..."));
+		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 72, "Play level..."));
+		this.controlList.add(new GuiButton(3, this.width / 2 - 100, this.height / 4 + 132, "Quit game"));
 	}
 
 	public final void drawScreen(int var1, int var2, float var3) {
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		this.drawDefaultBackground();
 		Tessellator var4 = Tessellator.instance;
 		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/gui/logo.png"));
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 		var4.setColorOpaque_I(16777215);
 		this.drawTexturedModalRect((this.width - 256) / 2, 30, 0, 0, 256, 49);
+		GL11.glDisable(GL11.GL_BLEND);
 		GL11.glPushMatrix();
 		GL11.glTranslatef((float)(this.width / 2 + 90), 70.0F, 0.0F);
 		GL11.glRotatef(-20.0F, 0.0F, 0.0F, 1.0F);
@@ -65,15 +182,141 @@
 		drawCenteredString(this.fontRenderer, this.currentSplash, 0, -8, 16776960);
 		GL11.glPopMatrix();
 		String var16 = "Copyright Mojang Specifications. Do not distribute.";
-		drawString(this.fontRenderer, var16, this.width - this.fontRenderer.getStringWidth(var16) - 2, this.height - 10, 16777215);
+		drawString(this.fontRenderer, var16, this.width - this.fontRenderer.getStringWidth(var16) - 2, this.height - 10, 0xFFFFFF);
+		drawString(this.fontRenderer, Minecraft.VERSION, 2, 2, 0xFFFFFF);
+		drawString(this.fontRenderer, "by BlueStaggo", 2, 12, 0xCCCCCC);
 		long var7 = Runtime.getRuntime().maxMemory();
 		long var9 = Runtime.getRuntime().totalMemory();
 		long var11 = Runtime.getRuntime().freeMemory();
 		long var13 = var7 - var11;
 		var16 = "Free memory: " + var13 * 100L / var7 + "% of " + var7 / 1024L / 1024L + "MB";
-		drawString(this.fontRenderer, var16, this.width - this.fontRenderer.getStringWidth(var16) - 2, 2, 8421504);
+		drawString(this.fontRenderer, var16, this.width - this.fontRenderer.getStringWidth(var16) - 2, 2, 0xFFFFFF);
 		var16 = "Allocated memory: " + var9 * 100L / var7 + "% (" + var9 / 1024L / 1024L + "MB)";
-		drawString(this.fontRenderer, var16, this.width - this.fontRenderer.getStringWidth(var16) - 2, 12, 8421504);
+		drawString(this.fontRenderer, var16, this.width - this.fontRenderer.getStringWidth(var16) - 2, 12, 0xFFFFFF);
 		super.drawScreen(var1, var2, var3);
+
+		if (ThreadSaveLevel.isBusy()) {
+			GL11.glEnable(GL11.GL_BLEND);
+			this.fontRenderer.alpha = Math.abs(MathHelper.cos((this.updateCounter * 100.0F + var3) / 2.5F)) * 0.75F + 0.25F;
+			drawString(this.fontRenderer, "Saving in progress...", 4, 4, 0xFFFFFF);
+			this.fontRenderer.alpha = 1.0F;
+			GL11.glDisable(GL11.GL_BLEND);
+		}
+	}
+
+	protected final void actionPerformed(GuiButton var1) {
+		if (var1.id == 0) {
+			this.mc.displayGuiScreen(new GuiOptions(this, this.mc.options));
+		}
+
+		if (var1.id == 1) {
+			this.mc.adventureMode = true;
+			GuiFileSelection fileSelection = new GuiFileSelection(
+					this, new File(Minecraft.getAppDir(), "inadv-worlds"), "Select world", GuiMainMenu::worldInfoProvider);
+			fileSelection
+					.filenameFilter((file, name) -> new File(file, name).isDirectory())
+					.callbackExisting(file -> {
+						this.mc.adventureMode = true;
+						this.mc.worldSaveLocation = file;
+						try {
+							this.mc.loadWorld();
+							this.mc.displayGuiScreen(null);
+						} catch (IOException e) {
+							e.printStackTrace();
+							this.mc.adventureMode = false;
+						}
+					})
+					.callbackNonExisting(this.mc::loadWorld)
+					.callbackDeletion(file -> {
+						this.mc.adventureMode = true;
+						this.mc.worldSaveLocation = file;
+						this.mc.displayGuiScreen(new GuiDeleteWorld(fileSelection));
+					})
+					.inputValidifier(s -> !s.isEmpty() && s.chars().allMatch(c -> Minecraft.VALID_PATH_CHARACTERS.contains((char)c)))
+					.nonExistingTitle("Enter world name");
+			this.mc.displayGuiScreen(fileSelection);
+		}
+
+		if (var1.id == 2) {
+			this.mc.adventureMode = false;
+			GuiFileSelection fileSelection = new GuiFileSelection(
+					this, new File(Minecraft.getAppDir(), "inadv-levels"), "Select level", GuiMainMenu::levelInfoProvider);
+			fileSelection
+					.filenameFilter((file, name) -> new File(file, name).isFile() && name.endsWith(".mclevel"))
+					.callbackExisting(this.mc::loadLevel)
+					.callbackNonExisting(this.mc::loadLevel)
+					.callbackDeletion(file -> {
+						this.mc.adventureMode = false;
+						this.mc.worldSaveLocation = file;
+						this.mc.displayGuiScreen(new GuiDeleteWorld(fileSelection));
+					})
+					.inputValidifier(s -> s.chars().allMatch(c -> Minecraft.VALID_PATH_CHARACTERS.contains((char)c)))
+					.nonExistingTitle("Enter level name (empty for no saving)");
+			this.mc.displayGuiScreen(fileSelection);
+		}
+
+		if (var1.id == 3) {
+			this.mc.shutdown();
+		}
+	}
+
+	private static GuiFileSelection.FileInfo levelInfoProvider(File file) {
+		NBTBase data;
+		try (InputStream levelStream = Files.newInputStream(file.toPath());
+			 DataInputStream dataStream = new DataInputStream(new GZIPInputStream(levelStream))) {
+			data = NBTBase.readTag(dataStream);
+		} catch (IOException e) {
+			return null;
+		}
+		if (!(data instanceof NBTTagCompound)) return null;
+
+		NBTTagCompound about = ((NBTTagCompound) data).getCompoundTag("About");
+		NBTTagCompound map = ((NBTTagCompound) data).getCompoundTag("Map");
+		NBTTagCompound environment = ((NBTTagCompound) data).getCompoundTag("Environment");
+		if (about == null || map == null || environment == null) return null;
+
+		return new GuiFileSelection.FileInfo(
+				LevelType.fromName(environment.getString("LevelType")),
+				LevelTheme.fromName(environment.getString("LevelTheme")),
+				LevelStructure.fromName(environment.getString("LevelStructure")),
+				map.getShort("Width"),
+				map.getShort("Height"),
+				map.getShort("Length"),
+				about.getBoolean("Creative"),
+				file.lastModified(),
+				file.length()
+		);
+	}
+
+	private static GuiFileSelection.FileInfo worldInfoProvider(File file) {
+		if (!file.isDirectory()) return null;
+
+		File dataFile = new File(file, "player.dat");
+		if (!dataFile.isFile()) return null;
+
+		NBTBase playerData;
+		try (InputStream playerStream = Files.newInputStream(dataFile.toPath());
+			 DataInputStream dataStream = new DataInputStream(new GZIPInputStream(playerStream))) {
+			playerData = NBTBase.readTag(dataStream);
+		} catch (IOException e) {
+			return null;
+		}
+
+		if (!(playerData instanceof NBTTagCompound)) return null;
+		NBTTagCompound worldInfoTag = ((NBTTagCompound) playerData).getCompoundTag("WorldInfo");
+		if (worldInfoTag == null) return null;
+
+		long fileSize = Arrays.stream(Objects.requireNonNull(file.listFiles())).mapToLong(File::length).sum();
+        return new GuiFileSelection.FileInfo(
+				LevelType.fromName(worldInfoTag.getString("CurrentLevelType")),
+				LevelTheme.fromName(worldInfoTag.getString("CurrentLevelTheme")),
+				LevelStructure.fromName(worldInfoTag.getString("CurrentLevelStructure")),
+				worldInfoTag.getInteger("LevelWidth"),
+				worldInfoTag.getInteger("LevelHeight"),
+				worldInfoTag.getInteger("LevelLength"),
+				worldInfoTag.getBoolean("Creative"),
+				dataFile.lastModified(),
+				fileSize
+		);
 	}
 }
--- /dev/null
+++ net/minecraft/client/gui/GuiTextPrompt.java
@@ -1,0 +1,76 @@
+package net.minecraft.client.gui;
+
+import org.lwjgl.opengl.GL11;
+
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+public class GuiTextPrompt extends GuiScreen {
+    private final GuiScreen parent;
+    private final String prompt;
+    private final Consumer<String> consumer;
+    private final Predicate<String> validifier;
+    private String text = "";
+    private int updateCounter;
+
+    public GuiTextPrompt(GuiScreen parent, String prompt, Consumer<String> consumer) {
+        this(parent, prompt, consumer, null);
+    }
+
+    public GuiTextPrompt(GuiScreen parent, String prompt, Consumer<String> consumer, Predicate<String> validifier) {
+        this.parent = parent;
+        this.prompt = prompt;
+        this.consumer = consumer;
+        this.validifier = validifier;
+    }
+
+    public void initGui() {
+        this.controlList.add(new GuiButton(0, this.width / 2 - 105, this.height / 2 + 15, 100, 20, "OK"));
+        this.controlList.add(new GuiButton(1, this.width / 2 + 5, this.height / 2 + 15, 100, 20, "Cancel"));
+        ((GuiButton)this.controlList.get(0)).enabled = this.validifier == null || this.validifier.test(this.text);
+    }
+
+    public void drawScreen(int var1, int var2, float var3) {
+        int padding = 5;
+        this.drawDefaultBackground();
+        GL11.glEnable(GL11.GL_TEXTURE_2D);
+        GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/dirt.png"));
+        GL11.glColor4f(0.5F, 0.5F, 0.5F, 1.0F);
+        drawGradientRect(this.width / 2 - 116, this.height / 2 - 36, this.width / 2 + 116, this.height / 2 + 46, 0xFFAAAAAA, 0xFFAAAAAA);
+        drawTexturedModalRect(this.width / 2 - 115, this.height / 2 - 35, 0, 0, 230, 80, 32);
+
+        drawCenteredString(this.fontRenderer, this.prompt, this.width / 2, this.height / 2 - 25, 0xFFFFFF);
+        drawGradientRect(this.width / 2 - 100 - padding - 1, this.height / 2 - 4 - padding - 1, this.width / 2 + 100 + padding + 1, this.height / 2 + 4 + padding + 1, 0xFFAAAAAA, 0xFFAAAAAA);
+        drawGradientRect(this.width / 2 - 100 - padding, this.height / 2 - 4 - padding, this.width / 2 + 100 + padding, this.height / 2 + 4 + padding, 0xFF000000, 0xFF000000);
+        drawString(this.fontRenderer, this.text + (this.updateCounter % 10 < 5 ? "_" : ""), this.width / 2 - 100, this.height / 2 - 4, 0xFFFFFF);
+
+        super.drawScreen(var1, var2, var3);
+    }
+
+    public void updateScreen() {
+        this.updateCounter++;
+    }
+
+    protected void keyTyped(char var1, int var2) {
+        if (var1 == '\b') {
+            if (!this.text.isEmpty()) {
+                this.text = this.text.substring(0, this.text.length() - 1);
+            }
+        } else if (var1 == '\n' || var1 == '\r') {
+            this.mc.displayGuiScreen(this.parent);
+            this.consumer.accept(this.text);
+        } else if (var2 == 1) {
+            this.mc.displayGuiScreen(this.parent);
+        } else if (var1 >= 32 && var1 < 128) { // Only ASCII characters allowed
+            this.text += var1;
+        }
+        ((GuiButton)this.controlList.get(0)).enabled = this.validifier == null || this.validifier.test(this.text);
+    }
+
+    protected void actionPerformed(GuiButton var1) {
+        this.mc.displayGuiScreen(this.parent);
+        if (var1.id == 0) {
+            this.consumer.accept(this.text);
+        }
+    }
+}
--- /dev/null
+++ net/minecraft/client/gui/GuiSliderGeneric.java
@@ -1,0 +1,151 @@
+package net.minecraft.client.gui;
+
+import net.minecraft.client.Minecraft;
+
+import org.lwjgl.opengl.GL11;
+
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.UnaryOperator;
+
+public class GuiSliderGeneric extends GuiButton {
+	public final String label;
+	public float multiplier = 1.0F;
+	public float sliderValue;
+	public boolean round;
+	public boolean dragging;
+	public boolean vertical;
+	public boolean showMultiplier;
+	public Function<GuiSliderGeneric, String> formatter = s -> s.label + ": "
+			+ (s.round ? Integer.toString((int)s.getValue()) : Float.toString(s.getValue()))
+			+ (s.multiplier == 1.0F || !s.showMultiplier ? "" : " / "
+			+ (s.round ? Integer.toString((int)s.multiplier) : Float.toString(s.multiplier)));
+	private final Consumer<Float> callback;
+
+	public GuiSliderGeneric(int id, int x, int y, int w, int h, String label) {
+		this(id, x, y, w, h, label, f -> {});
+	}
+
+	public GuiSliderGeneric(int id, int x, int y, int w, int h, String label, Consumer<Float> callback) {
+		super(id, x, y, w, h, label);
+		this.width = w;
+		this.height = h;
+		this.label = label;
+		this.displayString = this.getDisplayString();
+		this.callback = callback;
+	}
+
+	protected byte getHoverState(boolean var1) {
+		return 0;
+	}
+
+	public float getValue() {
+		float value = this.sliderValue * this.multiplier;
+		if (round) {
+			value = Math.round(value);
+		}
+		return value;
+	}
+
+	public String getDisplayString() {
+		if (this.label == null) {
+			return "";
+		}
+
+		return this.formatter.apply(this);
+	}
+
+	public void updateText() {
+		this.displayString = getDisplayString();
+	}
+
+	protected void mouseDragged(Minecraft var1, int var2, int var3) {
+		if (this.visible) {
+			if (this.dragging) {
+				float prevValue = this.sliderValue;
+
+				this.sliderValue = this.vertical
+						? (float)(var3 - (this.yPosition + 4)) / (float)(this.height - 8)
+						: (float)(var2 - (this.xPosition + 4)) / (float)(this.width - 8);
+				if (this.sliderValue < 0.0F) {
+					this.sliderValue = 0.0F;
+				}
+
+				if (this.sliderValue > 1.0F) {
+					this.sliderValue = 1.0F;
+				}
+
+				if (this.sliderValue != prevValue) {
+					this.callback.accept(this.getValue());
+				}
+
+				this.displayString = this.getDisplayString();
+			}
+
+
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			if (this.vertical) {
+				this.drawTexturedModalRect(this.xPosition, this.yPosition + (int)(this.sliderValue * (float)(this.height - 8)), 18, 112, this.width, 4);
+				this.drawTexturedModalRect(this.xPosition, this.yPosition + (int)(this.sliderValue * (float)(this.height - 8)) + 4, 18, 252, this.width, 4);
+			} else {
+				this.drawTexturedModalRect(this.xPosition + (int)(this.sliderValue * (float)(this.width - 8)), this.yPosition, 0, 66, 4, this.height);
+				this.drawTexturedModalRect(this.xPosition + (int)(this.sliderValue * (float)(this.width - 8)) + 4, this.yPosition, 196, 66, 4, this.height);
+			}
+		}
+	}
+
+	public boolean mousePressed(int var1, int var2) {
+		if (super.mousePressed(var1, var2)) {
+			this.sliderValue = this.vertical
+					? (float)(var1 - (this.yPosition + 4)) / (float)(this.height - 8)
+					: (float)(var1 - (this.xPosition + 4)) / (float)(this.width - 8);
+
+			if (this.sliderValue < 0.0F) {
+				this.sliderValue = 0.0F;
+			}
+
+			if (this.sliderValue > 1.0F) {
+				this.sliderValue = 1.0F;
+			}
+
+			this.callback.accept(this.getValue());
+			this.dragging = true;
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	public void mouseReleased(int var1, int var2) {
+		this.dragging = false;
+	}
+
+	public void mouseScrolled(float delta) {
+		if (this.multiplier == 0.0F) return;
+
+		this.sliderValue -= delta / 120.0F / this.multiplier;
+
+		if (this.sliderValue < 0.0F) {
+			this.sliderValue = 0.0F;
+		}
+
+		if (this.sliderValue > 1.0F) {
+			this.sliderValue = 1.0F;
+		}
+
+		if (delta != 0.0F) {
+			this.callback.accept(this.getValue());
+		}
+	}
+
+	public void drawButton(Minecraft var1, int var2, int var3) {
+		if (this.visible) {
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, var1.renderEngine.getTexture("/gui/gui.png"));
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		}
+
+		if (!this.vertical) {
+			super.drawButton(var1, var2, var3);
+		}
+	}
+}
--- net/minecraft/client/render/entity/RenderPlayer.java
+++ net/minecraft/client/render/entity/RenderPlayer.java
@@ -8,6 +8,7 @@
 import net.minecraft.game.item.Item;
 import net.minecraft.game.item.ItemArmor;
 import net.minecraft.game.item.ItemStack;
+import org.lwjgl.opengl.GL11;
 
 public final class RenderPlayer extends RenderLiving {
 	private ModelBiped modelBipedMain = (ModelBiped)this.mainModel;
@@ -20,10 +21,13 @@
 	}
 
 	private void renderPlayer(EntityPlayer var1, float var2, float var3, float var4, float var5, float var6) {
+		this.modelArmorChestplate.isSneaking = this.modelArmor.isSneaking = this.modelBipedMain.isSneaking = var1.isSneaking();
 		super.a(var1, var2, var3 - var1.yOffset, var4, var5, var6);
+		this.modelArmorChestplate.isSneaking = this.modelArmor.isSneaking = this.modelBipedMain.isSneaking = false;
 	}
 
 	public final void drawFirstPersonHand() {
+		this.modelBipedMain.setFirstPersonHandAngles();
 		this.modelBipedMain.bipedRightArm.render(1.0F);
 	}
 
--- net/minecraft/game/level/generator/LevelGenerator.java
+++ net/minecraft/game/level/generator/LevelGenerator.java
@@ -1,15 +1,17 @@
 package net.minecraft.game.level.generator;
 
-import java.util.ArrayList;
-import java.util.Random;
+import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import net.minecraft.game.item.ItemStack;
+import net.minecraft.game.level.EnumSkyBlock;
 import net.minecraft.game.level.MobSpawner;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.block.Block;
 import net.minecraft.game.level.block.BlockFlower;
-import net.minecraft.game.level.generator.noise.NoiseGeneratorDistort;
-import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
-import util.IProgressUpdate;
-import util.MathHelper;
+import net.minecraft.game.level.block.tileentity.TileEntityChest;
+import net.minecraft.game.level.generator.terrain.TerrainGenStage;
+import util.*;
 
 public final class LevelGenerator {
 	private IProgressUpdate guiLoading;
@@ -18,302 +20,125 @@
 	private int height;
 	private Random rand = new Random();
 	private byte[] blocksByteArray;
+	private ByteArray3D blockArray3D;
 	private int waterLevel;
 	private int groundLevel;
-	public boolean islandGen = false;
-	public boolean floatingGen = false;
-	public boolean flatGen = false;
-	public int levelType;
+	public LevelType levelType;
+	public LevelTheme levelTheme;
+	public LevelStructure levelStructure;
+	public boolean generateHouse = true;
+	public boolean spawnMobs = true;
+	public boolean survivalWorld = true;
 	private int phaseBar;
 	private int phases;
 	private float phaseBareLength = 0.0F;
 	private int[] floodFillBlocks = new int[1048576];
+	private Set<ChestPlacement> chestQueue = new HashSet<>();
+
+	private static class ChestPlacement {
+		final int x, y, z;
+		final ItemStack[] items;
+
+		public ChestPlacement(int x, int y, int z, ItemStack[] items) {
+			this.x = x;
+			this.y = y;
+			this.z = z;
+			this.items = items;
+		}
+	}
 
 	public LevelGenerator(IProgressUpdate var1) {
 		this.guiLoading = var1;
 	}
 
 	public final World generate(String var1, int var2, int var3, int var4) {
-		int var5 = 1;
-		if(this.floatingGen) {
-			var5 = (var4 - 64) / 48 + 1;
-		}
+		TerrainGenStage[] genStages = this.levelType.getTerrainGenStages(this.levelTheme);
+		TerrainGenStage[] structureStages = this.levelStructure.getTerrainGenStages(this.levelTheme);
+		int var5 = this.levelType.getLayerCount(var4);
 
-		this.phases = 13 + var5 * 4;
+		this.phases = 14 + var5 * genStages.length + structureStages.length;
 		this.guiLoading.displayProgressMessage("Generating level");
 		World var6 = new World();
+		Block fluid = levelTheme.getDefaultFluid();
+		var6.survivalWorld = this.survivalWorld;
 		var6.waterLevel = this.waterLevel;
 		var6.groundLevel = this.groundLevel;
-		this.width = var2;
-		this.depth = var3;
-		this.height = var4;
+		var6.width = this.width = var2;
+		var6.length = this.depth = var3;
+		var6.height = this.height = var4;
+		var6.levelType = this.levelType;
+		var6.levelTheme = this.levelTheme;
+		var6.levelStructure = this.levelStructure;
+		var6.skyColor = levelTheme.getSkyColor();
+		var6.fogColor = levelTheme.getFogColor();
+		var6.cloudColor = levelTheme.getCloudColor();
+		var6.skylightSubtracted = levelTheme.getSkylightSubtracted();
+		var6.skyBrightness = levelTheme.getSkyBrightness();
+		var6.defaultFluid = fluid != null ? fluid.blockID : 0;
 		this.blocksByteArray = new byte[var2 * var3 * var4];
+		this.blockArray3D = new ByteArray3D(this.blocksByteArray, var2, var3, var4);
 
 		int var7;
-		LevelGenerator var9;
-		int var21;
-		int var25;
-		int var31;
+		int x3;
+		int z;
+		int offsettedHeight;
 		int var45;
-		int var51;
-		int var52;
-		int var53;
+		int d;
+		int eX;
+		int eZ;
 		int var56;
+		IntArray2D heightmap = new IntArray2D(var2, var3);
 		for(var7 = 0; var7 < var5; ++var7) {
-			this.waterLevel = var4 - 32 - var7 * 48;
-			this.groundLevel = this.waterLevel - 2;
-			int[] var8;
-			NoiseGeneratorOctaves var13;
-			int var22;
-			double var32;
-			int[] var46;
-			if(this.flatGen) {
-				var8 = new int[var2 * var3];
-
-				for(var45 = 0; var45 < var8.length; ++var45) {
-					var8[var45] = 0;
-				}
-
-				this.loadingBar();
-				this.loadingBar();
-			} else {
-				this.guiLoading.displayLoadingString("Raising..");
-				this.loadingBar();
-				var9 = this;
-				NoiseGeneratorDistort var10 = new NoiseGeneratorDistort(new NoiseGeneratorOctaves(this.rand, 8), new NoiseGeneratorOctaves(this.rand, 8));
-				NoiseGeneratorDistort var11 = new NoiseGeneratorDistort(new NoiseGeneratorOctaves(this.rand, 8), new NoiseGeneratorOctaves(this.rand, 8));
-				NoiseGeneratorOctaves var12 = new NoiseGeneratorOctaves(this.rand, 6);
-				var13 = new NoiseGeneratorOctaves(this.rand, 2);
-				int[] var14 = new int[this.width * this.depth];
-				var22 = 0;
-
-				label349:
-				while(true) {
-					if(var22 >= var9.width) {
-						var8 = var14;
-						this.guiLoading.displayLoadingString("Eroding..");
-						this.loadingBar();
-						var46 = var14;
-						var9 = this;
-						var11 = new NoiseGeneratorDistort(new NoiseGeneratorOctaves(this.rand, 8), new NoiseGeneratorOctaves(this.rand, 8));
-						NoiseGeneratorDistort var50 = new NoiseGeneratorDistort(new NoiseGeneratorOctaves(this.rand, 8), new NoiseGeneratorOctaves(this.rand, 8));
-						var52 = 0;
-
-						while(true) {
-							if(var52 >= var9.width) {
-								break label349;
-							}
-
-							var9.setNextPhase((float)var52 * 100.0F / (float)(var9.width - 1));
-
-							for(var53 = 0; var53 < var9.depth; ++var53) {
-								double var20 = var11.generateNoise((double)(var52 << 1), (double)(var53 << 1)) / 8.0D;
-								var22 = var50.generateNoise((double)(var52 << 1), (double)(var53 << 1)) > 0.0D ? 1 : 0;
-								if(var20 > 2.0D) {
-									int var58 = var46[var52 + var53 * var9.width];
-									var58 = ((var58 - var22) / 2 << 1) + var22;
-									var46[var52 + var53 * var9.width] = var58;
-								}
-							}
-
-							++var52;
-						}
-					}
-
-					double var23 = Math.abs(((double)var22 / ((double)var9.width - 1.0D) - 0.5D) * 2.0D);
-					var9.setNextPhase((float)var22 * 100.0F / (float)(var9.width - 1));
-
-					for(var25 = 0; var25 < var9.depth; ++var25) {
-						double var26 = Math.abs(((double)var25 / ((double)var9.depth - 1.0D) - 0.5D) * 2.0D);
-						double var28 = var10.generateNoise((double)((float)var22 * 1.3F), (double)((float)var25 * 1.3F)) / 6.0D + -4.0D;
-						double var30 = var11.generateNoise((double)((float)var22 * 1.3F), (double)((float)var25 * 1.3F)) / 5.0D + 10.0D + -4.0D;
-						var32 = var12.generateNoise((double)var22, (double)var25) / 8.0D;
-						if(var32 > 0.0D) {
-							var30 = var28;
-						}
-
-						double var34 = Math.max(var28, var30) / 2.0D;
-						if(var9.islandGen) {
-							double var36 = Math.sqrt(var23 * var23 + var26 * var26) * (double)1.2F;
-							double var39 = var13.generateNoise((double)((float)var22 * 0.05F), (double)((float)var25 * 0.05F)) / 4.0D + 1.0D;
-							var36 = Math.min(var36, var39);
-							var36 = Math.max(var36, Math.max(var23, var26));
-							if(var36 > 1.0D) {
-								var36 = 1.0D;
-							}
-
-							if(var36 < 0.0D) {
-								var36 = 0.0D;
-							}
-
-							var36 *= var36;
-							var34 = var34 * (1.0D - var36) - var36 * 10.0D + 5.0D;
-							if(var34 < 0.0D) {
-								var34 -= var34 * var34 * (double)0.2F;
-							}
-						} else if(var34 < 0.0D) {
-							var34 *= 0.8D;
-						}
-
-						var14[var22 + var25 * var9.width] = (int)var34;
-					}
-
-					++var22;
-				}
-			}
-
-			this.guiLoading.displayLoadingString("Soiling..");
-			this.loadingBar();
-			var46 = var8;
-			var9 = this;
-			int var49 = this.width;
-			var51 = this.depth;
-			var52 = this.height;
-			NoiseGeneratorOctaves var54 = new NoiseGeneratorOctaves(this.rand, 8);
-			NoiseGeneratorOctaves var55 = new NoiseGeneratorOctaves(this.rand, 8);
-
-			for(var21 = 0; var21 < var49; ++var21) {
-				double var57 = Math.abs(((double)var21 / ((double)var49 - 1.0D) - 0.5D) * 2.0D);
-				var9.setNextPhase((float)var21 * 100.0F / (float)(var49 - 1));
-
-				for(int var24 = 0; var24 < var51; ++var24) {
-					double var64 = Math.abs(((double)var24 / ((double)var51 - 1.0D) - 0.5D) * 2.0D);
-					double var27 = Math.max(var57, var64);
-					var27 = var27 * var27 * var27;
-					int var29 = (int)(var54.generateNoise((double)var21, (double)var24) / 24.0D) - 4;
-					int var72 = var46[var21 + var24 * var49] + var9.waterLevel;
-					var31 = var72 + var29;
-					var46[var21 + var24 * var49] = Math.max(var72, var31);
-					if(var46[var21 + var24 * var49] > var52 - 2) {
-						var46[var21 + var24 * var49] = var52 - 2;
-					}
-
-					if(var46[var21 + var24 * var49] <= 0) {
-						var46[var21 + var24 * var49] = 1;
-					}
-
-					var32 = var55.generateNoise((double)var21 * 2.3D, (double)var24 * 2.3D) / 24.0D;
-					int var76 = (int)(Math.sqrt(Math.abs(var32)) * Math.signum(var32) * 20.0D) + var9.waterLevel;
-					var76 = (int)((double)var76 * (1.0D - var27) + var27 * (double)var9.height);
-					if(var76 > var9.waterLevel) {
-						var76 = var9.height;
-					}
-
-					for(int var35 = 0; var35 < var52; ++var35) {
-						int var79 = (var35 * var9.depth + var24) * var9.width + var21;
-						int var37 = 0;
-						if(var35 <= var72) {
-							var37 = Block.dirt.blockID;
-						}
-
-						if(var35 <= var31) {
-							var37 = Block.stone.blockID;
-						}
-
-						if(var9.floatingGen && var35 < var76) {
-							var37 = 0;
-						}
-
-						if(var9.blocksByteArray[var79] == 0) {
-							var9.blocksByteArray[var79] = (byte)var37;
-						}
-					}
-				}
-			}
-
-			this.guiLoading.displayLoadingString("Growing..");
-			this.loadingBar();
-			var46 = var8;
-			var9 = this;
-			var49 = this.width;
-			var51 = this.depth;
-			var13 = new NoiseGeneratorOctaves(this.rand, 8);
-			var54 = new NoiseGeneratorOctaves(this.rand, 8);
-			var56 = this.waterLevel - 1;
-			if(this.levelType == 2) {
-				var56 += 2;
-			}
-
-			for(var21 = 0; var21 < var49; ++var21) {
-				var9.setNextPhase((float)var21 * 100.0F / (float)(var49 - 1));
-
-				for(var22 = 0; var22 < var51; ++var22) {
-					boolean var60 = var13.generateNoise((double)var21, (double)var22) > 8.0D;
-					if(var9.islandGen) {
-						var60 = var13.generateNoise((double)var21, (double)var22) > -8.0D;
-					}
-
-					if(var9.levelType == 2) {
-						var60 = var13.generateNoise((double)var21, (double)var22) > -32.0D;
-					}
-
-					boolean var61 = var54.generateNoise((double)var21, (double)var22) > 12.0D;
-					if(var9.levelType == 1 || var9.levelType == 3) {
-						var60 = var13.generateNoise((double)var21, (double)var22) > -8.0D;
-					}
-
-					var25 = var46[var21 + var22 * var49];
-					int var65 = (var25 * var9.depth + var22) * var9.width + var21;
-					int var67 = var9.blocksByteArray[((var25 + 1) * var9.depth + var22) * var9.width + var21] & 255;
-					if((var67 == Block.waterMoving.blockID || var67 == Block.waterStill.blockID || var67 == 0) && var25 <= var9.waterLevel - 1 && var61) {
-						var9.blocksByteArray[var65] = (byte)Block.gravel.blockID;
-					}
-
-					if(var67 == 0) {
-						int var69 = -1;
-						if(var25 <= var56 && var60) {
-							var69 = Block.sand.blockID;
-							if(var9.levelType == 1) {
-								var69 = Block.grass.blockID;
-							}
-						}
-
-						if(var9.blocksByteArray[var65] != 0 && var69 > 0) {
-							var9.blocksByteArray[var65] = (byte)var69;
-						}
-					}
-				}
-			}
+			var6.waterLevel = this.waterLevel = Math.max(this.levelType.getGenHeight(var4, var7), 2);
+			var6.groundLevel = this.groundLevel = Math.max(this.waterLevel - 2, 1);
+
+			for (TerrainGenStage genStage : genStages) {
+				this.guiLoading.displayLoadingString(genStage.name);
+				this.setNextPhase(0.0F);
+				genStage.blockTransformer.transformBlocks(this.blockArray3D, heightmap, this.rand, var6, this::setNextPhase,
+						(cx, cy, cz) -> this.queueChest(cx, cy, cz, genStage.getChestItems(this.rand)));
+				this.loadingBar();
+			}
+			heightmap.clear();
 		}
 
 		this.guiLoading.displayLoadingString("Carving..");
 		this.loadingBar();
-		var9 = this;
-		var51 = this.width;
-		var52 = this.depth;
-		var53 = this.height;
-		var56 = var51 * var52 * var53 / 256 / 64 << 1;
+		d = this.width;
+		eX = this.depth;
+		eZ = this.height;
+		var56 = d * eX * eZ / 256 / 48;
 
-		for(var21 = 0; var21 < var56; ++var21) {
-			var9.setNextPhase((float)var21 * 100.0F / (float)(var56 - 1));
-			float var59 = var9.rand.nextFloat() * (float)var51;
-			float var63 = var9.rand.nextFloat() * (float)var53;
-			float var62 = var9.rand.nextFloat() * (float)var52;
-			var25 = (int)((var9.rand.nextFloat() + var9.rand.nextFloat()) * 200.0F);
-			float var66 = var9.rand.nextFloat() * (float)Math.PI * 2.0F;
+		for(x3 = 0; x3 < var56; ++x3) {
+			this.setNextPhase((float)x3 * 100.0F / (float)(var56 - 1));
+			float var59 = this.rand.nextFloat() * (float)d;
+			float var63 = this.rand.nextFloat() * (float)eZ;
+			float var62 = this.rand.nextFloat() * (float)eX;
+			z = (int)((this.rand.nextFloat() + this.rand.nextFloat()) * 250.0F);
+			float var66 = this.rand.nextFloat() * (float)Math.PI * 2.0F;
 			float var68 = 0.0F;
-			float var71 = var9.rand.nextFloat() * (float)Math.PI * 2.0F;
+			float var71 = this.rand.nextFloat() * (float)Math.PI * 2.0F;
 			float var70 = 0.0F;
-			float var73 = var9.rand.nextFloat() * var9.rand.nextFloat();
+			float var73 = this.rand.nextFloat() * (this.rand.nextFloat() * 0.65F + 0.35F);
 
-			for(var31 = 0; var31 < var25; ++var31) {
+			for(offsettedHeight = 0; offsettedHeight < z; ++offsettedHeight) {
 				var59 += MathHelper.sin(var66) * MathHelper.cos(var71);
 				var62 += MathHelper.cos(var66) * MathHelper.cos(var71);
 				var63 += MathHelper.sin(var71);
 				var66 += var68 * 0.2F;
 				var68 *= 0.9F;
-				var68 += var9.rand.nextFloat() - var9.rand.nextFloat();
+				var68 += this.rand.nextFloat() - this.rand.nextFloat();
 				var71 += var70 * 0.5F;
 				var71 *= 0.5F;
 				var70 *= 12.0F / 16.0F;
-				var70 += var9.rand.nextFloat() - var9.rand.nextFloat();
-				if(var9.rand.nextFloat() >= 0.25F) {
-					float var74 = var59 + (var9.rand.nextFloat() * 4.0F - 2.0F) * 0.2F;
-					float var33 = var63 + (var9.rand.nextFloat() * 4.0F - 2.0F) * 0.2F;
-					float var77 = var62 + (var9.rand.nextFloat() * 4.0F - 2.0F) * 0.2F;
-					float var75 = ((float)var9.height - var33) / (float)var9.height;
-					float var80 = 1.2F + (var75 * 3.5F + 1.0F) * var73;
-					float var78 = MathHelper.sin((float)var31 * (float)Math.PI / (float)var25) * var80;
+				var70 += this.rand.nextFloat() - this.rand.nextFloat();
+				if(this.rand.nextFloat() >= 0.25F) {
+					float var74 = var59 + (this.rand.nextFloat() * 4.0F - 2.0F) * 0.2F;
+					float var33 = var63 + (this.rand.nextFloat() * 4.0F - 2.0F) * 0.2F;
+					float var77 = var62 + (this.rand.nextFloat() * 4.0F - 2.0F) * 0.2F;
+					float var75 = ((float)this.height - var33) / (float)this.height;
+					float var80 = 1.5F + (var75 * 3.5F + 1.0F) * var73;
+					float var78 = MathHelper.sin((float)offsettedHeight * (float)Math.PI / (float)z) * var80;
 
 					for(var5 = (int)(var74 - var78); var5 <= (int)(var74 + var78); ++var5) {
 						for(int var81 = (int)(var33 - var78); var81 <= (int)(var33 + var78); ++var81) {
@@ -322,10 +147,11 @@
 								float var42 = (float)var81 - var33;
 								float var48 = (float)var40 - var77;
 								var41 = var41 * var41 + var42 * var42 * 2.0F + var48 * var48;
-								if(var41 < var78 * var78 && var5 > 0 && var81 > 0 && var40 > 0 && var5 < var9.width - 1 && var81 < var9.height - 1 && var40 < var9.depth - 1) {
-									var7 = (var81 * var9.depth + var40) * var9.width + var5;
-									if(var9.blocksByteArray[var7] == Block.stone.blockID) {
-										var9.blocksByteArray[var7] = 0;
+								if(var41 < var78 * var78 && var5 > 0 && var81 > 0 && var40 > 0 && var5 < this.width - 1 && var81 < this.height - 1 && var40 < this.depth - 1) {
+									var7 = (var81 * this.depth + var40) * this.width + var5;
+									int b = this.blocksByteArray[var7];
+									if(b == Block.stone.blockID) {
+										this.blocksByteArray[var7] = 0;
 									}
 								}
 							}
@@ -335,133 +161,146 @@
 			}
 		}
 
-		var7 = this.populateOre(Block.oreCoal.blockID, 1000, 10, (var4 << 2) / 5);
-		int var44 = this.populateOre(Block.oreIron.blockID, 800, 8, var4 * 3 / 5);
-		var45 = this.populateOre(Block.oreGold.blockID, 500, 6, (var4 << 1) / 5);
-		var5 = this.populateOre(Block.oreDiamond.blockID, 800, 2, var4 / 5);
-		System.out.println("Coal: " + var7 + ", Iron: " + var44 + ", Gold: " + var45 + ", Diamond: " + var5);
+		System.out.println("Coal: " + this.populateOre(Block.stone.blockID, Block.oreCoal.blockID, (int)(1000 * this.levelTheme.getOreMultiplier()), 10, 0, var4 * 4 / 5));
+		System.out.println("Iron: " + this.populateOre(Block.stone.blockID, Block.oreIron.blockID, (int)(800 * this.levelTheme.getOreMultiplier()), 8, 0, var4 * 3 / 5));
+		System.out.println("Copper: " + this.populateOre(Block.stone.blockID, Block.oreCopper.blockID, (int)(400 * this.levelTheme.getOreMultiplier()), 6, 0, var4 / 2));
+		System.out.println("Gold: " + this.populateOre(Block.stone.blockID, Block.oreGold.blockID, (int)(300 * this.levelTheme.getOreMultiplier()), 6, 0, var4 * 2 / 5));
+		System.out.println("Diamond: " + this.populateOre(Block.stone.blockID, Block.oreDiamond.blockID, (int)(800 * this.levelTheme.getOreMultiplier()), 2, 0, var4 / 5));
+		AtomicInteger clay = new AtomicInteger();
+		if (this.levelTheme.getStillFluid() == Block.waterStill) {
+			this.populateSphereoid(this.levelTheme.getClayCount(), 4.0F, var4 / 4, var4 / 2, (cx, cy, cz) -> {
+				int i = (cy * this.depth + cz) * this.width + cx;
+				if (this.blocksByteArray[i] == Block.dirt.blockID && this.levelTheme.growGrassOnDirt() && this.blockArray3D.get(cx, cy + 1, cz) == 0) {
+					return;
+				}
+
+				if (this.blocksByteArray[i] == Block.dirt.blockID || this.blocksByteArray[i] == Block.sand.blockID) {
+					this.blocksByteArray[i] = (byte)Block.clay.blockID;
+					clay.getAndIncrement();
+				}
+			});
+		}
+		System.out.println("Clay: " + clay.get());
+		System.out.println("Gravel: " + this.populateOre(Block.stone.blockID, Block.gravel.blockID, 800, 10, 0, var4 / 2));
 		this.guiLoading.displayLoadingString("Melting..");
 		this.loadingBar();
-		this.lavaGen();
-		var6.cloudHeight = var4 + 2;
-		if(this.floatingGen) {
-			this.groundLevel = -128;
-			this.waterLevel = this.groundLevel + 1;
-			var6.cloudHeight = -16;
-		} else if(!this.islandGen) {
-			this.groundLevel = this.waterLevel + 1;
-			this.waterLevel = this.groundLevel - 16;
-		} else {
-			this.groundLevel = this.waterLevel - 9;
-		}
+		this.lavaGen(heightmap);
+		var6.cloudHeight = this.levelType.getCloudHeight(var4, this.waterLevel);
+		this.groundLevel = this.levelType.modifyGroundLevel(this.groundLevel, this.waterLevel);
+		this.waterLevel = this.levelType.modifyWaterLevel(this.groundLevel, this.waterLevel);
 
 		this.guiLoading.displayLoadingString("Watering..");
 		this.loadingBar();
 		this.liquidThemeSpawner();
-		if(!this.floatingGen) {
-			var5 = Block.waterStill.blockID;
-			if(this.levelType == 1) {
-				var5 = Block.lavaStill.blockID;
-			}
-
-			for(var7 = 0; var7 < var2; ++var7) {
-				this.floodFill(var7, this.waterLevel - 1, 0, 0, var5);
-				this.floodFill(var7, this.waterLevel - 1, var3 - 1, 0, var5);
-			}
-
-			for(var7 = 0; var7 < var3; ++var7) {
-				this.floodFill(var2 - 1, this.waterLevel - 1, var7, 0, var5);
-				this.floodFill(0, this.waterLevel - 1, var7, 0, var5);
-			}
-		}
-
-		if(this.levelType == 0) {
-			var6.skyColor = 10079487;
-			var6.fogColor = 16777215;
-			var6.cloudColor = 16777215;
-		}
-
-		if(this.levelType == 1) {
-			var6.cloudColor = 2164736;
-			var6.fogColor = 1049600;
-			var6.skyColor = 1049600;
-			var6.skylightSubtracted = var6.skyBrightness = 7;
-			var6.defaultFluid = Block.lavaMoving.blockID;
-			if(this.floatingGen) {
-				var6.cloudHeight = var4 + 2;
-				this.waterLevel = -16;
-			}
-		}
-
-		if(this.levelType == 2) {
-			var6.skyColor = 13033215;
-			var6.fogColor = 13033215;
-			var6.cloudColor = 15658751;
-			var6.skylightSubtracted = var6.skyBrightness = 15;
-			var6.skyBrightness = 16;
-			var6.cloudHeight = var4 + 64;
-		}
-
-		if(this.levelType == 3) {
-			var6.skyColor = 7699847;
-			var6.fogColor = 5069403;
-			var6.cloudColor = 5069403;
-			var6.skylightSubtracted = var6.skyBrightness = 12;
-		}
+		if(this.levelType.doEdgeFloodFill() && this.groundLevel <= this.waterLevel) {
+			fluid = this.levelTheme.getStillFluid();
+			if (fluid != null) {
+				var5 = fluid.blockID;
+
+				for(var7 = 0; var7 < var2; ++var7) {
+					this.floodFill(var7, this.waterLevel - 1, 0, 0, var5);
+					this.floodFill(var7, this.waterLevel - 1, var3 - 1, 0, var5);
+				}
+
+				for(var7 = 0; var7 < var3; ++var7) {
+					this.floodFill(var2 - 1, this.waterLevel - 1, var7, 0, var5);
+					this.floodFill(0, this.waterLevel - 1, var7, 0, var5);
+				}
+			}
+		}
+
+		var6.cloudHeight = levelTheme.modifyCloudHeight(var6.cloudHeight, var4, levelType);
+		this.waterLevel = levelTheme.modifyWaterLevel(this.waterLevel, levelType);
 
 		var6.waterLevel = this.waterLevel;
 		var6.groundLevel = this.groundLevel;
+
+		for (TerrainGenStage structureStage : structureStages) {
+			this.guiLoading.displayLoadingString(structureStage.name);
+			this.setNextPhase(0.0F);
+			structureStage.blockTransformer.transformBlocks(this.blockArray3D, heightmap, this.rand, var6, this::setNextPhase,
+					(cx, cy, cz) -> this.queueChest(cx, cy, cz, structureStage.getChestItems(this.rand)));
+			this.loadingBar();
+		}
+
 		this.guiLoading.displayLoadingString("Assembling..");
 		this.loadingBar();
 		this.setNextPhase(0.0F);
-		var6.generate(var2, var4, var3, this.blocksByteArray, (byte[])null);
+		var6.generate(var2, var4, var3, this.blocksByteArray, null, null, null);
 		this.guiLoading.displayLoadingString("Building..");
 		this.loadingBar();
 		this.setNextPhase(0.0F);
-		var6.findSpawn();
-		generateHouse(var6);
+
+		System.out.println("Chests: " + this.chestQueue.size());
+		for (ChestPlacement chest : this.chestQueue) {
+			if (var6.getBlockId(chest.x, chest.y, chest.z) == Block.crate.blockID) {
+				continue;
+			}
+
+			TileEntityChest chestTileEntity = new TileEntityChest();
+			for (int i = 0; i < chest.items.length; i++) {
+				chestTileEntity.setInventorySlotContents(i, chest.items[i]);
+			}
+
+			var6.setBlock(chest.x, chest.y, chest.z, Block.crate.blockID);
+			var6.setBlockTileEntity(chest.x, chest.y, chest.z, chestTileEntity);
+		}
+
+		var6.findSpawn(this.rand);
+		if (this.generateHouse) {
+			generateHouse(var6);
+		}
 		this.guiLoading.displayLoadingString("Planting..");
 		this.loadingBar();
-		if(this.levelType != 1) {
+		if (this.levelTheme.growGrassOnDirt()) {
 			this.growGrassOnDirt(var6);
 		}
 
 		this.loadingBar();
 		this.growTrees(var6);
-		if(this.levelType == 3) {
-			for(var5 = 0; var5 < 50; ++var5) {
-				this.growTrees(var6);
-			}
-		}
 
-		short var43 = 100;
-		if(this.levelType == 2) {
-			var43 = 1000;
-		}
+		int var43 = this.levelTheme.getFlowerCount();
+		int var43a = this.levelTheme.getMushroomCount();
 
 		this.loadingBar();
 		this.populateFlowersAndMushrooms(var6, Block.plantYellow, var43);
 		this.loadingBar();
 		this.populateFlowersAndMushrooms(var6, Block.plantRed, var43);
 		this.loadingBar();
-		this.populateFlowersAndMushrooms(var6, Block.mushroomBrown, 50);
-		this.loadingBar();
-		this.populateFlowersAndMushrooms(var6, Block.mushroomRed, 50);
-		this.guiLoading.displayLoadingString("Lighting..");
-		this.loadingBar();
+		this.populateFlowersAndMushrooms(var6, Block.plantBlue, var43);
+		this.loadingBar();
+		this.populateFlowersAndMushrooms(var6, Block.mushroomBrown, var43a);
+		this.loadingBar();
+		this.populateFlowersAndMushrooms(var6, Block.mushroomRed, var43a);
+		this.guiLoading.displayLoadingString("Lighting.. (Initializing)");
+		this.loadingBar();
+		var6.initLighting();
+		var6.scheduleLightingUpdate(EnumSkyBlock.Block, 0, 0, 0, var6.width, var6.height, var6.length);
 
-		for(var7 = 0; var7 < 10000; ++var7) {
-			this.setNextPhase((float)(var7 * 100 / 10000));
-			var6.updateLighting();
+		int maxQueue = var6.getLightingQueue();
+		long updateTime = System.currentTimeMillis();
+		while (var6.updatingLighting()) {
+			int queue = var6.getLightingQueue();
+			if (queue > maxQueue) {
+				maxQueue = queue;
+			}
+			if (System.currentTimeMillis() - updateTime > 50) {
+				this.guiLoading.displayLoadingString("Lighting.. (" + queue + " / " + maxQueue + ")");
+				this.setNextPhase((maxQueue - queue) * 100.0F / maxQueue);
+				updateTime = System.currentTimeMillis();
+			}
 		}
 
 		this.guiLoading.displayLoadingString("Spawning..");
 		this.loadingBar();
-		MobSpawner var47 = new MobSpawner(var6);
-
-		for(var2 = 0; var2 < 1000; ++var2) {
-			this.setNextPhase((float)var2 * 100.0F / 999.0F);
-			var47.performSpawning();
+
+		if (this.spawnMobs) {
+			MobSpawner var47 = new MobSpawner(var6);
+
+			for(var2 = 0; var2 < 1000; ++var2) {
+				this.setNextPhase((float)var2 * 100.0F / 999.0F);
+				var47.performSpawning();
+			}
 		}
 
 		var6.createTime = System.currentTimeMillis();
@@ -474,6 +313,10 @@
 		}
 	}
 
+	private void queueChest(int x, int y, int z, ItemStack[] items) {
+		this.chestQueue.add(new ChestPlacement(x, y, z, items));
+	}
+
 	private static void generateHouse(World var0) {
 		int var1 = var0.xSpawn;
 		int var2 = var0.ySpawn;
@@ -507,45 +350,33 @@
 		for(int var2 = 0; var2 < this.width; ++var2) {
 			this.setNextPhase((float)var2 * 100.0F / (float)(this.width - 1));
 
-			for(int var3 = 0; var3 < this.height; ++var3) {
-				for(int var4 = 0; var4 < this.depth; ++var4) {
-					if(var1.getBlockId(var2, var3, var4) == Block.dirt.blockID && var1.getBlockLightValue(var2, var3 + 1, var4) >= 4 && !var1.getBlockMaterial(var2, var3 + 1, var4).getCanBlockGrass()) {
+			for(int var4 = 0; var4 < this.depth; ++var4) {
+				for(int var3 = 0; var3 < this.height; ++var3) {
+					if(var1.getBlockId(var2, var3, var4) == Block.dirt.blockID && (var1.getBlockLightValue(var2, var3 + 1, var4) >= 4 && !var1.getBlockMaterial(var2, var3 + 1, var4).getCanBlockGrass() || var3 == this.height - 2)) {
 						var1.setBlock(var2, var3, var4, Block.grass.blockID);
 					}
 				}
+
+				if (this.levelTheme.hasSnow()) {
+					for (int var3 = this.height - 1; var3 > 0; var3--) {
+						Block ground = Block.blocksList[blocksByteArray[((var3 - 1) * this.depth + var4) * this.width + var2]];
+						if (ground != null) {
+							if (ground.isOpaqueCube() && ground.material.getIsSolid() && blocksByteArray[(var3 * this.depth + var4) * this.width + var2] == 0) {
+								blocksByteArray[(var3 * this.depth + var4) * this.width + var2] = (byte)Block.snow.blockID;
+							} else if (ground == Block.waterStill || ground == Block.waterMoving) {
+								blocksByteArray[((var3 - 1) * this.depth + var4) * this.width + var2] = (byte)Block.ice.blockID;
+							}
+							break;
+						}
+					}
+				}
 			}
 		}
 
 	}
 
 	private void growTrees(World var1) {
-		int var2 = this.width * this.depth * this.height / 80000;
-
-		for(int var3 = 0; var3 < var2; ++var3) {
-			if(var3 % 100 == 0) {
-				this.setNextPhase((float)var3 * 100.0F / (float)(var2 - 1));
-			}
-
-			int var4 = this.rand.nextInt(this.width);
-			int var5 = this.rand.nextInt(this.height);
-			int var6 = this.rand.nextInt(this.depth);
-
-			for(int var7 = 0; var7 < 25; ++var7) {
-				int var8 = var4;
-				int var9 = var5;
-				int var10 = var6;
-
-				for(int var11 = 0; var11 < 20; ++var11) {
-					var8 += this.rand.nextInt(12) - this.rand.nextInt(12);
-					var9 += this.rand.nextInt(3) - this.rand.nextInt(6);
-					var10 += this.rand.nextInt(12) - this.rand.nextInt(12);
-					if(var8 >= 0 && var9 >= 0 && var10 >= 0 && var8 < this.width && var9 < this.height && var10 < this.depth) {
-						var1.growTrees(var8, var9, var10);
-					}
-				}
-			}
-		}
-
+		this.levelTheme.growTrees(var1, this.rand, this::setNextPhase);
 	}
 
 	private void populateFlowersAndMushrooms(World var1, BlockFlower var2, int var3) {
@@ -570,7 +401,7 @@
 					var10 += this.rand.nextInt(2) - this.rand.nextInt(2);
 					var11 += this.rand.nextInt(4) - this.rand.nextInt(4);
 					if(var9 >= 0 && var11 >= 0 && var10 > 0 && var9 < this.width && var11 < this.depth && var10 < this.height && var1.getBlockId(var9, var10, var11) == 0 && var2.canBlockStay(var1, var9, var10, var11)) {
-						var1.setBlockWithNotify(var9, var10, var11, var2.blockID);
+						var1.setBlock(var9, var10, var11, var2.blockID);
 					}
 				}
 			}
@@ -578,7 +409,7 @@
 
 	}
 
-	private int populateOre(int var1, int var2, int var3, int var4) {
+	private int populateOre(int var0, int var1, int var2, int var3, int var4a, int var4) {
 		int var5 = 0;
 		byte var26 = (byte)var1;
 		int var6 = this.width;
@@ -591,7 +422,7 @@
 			float var10 = this.rand.nextFloat() * (float)var6;
 			float var11 = this.rand.nextFloat() * (float)var8;
 			float var12 = this.rand.nextFloat() * (float)var7;
-			if(var11 <= (float)var4) {
+			if(var11 >= var4a && var11 <= var4) {
 				int var13 = (int)((this.rand.nextFloat() + this.rand.nextFloat()) * 75.0F * (float)var3 / 100.0F);
 				float var14 = this.rand.nextFloat() * (float)Math.PI * 2.0F;
 				float var15 = 0.0F;
@@ -620,9 +451,15 @@
 								var23 = var23 * var23 + var24 * var24 * 2.0F + var25 * var25;
 								if(var23 < var19 * var19 && var20 > 0 && var21 > 0 && var22 > 0 && var20 < this.width - 1 && var21 < this.height - 1 && var22 < this.depth - 1) {
 									int var27 = (var21 * this.depth + var22) * this.width + var20;
-									if(this.blocksByteArray[var27] == Block.stone.blockID) {
+									if(this.blocksByteArray[var27] == var0) {
+										if (var0 == Block.dirt.blockID
+												&& this.levelTheme.growGrassOnDirt()
+												&& this.blocksByteArray[var27 + 1] != 0) {
+											++var5;
+											continue;
+										}
 										this.blocksByteArray[var27] = var26;
-										++var5;
+                                        ++var5;
 									}
 								}
 							}
@@ -635,13 +472,35 @@
 		return var5;
 	}
 
+
+	private void populateSphereoid(int frequency, float radius, int minY, int maxY, CoordinateConsumer plotter) {
+		frequency = this.width * this.height * this.depth / 256 / 64 * frequency / 100;
+		for (int i = 0; i < frequency; i++) {
+			int y = rand.nextInt(this.height - 2) + 1;
+			if (y <= minY || y >= maxY) continue;
+
+			int x = rand.nextInt(this.width - 2) + 1;
+			int z = rand.nextInt(this.depth - 2) + 1;
+
+			float scaleX = 0.5F + rand.nextFloat();
+			float scaleY = 0.5F + rand.nextFloat();
+			float rotation = rand.nextFloat() * (float)Math.PI;
+			float skew = rand.nextFloat() - 0.5F;
+
+			drawSphereoid(x, y, z, radius, scaleX, scaleY, rotation, skew, plotter);
+		}
+	}
+
 	private void liquidThemeSpawner() {
-		int var1 = Block.waterStill.blockID;
-		if(this.levelType == 1) {
-			var1 = Block.lavaStill.blockID;
+		Block fluid = this.levelTheme.getStillFluid();
+		if (this.levelType.getLakeRarity() <= 0 || fluid == null) {
+			return;
 		}
 
-		int var2 = this.width * this.depth * this.height / 1000;
+		int var1 = fluid.blockID;
+		int var2 = this.width * this.depth * this.height
+			/ this.levelTheme.modifyLakeRarity(this.levelType.getLakeRarity());
+		long lakeSize = this.levelTheme.modifyLakeSize(this.levelType.getMaxLakeSize());
 
 		for(int var3 = 0; var3 < var2; ++var3) {
 			if(var3 % 100 == 0) {
@@ -649,11 +508,11 @@
 			}
 
 			int var4 = this.rand.nextInt(this.width);
-			int var5 = this.rand.nextInt(this.height);
+			int var5 = this.rand.nextInt(this.height / 2 + 8) + this.height / 2 - 8;
 			int var6 = this.rand.nextInt(this.depth);
 			if(this.blocksByteArray[(var5 * this.depth + var6) * this.width + var4] == 0) {
-				long var7 = this.floodFill(var4, var5, var6, 0, 255);
-				if(var7 > 0L && var7 < 640L) {
+				long var7 = this.floodFill(var4, var5, var6, 0, 255, lakeSize);
+				if(var7 > 0L && (var7 < lakeSize || lakeSize <= 0)) {
 					this.floodFill(var4, var5, var6, 255, var1);
 				} else {
 					this.floodFill(var4, var5, var6, 255, 0);
@@ -674,12 +533,12 @@
 		if(var1 < 0.0F) {
 			throw new IllegalStateException("Failed to set next phase!");
 		} else {
-			int var2 = (int)(((float)(this.phaseBar - 1) + var1 / 100.0F) * 100.0F / (float)this.phases);
+			int var2 = (int)(((float)(this.phaseBar) + var1 / 100.0F) * 100.0F / (float)(this.phases + 1));
 			this.guiLoading.setLoadingProgress(var2);
 		}
 	}
 
-	private void lavaGen() {
+	private void lavaGen(IntArray2D heightmap) {
 		int var1 = this.width * this.depth * this.height / 2000;
 		int var2 = this.groundLevel;
 
@@ -692,7 +551,7 @@
 			int var5 = Math.min(Math.min(this.rand.nextInt(var2), this.rand.nextInt(var2)), Math.min(this.rand.nextInt(var2), this.rand.nextInt(var2)));
 			int var6 = this.rand.nextInt(this.depth);
 			if(this.blocksByteArray[(var5 * this.depth + var6) * this.width + var4] == 0) {
-				long var7 = this.floodFill(var4, var5, var6, 0, 255);
+				long var7 = this.floodFill(var4, var5, var6, 0, 255, 640L);
 				if(var7 > 0L && var7 < 640L) {
 					this.floodFill(var4, var5, var6, 255, Block.lavaStill.blockID);
 				} else {
@@ -704,69 +563,88 @@
 		this.setNextPhase(100.0F);
 	}
 
-	private long floodFill(int var1, int var2, int var3, int var4, int var5) {
+	private long floodFill(int sx, int sy, int sz, int var4, int var5) {
+		return this.floodFill(sx,  sy, sz, var4, var5, 0L);
+	}
+
+	private long floodFill(int sx, int sy, int sz, int var4, int var5, long var5a) {
 		byte var6 = (byte)var5;
 		byte var22 = (byte)var4;
 		ArrayList var7 = new ArrayList();
 		byte var8 = 0;
-		int var9 = 1;
-
-		int var10;
-		for(var10 = 1; 1 << var9 < this.width; ++var9) {
-		}
-
-		while(1 << var10 < this.depth) {
-			++var10;
-		}
-
-		int var11 = this.depth - 1;
-		int var12 = this.width - 1;
+		int widthOff = 1;
+
+		int depthOff;
+		for(depthOff = 1; 1 << widthOff < this.width; ++widthOff) {
+		}
+
+		while(1 << depthOff < this.depth) {
+			++depthOff;
+		}
+
+		int depthClip = 1;
+		int widthClip = 1;
+
+		while (depthClip < this.depth - 1) {
+			depthClip <<= 1;
+			depthClip |= 1;
+		}
+
+		while (widthClip < this.width - 1) {
+			widthClip <<= 1;
+			widthClip |= 1;
+		}
+
 		int var23 = var8 + 1;
-		this.floodFillBlocks[0] = ((var2 << var10) + var3 << var9) + var1;
+		this.floodFillBlocks[0] = ((sy << depthOff) + sz << widthOff) + sx;
 		long var14 = 0L;
-		var1 = this.width * this.depth;
+		sx = this.width * this.depth;
 
 		while(var23 > 0) {
 			--var23;
-			var2 = this.floodFillBlocks[var23];
+			sy = this.floodFillBlocks[var23];
 			if(var23 == 0 && var7.size() > 0) {
 				this.floodFillBlocks = (int[])var7.remove(var7.size() - 1);
 				var23 = this.floodFillBlocks.length;
 			}
 
-			var3 = var2 >> var9 & var11;
-			int var13 = var2 >> var9 + var10;
-			int var16 = var2 & var12;
-
-			int var17;
-			for(var17 = var16; var16 > 0 && this.blocksByteArray[var2 - 1] == var22; --var2) {
-				--var16;
-			}
-
-			while(var17 < this.width && this.blocksByteArray[var2 + var17 - var16] == var22) {
-				++var17;
-			}
-
-			int var18 = var2 >> var9 & var11;
-			int var19 = var2 >> var9 + var10;
-			if(var5 == 255 && (var16 == 0 || var17 == this.width - 1 || var13 == 0 || var13 == this.height - 1 || var3 == 0 || var3 == this.depth - 1)) {
+			sz = sy >> widthOff & depthClip;
+			int y = sy >> widthOff + depthOff;
+			int x = sy & widthClip;
+
+			int var2b = (y * this.depth + sz) * this.width + x;
+
+			int x2;
+			for(x2 = x; x > 0 && this.blocksByteArray[var2b - 1] == var22; --sy, --var2b) {
+				--x;
+			}
+
+			while(x2 < this.width && this.blocksByteArray[var2b + x2 - x] == var22) {
+				++x2;
+			}
+
+			int z2 = sy >> widthOff & depthClip;
+			int y2 = sy >> widthOff + depthOff;
+			if(var5 == 255 && (x == 0 || x2 == this.width - 1 || y == 0 || y == this.height - 1 || sz == 0 || sz == this.depth - 1) && (!this.levelType.doFloodFillToEdge() || y >= this.waterLevel)) {
 				return -1L;
 			}
 
-			if(var18 != var3 || var19 != var13) {
+			if(z2 != sz || y2 != y) {
 				System.out.println("Diagonal flood!?");
 			}
 
 			boolean var24 = false;
 			boolean var25 = false;
 			boolean var20 = false;
-			var14 += (long)(var17 - var16);
-
-			for(var16 = var16; var16 < var17; ++var16) {
-				this.blocksByteArray[var2] = var6;
+			var14 += (long)(x2 - x);
+
+			if (var5a > 0 && var14 >= var5a) return var14;
+
+			for(x = x; x < x2; ++x) {
+				this.blocksByteArray[var2b] = var6;
 				boolean var21;
-				if(var3 > 0) {
-					var21 = this.blocksByteArray[var2 - this.width] == var22;
+				if(sz > 0) {
+					var21 = this.blocksByteArray[var2b - this.width] == var22;
 					if(var21 && !var24) {
 						if(var23 == this.floodFillBlocks.length) {
 							var7.add(this.floodFillBlocks);
@@ -774,14 +652,14 @@
 							var23 = 0;
 						}
 
-						this.floodFillBlocks[var23++] = var2 - this.width;
+						this.floodFillBlocks[var23++] = sy - (1 << widthOff);
 					}
 
 					var24 = var21;
 				}
 
-				if(var3 < this.depth - 1) {
-					var21 = this.blocksByteArray[var2 + this.width] == var22;
+				if(sz < this.depth - 1) {
+					var21 = this.blocksByteArray[var2b + this.width] == var22;
 					if(var21 && !var25) {
 						if(var23 == this.floodFillBlocks.length) {
 							var7.add(this.floodFillBlocks);
@@ -789,16 +667,16 @@
 							var23 = 0;
 						}
 
-						this.floodFillBlocks[var23++] = var2 + this.width;
+						this.floodFillBlocks[var23++] = sy + (1 << widthOff);
 					}
 
 					var25 = var21;
 				}
 
-				if(var13 > 0) {
-					byte var26 = this.blocksByteArray[var2 - var1];
+				if(y > 0) {
+					byte var26 = this.blocksByteArray[var2b - sx];
 					if((var6 == Block.lavaMoving.blockID || var6 == Block.lavaStill.blockID) && (var26 == Block.waterMoving.blockID || var26 == Block.waterStill.blockID)) {
-						this.blocksByteArray[var2 - var1] = (byte)Block.stone.blockID;
+						this.blocksByteArray[var2b - sx] = (byte)Block.stone.blockID;
 					}
 
 					var21 = var26 == var22;
@@ -809,16 +687,41 @@
 							var23 = 0;
 						}
 
-						this.floodFillBlocks[var23++] = var2 - var1;
+						this.floodFillBlocks[var23++] = sy - (1 << widthOff + depthOff);
 					}
 
 					var20 = var21;
 				}
 
-				++var2;
+				++sy;
+				++var2b;
 			}
 		}
 
 		return var14;
+	}
+
+	public static void drawSphereoid(int x, int y, int z, float radius, float scaleX, float scaleY, float rotation, float skew, CoordinateConsumer plotter) {
+		float sinRot = MathHelper.sin(rotation);
+		float cosRot = MathHelper.cos(rotation);
+		float radiusSquared = radius * radius;
+
+		int xExtent = -MathHelper.floor_float(-radius * Math.max(scaleX, 1.0F));
+		int yExtent = -MathHelper.floor_float(-radius * (scaleY + skew));
+		int zExtent = -MathHelper.floor_float(-radius * Math.max(scaleX, 1.0F));
+
+		for (int xx = -xExtent; xx <= xExtent; xx++) {
+			for (int yy = -yExtent; yy <= yExtent; yy++) {
+				for (int zz = -zExtent; zz <= zExtent; zz++) {
+					float sx = (cosRot * xx - sinRot * zz) / scaleX;
+					float sz = (sinRot * xx + cosRot * zz);
+					float sy = (yy + sz * skew) / scaleY;
+
+					if (sx * sx + sy * sy + sz * sz <= radiusSquared) {
+						plotter.accept(x + xx, y + yy, z + zz);
+					}
+				}
+			}
+		}
 	}
 }
--- net/minecraft/client/MouseHelper.java
+++ net/minecraft/client/MouseHelper.java
@@ -23,13 +23,6 @@
 
 	public MouseHelper(Component var1) {
 		this.windowComponent = var1;
-
-		try {
-			this.robot = new Robot();
-		} catch (AWTException var4) {
-			var4.printStackTrace();
-		}
-
 		IntBuffer var5 = BufferUtils.createIntBuffer(1);
 		var5.put(0);
 		var5.flip();
@@ -43,29 +36,18 @@
 	}
 
 	public final void grabMouseCursor() {
-		try {
-			Mouse.setNativeCursor(this.cursor);
-		} catch (LWJGLException var2) {
-			var2.printStackTrace();
-		}
-
-		this.ungrabMouseCursor();
+		Mouse.setGrabbed(true);
 		this.deltaX = 0;
 		this.deltaY = 0;
 	}
 
 	public final void ungrabMouseCursor() {
-		Point var1 = MouseInfo.getPointerInfo().getLocation();
-		Point var2 = this.windowComponent.getLocationOnScreen();
-		this.robot.mouseMove(this.mouseX, this.mouseY);
-		this.mouseX = var2.x + this.windowComponent.getWidth() / 2;
-		this.mouseY = var2.y + this.windowComponent.getHeight() / 2;
-		if(this.mouseInt == 0) {
-			this.deltaX = var1.x - this.mouseX;
-			this.deltaY = var1.y - this.mouseY;
-		} else {
-			this.deltaX = this.deltaY = 0;
-			--this.mouseInt;
-		}
+		Mouse.setCursorPosition(this.windowComponent.getWidth() / 2, this.windowComponent.getHeight() / 2);
+		Mouse.setGrabbed(false);
+	}
+
+	public void mouseXYChange() {
+		this.deltaX = Mouse.getDX();
+		this.deltaY = Mouse.getDY();
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/TerrainGenStage.java
@@ -1,0 +1,85 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.ItemStack;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+import util.ByteArray3D;
+import util.IntArray2D;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+import java.util.function.Consumer;
+
+public class TerrainGenStage {
+	public final String name;
+	public final BlockTransformer blockTransformer;
+	private List<ChestItem> chestItems;
+	private int minChestSlots = 5, chestSlotVariation = 11;
+
+	public TerrainGenStage(String name, BlockTransformer blockTransformer) {
+		this.name = name;
+		this.blockTransformer = blockTransformer;
+	}
+
+	protected static class ChestItem {
+		public final int id, count;
+		public final boolean damaged;
+
+		public ChestItem(int id, int count) {
+			this(id, count, false);
+		}
+
+		public ChestItem(int id, int count, boolean damaged) {
+			this.id = id;
+			this.count = count;
+			this.damaged = damaged;
+		}
+	}
+
+	protected void setChestSlots(int min, int max) {
+		if (max < min) throw new IllegalArgumentException("Maximum slots cannot be lower than minimum slots!");
+
+		this.minChestSlots = min;
+		this.chestSlotVariation = max - min + 1;
+	}
+
+	protected void addChestItem(ChestItem chestItem) {
+		if (chestItem == null) return;
+		if (this.chestItems == null) this.chestItems = new ArrayList<>();
+		this.chestItems.add(chestItem);
+	}
+
+	public ItemStack[] getChestItems(Random rand) {
+		ItemStack[] items = new ItemStack[27];
+		int slotCount = this.minChestSlots + rand.nextInt(this.chestSlotVariation);
+
+		for (int i = 0; i < slotCount; i++) {
+			int index;
+			do {
+				index = rand.nextInt(27);
+			} while (items[index] != null);
+
+			ChestItem chestItem = this.chestItems.get(rand.nextInt(this.chestItems.size()));
+			ItemStack item = new ItemStack(chestItem.id, rand.nextInt(chestItem.count) + 1);
+			if (chestItem.damaged) {
+				item.itemDamage = rand.nextInt(Item.itemsList[item.itemID].getMaxDamage());
+			}
+			items[index] = item;
+		}
+
+		return items;
+	}
+
+	@FunctionalInterface
+	public interface BlockTransformer {
+		void transformBlocks(ByteArray3D blocks, IntArray2D heightmap, Random rand, World world,
+		                     Consumer<Float> progressor, ChestPlacer chestPlacer);
+	}
+
+	@FunctionalInterface
+	public interface ChestPlacer {
+		void placeChest(int x, int y, int z);
+	}
+}
--- net/minecraft/game/level/block/BlockFarmland.java
+++ net/minecraft/game/level/block/BlockFarmland.java
@@ -6,7 +6,7 @@
 import net.minecraft.game.physics.AxisAlignedBB;
 
 public final class BlockFarmland extends Block {
-	protected BlockFarmland(int var1) {
+	public BlockFarmland(int var1) {
 		super(60, Material.ground);
 		this.blockIndexInTexture = 87;
 		this.setTickOnLoad(true);
@@ -14,7 +14,7 @@
 		this.setLightOpacity(255);
 	}
 
-	public final AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
+	public final AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
 		return new AxisAlignedBB((float)var1, (float)var2, (float)var3, (float)(var1 + 1), (float)(var2 + 1), (float)(var3 + 1));
 	}
 
@@ -30,7 +30,17 @@
 		return var1 == 1 && var2 > 0 ? this.blockIndexInTexture - 1 : (var1 == 1 ? this.blockIndexInTexture : 2);
 	}
 
+	public final int getBlockTextureFromSide(int var1) {
+		return var1 == 1 ? this.blockIndexInTexture : 2;
+	}
+
 	public final void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		Material material = var1.getBlockMaterial(var2, var3 + 1, var4);
+		if (material == Material.water) {
+			var1.setBlockAndMetadataWithNotify(var2, var3, var4, Block.mud.blockID, 0);
+			return;
+		}
+
 		if(var5.nextInt(5) == 0) {
 			int var8 = var4;
 			int var7 = var3;
@@ -103,7 +113,7 @@
 
 	public final void onEntityWalking(World var1, int var2, int var3, int var4) {
 		if(var1.random.nextInt(4) == 0) {
-			var1.setBlockWithNotify(var2, var3, var4, Block.dirt.blockID);
+			var1.setBlockWithNotify(var2, var3 - 1, var4, Block.dirt.blockID);
 		}
 
 	}
--- net/minecraft/client/player/MovementInput.java
+++ net/minecraft/client/player/MovementInput.java
@@ -4,6 +4,7 @@
 	public float moveStrafe = 0.0F;
 	public float moveForward = 0.0F;
 	public boolean jump = false;
+	public boolean sneak = false;
 
 	public void updatePlayerMoveState() {
 	}
--- net/minecraft/game/entity/EntityLiving.java
+++ net/minecraft/game/entity/EntityLiving.java
@@ -14,7 +14,6 @@
 	private float rotationYawHead;
 	private float prevRotationYawHead;
 	protected String texture = "/char.png";
-	private int scoreValue = 0;
 	public int health;
 	public int prevHealth;
 	private int livingSoundTime;
@@ -35,6 +34,7 @@
 	protected boolean isJumping;
 	private float defaultPitch;
 	protected float moveSpeed;
+	protected boolean flying;
 
 	public EntityLiving(World var1) {
 		super(var1);
@@ -101,6 +101,10 @@
 			this.air = this.maxAir;
 		}
 
+		if (this.getBlockInHead() == Block.fumes.blockID && this.ticksExisted % 40 == 0) {
+			this.attackEntityFrom(null, 2);
+		}
+
 		this.prevCameraPitch = this.cameraPitch;
 		if(this.attackTime > 0) {
 			--this.attackTime;
@@ -405,13 +409,15 @@
 				this.motionY = 0.3F;
 			}
 		} else {
-			this.moveFlying(var2, var3, this.onGround ? 0.1F : 0.02F);
+			int block = this.worldObj.getBlockId((int)this.posX, (int)(this.posY - 0.2F - this.yOffset), (int)this.posZ);
+			boolean slippery = this.onGround && block == Block.ice.blockID;
+			this.moveFlying(var2, var3, (this.onGround ? 0.1F : 0.02F) * (this.flying ? 2.5F : 1.0F) * (slippery ? 0.1F : 1.0F));
 			this.moveEntity(this.motionX, this.motionY, this.motionZ);
-			this.motionX *= 0.91F;
+			this.motionX *= slippery ? 0.98F : 0.91F;
 			this.motionY *= 0.98F;
-			this.motionZ *= 0.91F;
-			this.motionY = (float)((double)this.motionY - 0.08D);
-			if(this.onGround) {
+			this.motionZ *= slippery ? 0.98F : 0.91F;
+			if (!this.flying) this.motionY -= 0.08F;
+			if(this.onGround && !slippery) {
 				this.motionX *= 0.6F;
 				this.motionZ *= 0.6F;
 			}
--- net/minecraft/game/item/ItemStack.java
+++ net/minecraft/game/item/ItemStack.java
@@ -58,6 +58,10 @@
 		return Item.itemsList[this.itemID];
 	}
 
+	public final int getIconIndex() {
+		return this.getItem().getIconIndex(this);
+	}
+
 	public final NBTTagCompound writeToNBT(NBTTagCompound var1) {
 		var1.setShort("id", (short)this.itemID);
 		var1.setByte("Count", (byte)this.stackSize);
--- /dev/null
+++ util/DoubleArray3D.java
@@ -1,0 +1,35 @@
+package util;
+
+public class DoubleArray3D {
+	private final double[] array;
+	public final int width, length, height;
+
+	public DoubleArray3D(int width, int length, int height) {
+		this(null, width, length, height);
+	}
+
+	public DoubleArray3D(double[] array, int width, int length, int height) {
+		if (array == null) {
+			array = new double[width * length * height];
+		} else if (array.length < width * length * height) {
+			throw new IllegalArgumentException("Array is too small!");
+		}
+
+		this.array = array;
+		this.width = width;
+		this.length = length;
+		this.height = height;
+	}
+
+	public double get(int x, int y, int z) {
+		return this.array[(y * this.length + z) * this.width + x];
+	}
+
+	public void set(int x, int y, int z, double value) {
+		this.array[(y * this.length + z) * this.width + x] = value;
+	}
+
+	public double[] getArray() {
+		return array;
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/noise/NoiseGeneratorRD.java
@@ -1,0 +1,77 @@
+package net.minecraft.game.level.generator.noise;
+
+import java.util.Random;
+
+public class NoiseGeneratorRD {
+	Random random = new Random();
+	int seed = this.random.nextInt();
+	int levels = 0;
+	int fuzz = 16;
+
+	public NoiseGeneratorRD(int levels) {
+		this.levels = levels;
+	}
+
+	public int[] read(int width, int height) {
+		Random random = new Random();
+		int[] tmp = new int[width * height];
+		int level = this.levels;
+		int result = width >> level;
+
+		int y;
+		int x;
+		for(y = 0; y < height; y += result) {
+			for(x = 0; x < width; x += result) {
+				tmp[x + y * width] = (random.nextInt(256) - 128) * this.fuzz;
+			}
+		}
+
+		for(result = width >> level; result > 1; result /= 2) {
+			y = 256 * (result << level);
+			x = result / 2;
+
+			int y1;
+			int x1;
+			int c;
+			int r;
+			int d;
+			int mu;
+			int ml;
+			for(y1 = 0; y1 < height; y1 += result) {
+				for(x1 = 0; x1 < width; x1 += result) {
+					c = tmp[(x1 + 0) % width + (y1 + 0) % height * width];
+					r = tmp[(x1 + result) % width + (y1 + 0) % height * width];
+					d = tmp[(x1 + 0) % width + (y1 + result) % height * width];
+					mu = tmp[(x1 + result) % width + (y1 + result) % height * width];
+					ml = (c + d + r + mu) / 4 + random.nextInt(y * 2) - y;
+					tmp[x1 + x + (y1 + x) * width] = ml;
+				}
+			}
+
+			for(y1 = 0; y1 < height; y1 += result) {
+				for(x1 = 0; x1 < width; x1 += result) {
+					c = tmp[x1 + y1 * width];
+					r = tmp[(x1 + result) % width + y1 * width];
+					d = tmp[x1 + (y1 + result) % width * width];
+					mu = tmp[(x1 + x & width - 1) + (y1 + x - result & height - 1) * width];
+					ml = tmp[(x1 + x - result & width - 1) + (y1 + x & height - 1) * width];
+					int m = tmp[(x1 + x) % width + (y1 + x) % height * width];
+					int u = (c + r + m + mu) / 4 + random.nextInt(y * 2) - y;
+					int l = (c + d + m + ml) / 4 + random.nextInt(y * 2) - y;
+					tmp[x1 + x + y1 * width] = u;
+					tmp[x1 + (y1 + x) * width] = l;
+				}
+			}
+		}
+
+		int[] var19 = new int[width * height];
+
+		for(y = 0; y < height; ++y) {
+			for(x = 0; x < width; ++x) {
+				var19[x + y * width] = tmp[x % width + y % height * width] / 512 + 128;
+			}
+		}
+
+		return var19;
+	}
+}
--- net/minecraft/game/level/block/BlockMushroom.java
+++ net/minecraft/game/level/block/BlockMushroom.java
@@ -2,14 +2,28 @@
 
 import net.minecraft.game.level.World;
 
+import java.util.Random;
+
 public final class BlockMushroom extends BlockFlower {
-	protected BlockMushroom(int var1, int var2) {
+	public BlockMushroom(int var1, int var2) {
 		super(var1, var2);
 		this.setBlockBounds(0.3F, 0.0F, 0.3F, 0.7F, 0.4F, 0.7F);
 	}
 
-	protected final boolean canThisPlantGrowOnThisBlockID(int var1) {
+	public final boolean canThisPlantGrowOnThisBlockID(int var1) {
 		return Block.opaqueCubeLookup[var1];
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		if(var5.nextInt(100) == 0) {
+			int var6 = var2 + var5.nextInt(3) - 1;
+			int var7 = var3 + var5.nextInt(2) - var5.nextInt(2);
+			int var8 = var4 + var5.nextInt(3) - 1;
+			if(var1.getBlockId(var6, var7, var8) == 0 && this.canBlockStay(var1, var6, var7, var8)) {
+				var1.setBlockWithNotify(var6, var7, var8, this.blockID);
+			}
+		}
+
 	}
 
 	public final boolean canBlockStay(World var1, int var2, int var3, int var4) {
--- /dev/null
+++ net/minecraft/game/level/block/BlockChain.java
@@ -1,0 +1,42 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+import net.minecraft.game.physics.AxisAlignedBB;
+
+public class BlockChain extends Block {
+    public final int conductionChannel;
+
+    public BlockChain(int var1, int var2, int var3) {
+        super(var1, var2, Material.iron);
+        this.conductionChannel = var3;
+    }
+
+    public boolean isConductive() {
+        return true;
+    }
+
+    public boolean conductWithBlock(Block block) {
+        boolean isOre = block instanceof BlockOreBlock;
+        boolean isChain = block instanceof BlockChain;
+        return isOre && ((BlockOreBlock) block).conductionChannel == this.conductionChannel
+            || isChain && ((BlockChain) block).conductionChannel == this.conductionChannel
+            || !isOre && !isChain;
+    }
+
+    public int getRenderType() {
+        return 8;
+    }
+
+    public boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
+        return true;
+    }
+
+    public final AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
+        return null;
+    }
+
+    public boolean isOpaqueCube() {
+        return false;
+    }
+}
--- net/minecraft/game/level/block/BlockSand.java
+++ net/minecraft/game/level/block/BlockSand.java
@@ -1,60 +1,154 @@
 package net.minecraft.game.level.block;
 
+import java.util.List;
 import java.util.Random;
+
+import net.minecraft.game.entity.Entity;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.material.Material;
+import net.minecraft.game.physics.AxisAlignedBB;
 
 public class BlockSand extends Block {
 	public BlockSand(int var1, int var2) {
 		super(var1, var2, Material.sand);
-		new Random();
+	}
+
+	public int tickRate() {
+		return 3;
+	}
+
+	protected int fallDirection(World var1, int var2, int var3, int var4) {
+		return -1;
+	}
+
+	protected boolean passGrates() {
+		return true;
 	}
 
 	public final void onBlockAdded(World var1, int var2, int var3, int var4) {
-		this.tryToFall(var1, var2, var3, var4);
+		var1.scheduleBlockUpdate(var2, var3, var4, this.blockID);
 	}
 
 	public final void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
-		this.tryToFall(var1, var2, var3, var4);
-	}
-
-	private void tryToFall(World var1, int var2, int var3, int var4) {
-		int var5 = var3;
-
-		while(true) {
-			int var8 = var5 - 1;
-			int var6 = var1.getBlockId(var2, var8, var4);
-			boolean var10000;
-			if(var6 == 0) {
-				var10000 = true;
-			} else if(var6 == Block.fire.blockID) {
-				var10000 = true;
-			} else {
-				Material var10 = Block.blocksList[var6].material;
-				var10000 = var10 == Material.water ? true : var10 == Material.lava;
-			}
-
-			if(!var10000 || var5 < 0) {
-				if(var5 < 0) {
-					var1.setTileNoUpdate(var2, var3, var4, 0);
-				}
-
-				if(var5 != var3) {
-					var6 = var1.getBlockId(var2, var5, var4);
-					if(var6 > 0 && Block.blocksList[var6].material != Material.air) {
-						var1.setTileNoUpdate(var2, var5, var4, 0);
-					}
-
-					var1.swap(var2, var3, var4, var2, var5, var4);
-				}
-
+		var1.scheduleBlockUpdate(var2, var3, var4, this.blockID);
+	}
+
+	public boolean canReceivePower(World var1, int var2, int var3, int var4, int var5) {
+		return true;
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+		world.scheduleBlockUpdate(x, y, z, this.blockID);
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		this.fall(var1, var2, var3, var4);
+	}
+
+	public void onBlockRemoval(World var1, int var2, int var3, int var4, int var4a) {
+		int grateType = (var4a >>> 4) & 3;
+		if (grateType == 1) {
+			var1.setTileNoUpdate(var2, var3, var4, Block.ironGrate.blockID);
+			var1.setBlockMetadata(var2, var3, var4, 1);
+		} else if (grateType == 2) {
+			var1.setTileNoUpdate(var2, var3, var4, Block.woodenGrate.blockID);
+			var1.setBlockMetadata(var2, var3, var4, 1);
+		} else if (grateType == 3) {
+			var1.setTileNoUpdate(var2, var3, var4, Block.goldenGrate.blockID);
+			var1.setBlockMetadata(var2, var3, var4, 1);
+		}
+	}
+
+	public void dropBlockAsItemWithChance(World var1, int var2, int var3, int var4, int var5, float var6) {
+		int grateType = (var5 >>> 4) & 3;
+		if (grateType == 1) {
+			Block.ironGrate.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, var6);
+		} else if (grateType == 2) {
+			Block.woodenGrate.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, var6);
+		} else if (grateType == 3) {
+			Block.goldenGrate.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, var6);
+		}
+		super.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, var6);
+	}
+
+	public void fall(World var1, int var2, int var3, int var4) {
+		int dir = this.fallDirection(var1, var2, var3, var4);
+		int dirSign = dir > 0 ? 1 : -1;
+
+		for (int i = 0; i < Math.abs(dir); i++) {
+			int meta = var1.getBlockMetadata(var2, var3, var4) & 255;
+			boolean grated = ((meta >>> 4) & 3) == 1;
+			boolean woodenGrated = ((meta >>> 4) & 3) == 2;
+			boolean goldenGrated = ((meta >>> 4) & 3) == 3;
+
+			if (var3 + dirSign == -1 || var3 + dirSign == var1.height) {
 				return;
 			}
 
-			--var5;
-			if(var1.getBlockId(var2, var5, var4) == Block.fire.blockID) {
-				var1.setBlock(var2, var5, var4, 0);
+			AxisAlignedBB aabb = this.getCollisionBoundingBoxFromPool(var1, var2, var3, var4).getOffsetBoundingBox(0.0F, 0.99F, 0.0F).expand(-0.01F, 0.0F, -0.01F);
+			float snapY = dirSign == -1 ? aabb.minY - 0.99F : aabb.maxY + 0.01F;
+			var3 += dirSign;
+			Block blockBelow = Block.blocksList[var1.getBlockId(var2, var3, var4)];
+			if (blockBelow != null && (blockBelow.getCollisionBoundingBoxFromPool(var1, var2, var3, var4) != null
+					|| !passGrates() && (blockBelow == Block.ironGrate || blockBelow == Block.woodenGrate || blockBelow == Block.goldenGrate))) return;
+
+			if (blockBelow != null && blockBelow != Block.ironGrate && blockBelow != Block.woodenGrate && blockBelow != Block.goldenGrate) {
+				blockBelow.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+			}
+
+			var1.setTileNoUpdate(var2, var3, var4, 0);
+			var1.swap(var2, var3 - dirSign, var4, var2, var3, var4);
+
+			meta &= 15;
+			if (passGrates()) {
+				if (blockBelow == Block.ironGrate) {
+					meta |= 16;
+				} else if (blockBelow == Block.woodenGrate) {
+					meta |= 32;
+				} else if (blockBelow == Block.goldenGrate) {
+					meta |= 48;
+				}
+			}
+			var1.setBlockMetadata(var2, var3, var4, meta);
+
+			if (grated) {
+				var1.setBlock(var2, var3 - dirSign, var4, Block.ironGrate.blockID);
+				var1.setBlockMetadata(var2, var3 - dirSign, var4, 1);
+			} else if (woodenGrated) {
+				var1.setBlock(var2, var3 - dirSign, var4, Block.woodenGrate.blockID);
+				var1.setBlockMetadata(var2, var3 - dirSign, var4, 1);
+			} else if (goldenGrated) {
+				var1.setBlock(var2, var3 - dirSign, var4, Block.goldenGrate.blockID);
+				var1.setBlockMetadata(var2, var3 - dirSign, var4, 1);
+			}
+
+			List ridingEntities = var1.entityMap.getEntitiesWithinAABB(null, aabb);
+			if (var1.playerEntity.boundingBox.intersectsWith(aabb)) {
+				ridingEntities.add(var1.playerEntity);
+			}
+
+			for (Object object : ridingEntities) {
+				Entity entity = (Entity)object;
+				if (dirSign != -1 && !entity.onGround) continue;
+				entity.boundingBox.minY = snapY;
+				entity.boundingBox.maxY = entity.boundingBox.minY + entity.height;
+				entity.posY = entity.boundingBox.minY + entity.yOffset;
+				if (entity.isSneaking()) {
+					entity.posY -= 0.2F;
+				}
+				entity.lastTickPosY = entity.prevPosY = entity.posY;
+				entity.onGround = true;
 			}
 		}
+
+		var1.scheduleBlockUpdate(var2, var3, var4, this.blockID);
+	}
+
+	public int getRenderType() {
+		return 9;
+	}
+
+	public boolean has3DIcon() {
+		return true;
 	}
 }
--- net/minecraft/game/item/ItemPainting.java
+++ net/minecraft/game/item/ItemPainting.java
@@ -6,7 +6,6 @@
 public final class ItemPainting extends Item {
 	public ItemPainting(int var1) {
 		super(65);
-		this.maxDamage = 64;
 	}
 
 	public final boolean onItemUse(ItemStack var1, World var2, int var3, int var4, int var5, int var6) {
--- /dev/null
+++ util/IntArray2D.java
@@ -1,0 +1,40 @@
+package util;
+
+import java.util.Arrays;
+
+public class IntArray2D {
+	private final int[] array;
+	public final int width, length;
+
+	public IntArray2D(int width, int length) {
+		this(null, width, length);
+	}
+
+	public IntArray2D(int[] array, int width, int length) {
+		if (array == null) {
+			array = new int[width * length];
+		} else if (array.length < width * length) {
+			throw new IllegalArgumentException("Array is too small!");
+		}
+
+		this.array = array;
+		this.width = width;
+		this.length = length;
+	}
+
+	public int get(int x, int z) {
+		return this.array[x + z * this.width];
+	}
+
+	public void set(int x, int z, int value) {
+		this.array[x + z * this.width] = value;
+	}
+
+	public int[] getArray() {
+		return array;
+	}
+
+	public void clear() {
+		Arrays.fill(array, 0);
+	}
+}
--- net/minecraft/client/render/Tessellator.java
+++ net/minecraft/client/render/Tessellator.java
@@ -7,6 +7,7 @@
 import org.lwjgl.opengl.ARBVertexBufferObject;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL15;
+import org.lwjgl.opengl.GLContext;
 
 public final class Tessellator {
 	private static boolean convertQuadsToTriangles = false;
@@ -31,7 +32,7 @@
 	private int vboCount = 10;
 
 	private Tessellator() {
-		this.useVBO = false;
+		this.useVBO = tryVBO && GLContext.getCapabilities().GL_ARB_vertex_buffer_object;
 		if(this.useVBO) {
 			this.vertexBuffers = BufferUtils.createIntBuffer(this.vboCount);
 			ARBVertexBufferObject.glGenBuffersARB(this.vertexBuffers);
@@ -202,6 +203,7 @@
 		++this.vertexCount;
 		if(this.vertexCount % 4 == 0 && this.rawBufferIndex >= 2097120) {
 			this.draw();
+			this.startDrawing(this.drawMode);
 		}
 
 	}
--- /dev/null
+++ net/minecraft/client/gui/GuiRecipeGuide.java
@@ -1,0 +1,136 @@
+package net.minecraft.client.gui;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.Stream;
+
+import net.minecraft.client.InventoryReadonly;
+import net.minecraft.client.gui.container.GuiContainer;
+import net.minecraft.client.gui.container.Slot;
+import net.minecraft.game.item.ItemStack;
+import net.minecraft.game.item.recipe.CraftingManager;
+import org.lwjgl.opengl.GL11;
+
+public class GuiRecipeGuide extends GuiContainer {
+    private final List<ItemStack[]> recipes = new ArrayList<>();
+    private int currentRecipe = 0;
+    private final ItemStack filterItem;
+    private final String filterItemName;
+
+    public GuiRecipeGuide() {
+        this(null);
+    }
+
+    public GuiRecipeGuide(ItemStack filterItem) {
+        this.xSize = 176;
+        this.ySize = 216;
+        this.filterItem = filterItem;
+
+        String name = "Crafting";
+//        if (filterItem != null) {
+//            ItemTooltip tooltip = this.filterItem.getTooltip();
+//            if (tooltip != null) {
+//                name = tooltip.lines.get(0);
+//            }
+//        }
+        filterItemName = name;
+
+        this.setupRecipes();
+        this.setupCurrentRecipe();
+    }
+
+    private int getMaxRecipePage() {
+        return this.recipes.size() % 3 == 0 ? this.recipes.size() / 3 - 1 : this.recipes.size() / 3;
+    }
+
+    private void setupRecipes() {
+        this.recipes.clear();
+        int r;
+        for (r = 0; r < CraftingManager.getInstance().count(); r++) {
+            ItemStack[] recipe = CraftingManager.getInstance().getRecipeAsItems(r);
+            if (showRecipe(recipe)) {
+                recipes.add(recipe);
+            }
+        }
+    }
+
+    private boolean showRecipe(ItemStack[] recipe) {
+        Stream<ItemStack> filterStream = Arrays.stream(recipe).filter(Objects::nonNull);
+        return filterItem == null
+            || filterItem.itemID == 0
+            || filterStream.anyMatch(i ->
+                i.itemID == filterItem.itemID);
+    }
+
+    protected void drawGuiContainerBackgroundLayer() {
+        int bg = this.mc.renderEngine.getTexture("/gui/guide.png");
+        GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+        this.mc.renderEngine.bindTexture(bg);
+        int posX = (this.width - this.xSize) / 2;
+        int posY = (this.height - this.ySize) / 2;
+        this.drawTexturedModalRect(posX, posY, 0, 0, this.xSize, this.ySize);
+    }
+
+    public void initGui() {
+        int posX = (this.width - this.xSize) / 2;
+        int posY = (this.height - this.ySize) / 2;
+        this.controlList.clear();
+        this.controlList.add(new GuiButton(0, 5 + posX, 193 + posY, 18, 18, "<"));
+        this.controlList.add(new GuiButton(1, 153 + posX, 193 + posY, 18, 18, ">"));
+    }
+
+    private void setupCurrentRecipe() {
+        this.inventorySlots.clear();
+        if (this.recipes.size() == 0) {
+            return;
+        }
+        for (int j = 0; j < 3; j++) {
+            if (this.currentRecipe + j >= recipes.size())
+                break;
+
+            ItemStack[] items = recipes.get(this.currentRecipe + j);
+            InventoryReadonly inventory = new InventoryReadonly(items);
+            for (int i = 0; i < 9; i++) {
+                this.inventorySlots.add(new Slot(this, inventory, i, 30 + (i % 3) * 18, 17 + (i / 3) * 18 + 63 * j));
+            }
+            this.inventorySlots.add(new Slot(this, inventory, 9, 124, 35 + 63 * j));
+        }
+    }
+
+    protected void drawGuiContainerForegroundLayer() {
+        if (this.recipes.size() > 0) {
+            String title =
+                (this.currentRecipe / 3 + 1)
+                    + " / "
+                    + (this.getMaxRecipePage() + 1)
+                    + " "
+                    + this.filterItemName
+                    + " recipes";
+
+            this.drawString(this.fontRenderer, title, 5, 5, 0xFFFFFF);
+        } else {
+            this.drawString(this.fontRenderer, "No recipes", 5, 5, 0xFFFFFF);
+        }
+    }
+
+    protected void actionPerformed(GuiButton var1) {
+        switch (var1.id) {
+            case 0:
+                this.currentRecipe -= 3;
+                if (this.currentRecipe < 0) {
+                    this.currentRecipe = getMaxRecipePage() * 3;
+                }
+                break;
+
+            case 1:
+                this.currentRecipe += 3;
+                if (this.currentRecipe >= this.recipes.size()) {
+                    this.currentRecipe = 0;
+                }
+                break;
+        }
+        this.setupCurrentRecipe();
+    }
+}
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageFortifying.java
@@ -1,0 +1,128 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.level.block.Block;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public class StageFortifying extends TerrainGenStage {
+	public StageFortifying() {
+		super("Fortifying..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			int ruinCount = blocks.width * blocks.length / (1000 * world.height / 128);
+			int baseY = Math.max(Math.max(world.waterLevel, world.groundLevel), world.height / 4);
+			if ((blocks.height - baseY - 16) / 2 <= 0) {
+				return;
+			}
+
+			for (int i = 0; i < ruinCount; i++) {
+				progressor.accept(i * 100.0F / ruinCount);
+
+				int x = rand.nextInt(blocks.width - 48) + 16;
+				int y = rand.nextInt((blocks.height - baseY - 16) / 2) + baseY;
+				int z = rand.nextInt(blocks.length - 48) + 16;
+				int subRuinCount = 10;
+
+				for (int j = 0; j < subRuinCount; j++) {
+					int sx = x + rand.nextInt(33) - 16;
+					int sy = y + rand.nextInt(17) - 8;
+					int sz = z + rand.nextInt(33) - 16;
+					int width = rand.nextInt(13) + 4;
+					int length = rand.nextInt(13) + 4;
+					boolean hasFloor = rand.nextInt(2) == 0;
+
+					Set<Integer> floorHeights = new HashSet<>();
+					int minFloorHeight = sy - rand.nextInt(5) - 1;
+					floorHeights.add(minFloorHeight);
+
+					for (int xx = sx; xx < sx + width; xx++) {
+						for (int zz = sz; zz < sz + length; zz++) {
+							if (Block.opaqueCubeLookup[blocks.get(xx, sy, zz)]) {
+								continue;
+							}
+
+							boolean wall = xx == sx || xx == sx + width - 1 || zz == sz || zz == sz + length - 1;
+							boolean corner = (xx == sx || xx == sx + width - 1) && (zz == sz || zz == sz + length - 1);
+							boolean hasWindows = rand.nextInt(4) == 0;
+
+							for (int yy = sy + ((xx / 2 + zz / 2) % 2); yy > 0; yy--) {
+								int b = blocks.get(xx, yy, zz);
+
+								if (Block.opaqueCubeLookup[b]) {
+									boolean doorway = b == Block.planks.blockID;
+									if (b == Block.stairDouble.blockID && blocks.get(xx, yy - 2, zz) != Block.stairDouble.blockID) {
+										while (!floorHeights.contains(yy) && yy > 0) {
+											yy--;
+										}
+										if (yy > 0) {
+											doorway = true;
+										}
+									}
+
+									doorway &= rand.nextInt(2) == 0 || (xx + zz) % 2 == 0;
+
+									if (doorway) {
+										for (int yy2 = yy + 1; yy2 < yy + 4; yy2++) {
+											blocks.set(xx, yy2, zz, 0);
+										}
+									}
+									break;
+								}
+
+								if (yy <= minFloorHeight) {
+									minFloorHeight = yy - (rand.nextInt(5) + 3);
+									floorHeights.add(minFloorHeight);
+								}
+
+								if (wall) {
+									int wallBlock = Block.cobblestone.blockID;
+									if (yy >= sy || corner) {
+										wallBlock = Block.stairDouble.blockID;
+									} else if (hasWindows && yy < sy - 1 && (-(yy - sy) / 2) % 2 == 1
+											&& (!floorHeights.contains(yy) || !hasFloor)) {
+										wallBlock = 0;
+									} else if (rand.nextInt(3) != 0 && -rand.nextInt(10) > yy - sy) {
+										wallBlock = Block.cobblestoneMossy.blockID;
+									}
+									blocks.set(xx, yy, zz, wallBlock);
+								} else if (hasFloor && floorHeights.contains(yy)) {
+									blocks.set(xx, yy, zz, Block.planks.blockID);
+								}
+							}
+						}
+					}
+
+					if (hasFloor && !floorHeights.isEmpty()) {
+						while (rand.nextInt(5) == 0) {
+							int cx = sx + 1 + rand.nextInt(width - 2);
+							int cz = sz + 1 + rand.nextInt(length - 2);
+							int cy = floorHeights.size() == 1
+									? floorHeights.stream().findFirst().get()
+									: floorHeights.stream().skip(rand.nextInt(floorHeights.size() - 1)).findFirst().orElse(-1)
+									+ 1;
+							if (cy > 0) {
+								chestPlacer.placeChest(cx, cy, cz);
+							}
+						}
+					}
+				}
+			}
+		});
+
+		this.addChestItem(new ChestItem(Item.swordSteel.shiftedIndex, 1, true));
+		this.addChestItem(new ChestItem(Item.helmetChain.shiftedIndex, 1, true));
+		this.addChestItem(new ChestItem(Item.plateChain.shiftedIndex, 1, true));
+		this.addChestItem(new ChestItem(Item.legsChain.shiftedIndex, 1, true));
+		this.addChestItem(new ChestItem(Item.bootsChain.shiftedIndex, 1, true));
+		this.addChestItem(new ChestItem(Item.bow.shiftedIndex, 1));
+		this.addChestItem(new ChestItem(Item.arrow.shiftedIndex, 64));
+		this.addChestItem(new ChestItem(Item.ingotIron.shiftedIndex, 8));
+
+		for (int i = 0; i < 5; i++) {
+			this.addChestItem(new ChestItem(Block.leaves.blockID, 20));
+			this.addChestItem(new ChestItem(Block.cobblestone.blockID, 20));
+			this.addChestItem(new ChestItem(Block.planks.blockID, 20));
+			this.addChestItem(new ChestItem(Item.stick.shiftedIndex, 10));
+		}
+	}
+}
--- net/minecraft/client/Session.java
+++ net/minecraft/client/Session.java
@@ -2,6 +2,9 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.level.block.Block;
 
 public final class Session {
@@ -15,7 +18,8 @@
 	}
 
 	static {
-		(registeredBlocksList = new ArrayList()).add(Block.stone);
+		registeredBlocksList = new ArrayList();
+		registeredBlocksList.add(Block.stone);
 		registeredBlocksList.add(Block.cobblestone);
 		registeredBlocksList.add(Block.brick);
 		registeredBlocksList.add(Block.dirt);
@@ -24,15 +28,28 @@
 		registeredBlocksList.add(Block.leaves);
 		registeredBlocksList.add(Block.torch);
 		registeredBlocksList.add(Block.stairSingle);
+		registeredBlocksList.add(Block.stairDouble);
+		registeredBlocksList.add(Block.woodStairSingle);
 		registeredBlocksList.add(Block.glass);
 		registeredBlocksList.add(Block.cobblestoneMossy);
+		registeredBlocksList.add(Block.grass);
 		registeredBlocksList.add(Block.sapling);
 		registeredBlocksList.add(Block.plantYellow);
 		registeredBlocksList.add(Block.plantRed);
+		registeredBlocksList.add(Block.plantBlue);
 		registeredBlocksList.add(Block.mushroomBrown);
 		registeredBlocksList.add(Block.mushroomRed);
+		registeredBlocksList.add(new ItemStack(Block.brownMushroomBlock.blockID, 1, 14));
+		registeredBlocksList.add(new ItemStack(Block.redMushroomBlock.blockID, 1, 14));
+		registeredBlocksList.add(Item.seeds);
 		registeredBlocksList.add(Block.sand);
 		registeredBlocksList.add(Block.gravel);
+		registeredBlocksList.add(Block.cactus);
+		registeredBlocksList.add(Block.ice);
+		registeredBlocksList.add(Block.blockSnow);
+		registeredBlocksList.add(Block.snow);
+		registeredBlocksList.add(Block.mud);
+		registeredBlocksList.add(Block.clay);
 		registeredBlocksList.add(Block.sponge);
 		registeredBlocksList.add(Block.clothRed);
 		registeredBlocksList.add(Block.clothOrange);
@@ -52,12 +69,46 @@
 		registeredBlocksList.add(Block.clothWhite);
 		registeredBlocksList.add(Block.oreCoal);
 		registeredBlocksList.add(Block.oreIron);
+		registeredBlocksList.add(Block.oreCopper);
 		registeredBlocksList.add(Block.oreGold);
+		registeredBlocksList.add(Block.oreDiamond);
 		registeredBlocksList.add(Block.blockSteel);
+		registeredBlocksList.add(Block.blockCopper);
 		registeredBlocksList.add(Block.blockGold);
+		registeredBlocksList.add(Block.blockDiamond);
 		registeredBlocksList.add(Block.bookShelf);
 		registeredBlocksList.add(Block.tnt);
 		registeredBlocksList.add(Block.obsidian);
+		registeredBlocksList.add(Block.workbench);
+		registeredBlocksList.add(Block.stoneOvenIdle);
+		registeredBlocksList.add(Block.stoneOvenActive);
+		registeredBlocksList.add(Block.crate);
+		registeredBlocksList.add(Block.tilledField);
+		registeredBlocksList.add(Item.doorWood);
+		registeredBlocksList.add(Item.doorSteel);
+		registeredBlocksList.add(Block.activator);
+		registeredBlocksList.add(Block.observer);
+		registeredBlocksList.add(Block.diode);
+		registeredBlocksList.add(Block.logicGate);
+		registeredBlocksList.add(Block.cog);
+		registeredBlocksList.add(Block.copperChain);
+		registeredBlocksList.add(Block.ironChain);
+		registeredBlocksList.add(Block.goldChain);
+		registeredBlocksList.add(Block.woodenGrate);
+		registeredBlocksList.add(Block.ironGrate);
+		registeredBlocksList.add(Block.goldenGrate);
+		registeredBlocksList.add(Block.lampInactive);
+		registeredBlocksList.add(Block.lampActive);
+		registeredBlocksList.add(Block.piston);
+		registeredBlocksList.add(Block.pistonCopper);
+		registeredBlocksList.add(Block.pistonGold);
+		registeredBlocksList.add(Block.magneticPlatform);
+		registeredBlocksList.add(Block.fumes);
+		registeredBlocksList.add(Item.wrench);
+		registeredBlocksList.add(Item.bucketWater);
+		registeredBlocksList.add(Item.bucketLava);
+		registeredBlocksList.add(Item.hoeGold);
+		registeredBlocksList.add(Item.striker);
 		System.out.println(registeredBlocksList.size());
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageRaisingRD.java
@@ -1,0 +1,63 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorRD;
+
+public class StageRaisingRD extends TerrainGenStage {
+	public StageRaisingRD(Block soil) {
+		super("Raising..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			int w = world.width;
+			int h = world.length;
+			int d = world.height;
+			int nw = Math.max(w, h);
+			double nwlog = (Math.log(Math.max(w, h)) / Math.log(2.0D) + 1.0e-10D);
+			if (nwlog % 1.0D > 1.0e-9D) nw = 1 << (int)(nwlog + 1.0D);
+			int[] heightmap1 = (new NoiseGeneratorRD(0)).read(nw, nw);
+			int[] heightmap2 = (new NoiseGeneratorRD(0)).read(nw, nw);
+			int[] cf = (new NoiseGeneratorRD(1)).read(nw, nw);
+			int[] rockMap = (new NoiseGeneratorRD(1)).read(nw, nw);
+
+			for(int x = 0; x < w; ++x) {
+				progressor.accept(x * 100.0F / (float)(blocks.width - 1));
+				for(int z = 0; z < h; ++z) {
+					blocks.set(x, 1, z, soil.blockID);
+					blocks.set(x, 2, z, soil.blockID);
+					for(int y = 0; y < d - 1; ++y) {
+						int i = (x % nw) + (z % nw) * nw;
+						int dh1 = heightmap1[i];
+						int dh2 = heightmap2[i];
+						int cfh = cf[i];
+						if(cfh < 128) {
+							dh2 = dh1;
+						}
+
+						int dh = dh1;
+						if(dh2 > dh1) {
+							dh = dh2;
+						}
+
+						dh = dh / 8 + d / 3;
+						int rh = rockMap[i] / 8 + d / 3;
+						if(rh > dh - 2) {
+							rh = dh - 2;
+						}
+
+						int id = 0;
+						if(y <= dh) {
+							id = soil.blockID;
+						}
+
+						if(y <= rh) {
+							id = y == d - 2 ? soil.blockID : Block.stone.blockID;
+						}
+
+						if (id != 0) {
+							blocks.set(x, y, z, (byte)id);
+						}
+					}
+				}
+			}
+		});
+	}
+}
--- net/minecraft/client/gui/GuiOptions.java
+++ net/minecraft/client/gui/GuiOptions.java
@@ -14,7 +14,21 @@
 
 	public final void initGui() {
 		for(int var1 = 0; var1 < this.options.numberOfOptions; ++var1) {
-			this.controlList.add(new GuiSmallButton(var1, this.width / 2 - 155 + var1 % 2 * 160, this.height / 6 + 24 * (var1 >> 1), this.options.setOptionString(var1)));
+			final int id = var1;
+			int x = this.width / 2 - 155 + var1 % 2 * 160;
+			int y = this.height / 6 + 24 * (var1 >> 1);
+			if (this.options.isSlider(var1)) {
+				GuiSliderGeneric slider = new GuiSliderGeneric(
+						var1, x, y, 150, 20, this.options.setOptionString(var1),
+						f -> this.options.setOptionFloat(id, f)
+				);
+				slider.sliderValue = this.options.getOptionFloat(id);
+				slider.formatter = s -> this.options.setOptionString(id);
+				slider.updateText();
+				this.controlList.add(slider);
+			} else {
+				this.controlList.add(new GuiSmallButton(var1, x, y, this.options.setOptionString(var1)));
+			}
 		}
 
 		this.controlList.add(new GuiButton(100, this.width / 2 - 100, this.height / 6 + 120 + 12, "Controls..."));
@@ -23,7 +37,7 @@
 
 	protected final void actionPerformed(GuiButton var1) {
 		if(var1.enabled) {
-			if(var1.id < 100) {
+			if(var1.id < 100 && !(var1 instanceof GuiSliderGeneric)) {
 				this.options.setOptionValue(var1.id, 1);
 				var1.displayString = this.options.setOptionString(var1.id);
 			}
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageGrowing.java
@@ -1,0 +1,91 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public final class StageGrowing extends TerrainGenStage {
+	private static final Set<Integer> GRAVEL_BEACH_REPLACABLES = new HashSet<>();
+
+	static {
+		GRAVEL_BEACH_REPLACABLES.add(Block.waterMoving.blockID);
+		GRAVEL_BEACH_REPLACABLES.add(Block.waterStill.blockID);
+		GRAVEL_BEACH_REPLACABLES.add(0);
+	}
+
+	private StageGrowing(Builder properties) {
+		super("Growing..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			NoiseGenerator sandBeachNoise = new NoiseGeneratorOctaves(rand, 8);
+			NoiseGenerator gravelBeachNoise = new NoiseGeneratorOctaves(rand, 8);
+
+			for (int x = 0; x < blocks.width; x++) {
+				progressor.accept(x * 100.0F / (float)(blocks.width - 1));
+
+				for (int z = 0; z < blocks.length; z++) {
+					boolean sandBeach = sandBeachNoise.generateNoise(x, z) > properties.sandBeachThreshold;
+					boolean gravelBeach = gravelBeachNoise.generateNoise(x, z) > properties.gravelBeachThreshold;
+
+					int y = heightmap.get(x, z);
+					int blockAbove = blocks.get(x, y + 1, z);
+					if (gravelBeach && y <= world.waterLevel + properties.beachHeightOffset && GRAVEL_BEACH_REPLACABLES.contains(blockAbove)) {
+						blocks.set(x, y, z, properties.gravelBeachBlock.blockID);
+					}
+
+					if (sandBeach && blockAbove == 0 && y <= world.waterLevel + properties.beachHeightOffset) {
+						blocks.set(x, y, z, properties.sandBeachBlock.blockID);
+					}
+				}
+			}
+		});
+	}
+
+	public static class Builder {
+		public double sandBeachThreshold = 8.0D;
+		public double gravelBeachThreshold = 12.0D;
+		public Block sandBeachBlock = Block.sand;
+		public Block gravelBeachBlock = Block.gravel;
+		public int beachHeightOffset = -1;
+
+		public Builder sandBeachThreshold(double sandBeachThreshold) {
+			this.sandBeachThreshold = sandBeachThreshold;
+			return this;
+		}
+
+		public Builder gravelBeachThreshold(double gravelBeachThreshold) {
+			this.gravelBeachThreshold = gravelBeachThreshold;
+			return this;
+		}
+
+		public Builder sandBeachBlock(Block sandBeachBlock) {
+			this.sandBeachBlock = sandBeachBlock;
+			return this;
+		}
+
+		public Builder gravelBeachBlock(Block gravelBeachBlock) {
+			this.gravelBeachBlock = gravelBeachBlock;
+			return this;
+		}
+
+		public Builder beachHeightOffset(int beachHeightOffset) {
+			this.beachHeightOffset = beachHeightOffset;
+			return this;
+		}
+
+		public Builder applyTheme(LevelTheme theme) {
+			return this
+					.sandBeachThreshold(theme.modifySandBeachThreshold(this.sandBeachThreshold))
+					.gravelBeachThreshold(theme.modifyGravelBeachThreshold(this.gravelBeachThreshold))
+					.sandBeachBlock(theme.getSandBeachBlock())
+					.gravelBeachBlock(theme.getGravelBeachBlock())
+					.beachHeightOffset(theme.modifyBeachHeightOffset(this.beachHeightOffset));
+		}
+
+		public StageGrowing build() {
+			return new StageGrowing(this);
+		}
+	}
+}
--- net/minecraft/game/item/recipe/RecipesIngots.java
+++ net/minecraft/game/item/recipe/RecipesIngots.java
@@ -5,14 +5,13 @@
 import net.minecraft.game.level.block.Block;
 
 public final class RecipesIngots {
-	private Object[][] recipeItems = new Object[][]{{Block.blockGold, Item.ingotGold}, {Block.blockSteel, Item.ingotIron}, {Block.blockDiamond, Item.diamond}};
+	private Object[][] recipeItems = new Object[][]{{Block.blockGold, Item.ingotGold}, {Block.blockSteel, Item.ingotIron}, {Block.blockDiamond, Item.diamond}, {Block.blockCopper, Item.ingotCopper}};
 
 	public final void addRecipes(CraftingManager var1) {
 		for(int var2 = 0; var2 < this.recipeItems.length; ++var2) {
 			Block var3 = (Block)this.recipeItems[var2][0];
 			Item var4 = (Item)this.recipeItems[var2][1];
 			var1.addRecipe(new ItemStack(var3), new Object[]{"###", "###", "###", Character.valueOf('#'), var4});
-			var1.addRecipe(new ItemStack(var4, 9), new Object[]{"#", Character.valueOf('#'), var3});
 		}
 
 	}
--- net/minecraft/game/entity/player/EntityPlayer.java
+++ net/minecraft/game/entity/player/EntityPlayer.java
@@ -24,6 +24,7 @@
 	public float prevCameraYaw;
 	public float cameraYaw;
 	private int damageRemainder = 0;
+	protected int flyToggleTimer;
 
 	public EntityPlayer(World var1) {
 		super(var1);
@@ -52,7 +53,17 @@
 	}
 
 	public void onLivingUpdate() {
-		this.worldObj.playSoundEffect(this.posX, this.posY, this.posZ, "calm", 0.0F);
+		if (!this.worldObj.survivalWorld) {
+			ItemStack item = this.inventory.getCurrentItem();
+			if (item != null && item.isItemStackDamageable() > 0) {
+				item.itemDamage = 0;
+			}
+		}
+
+		if(this.flyToggleTimer > 0) {
+			--this.flyToggleTimer;
+		}
+
 		if(this.worldObj.difficultySetting == 0 && this.health < 20 && this.ticksExisted % 20 << 2 == 0) {
 			this.heal(1);
 		}
@@ -67,6 +78,21 @@
 
 		this.prevCameraYaw = this.cameraYaw;
 		super.onLivingUpdate();
+
+		if (this.flying) {
+			if (this.flyDown() && this.flyUp()) {
+				this.motionY = 0.0F;
+			} else if (this.flyUp()) {
+				this.motionY = 0.4F;
+			} else if (this.flyDown()) {
+				this.motionY = -0.4F;
+			} else {
+				this.motionY *= 0.5F;
+			}
+			this.flying = !this.onGround;
+			this.distanceWalkedModified = this.prevDistanceWalkedModified;
+		}
+
 		float var1 = MathHelper.sqrt_float(this.motionX * this.motionX + this.motionZ * this.motionZ);
 		float var2 = (float)Math.atan((double)(-this.motionY * 0.2F)) * 15.0F;
 		if(var1 > 0.1F) {
@@ -218,5 +244,13 @@
 	}
 
 	public void displayGUIFurnace(TileEntityFurnace var1) {
+	}
+
+	protected boolean flyUp() {
+		return false;
+	}
+
+	protected boolean flyDown() {
+		return false;
 	}
 }
--- net/minecraft/client/gui/GuiGameOver.java
+++ net/minecraft/client/gui/GuiGameOver.java
@@ -6,10 +6,12 @@
 public final class GuiGameOver extends GuiScreen {
 	public final void initGui() {
 		this.controlList.clear();
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 72, "Generate new level..."));
-		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 96, "Load level.."));
-		if(this.mc.session == null) {
-			((GuiButton)this.controlList.get(1)).enabled = false;
+		if (this.mc.adventureMode || true) {
+			this.controlList.add(new GuiButton(3, this.width / 2 - 100, this.height / 4 + 72, "Respawn"));
+			this.controlList.add(new GuiButton(4, this.width / 2 - 100, this.height / 4 + 96, "Quit to title"));
+		} else {
+			this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 72, "Generate new level..."));
+			this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 96, "Load level..."));
 		}
 
 	}
@@ -26,8 +28,18 @@
 			this.mc.displayGuiScreen(new GuiNewLevel(this));
 		}
 
-		if(this.mc.session != null && var1.id == 2) {
-			this.mc.displayGuiScreen(new GuiLoadLevel(this));
+		if(var1.id == 2) {
+			this.mc.displayGuiScreen(new GuiTextPrompt(this, "Enter level name", this.mc::loadLevel));
+		}
+
+		if(var1.id == 3) {
+			this.mc.respawn();
+			this.mc.displayGuiScreen(null);
+		}
+
+		if(var1.id == 4) {
+			this.mc.respawn();
+			this.mc.setLevel(null);
 		}
 
 	}
@@ -38,10 +50,7 @@
 		GL11.glScalef(2.0F, 2.0F, 2.0F);
 		drawCenteredString(this.fontRenderer, "Game over!", this.width / 2 / 2, 30, 16777215);
 		GL11.glPopMatrix();
-		FontRenderer var10000 = this.fontRenderer;
-		StringBuilder var10001 = (new StringBuilder()).append("Score: &e");
-		EntityPlayerSP var4 = this.mc.thePlayer;
-		drawCenteredString(var10000, var10001.append(var4.getScore).toString(), this.width / 2, 100, 16777215);
+		drawCenteredString(this.fontRenderer, "Score: &e" + this.mc.thePlayer.getScore, this.width / 2, 100, 16777215);
 		super.drawScreen(var1, var2, var3);
 	}
 
--- net/minecraft/client/render/RenderEngine.java
+++ net/minecraft/client/render/RenderEngine.java
@@ -1,9 +1,10 @@
 package net.minecraft.client.render;
 
-import java.awt.Graphics;
+import java.awt.*;
 import java.awt.image.BufferedImage;
 import java.awt.image.ImageObserver;
 import java.io.IOException;
+import java.io.InputStream;
 import java.nio.ByteBuffer;
 import java.nio.IntBuffer;
 import java.util.ArrayList;
@@ -26,9 +27,18 @@
 	private Map urlToImageDataMap = new HashMap();
 	private GameSettings options;
 	private boolean clampTexture = false;
+	private boolean bilinearTexture = false;
+	private BufferedImage missingTextureImage = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
 
 	public RenderEngine(GameSettings var1) {
 		this.options = var1;
+		Graphics var3 = this.missingTextureImage.getGraphics();
+		var3.setColor(Color.black);
+		var3.fillRect(0, 0, 16, 16);
+		var3.setColor(Color.magenta);
+		var3.fillRect(0, 8, 8, 8);
+		var3.fillRect(8, 0, 8, 8);
+		var3.dispose();
 	}
 
 	public final int getTexture(String var1) {
@@ -39,21 +49,55 @@
 			try {
 				this.singleIntBuffer.clear();
 				GL11.glGenTextures(this.singleIntBuffer);
-				int var4 = this.singleIntBuffer.get(0);
-				if(var1.startsWith("##")) {
-					this.setupTexture(unwrapImageByColumns(ImageIO.read(RenderEngine.class.getResourceAsStream(var1.substring(2)))), var4);
-				} else if(var1.startsWith("%%")) {
-					this.clampTexture = true;
-					this.setupTexture(ImageIO.read(RenderEngine.class.getResourceAsStream(var1.substring(2))), var4);
-					this.clampTexture = false;
-				} else {
-					this.setupTexture(ImageIO.read(RenderEngine.class.getResourceAsStream(var1)), var4);
-				}
-
-				this.textureMap.put(var1, Integer.valueOf(var4));
-				return var4;
+				int textureId = this.singleIntBuffer.get(0);
+
+				int mode = var1.startsWith("##") ? 1
+						: var1.startsWith("%%") ? 2
+						: var1.startsWith("$$") ? 3
+						: 0;
+				String path = var1;
+				if (mode != 0) {
+					path = path.substring(2);
+				}
+
+				BufferedImage image = this.missingTextureImage;
+				try (InputStream stream = RenderEngine.class.getResourceAsStream(path)) {
+					if (stream != null) {
+						BufferedImage newImage = ImageIO.read(stream);
+						if (newImage != null) {
+							image = newImage;
+						}
+					}
+				}
+
+                switch (mode) {
+                    case 1:
+                        this.setupTexture(unwrapImageByColumns(image), textureId);
+                        break;
+                    case 2:
+                        this.clampTexture = true;
+                        this.setupTexture(image, textureId);
+                        this.clampTexture = false;
+                        break;
+                    case 3:
+                        this.bilinearTexture = true;
+                        this.setupTexture(image, textureId);
+                        this.bilinearTexture = false;
+                        break;
+                    default:
+                        this.setupTexture(image, textureId);
+                        break;
+                }
+
+				this.textureMap.put(var1, textureId);
+				return textureId;
 			} catch (IOException var3) {
-				throw new RuntimeException("!!");
+				var3.printStackTrace();
+				GL11.glGenTextures(this.singleIntBuffer);
+				int textureId = this.singleIntBuffer.get(0);
+				this.setupTexture(this.missingTextureImage, textureId);
+				this.textureMap.put(var1, textureId);
+				return textureId;
 			}
 		}
 	}
@@ -73,8 +117,13 @@
 
 	private void setupTexture(BufferedImage var1, int var2) {
 		GL11.glBindTexture(GL11.GL_TEXTURE_2D, var2);
-		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
-		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
+		if (this.bilinearTexture) {
+			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
+			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
+		} else {
+			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
+			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
+		}
 		if(this.clampTexture) {
 			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_CLAMP);
 			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_CLAMP);
--- net/minecraft/client/gui/GuiScreen.java
+++ net/minecraft/client/gui/GuiScreen.java
@@ -15,6 +15,7 @@
 	protected List controlList = new ArrayList();
 	public boolean allowUserInput = false;
 	protected FontRenderer fontRenderer;
+	private GuiButton selectedButton = null;
 
 	public void drawScreen(int var1, int var2, float var3) {
 		for(int var5 = 0; var5 < this.controlList.size(); ++var5) {
@@ -37,12 +38,22 @@
 			for(var3 = 0; var3 < this.controlList.size(); ++var3) {
 				GuiButton var4 = (GuiButton)this.controlList.get(var3);
 				if(var4.mousePressed(var1, var2)) {
+					this.selectedButton = var4;
 					this.mc.sndManager.playSoundFX("random.click", 1.0F, 1.0F);
 					this.actionPerformed(var4);
 				}
 			}
 		}
-
+	}
+
+	protected void mouseMovedOrUp(int var1, int var2, int var3) {
+		if(this.selectedButton != null && var3 == 0) {
+			this.selectedButton.mouseReleased(var1, var2);
+			this.selectedButton = null;
+		}
+	}
+
+	protected void mouseScrolled(int delta) {
 	}
 
 	protected void actionPerformed(GuiButton var1) {
@@ -53,6 +64,7 @@
 		this.fontRenderer = var1.fontRenderer;
 		this.width = var2;
 		this.height = var3;
+		this.controlList.clear();
 		this.initGui();
 	}
 
@@ -65,9 +77,13 @@
 			int var2 = this.height - Mouse.getEventY() * this.height / this.mc.displayHeight - 1;
 			this.drawSlotInventory(var1, var2, Mouse.getEventButton());
 		} else {
-			Mouse.getEventX();
-			Mouse.getEventY();
-			Mouse.getEventButton();
+			int var1 = Mouse.getEventX() * this.width / this.mc.displayWidth;
+			int var2 = this.height - Mouse.getEventY() * this.height / this.mc.displayHeight - 1;
+			this.mouseMovedOrUp(var1, var2, Mouse.getEventButton());
+		}
+
+		if(Mouse.getEventDWheel() != 0) {
+			this.mouseScrolled(Mouse.getEventDWheel());
 		}
 	}
 
@@ -97,19 +113,63 @@
 			GL11.glDisable(GL11.GL_LIGHTING);
 			GL11.glDisable(GL11.GL_FOG);
 			Tessellator var2 = Tessellator.instance;
-			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/dirt.png"));
+//			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/dirt.png"));
+//			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+//			var2.startDrawingQuads();
+//			var2.setColorOpaque_I(4210752);
+//			var2.addVertexWithUV(0.0F, (float)this.height, 0.0F, 0.0F, (float)this.height / 32.0F);
+//			var2.addVertexWithUV((float)this.width, (float)this.height, 0.0F, (float)this.width / 32.0F, (float)this.height / 32.0F);
+//			var2.addVertexWithUV((float)this.width, 0.0F, 0.0F, (float)this.width / 32.0F, 0.0F);
+//			var2.addVertexWithUV(0.0F, 0.0F, 0.0F, 0.0F, 0.0F);
+//			var2.draw();
+
+			// Sky
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, 0);
+			var2.startDrawingQuads();
+			var2.setColorRGBA_F(0.9F, 0.95F, 1.0F, 1.0F);
+			var2.addVertex(0.0F, this.height, this.zLevel);
+			var2.addVertex(this.width, this.height, this.zLevel);
+//			var2.setColorRGBA_F(0.6F, 0.8F, 1.0F, 1.0F);
+			var2.setColorRGBA_F(0.35F, 0.7F, 1.0F, 1.0F);
+			var2.addVertex(this.width, 0.0F, this.zLevel);
+			var2.addVertex(0.0F, 0.0F, this.zLevel);
+			var2.draw();
+
+			// Horizon
+			float scale = 4.0F;
+			float scroll = (System.currentTimeMillis() % 250000L) / 250000.0F;
+			GL11.glEnable(GL11.GL_BLEND);
+			GL11.glColor4f(0.6F, 0.8F, 1.0F, 1.0F);
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/horizon/hills.png"));
+			var2.startDrawingQuads();
+			var2.addVertexWithUV(0.0F, this.height, this.zLevel, scroll, 1.0F);
+			var2.addVertexWithUV((float)this.width, this.height, this.zLevel, 1.0F / scale + scroll, 1.0F);
+			var2.addVertexWithUV((float)this.width, this.height - (float)this.width / this.height * 16.0F * scale, this.zLevel, 1.0F / scale + scroll, 0.0F);
+			var2.addVertexWithUV(0.0F, this.height - (float)this.width / this.height * 16.0F * scale, this.zLevel, scroll, 0.0F);
+			var2.draw();
+
+			// Clouds
+			scale = (float)(this.height / 2.0F) / 12.0F;
+			scroll = (System.currentTimeMillis() % 250000L) / 250000.0F;
 			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/clouds.png"));
 			var2.startDrawingQuads();
-			var2.setColorOpaque_I(4210752);
-			var2.addVertexWithUV(0.0F, (float)this.height, 0.0F, 0.0F, (float)this.height / 32.0F);
-			var2.addVertexWithUV((float)this.width, (float)this.height, 0.0F, (float)this.width / 32.0F, (float)this.height / 32.0F);
-			var2.addVertexWithUV((float)this.width, 0.0F, 0.0F, (float)this.width / 32.0F, 0.0F);
-			var2.addVertexWithUV(0.0F, 0.0F, 0.0F, 0.0F, 0.0F);
+			var2.setColorRGBA_F(1.0F, 1.0F, 1.0F, 1.0F);
+			var2.addVertexWithUV(0.0F, 0.0F, this.zLevel, scroll, 1.0F / scale / 2.5F + 0.25F);
+			var2.addVertexWithUV((float)this.width, 0.0F, this.zLevel, 1.0F / scale + scroll, 1.0F / scale / 2.5F + 0.25F);
+			var2.setColorRGBA_F(0.6F, 0.8F, 1.0F, 0.0F);
+			var2.addVertexWithUV((float)this.width, this.height / 2.0F, this.zLevel, 1.0F / scale + scroll, 0.25F);
+			var2.addVertexWithUV(0.0F, this.height / 2.0F, this.zLevel, scroll, 0.25F);
 			var2.draw();
+			GL11.glDisable(GL11.GL_BLEND);
 		}
 	}
 
 	public boolean doesGuiPauseGame() {
 		return true;
+	}
+
+	protected final boolean hasSelectedButton() {
+		return this.selectedButton != null;
 	}
 }
--- net/minecraft/game/level/block/BlockStep.java
+++ net/minecraft/game/level/block/BlockStep.java
@@ -7,10 +7,10 @@
 public final class BlockStep extends Block {
 	private boolean blockType;
 
-	public BlockStep(int var1, boolean var2) {
-		super(var1, 6, Material.rock);
-		this.blockType = var2;
-		if(!var2) {
+	public BlockStep(int var1, int var2, Material var3, boolean var4) {
+		super(var1, var2, var3);
+		this.blockType = var4;
+		if(!var4) {
 			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
 		}
 
@@ -18,7 +18,7 @@
 	}
 
 	public final int getBlockTextureFromSide(int var1) {
-		return var1 <= 1 ? 6 : 5;
+		return this.blockIndexInTexture == 6 ? (var1 <= 1 ? 6 : 5) : this.blockIndexInTexture;
 	}
 
 	public final boolean isOpaqueCube() {
@@ -31,20 +31,26 @@
 	}
 
 	public final void onBlockAdded(World var1, int var2, int var3, int var4) {
-		if(this != Block.stairSingle) {
+		if(this.blockType) {
 			super.onBlockAdded(var1, var2, var3, var4);
+			return;
 		}
 
+		int stairDouble = this.blockID - 1;
 		int var5 = var1.getBlockId(var2, var3 - 1, var4);
-		if(var5 == stairSingle.blockID) {
+		if(var5 == this.blockID) {
 			var1.setBlockWithNotify(var2, var3, var4, 0);
-			var1.setBlockWithNotify(var2, var3 - 1, var4, Block.stairDouble.blockID);
+			var1.setBlockWithNotify(var2, var3 - 1, var4, stairDouble);
 		}
 
+	}
+
+	public int quantityDropped(Random var1) {
+		return this.blockType ? 2 : 1;
 	}
 
 	public final int idDropped(int var1, Random var2) {
-		return Block.stairSingle.blockID;
+		return this.blockType ? this.blockID + 1 : this.blockID;
 	}
 
 	public final boolean renderAsNormalBlock() {
--- net/minecraft/game/level/block/BlockFluid.java
+++ net/minecraft/game/level/block/BlockFluid.java
@@ -4,16 +4,19 @@
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.material.Material;
 import net.minecraft.game.physics.AxisAlignedBB;
+import net.minecraft.game.physics.Vec3D;
 
 public class BlockFluid extends Block {
 	protected int stillId;
 	protected int movingId;
+	protected int liquidType = 1;
 
-	protected BlockFluid(int var1, Material var2) {
+	public BlockFluid(int var1, Material var2) {
 		super(var1, var2);
 		this.blockIndexInTexture = 14;
 		if(var2 == Material.lava) {
 			this.blockIndexInTexture = 30;
+			this.liquidType = 2;
 		}
 
 		Block.isBlockFluid[var1] = true;
@@ -24,60 +27,41 @@
 		this.setResistance(2.0F);
 	}
 
+	public void resetBlockBounds() {
+		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, getFluidHeightPercent(7), 1.0F);
+	}
+
+	public static float getFluidHeightPercent(int var0) {
+		if(var0 >= 8) {
+			var0 = 0;
+		}
+
+		float var1 = (float)(var0 + 1) / 9.0F;
+		return var1;
+	}
+
+	public void setBoundsForRender(World var1, int var2, int var3, int var4) {
+		if (Block.isBlockFluid[var1.getBlockId(var2, var3 + 1, var4)]) {
+			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+		} else {
+			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F - getFluidHeightPercent(var1.getBlockMetadata(var2, var3, var4)), 1.0F);
+		}
+	}
+
 	public final int getBlockTextureFromSide(int var1) {
 		return this.material == Material.lava ? this.blockIndexInTexture : (var1 == 1 ? this.blockIndexInTexture : (var1 == 0 ? this.blockIndexInTexture : this.blockIndexInTexture + 32));
 	}
 
+	protected final int getFlowDecay(World var1, int var2, int var3, int var4) {
+		return var1.getBlockMaterial(var2, var3, var4) != this.material ? -1 : var1.getBlockMetadata(var2, var3, var4);
+	}
+
 	public final boolean renderAsNormalBlock() {
 		return false;
 	}
 
 	public void onBlockAdded(World var1, int var2, int var3, int var4) {
-		var1.scheduleBlockUpdate(var2, var3, var4, this.movingId);
-	}
-
-	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
-		this.update(var1, var2, var3, var4, 0);
-	}
-
-	public boolean update(World var1, int var2, int var3, int var4, int var5) {
-		boolean var7 = false;
-
-		boolean var6;
-		do {
-			--var3;
-			if(!this.canFlow(var1, var2, var3, var4)) {
-				break;
-			}
-
-			var6 = var1.setBlockWithNotify(var2, var3, var4, this.movingId);
-			if(var6) {
-				var7 = true;
-			}
-		} while(var6 && this.material != Material.lava);
-
-		++var3;
-		if(this.material == Material.water || !var7) {
-			var7 |= this.flow(var1, var2 - 1, var3, var4);
-			var7 |= this.flow(var1, var2 + 1, var3, var4);
-			var7 |= this.flow(var1, var2, var3, var4 - 1);
-			var7 |= this.flow(var1, var2, var3, var4 + 1);
-		}
-
-		if(this.material == Material.lava) {
-			var7 |= extinguishFireLava(var1, var2 - 1, var3, var4);
-			var7 |= extinguishFireLava(var1, var2 + 1, var3, var4);
-			var7 |= extinguishFireLava(var1, var2, var3, var4 - 1);
-			var7 |= extinguishFireLava(var1, var2, var3, var4 + 1);
-		}
-
-		if(!var7) {
-			var1.setTileNoUpdate(var2, var3, var4, this.stillId);
-		} else {
-			var1.scheduleBlockUpdate(var2, var3, var4, this.movingId);
-		}
-
-		return var7;
+		this.checkForHarden(var1, var2, var3, var4);
 	}
 
 	protected final boolean canFlow(World var1, int var2, int var3, int var4) {
@@ -127,9 +111,18 @@
 	}
 
 	public boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
-		if(var2 >= 0 && var3 >= 0 && var4 >= 0 && var2 < var1.width && var4 < var1.length) {
+		if(var2 >= 0 && var3 >= 0 && var4 >= 0 && var2 < var1.width && var3 < var1.height && var4 < var1.length) {
 			int var6 = var1.getBlockId(var2, var3, var4);
-			return var6 != this.movingId && var6 != this.stillId ? (var5 != 1 || var1.getBlockId(var2 - 1, var3, var4) != 0 && var1.getBlockId(var2 + 1, var3, var4) != 0 && var1.getBlockId(var2, var3, var4 - 1) != 0 && var1.getBlockId(var2, var3, var4 + 1) != 0 ? super.shouldSideBeRendered(var1, var2, var3, var4, var5) : true) : false;
+			float var6a = getFluidHeightPercent(var1.getBlockMetadata(var2, var3, var4));
+			if (Block.isBlockFluid[var1.getBlockId(var2, var3 + 1, var4)]) var6a = 1.0F;
+			int var2o = var2 + (var5 == 4 ? 1 : var5 == 5 ? -1 : 0);
+			int var3o = var3 + (var5 == 0 ? 1 : var5 == 1 ? -1 : 0);
+			int var4o = var4 + (var5 == 2 ? 1 : var5 == 3 ? -1 : 0);
+			float var6b = getFluidHeightPercent(var1.getBlockMetadata(var2o, var3o, var4o));
+			if (Block.isBlockFluid[var1.getBlockId(var2o, var3o + 1, var4o)]) var6b = 1.0F;
+			return (var6 != this.movingId && var6 != this.stillId || var5 >= 2 && var6a != var6b)
+					&& (var5 == 1 && (var1.getBlockId(var2 - 1, var3, var4) == 0 || var1.getBlockId(var2 + 1, var3, var4) == 0 || var1.getBlockId(var2, var3, var4 - 1) == 0 || var1.getBlockId(var2, var3, var4 + 1) == 0)
+					|| super.shouldSideBeRendered(var1, var2, var3, var4, var5));
 		} else {
 			return false;
 		}
@@ -139,7 +132,7 @@
 		return false;
 	}
 
-	public AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
+	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
 		return null;
 	}
 
@@ -148,14 +141,111 @@
 	}
 
 	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
-		if(var5 != 0) {
-			Material var6 = Block.blocksList[var5].material;
-			if(this.material == Material.water && var6 == Material.lava || var6 == Material.water && this.material == Material.lava) {
-				var1.setBlockWithNotify(var2, var3, var4, Block.stone.blockID);
-			}
-		}
-
-		var1.scheduleBlockUpdate(var2, var3, var4, this.blockID);
+		this.checkForHarden(var1, var2, var3, var4);
+	}
+
+	private int getEffectiveFlowDecay(World var1, int var2, int var3, int var4) {
+		if(var1.getBlockMaterial(var2, var3, var4) != this.material) {
+			return -1;
+		} else {
+			int var5 = var1.getBlockMetadata(var2, var3, var4);
+			if(var5 >= 8) {
+				var5 = 0;
+			}
+
+			return var5;
+		}
+	}
+
+	private Vec3D getFlowVector(World var1, int var2, int var3, int var4) {
+		Vec3D var5 = new Vec3D(0.0F, 0.0F, 0.0F);
+		int var6 = this.getEffectiveFlowDecay(var1, var2, var3, var4);
+
+		for(int var7 = 0; var7 < 4; ++var7) {
+			int var8 = var2;
+			int var9 = var4;
+			if(var7 == 0) {
+				var8 = var2 - 1;
+			}
+
+			if(var7 == 1) {
+				var9 = var4 - 1;
+			}
+
+			if(var7 == 2) {
+				++var8;
+			}
+
+			if(var7 == 3) {
+				++var9;
+			}
+
+			int var10 = this.getEffectiveFlowDecay(var1, var8, var3, var9);
+			if(var10 < 0) {
+				var10 = this.getEffectiveFlowDecay(var1, var8, var3 - 1, var9);
+				if(var10 >= 0) {
+					var10 -= var6 - 8;
+					var5 = var5.addVector((float)((var8 - var2) * var10), (float)(var10 * 0), (float)((var9 - var4) * var10));
+				}
+			} else if(var10 >= 0) {
+				var10 -= var6;
+				var5 = var5.addVector((float)((var8 - var2) * var10), (float)(var10 * 0), (float)((var9 - var4) * var10));
+			}
+		}
+
+		if(var1.getBlockMetadata(var2, var3, var4) >= 8) {
+			boolean var11 = false;
+			if(this.getIsBlockSolid(var1, var2, var3, var4 - 1, 2)) {
+				var11 = true;
+			}
+
+			if(var11 || this.getIsBlockSolid(var1, var2, var3, var4 + 1, 3)) {
+				var11 = true;
+			}
+
+			if(var11 || this.getIsBlockSolid(var1, var2 - 1, var3, var4, 4)) {
+				var11 = true;
+			}
+
+			if(var11 || this.getIsBlockSolid(var1, var2 + 1, var3, var4, 5)) {
+				var11 = true;
+			}
+
+			if(var11 || this.getIsBlockSolid(var1, var2, var3 + 1, var4 - 1, 2)) {
+				var11 = true;
+			}
+
+			if(var11 || this.getIsBlockSolid(var1, var2, var3 + 1, var4 + 1, 3)) {
+				var11 = true;
+			}
+
+			if(var11 || this.getIsBlockSolid(var1, var2 - 1, var3 + 1, var4, 4)) {
+				var11 = true;
+			}
+
+			if(var11 || this.getIsBlockSolid(var1, var2 + 1, var3 + 1, var4, 5)) {
+				var11 = true;
+			}
+
+			if(var11) {
+				var5 = var5.normalize().addVector(0.0F, -6.0F, 0.0F);
+			}
+		}
+
+		var5 = var5.normalize();
+		return var5;
+	}
+
+	public final boolean getIsBlockSolid(World var1, int var2, int var3, int var4, int var5) {
+		Material var6 = var1.getBlockMaterial(var2, var3, var4);
+		return var6 == this.material ? false : (var5 == 1 ? true : !var1.isBlockNormalCube(var2, var3, var4));
+	}
+
+	public final void velocityToAddToEntity(World var1, int var2, int var3, int var4, Vec3D var5) {
+		Vec3D var6 = this.getFlowVector(var1, var2, var3, var4);
+		var5.xCoord += var6.xCoord;
+		var5.yCoord += var6.yCoord;
+		var5.zCoord += var6.zCoord;
 	}
 
 	public int tickRate() {
@@ -221,5 +311,57 @@
 		Material var4 = var0.getBlockMaterial(var1, var2, var3);
 		Material var5 = var0.getBlockMaterial(var1, var2 - 1, var3);
 		return !var4.getIsSolid() && !var4.getIsLiquid() ? var5.getIsSolid() || var5.getIsLiquid() : false;
+	}
+
+	private void checkForHarden(World var1, int var2, int var3, int var4) {
+		if(var1.getBlockId(var2, var3, var4) == this.blockID) {
+			if(this.material == Material.lava) {
+				boolean var5 = false;
+				if(var5 || var1.getBlockMaterial(var2, var3, var4 - 1) == Material.water) {
+					var5 = true;
+				}
+
+				if(var5 || var1.getBlockMaterial(var2, var3, var4 + 1) == Material.water) {
+					var5 = true;
+				}
+
+				if(var5 || var1.getBlockMaterial(var2 - 1, var3, var4) == Material.water) {
+					var5 = true;
+				}
+
+				if(var5 || var1.getBlockMaterial(var2 + 1, var3, var4) == Material.water) {
+					var5 = true;
+				}
+
+				if(var5 || var1.getBlockMaterial(var2, var3 + 1, var4) == Material.water) {
+					var5 = true;
+				}
+
+				if(var5) {
+					int var6 = var1.getBlockMetadata(var2, var3, var4);
+					if(var6 == 0) {
+						var1.setBlockWithNotify(var2, var3, var4, Block.obsidian.blockID);
+					} else if(var6 <= 4) {
+						var1.setBlockWithNotify(var2, var3, var4, Block.cobblestone.blockID);
+					}
+
+					this.triggerLavaMixEffects(var1, var2, var3, var4);
+				}
+			}
+
+		}
+	}
+
+	protected static void triggerLavaMixEffects(World var0, int var1, int var2, int var3) {
+//		var0.playSoundEffect(((float)var1 + 0.5F), ((float)var2 + 0.5F), ((float)var3 + 0.5F), "random.fizz", 2.6F + (var0.random.nextFloat() - var0.random.nextFloat()) * 0.8F);
+
+		for(int var4 = 0; var4 < 8; ++var4) {
+			var0.spawnParticle("largesmoke", var1 + (float)Math.random(), var2 + (float)1.2D, var3 + (float)Math.random(), 0.0F, 0.0F, 0.0F);
+		}
+
+	}
+
+	public boolean displace(World world, int x, int y, int z) {
+		return true;
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeatureCacti.java
@@ -1,0 +1,27 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+
+import java.util.Random;
+
+public class FeatureCacti implements Feature {
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		for(int var6 = 0; var6 < 10; ++var6) {
+			int var7 = var3 + var2.nextInt(8) - var2.nextInt(8);
+			int var8 = var4 + var2.nextInt(4) - var2.nextInt(4);
+			int var9 = var5 + var2.nextInt(8) - var2.nextInt(8);
+			if(var1.getBlockId(var7, var8, var9) == 0) {
+				int var10 = 1 + var2.nextInt(var2.nextInt(3) + 2);
+
+				for(int var11 = 0; var11 < var10; ++var11) {
+					if(Block.cactus.canBlockStay(var1, var7, var8 + var11, var9)) {
+						var1.setBlock(var7, var8 + var11, var9, Block.cactus.blockID);
+					}
+				}
+			}
+		}
+
+		return true;
+	}
+}
--- net/minecraft/game/entity/monster/EntityCreeper.java
+++ net/minecraft/game/entity/monster/EntityCreeper.java
@@ -14,6 +14,7 @@
 	public EntityCreeper(World var1) {
 		super(var1);
 		this.texture = "/mob/creeper.png";
+		this.scoreValue = 250;
 	}
 
 	protected final void writeEntityToNBT(NBTTagCompound var1) {
--- net/minecraft/game/level/Light.java
+++ net/minecraft/game/level/Light.java
@@ -3,6 +3,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import net.minecraft.game.level.block.Block;
+import util.MathHelper;
 
 public final class Light {
 	private int lightingUpdateCounter = 0;
@@ -40,7 +41,7 @@
 	}
 
 	public final void updateSkylight(int var1, int var2, int var3, int var4) {
-		this.lightingUpdateList1.add(new MetadataChunkBlock(this, var1, var2, 0, var3, var4, 1));
+		this.lightingUpdateList1.add(0, new MetadataChunkBlock(null, var1, var2, 0, var3, var4, 1));
 	}
 
 	public final void updateDaylightCycle(int var1) {
@@ -61,7 +62,7 @@
 				this.updateLight(64);
 			}
 
-			this.metadataChunkBlock = new MetadataChunkBlock(this, 0, 0, 0, this.worldObj.width, this.worldObj.height, this.worldObj.length);
+			this.metadataChunkBlock = new MetadataChunkBlock(null, 0, 0, 0, this.worldObj.width, this.worldObj.height, this.worldObj.length);
 		}
 	}
 
@@ -103,8 +104,8 @@
 
 		for(var6 = 0; var6 < this.worldWidth; var6 += 32) {
 			for(var7 = 0; var7 < this.worldLength; var7 += 32) {
-				this.blockLightList.add(new MetadataChunkBlock(this, var6, 0, var7, var6 + 32, this.worldHeight, var7 + 32));
-				this.skyLightList.add(new MetadataChunkBlock(this, var6, 0, var7, var6 + 32, this.worldHeight, var7 + 32));
+				this.blockLightList.add(new MetadataChunkBlock(null, var6, 0, var7, var6 + 32, this.worldHeight, var7 + 32));
+				this.skyLightList.add(new MetadataChunkBlock(null, var6, 0, var7, var6 + 32, this.worldHeight, var7 + 32));
 			}
 		}
 
@@ -117,7 +118,7 @@
 	}
 
 	public final void updateBlockLight(int var1, int var2, int var3, int var4, int var5, int var6) {
-		this.blockLightList.add(new MetadataChunkBlock(this, var1, var2, var3, var4, var5, var6));
+		this.blockLightList.add(0, new MetadataChunkBlock(null, var1, var2, var3, var4, var5, var6));
 	}
 
 	private void updateLists(int var1, int var2, int var3, int var4, int var5, int var6) {
@@ -152,7 +153,7 @@
 			this.lightingUpdateList2.remove(this.lightingUpdateList2.size() - 1);
 		}
 
-		int var1 = 5;
+		int var1 = 50;
 
 		while(this.skyLightList.size() > 0 && var1-- > 0) {
 			MetadataChunkBlock var2 = (MetadataChunkBlock)this.skyLightList.remove(0);
@@ -184,7 +185,6 @@
 				int var11;
 				int var12;
 				int var13;
-				Light var22;
 				if(this.lightingUpdateList1.size() > 0) {
 					var20 = true;
 					var21 = (MetadataChunkBlock)this.lightingUpdateList1.remove(0);
@@ -192,26 +192,24 @@
 					var6 = var21.maxX;
 					var5 = var21.y;
 					var4 = var21.x;
-					var22 = this;
 
 					for(var8 = var4; var8 < var4 + var6; ++var8) {
 						for(var9 = var5; var9 < var5 + var7; ++var9) {
-							var10 = var22.heightMap[var8 + var9 * var22.worldWidth];
+							var10 = this.heightMap[var8 + var9 * this.worldWidth];
 
-							for(var11 = var22.worldHeight - 1; var11 > 0 && Block.lightOpacity[var22.blocks[(var11 * var22.worldLength + var9) * var22.worldWidth + var8]] == 0; --var11) {
+							for(var11 = this.worldHeight - 1; var11 > 0 && Block.lightOpacity[this.blocks[(var11 * this.worldLength + var9) * this.worldWidth + var8]] == 0; --var11) {
 							}
 
-							var22.heightMap[var8 + var9 * var22.worldWidth] = var11 + 1;
+							this.heightMap[var8 + var9 * this.worldWidth] = var11 + 1;
 							if(var10 != var11) {
 								var12 = var10 < var11 ? var10 : var11;
 								var13 = var10 > var11 ? var10 : var11;
-								var22.updateLists(var8, var12, var9, var8 + 1, var13, var9 + 1);
+								this.updateLists(var8, var12, var9, var8 + 1, var13, var9 + 1);
 							}
 						}
 					}
 				}
 
-				var22 = this;
 				var4 = this.worldObj.skylightSubtracted;
 				var5 = -999;
 				var6 = -999;
@@ -222,34 +220,34 @@
 				var11 = 1024;
 				var12 = 0;
 
-				while(var11-- > 0 && (var22.lightingUpdateCounter > 0 || var22.lightingUpdateList.size() > 0)) {
+				while(var11-- > 0 && (this.lightingUpdateCounter > 0 || this.lightingUpdateList.size() > 0)) {
 					++var12;
-					if(var22.lightingUpdateCounter == 0) {
-						if(var22.lightingUpdateList3 != null) {
-							int[] var23 = var22.lightingUpdateList3;
-							var22.lightingUpdateList2.add(var23);
+					if(this.lightingUpdateCounter == 0) {
+						if(this.lightingUpdateList3 != null) {
+							int[] var23 = this.lightingUpdateList3;
+							this.lightingUpdateList2.add(var23);
 						}
 
-						var22.lightingUpdateList3 = (int[])var22.lightingUpdateList.remove(var22.lightingUpdateList.size() - 1);
-						var22.lightingUpdateCounter = var22.lightingUpdateList3[var22.lightingUpdateList3.length - 1];
+						this.lightingUpdateList3 = (int[])this.lightingUpdateList.remove(this.lightingUpdateList.size() - 1);
+						this.lightingUpdateCounter = this.lightingUpdateList3[this.lightingUpdateList3.length - 1];
 					}
 
-					if(var22.lightingUpdateCounter > var22.lightingUpdateList3.length - 32) {
-						var13 = var22.lightingUpdateList3[--var22.lightingUpdateCounter];
-						var22.lightingUpdateList3[var22.lightingUpdateList3.length - 1] = var22.lightingUpdateCounter;
-						var22.lightingUpdateList.add(var22.lightingUpdateList3);
-						var22.lightingUpdateList3 = var22.getLightingUpdates();
-						var22.lightingUpdateCounter = 1;
-						var22.lightingUpdateList3[0] = var13;
+					if(this.lightingUpdateCounter > this.lightingUpdateList3.length - 32) {
+						var13 = this.lightingUpdateList3[--this.lightingUpdateCounter];
+						this.lightingUpdateList3[this.lightingUpdateList3.length - 1] = this.lightingUpdateCounter;
+						this.lightingUpdateList.add(this.lightingUpdateList3);
+						this.lightingUpdateList3 = this.getLightingUpdates();
+						this.lightingUpdateCounter = 1;
+						this.lightingUpdateList3[0] = var13;
 					} else {
-						var13 = var22.lightingUpdateList3[--var22.lightingUpdateCounter];
-						var1 = var13 % var22.worldWidth;
-						int var14 = var13 / var22.worldWidth % var22.worldHeight;
-						int var15 = var13 / var22.worldWidth / var22.worldHeight % var22.worldLength;
-						var22.chunks[var13 >> 3] = (byte)(var22.chunks[var13 >> 3] ^ 1 << (var13 & 7));
-						var13 = var22.heightMap[var1 + var15 * var22.worldWidth];
+						var13 = this.lightingUpdateList3[--this.lightingUpdateCounter];
+						var1 = var13 % this.worldWidth;
+						int var14 = var13 / this.worldWidth % this.worldHeight;
+						int var15 = var13 / this.worldWidth / this.worldHeight % this.worldLength;
+						this.chunks[var13 >> 3] = (byte)(this.chunks[var13 >> 3] ^ 1 << (var13 & 7));
+						var13 = this.heightMap[var1 + var15 * this.worldWidth];
 						int var16 = var14 >= var13 ? var4 : 0;
-						byte var24 = var22.blocks[(var14 * var22.worldLength + var15) * var22.worldWidth + var1];
+						byte var24 = this.blocks[(var14 * this.worldLength + var15) * this.worldWidth + var1];
 						int var17 = Block.lightOpacity[var24];
 						if(var17 > 100) {
 							var16 = 0;
@@ -261,42 +259,42 @@
 
 							int var18;
 							if(var1 > 0) {
-								var18 = (var22.data[(var14 * var22.worldLength + var15) * var22.worldWidth + (var1 - 1)] & 15) - var17;
+								var18 = (this.data[(var14 * this.worldLength + var15) * this.worldWidth + (var1 - 1)] & 15) - var17;
 								if(var18 > var16) {
 									var16 = var18;
 								}
 							}
 
-							if(var1 < var22.worldWidth - 1) {
-								var18 = (var22.data[(var14 * var22.worldLength + var15) * var22.worldWidth + var1 + 1] & 15) - var17;
+							if(var1 < this.worldWidth - 1) {
+								var18 = (this.data[(var14 * this.worldLength + var15) * this.worldWidth + var1 + 1] & 15) - var17;
 								if(var18 > var16) {
 									var16 = var18;
 								}
 							}
 
 							if(var14 > 0) {
-								var18 = (var22.data[((var14 - 1) * var22.worldLength + var15) * var22.worldWidth + var1] & 15) - var17;
+								var18 = (this.data[((var14 - 1) * this.worldLength + var15) * this.worldWidth + var1] & 15) - var17;
 								if(var18 > var16) {
 									var16 = var18;
 								}
 							}
 
-							if(var14 < var22.worldHeight - 1) {
-								var18 = (var22.data[((var14 + 1) * var22.worldLength + var15) * var22.worldWidth + var1] & 15) - var17;
+							if(var14 < this.worldHeight - 1) {
+								var18 = (this.data[((var14 + 1) * this.worldLength + var15) * this.worldWidth + var1] & 15) - var17;
 								if(var18 > var16) {
 									var16 = var18;
 								}
 							}
 
 							if(var15 > 0) {
-								var18 = (var22.data[(var14 * var22.worldLength + (var15 - 1)) * var22.worldWidth + var1] & 15) - var17;
+								var18 = (this.data[(var14 * this.worldLength + (var15 - 1)) * this.worldWidth + var1] & 15) - var17;
 								if(var18 > var16) {
 									var16 = var18;
 								}
 							}
 
-							if(var15 < var22.worldLength - 1) {
-								var18 = (var22.data[(var14 * var22.worldLength + var15 + 1) * var22.worldWidth + var1] & 15) - var17;
+							if(var15 < this.worldLength - 1) {
+								var18 = (this.data[(var14 * this.worldLength + var15 + 1) * this.worldWidth + var1] & 15) - var17;
 								if(var18 > var16) {
 									var16 = var18;
 								}
@@ -307,54 +305,54 @@
 							var16 = Block.lightValue[var24];
 						}
 
-						var17 = var22.data[(var14 * var22.worldLength + var15) * var22.worldWidth + var1] & 15;
+						var17 = this.data[(var14 * this.worldLength + var15) * this.worldWidth + var1] & 15;
 						if(var17 != var16) {
-							var22.data[(var14 * var22.worldLength + var15) * var22.worldWidth + var1] = (byte)((var22.data[(var14 * var22.worldLength + var15) * var22.worldWidth + var1] & 240) + var16);
-							if(var1 > 0 && (var22.data[(var14 * var22.worldLength + var15) * var22.worldWidth + (var1 - 1)] & 15) != var16 - 1) {
-								var13 = var1 - 1 + var14 * var22.worldWidth + var15 * var22.worldWidth * var22.worldHeight;
-								if((var22.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
-									var22.chunks[var13 >> 3] = (byte)(var22.chunks[var13 >> 3] | 1 << (var13 & 7));
-									var22.lightingUpdateList3[var22.lightingUpdateCounter++] = var13;
-								}
-							}
-
-							if(var1 < var22.worldWidth - 1 && (var22.data[(var14 * var22.worldLength + var15) * var22.worldWidth + var1 + 1] & 15) != var16 - 1) {
-								var13 = var1 + 1 + var14 * var22.worldWidth + var15 * var22.worldWidth * var22.worldHeight;
-								if((var22.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
-									var22.chunks[var13 >> 3] = (byte)(var22.chunks[var13 >> 3] | 1 << (var13 & 7));
-									var22.lightingUpdateList3[var22.lightingUpdateCounter++] = var13;
-								}
-							}
-
-							if(var14 > 0 && (var22.data[((var14 - 1) * var22.worldLength + var15) * var22.worldWidth + var1] & 15) != var16 - 1) {
-								var13 = var1 + (var14 - 1) * var22.worldWidth + var15 * var22.worldWidth * var22.worldHeight;
-								if((var22.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
-									var22.chunks[var13 >> 3] = (byte)(var22.chunks[var13 >> 3] | 1 << (var13 & 7));
-									var22.lightingUpdateList3[var22.lightingUpdateCounter++] = var13;
-								}
-							}
-
-							if(var14 < var22.worldHeight - 1 && (var22.data[((var14 + 1) * var22.worldLength + var15) * var22.worldWidth + var1] & 15) != var16 - 1) {
-								var13 = var1 + (var14 + 1) * var22.worldWidth + var15 * var22.worldWidth * var22.worldHeight;
-								if((var22.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
-									var22.chunks[var13 >> 3] = (byte)(var22.chunks[var13 >> 3] | 1 << (var13 & 7));
-									var22.lightingUpdateList3[var22.lightingUpdateCounter++] = var13;
-								}
-							}
-
-							if(var15 > 0 && (var22.data[(var14 * var22.worldLength + (var15 - 1)) * var22.worldWidth + var1] & 15) != var16 - 1) {
-								var13 = var1 + var14 * var22.worldWidth + (var15 - 1) * var22.worldWidth * var22.worldHeight;
-								if((var22.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
-									var22.chunks[var13 >> 3] = (byte)(var22.chunks[var13 >> 3] | 1 << (var13 & 7));
-									var22.lightingUpdateList3[var22.lightingUpdateCounter++] = var13;
-								}
-							}
-
-							if(var15 < var22.worldLength - 1 && (var22.data[(var14 * var22.worldLength + var15 + 1) * var22.worldWidth + var1] & 15) != var16 - 1) {
-								var13 = var1 + var14 * var22.worldWidth + (var15 + 1) * var22.worldWidth * var22.worldHeight;
-								if((var22.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
-									var22.chunks[var13 >> 3] = (byte)(var22.chunks[var13 >> 3] | 1 << (var13 & 7));
-									var22.lightingUpdateList3[var22.lightingUpdateCounter++] = var13;
+							this.data[(var14 * this.worldLength + var15) * this.worldWidth + var1] = (byte)((this.data[(var14 * this.worldLength + var15) * this.worldWidth + var1] & 240) + var16);
+							if(var1 > 0 && (this.data[(var14 * this.worldLength + var15) * this.worldWidth + (var1 - 1)] & 15) != var16 - 1) {
+								var13 = var1 - 1 + var14 * this.worldWidth + var15 * this.worldWidth * this.worldHeight;
+								if((this.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
+									this.chunks[var13 >> 3] = (byte)(this.chunks[var13 >> 3] | 1 << (var13 & 7));
+									this.lightingUpdateList3[this.lightingUpdateCounter++] = var13;
+								}
+							}
+
+							if(var1 < this.worldWidth - 1 && (this.data[(var14 * this.worldLength + var15) * this.worldWidth + var1 + 1] & 15) != var16 - 1) {
+								var13 = var1 + 1 + var14 * this.worldWidth + var15 * this.worldWidth * this.worldHeight;
+								if((this.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
+									this.chunks[var13 >> 3] = (byte)(this.chunks[var13 >> 3] | 1 << (var13 & 7));
+									this.lightingUpdateList3[this.lightingUpdateCounter++] = var13;
+								}
+							}
+
+							if(var14 > 0 && (this.data[((var14 - 1) * this.worldLength + var15) * this.worldWidth + var1] & 15) != var16 - 1) {
+								var13 = var1 + (var14 - 1) * this.worldWidth + var15 * this.worldWidth * this.worldHeight;
+								if((this.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
+									this.chunks[var13 >> 3] = (byte)(this.chunks[var13 >> 3] | 1 << (var13 & 7));
+									this.lightingUpdateList3[this.lightingUpdateCounter++] = var13;
+								}
+							}
+
+							if(var14 < this.worldHeight - 1 && (this.data[((var14 + 1) * this.worldLength + var15) * this.worldWidth + var1] & 15) != var16 - 1) {
+								var13 = var1 + (var14 + 1) * this.worldWidth + var15 * this.worldWidth * this.worldHeight;
+								if((this.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
+									this.chunks[var13 >> 3] = (byte)(this.chunks[var13 >> 3] | 1 << (var13 & 7));
+									this.lightingUpdateList3[this.lightingUpdateCounter++] = var13;
+								}
+							}
+
+							if(var15 > 0 && (this.data[(var14 * this.worldLength + (var15 - 1)) * this.worldWidth + var1] & 15) != var16 - 1) {
+								var13 = var1 + var14 * this.worldWidth + (var15 - 1) * this.worldWidth * this.worldHeight;
+								if((this.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
+									this.chunks[var13 >> 3] = (byte)(this.chunks[var13 >> 3] | 1 << (var13 & 7));
+									this.lightingUpdateList3[this.lightingUpdateCounter++] = var13;
+								}
+							}
+
+							if(var15 < this.worldLength - 1 && (this.data[(var14 * this.worldLength + var15 + 1) * this.worldWidth + var1] & 15) != var16 - 1) {
+								var13 = var1 + var14 * this.worldWidth + (var15 + 1) * this.worldWidth * this.worldHeight;
+								if((this.chunks[var13 >> 3] & 1 << (var13 & 7)) == 0) {
+									this.chunks[var13 >> 3] = (byte)(this.chunks[var13 >> 3] | 1 << (var13 & 7));
+									this.lightingUpdateList3[this.lightingUpdateCounter++] = var13;
 								}
 							}
 
@@ -389,7 +387,7 @@
 				}
 
 				if(var5 > -999) {
-					var22.skyLightList.add(new MetadataChunkBlock(var22, var5, var7, var9, var6, var8, var10));
+					this.skyLightList.add(new MetadataChunkBlock(null, var5, var7, var9, var6, var8, var10));
 				}
 
 				if(var12 > 0) {
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageFlooding.java
@@ -1,0 +1,26 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+
+public class StageFlooding extends TerrainGenStage {
+	public StageFlooding(Block block) {
+		super("Flooding..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			if (block == null) {
+				return;
+			}
+
+			for (int x = 0; x < blocks.width; x++) {
+				progressor.accept(x * 100.0F / (blocks.width - 1));
+
+				for (int z = 0; z < blocks.length; z++) {
+					for (int y = world.waterLevel - 1; y >= 0 && blocks.get(x, y, z) == 0; y--) {
+						blocks.set(x, y, z, block.blockID);
+						if (blocks.get(x, y - 1, z) == Block.grass.blockID) {
+							blocks.set(x, y - 1, z, Block.dirt.blockID);
+						}
+					}
+				}
+			}
+		});
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/block/BlockObserver.java
@@ -1,0 +1,55 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+import java.util.HashSet;
+import java.util.Random;
+import java.util.Set;
+
+public class BlockObserver extends Block {
+	public BlockObserver(int var1) {
+		super(var1, 84, Material.iron);
+	}
+
+	public int tickRate() {
+		return 0;
+	}
+
+	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
+		var1.setBlockMetadata(var2, var3, var4, var5);
+	}
+
+	public int getBlockTextureFromSide(int var1) {
+		return var1 == 3 ? 83 : var1 == 2 ? 118 : 84;
+	}
+
+	public int getBlockTexture(World var1, int var2, int var3, int var4, int var5) {
+		int dir = var1.getBlockMetadata(var2, var3, var4);
+		return var5 == dir ? 83 : var5 == dir / 2 * 2 + 1 - (dir % 2) ? 118 : 84;
+	}
+
+	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
+		if (var5 == var1.getBlockMetadata(var2, var3, var4)) {
+			for (int i = 0; i < 5; i++) {
+				var1.spawnParticle("largesmoke",
+						var2 + var1.random.nextFloat() * 1.5F - 0.25F,
+						var3 + var1.random.nextFloat() * 1.5F - 0.25F,
+						var4 + var1.random.nextFloat() * 1.5F - 0.25F,
+						0.0F, 0.0F, 0.0F);
+			}
+
+			var1.scheduleBlockUpdate(var2, var3, var4, this.blockID);
+		}
+	}
+
+	public boolean canReceivePower(World var1, int var2, int var3, int var4, int var5) {
+		int dir = var1.getBlockMetadata(var2, var3, var4);
+		return var5 == dir / 2 * 2 + 1 - dir % 2;
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		int dir = var1.getBlockMetadata(var2, var3, var4);
+		var1.transmitPowerInDirection(var2, var3, var4, dir / 2 * 2 + 1 - dir % 2);
+	}
+}
--- net/minecraft/game/level/block/BlockSponge.java
+++ net/minecraft/game/level/block/BlockSponge.java
@@ -4,7 +4,7 @@
 import net.minecraft.game.level.material.Material;
 
 public final class BlockSponge extends Block {
-	protected BlockSponge(int var1) {
+	public BlockSponge(int var1) {
 		super(19, Material.sponge);
 		this.blockIndexInTexture = 48;
 	}
@@ -22,7 +22,7 @@
 
 	}
 
-	public final void onBlockRemoval(World var1, int var2, int var3, int var4) {
+	public final void onBlockRemoval(World var1, int var2, int var3, int var4, int var4a) {
 		for(int var5 = var2 - 2; var5 <= var2 + 2; ++var5) {
 			for(int var6 = var3 - 2; var6 <= var3 + 2; ++var6) {
 				for(int var7 = var4 - 2; var7 <= var4 + 2; ++var7) {
--- net/minecraft/game/item/ItemSpade.java
+++ net/minecraft/game/item/ItemSpade.java
@@ -3,7 +3,7 @@
 import net.minecraft.game.level.block.Block;
 
 public final class ItemSpade extends ItemTool {
-	private static Block[] blocksEffectiveAgainst = new Block[]{Block.grass, Block.dirt, Block.sand, Block.gravel};
+	private static Block[] blocksEffectiveAgainst = new Block[]{Block.grass, Block.dirt, Block.sand, Block.gravel, Block.mud, Block.clay};
 
 	public ItemSpade(int var1, int var2) {
 		super(var1, 1, var2, blocksEffectiveAgainst);
--- net/minecraft/game/entity/animal/EntitySheep.java
+++ net/minecraft/game/entity/animal/EntitySheep.java
@@ -22,7 +22,7 @@
 			int var3 = 1 + this.rand.nextInt(3);
 
 			for(int var4 = 0; var4 < var3; ++var4) {
-				EntityItem var5 = this.entityDropItem(Block.clothGray.blockID, 1, 1.0F);
+				EntityItem var5 = this.entityDropItem(Block.clothWhite.blockID, 1, 1.0F);
 				var5.motionY += this.rand.nextFloat() * 0.05F;
 				var5.motionX += (this.rand.nextFloat() - this.rand.nextFloat()) * 0.1F;
 				var5.motionZ += (this.rand.nextFloat() - this.rand.nextFloat()) * 0.1F;
--- /dev/null
+++ net/minecraft/game/level/block/BlockMud.java
@@ -1,0 +1,21 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.entity.Entity;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+import net.minecraft.game.physics.AxisAlignedBB;
+
+public class BlockMud extends Block {
+    public BlockMud(int var1, int var2, Material var3) {
+        super(var1, var2, var3);
+    }
+
+    public AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
+        return new AxisAlignedBB(var1, var2, var3, var1 + 1.0F, var2 + 0.875F, var3 + 1.0F);
+    }
+
+    public void onEntityCollidedWithBlock(World var1, int var2, int var3, int var4, Entity var5) {
+        var5.motionX *= 0.4F;
+        var5.motionZ *= 0.4F;
+    }
+}
--- /dev/null
+++ util/CoordinateConsumer.java
@@ -1,0 +1,16 @@
+package util;
+
+import java.util.Objects;
+
+@FunctionalInterface
+public interface CoordinateConsumer {
+    void accept(int x, int y, int z);
+
+    default CoordinateConsumer andThen(CoordinateConsumer after) {
+        Objects.requireNonNull(after);
+        return (x, y, z) -> {
+            this.accept(x, y, z);
+            after.accept(x, y, z);
+        };
+    }
+}
--- net/minecraft/game/entity/misc/EntityItem.java
+++ net/minecraft/game/entity/misc/EntityItem.java
@@ -27,6 +27,7 @@
 		this.motionY = 0.2F;
 		this.motionZ = (float)(Math.random() * (double)0.2F - (double)0.1F);
 		this.canTriggerWalking = false;
+		this.isDead = !var1.survivalWorld;
 	}
 
 	public EntityItem(World var1) {
--- net/minecraft/game/level/block/BlockStationary.java
+++ net/minecraft/game/level/block/BlockStationary.java
@@ -1,58 +1,51 @@
 package net.minecraft.game.level.block;
 
-import java.util.Random;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.material.Material;
 
+import java.util.Random;
+
 public final class BlockStationary extends BlockFluid {
-	protected BlockStationary(int var1, Material var2) {
+	public BlockStationary(int var1, Material var2) {
 		super(var1, var2);
 		this.movingId = var1 - 1;
 		this.stillId = var1;
-		this.setTickOnLoad(false);
-	}
-
-	public final void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		this.setTickOnLoad(var2 == Material.lava);
 	}
 
 	public final void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
-		boolean var6 = false;
-		if(this.canFlow(var1, var2, var3 - 1, var4)) {
-			var6 = true;
-		}
-
-		if(!var6 && this.canFlow(var1, var2 - 1, var3, var4)) {
-			var6 = true;
-		}
-
-		if(!var6 && this.canFlow(var1, var2 + 1, var3, var4)) {
-			var6 = true;
-		}
-
-		if(!var6 && this.canFlow(var1, var2, var3, var4 - 1)) {
-			var6 = true;
-		}
-
-		if(!var6 && this.canFlow(var1, var2, var3, var4 + 1)) {
-			var6 = true;
-		}
-
-		if(var5 != 0) {
-			Material var7 = Block.blocksList[var5].material;
-			if(this.material == Material.water && var7 == Material.lava || var7 == Material.water && this.material == Material.lava) {
-				var1.setBlockWithNotify(var2, var3, var4, Block.stone.blockID);
-				return;
+		super.onNeighborBlockChange(var1, var2, var3, var4, var5);
+		if(var1.getBlockId(var2, var3, var4) == this.blockID) {
+			int var6 = var1.getBlockMetadata(var2, var3, var4);
+			var1.setBlockAndMetadata(var2, var3, var4, this.blockID - 1, var6);
+			var1.markBlocksDirty(var2, var3, var4, var2, var3, var4);
+			var1.scheduleBlockUpdate(var2, var3, var4, this.blockID - 1);
+		}
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		if(this.material == Material.lava) {
+			int var6 = var5.nextInt(3);
+
+			for(int var7 = 0; var7 < var6; ++var7) {
+				var2 += var5.nextInt(3) - 1;
+				++var3;
+				var4 += var5.nextInt(3) - 1;
+				int var8 = var1.getBlockId(var2, var3, var4);
+				if(var8 == 0) {
+					if(Block.fire.canBlockCatchFire(var1, var2 - 1, var3, var4)
+							|| Block.fire.canBlockCatchFire(var1, var2 + 1, var3, var4)
+							|| Block.fire.canBlockCatchFire(var1, var2, var3, var4 - 1)
+							|| Block.fire.canBlockCatchFire(var1, var2, var3, var4 + 1)
+							|| Block.fire.canBlockCatchFire(var1, var2, var3 - 1, var4)
+							|| Block.fire.canBlockCatchFire(var1, var2, var3 + 1, var4)) {
+						var1.setBlockWithNotify(var2, var3, var4, Block.fire.blockID);
+						return;
+					}
+				} else if(Block.blocksList[var8].material.getIsSolid()) {
+					return;
+				}
 			}
 		}
-
-		if(Block.fire.getChanceOfNeighborsEncouragingFire(var5)) {
-			var6 = true;
-		}
-
-		if(var6) {
-			var1.setTileNoUpdate(var2, var3, var4, this.movingId);
-			var1.scheduleBlockUpdate(var2, var3, var4, this.movingId);
-		}
-
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/block/BlockMushroomCap.java
@@ -1,0 +1,50 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+import java.util.Random;
+
+public class BlockMushroomCap extends Block {
+    private static boolean silkTouched;
+    private int field_35292_a;
+
+    public BlockMushroomCap(int var1, Material var2, int var3, int var4) {
+        super(var1, var3, var2);
+        this.field_35292_a = var4;
+    }
+
+    public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
+        if (var2 == 14) return this.blockIndexInTexture - 16 - this.field_35292_a;
+        if (var2 == 15) return this.blockIndexInTexture - 1;
+        return var2 == 10 && var1 > 1 ? this.blockIndexInTexture - 1 : (var2 >= 1 && var2 <= 9 && var1 == 1 ? this.blockIndexInTexture - 16 - this.field_35292_a : (var2 >= 1 && var2 <= 3 && var1 == 2 ? this.blockIndexInTexture - 16 - this.field_35292_a : (var2 >= 7 && var2 <= 9 && var1 == 3 ? this.blockIndexInTexture - 16 - this.field_35292_a : ((var2 == 1 || var2 == 4 || var2 == 7) && var1 == 4 ? this.blockIndexInTexture - 16 - this.field_35292_a : ((var2 == 3 || var2 == 6 || var2 == 9) && var1 == 5 ? this.blockIndexInTexture - 16 - this.field_35292_a : this.blockIndexInTexture)))));
+    }
+
+    public int quantityDropped(Random var1) {
+        if (silkTouched) return 1;
+
+        int var2 = var1.nextInt(10) - 7;
+        if(var2 < 0) {
+            var2 = 0;
+        }
+
+        return var2;
+    }
+
+    public int idDropped(int var1, Random var2) {
+        if (silkTouched) return this.blockID;
+        return Block.mushroomBrown.blockID + this.field_35292_a;
+    }
+
+    public int damageDropped(int metadata, int dropId, Random var1) {
+        if (!silkTouched) return 0;
+        metadata &= 255;
+        return metadata == 10 || metadata == 15 ? 15 : 14;
+    }
+
+    public void dropBlockAsItemWithChance(World var1, int var2, int var3, int var4, int var5, float var6) {
+        silkTouched = (var5 & DROP_FLAG_SILK_TOUCH) != 0;
+        super.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, var6);
+        silkTouched = false;
+    }
+}
--- /dev/null
+++ net/minecraft/client/InventoryReadonly.java
@@ -1,0 +1,44 @@
+package net.minecraft.client;
+
+import net.minecraft.game.IInventory;
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.ItemStack;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.util.*;
+
+public class InventoryReadonly implements IInventory {
+    private final ItemStack[] items;
+
+    public InventoryReadonly(ItemStack[] items) {
+        this.items = items;
+    }
+
+    public int getSizeInventory() {
+        return items.length;
+    }
+
+    public ItemStack getStackInSlot(int var1) {
+        return var1 < items.length
+            ? items[var1] == null
+            ? null
+            : new ItemStack(items[var1].itemID, items[var1].stackSize, items[var1].itemDamage)
+            : null;
+    }
+
+    public ItemStack decrStackSize(int var1, int var2) {
+        return null;
+    }
+
+    public void setInventorySlotContents(int var1, ItemStack var2) {
+    }
+
+    public String getInvName() {
+        return "Readonly Inventory";
+    }
+
+    public int getInventoryStackLimit() {
+        return 64;
+    }
+}
--- net/minecraft/client/render/ItemRenderer.java
+++ net/minecraft/client/render/ItemRenderer.java
@@ -8,6 +8,7 @@
 import net.minecraft.client.render.entity.RenderPlayer;
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.material.Material;
 import org.lwjgl.opengl.GL11;
 import util.MathHelper;
 
@@ -58,9 +59,9 @@
 			}
 
 			GL11.glScalef(0.4F, 0.4F, 0.4F);
-			if(this.itemToRender.itemID < 256 && Block.blocksList[this.itemToRender.itemID].getRenderType() == 0) {
+			if(this.itemToRender.itemID < 256 && Block.blocksList[this.itemToRender.itemID].has3DIcon()) {
 				GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/terrain.png"));
-				this.renderBlocksInstance.renderBlockOnInventory(Block.blocksList[this.itemToRender.itemID]);
+				this.renderBlocksInstance.renderBlockOnInventory(Block.blocksList[this.itemToRender.itemID], this.itemToRender.itemDamage);
 			} else {
 				if(this.itemToRender.itemID < 256) {
 					GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/terrain.png"));
@@ -70,13 +71,13 @@
 
 				Tessellator var11 = Tessellator.instance;
 				ItemStack var10 = this.itemToRender;
-				var5 = (float)(var10.getItem().getIconIndex() % 16 << 4) / 256.0F;
-				var10 = this.itemToRender;
-				var1 = (float)((var10.getItem().getIconIndex() % 16 << 4) + 16) / 256.0F;
-				var10 = this.itemToRender;
-				var2 = (float)(var10.getItem().getIconIndex() / 16 << 4) / 256.0F;
-				var10 = this.itemToRender;
-				var9 = (float)((var10.getItem().getIconIndex() / 16 << 4) + 16) / 256.0F;
+				var5 = (float)(var10.getIconIndex() % 16 << 4) / 256.0F;
+				var10 = this.itemToRender;
+				var1 = (float)((var10.getIconIndex() % 16 << 4) + 16) / 256.0F;
+				var10 = this.itemToRender;
+				var2 = (float)(var10.getIconIndex() / 16 << 4) / 256.0F;
+				var10 = this.itemToRender;
+				var9 = (float)((var10.getIconIndex() / 16 << 4) + 16) / 256.0F;
 				GL11.glEnable(GL11.GL_NORMALIZE);
 				GL11.glTranslatef(0.0F, -0.3F, 0.0F);
 				GL11.glScalef(1.5F, 1.5F, 1.5F);
@@ -235,12 +236,17 @@
 			GL11.glDisable(GL11.GL_BLEND);
 		}
 
-		if(this.mc.thePlayer.isInsideOfWater()) {
+		Block headBlock = Block.blocksList[this.mc.thePlayer.getBlockInHead()];
+		if(headBlock != null && (headBlock.material == Material.water || headBlock == Block.fumes)) {
 			var2 = this.mc.renderEngine.getTexture("/water.png");
 			GL11.glBindTexture(GL11.GL_TEXTURE_2D, var2);
 			var3 = Tessellator.instance;
-			float var8 = this.mc.thePlayer.getEntityBrightness(var1);
-			GL11.glColor4f(var8, var8, var8, 0.5F);
+			if (headBlock == Block.fumes) {
+				GL11.glColor4f(0.0F, 0.0F, 0.0F, 1.0F);
+			} else {
+				float var8 = this.mc.thePlayer.getEntityBrightness(var1);
+				GL11.glColor4f(var8, var8, var8, 0.5F);
+			}
 			GL11.glEnable(GL11.GL_BLEND);
 			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 			GL11.glPushMatrix();
--- /dev/null
+++ net/minecraft/game/level/generator/LevelTheme.java
@@ -1,0 +1,795 @@
+package net.minecraft.game.level.generator;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.generator.feature.*;
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+public enum LevelTheme {
+	NORMAL("Normal"),
+	HELL("Hell") {
+		@Override
+		public boolean canNaturallyGenerate() {
+			return false;
+		}
+
+		@Override
+		public int getSkyColor() {
+			return 0x100400;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0x100400;
+		}
+
+		@Override
+		public int getCloudColor() {
+			return 0x210800;
+		}
+
+		@Override
+		public int getSkyBrightness() {
+			return 7;
+		}
+
+		@Override
+		public int modifyCloudHeight(int cloudHeight, int levelHeight, LevelType levelType) {
+			return levelType == LevelType.FLOATING ? levelHeight + 2 : cloudHeight;
+		}
+
+		@Override
+		public int modifyWaterLevel(int waterLevel, LevelType levelType) {
+			return levelType == LevelType.FLOATING ? -16 : waterLevel;
+		}
+
+		@Override
+		public double modifySandBeachThreshold(double threshold) {
+			return -8.0D;
+		}
+
+		@Override
+		public Block getSandBeachBlock() {
+			return Block.grass;
+		}
+
+		@Override
+		public Block getStillFluid() {
+			return Block.lavaStill;
+		}
+
+		@Override
+		public Block getDefaultFluid() {
+			return Block.lavaMoving;
+		}
+
+		@Override
+		public boolean growGrassOnDirt() {
+			return false;
+		}
+	},
+	PARADISE("Paradise") {
+		private final Feature FEATURE_PALM_TREE = new FeaturePalmTree();
+
+		@Override
+		public int getSkyColor() {
+			return 0xc6deff;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0xc6deff;
+		}
+
+		@Override
+		public int getCloudColor() {
+			return 0xeeeeff;
+		}
+
+		@Override
+		public int getSkylightSubtracted() {
+			return 15;
+		}
+
+		@Override
+		public int getSkyBrightness() {
+			return 16;
+		}
+
+		@Override
+		public int modifyCloudHeight(int cloudHeight, int levelHeight, LevelType levelType) {
+			return levelHeight + 64;
+		}
+
+		@Override
+		public double modifySandBeachThreshold(double threshold) {
+			return -32.0D;
+		}
+
+		@Override
+		public int modifyBeachHeightOffset(int offset) {
+			return offset + 2;
+		}
+
+		@Override
+		public int getFlowerCount() {
+			return 1000;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return FEATURE_PALM_TREE;
+		}
+
+		@Override
+		public boolean canNaturallyGenerate() {
+			return false;
+		}
+
+		@Override
+		public float getOreMultiplier() {
+			return 2.0F;
+		}
+	},
+	WOODS("Woods") {
+		private final FeatureBigTree FEATURE_BIG_TREE = new FeatureBigTree();
+
+		@Override
+		public int getSkyColor() {
+			return 0x757d87;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0x4d5a5b;
+		}
+
+		@Override
+		public int getCloudColor() {
+			return 0x4d5a5b;
+		}
+
+		@Override
+		public int getSkyBrightness() {
+			return 12;
+		}
+
+		@Override
+		public double modifySandBeachThreshold(double threshold) {
+			return -8.0D;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			FEATURE_BIG_TREE.leafDistanceLimit = 4 + rand.nextInt(2);
+			return rand.nextInt(3) == 0 ? FEATURE_TREE : FEATURE_BIG_TREE;
+		}
+
+		@Override
+		public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+			this.growTreesNoise(world, rand, progressor, 8, 2.0D, 20.0D, 0.75D, 5);
+		}
+	},
+	RAINFOREST("Rainforest") {
+		private final Feature FEATURE_RAINFOREST_TREE = new FeatureSwampTree(5, 20);
+
+		@Override
+		public int getSkyColor() {
+			return 0x88ddff;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0xffffdd;
+		}
+
+		@Override
+		public int getTreeSpread() {
+			return 20000;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return FEATURE_RAINFOREST_TREE;
+		}
+
+		@Override
+		public int getFlowerCount() {
+			return 250;
+		}
+
+		@Override
+		public int getMushroomCount() {
+			return 250;
+		}
+	},
+	WINTER("Winter") {
+		@Override
+		public int getSkyColor() {
+			return 0xaaaaff;
+		}
+
+		@Override
+		public boolean hasSnow() {
+			return true;
+		}
+	},
+	TAIGA("Taiga") {
+		private final Feature FEATURE_TAIGA_1 = new FeatureTaiga1();
+		private final Feature FEATURE_TAIGA_2 = new FeatureTaiga2();
+
+		@Override
+		public int getSkyColor() {
+			return 0x9fbbff;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0xddeeff;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return rand.nextInt(3) == 0 ? FEATURE_TAIGA_1 : FEATURE_TAIGA_2;
+		}
+
+		@Override
+		public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+			this.growTreesNoise(world, rand, progressor, 8, 2.0D, 25.0D, 0.5D, 5);
+		}
+	},
+	SNOWY_TAIGA("Snowy Taiga") {
+		private final Feature FEATURE_TAIGA_1 = new FeatureTaiga1();
+		private final Feature FEATURE_TAIGA_2 = new FeatureTaiga2();
+
+		@Override
+		public int getSkyColor() {
+			return 0xaa90ff;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0xddeeff;
+		}
+
+		@Override
+		public boolean hasSnow() {
+			return true;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return rand.nextInt(3) == 0 ? FEATURE_TAIGA_1 : FEATURE_TAIGA_2;
+		}
+
+		@Override
+		public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+			this.growTreesNoise(world, rand, progressor, 8, 2.0D, 25.0D, 0.0D, 5);
+		}
+	},
+	DESERT("Desert") {
+		private final Feature FEATURE_CACTI = new FeatureCacti();
+		private final Feature FEATURE_PALM_TREE = new FeaturePalmTree();
+
+		@Override
+		public int getSkyColor() {
+			return 0xffff7f;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0xffffbb;
+		}
+
+		@Override
+		public int getCloudColor() {
+			return 0xddbb66;
+		}
+
+		@Override
+		public Block getSoilBlock() {
+			return Block.sand;
+		}
+
+		@Override
+		public Block getStillFluid() {
+			return null;
+		}
+
+		@Override
+		public Block getDefaultFluid() {
+			return null;
+		}
+
+		@Override
+		public int modifyWaterLevel(int waterLevel, LevelType levelType) {
+			return -1;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return FEATURE_PALM_TREE;
+		}
+
+		@Override
+		public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+			int var2 = world.width * world.length * world.height / 1000;
+
+			for(int var3 = 0; var3 < var2; ++var3) {
+				if(var3 % 100 == 0) {
+					progressor.accept((float)var3 * 100.0F / (float)(var2 - 1));
+				}
+
+				int var4 = rand.nextInt(world.width);
+				int var5 = rand.nextInt(world.height);
+				int var6 = rand.nextInt(world.length);
+
+				if(var4 > 0 && var5 > 0 && var6 > 0 && var4 < world.width && var5 < world.height && var6 < world.length) {
+					FEATURE_CACTI.generate(world, rand, var4, var5, var6);
+				}
+			}
+		}
+	},
+	OASIS("Oasis") {
+		@Override
+		public int getSkyColor() {
+			return 0x7fffdd;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0xffffbb;
+		}
+
+		@Override
+		public Block getSoilBlock() {
+			return Block.sand;
+		}
+
+		@Override
+		public int modifyBeachHeightOffset(int offset) {
+			return offset + 3;
+		}
+
+		@Override
+		public Block getSandBeachBlock() {
+			return Block.grass;
+		}
+
+		@Override
+		public double modifySandBeachThreshold(double threshold) {
+			return -8.0D;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return DESERT.getTreeType(rand);
+		}
+
+		@Override
+		public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+			super.growTrees(world, rand, progressor);
+			DESERT.growTrees(world, rand, progressor);
+		}
+	},
+	OLD_GROWTH_FOREST("Old Growth Forest") {
+		private final Feature FEATURE_BIG_TREE = new FeatureBigTree();
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return FEATURE_BIG_TREE;
+		}
+
+		@Override
+		public int getSkyColor() {
+			return 0x88bbff;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0xc0d8ff;
+		}
+
+		@Override
+		public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+			NoiseGenerator forestNoise = new NoiseGeneratorOctaves(rand, 5);
+			for (int x = 8; x < world.width - 16; x += 16) {
+				progressor.accept((float)x / (float)(world.width / 16 - 1));
+				for (int z = 8; z < world.length - 16; z += 16) {
+					int treeAmount = (int)forestNoise.generateNoise(x * 0.25D, z * 0.25D) << 3;
+					for (int i = 0; i < treeAmount; i++) {
+						int sx = x + rand.nextInt(16);
+						int sz = z + rand.nextInt(16);
+						int sy = world.getHeightValue(sx, sz);
+						this.placeTree(world, rand, sx, sy, sz);
+					}
+				}
+			}
+		}
+	},
+	SWAMPLAND("Swampland") {
+		private final Feature FEATURE_SWAMPLAND_TREE = new FeatureSwampTree();
+		private final Feature FEATURE_BIG_MUSHROOM = new FeatureBigMushroom();
+
+		@Override
+		public int getSkyColor() {
+			return 0x66ddbb;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0xcceeaa;
+		}
+
+		@Override
+		public int getCloudColor() {
+			return 0xccffdd;
+		}
+
+		@Override
+		public int getTreeSpread() {
+			return 15000;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return rand.nextInt(10) == 0 ? FEATURE_BIG_MUSHROOM : FEATURE_SWAMPLAND_TREE;
+		}
+
+		@Override
+		public int getMushroomCount() {
+			return 400;
+		}
+
+		@Override
+		public int getSkyBrightness() {
+			return 14;
+		}
+
+		@Override
+		public Block getGravelBeachBlock() {
+			return Block.mud;
+		}
+
+		@Override
+		public int modifyBeachHeightOffset(int offset) {
+			return offset + 2;
+		}
+
+		@Override
+		public double modifyGravelBeachThreshold(double threshold) {
+			return threshold * 0.5D;
+		}
+
+		@Override
+		public int modifyLakeRarity(int rarity) {
+			return rarity / 2;
+		}
+
+		@Override
+		public long modifyLakeSize(long size) {
+			return size * 2;
+		}
+	},
+	WASTELAND("Wasteland") {
+		private final FeatureBigTree FEATURE_DEAD_TREE = new FeatureBigTree();{
+			FEATURE_DEAD_TREE.leaves = 0;
+		}
+		private final FeatureBigTree FEATURE_LIVING_TREE = new FeatureBigTree();
+
+        @Override
+		public int getSkyColor() {
+			return 0x43524c;
+		}
+
+		@Override
+		public int getFogColor() {
+			return 0x373631;
+		}
+
+		@Override
+		public int getCloudColor() {
+			return 0x4d5a5b;
+		}
+
+		@Override
+		public int getSkyBrightness() {
+			return 7;
+		}
+
+		@Override
+		public double modifySandBeachThreshold(double threshold) {
+			return -8.0D;
+		}
+
+		@Override
+		public double modifyGravelBeachThreshold(double threshold) {
+			return -8.0D;
+		}
+
+		@Override
+		public Feature getTreeType(Random rand) {
+			return FEATURE_DEAD_TREE;
+		}
+
+		@Override
+		public Feature getGrownTreeType(Random rand) {
+			return FEATURE_LIVING_TREE;
+		}
+
+		@Override
+		public Block getStillFluid() {
+			return null;
+		}
+
+		@Override
+		public Block getDefaultFluid() {
+			return null;
+		}
+
+		@Override
+		public int getTreeSpread() {
+			return 200000;
+		}
+
+		@Override
+		public boolean growGrassOnDirt() {
+			return false;
+		}
+
+		@Override
+		public int getFlowerCount() {
+			return 0;
+		}
+
+		@Override
+		public int getMushroomCount() {
+			return 0;
+		}
+
+		@Override
+		public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+			super.growTrees(world, rand, progressor);
+
+			int baseLevel = Math.max(world.groundLevel, world.waterLevel);
+			long fumesCount = (long)world.width * (long)(world.height - baseLevel) * (long)world.length / 25000L;
+			for (long i = 0; i < fumesCount; i++) {
+				int x = rand.nextInt(world.width);
+				int y = rand.nextInt(Math.max(world.height - baseLevel, 1)) + baseLevel;
+				int z = rand.nextInt(world.length);
+				int subFumeCount = 2 + rand.nextInt(5);
+
+				for (int f = 0; f < subFumeCount; f++) {
+					int ox = x + rand.nextInt(9) - 4;
+					int oy = y + rand.nextInt(7) - 3;
+					int oz = z + rand.nextInt(9) - 4;
+					float radius = 2 + rand.nextFloat() * 3.0F;
+					float scaleX = 0.8F + rand.nextFloat() * 0.2F;
+					float scaleY = 0.25F + rand.nextFloat() * 0.5F;
+					float rotation = rand.nextFloat() * (float)Math.PI;
+					float skew = rand.nextFloat() - 0.5F;
+					LevelGenerator.drawSphereoid(ox, oy, oz, radius, scaleX, scaleY, rotation, skew, (px, py, pz) -> {
+						if (world.getBlockId(px, py, pz) == 0) {
+							world.setTileNoUpdate(px, py, pz, Block.fumes.blockID);
+							world.setBlockMetadata(px, py, pz, 0);
+						}
+					});
+				}
+			}
+		}
+	};
+
+	private static final Map<String, LevelTheme> NAME_TO_TYPE = Arrays.stream(values())
+			.collect(Collectors.toMap(LevelTheme::toString, Function.identity()));
+	private static final List<LevelTheme> NATURAL_THEMES = Arrays.stream(values())
+			.filter(LevelTheme::canNaturallyGenerate).collect(Collectors.toList());
+
+	private static final Feature FEATURE_TREE = new FeatureTree();
+
+	public final String name;
+
+	LevelTheme(String name) {
+		this.name = name;
+	}
+
+	public boolean canNaturallyGenerate() {
+		return true;
+	}
+
+	public int getSkyColor() {
+		return 0x99ccff;
+	}
+
+	public int getFogColor() {
+		return 0xffffff;
+	}
+
+	public int getCloudColor() {
+		return 0xffffff;
+	}
+
+	public int getSkylightSubtracted() {
+		return this.getSkyBrightness();
+	}
+
+	public int getSkyBrightness() {
+		return 15;
+	}
+
+	public int modifyCloudHeight(int cloudHeight, int levelHeight, LevelType levelType) {
+		return cloudHeight;
+	}
+
+	public int modifyWaterLevel(int waterLevel, LevelType levelType) {
+		return waterLevel;
+	}
+
+	public double modifySandBeachThreshold(double threshold) {
+		return threshold;
+	}
+
+	public double modifyGravelBeachThreshold(double threshold) {
+		return threshold;
+	}
+
+	public Block getSoilBlock() {
+		return Block.dirt;
+	}
+
+	public Block getStoneBlock() {
+		return Block.stone;
+	}
+
+	public Block getSandBeachBlock() {
+		return Block.sand;
+	}
+
+	public Block getGravelBeachBlock() {
+		return Block.gravel;
+	}
+
+	public int modifyBeachHeightOffset(int offset) {
+		return offset;
+	}
+
+	public Block getStillFluid() {
+		return Block.waterStill;
+	}
+
+	public Block getDefaultFluid() {
+		return Block.waterMoving;
+	}
+
+	public int modifyLakeRarity(int rarity) {
+		return rarity;
+	}
+
+	public long modifyLakeSize(long size) {
+		return size;
+	}
+
+	public boolean growGrassOnDirt() {
+		return true;
+	}
+
+	public boolean hasSnow() {
+		return false;
+	}
+
+	public int getFlowerCount() {
+		return 100;
+	}
+
+	public int getMushroomCount() {
+		return 50;
+	}
+
+	public int getClayCount() {
+		return 100;
+	}
+
+	public int getTreeSpread() {
+		return 80000;
+	}
+
+	public float getOreMultiplier() {
+		return 1.0F;
+	}
+
+	public void growTrees(World world, Random rand, Consumer<Float> progressor) {
+		int var2 = world.width * world.length * world.height / this.getTreeSpread();
+
+		for(int var3 = 0; var3 < var2; ++var3) {
+			if(var3 % 100 == 0) {
+				progressor.accept((float)var3 * 100.0F / (float)(var2 - 1));
+			}
+
+			int var4 = rand.nextInt(world.width);
+			int var5 = rand.nextInt(world.height);
+			int var6 = rand.nextInt(world.length);
+
+			for(int var7 = 0; var7 < 25; ++var7) {
+				int var8 = var4;
+				int var9 = var5;
+				int var10 = var6;
+
+				for(int var11 = 0; var11 < 20; ++var11) {
+					var8 += rand.nextInt(12) - rand.nextInt(12);
+					var9 += rand.nextInt(3) - rand.nextInt(6);
+					var10 += rand.nextInt(12) - rand.nextInt(12);
+					if(var8 > 0 && var9 > 0 && var10 > 0 && var8 < world.width && var9 < world.height && var10 < world.length) {
+						this.placeTree(world, rand, var8, var9, var10);
+					}
+				}
+			}
+		}
+	}
+
+	protected void growTreesNoise(World world, Random rand, Consumer<Float> progressor, int octaves, double spread, double density, double noiseBoost, int boost) {
+		NoiseGenerator forestNoise = new NoiseGeneratorOctaves(rand, octaves);
+
+		for (int x = 8; x < world.width - 16; x += 16) {
+			progressor.accept((float)x / (float)(world.width / 16 - 1));
+
+			for (int z = 8; z < world.length - 16; z += 16) {
+				double forestAmount = forestNoise.generateNoiseNormalized(x * spread, z * spread);
+				int treeAmount = (int)((forestAmount + noiseBoost) * density) + rand.nextInt(boost);
+				if (treeAmount <= 0) {
+					while (rand.nextInt(2) == 0) {
+						treeAmount++;
+					}
+				}
+
+				for (int i = 0; i < treeAmount; i++) {
+					int sx = x + rand.nextInt(16);
+					int sz = z + rand.nextInt(16);
+					int sy = world.getHeightValue(sx, sz);
+					this.placeTree(world, rand, sx, sy, sz);
+				}
+			}
+		}
+	}
+
+	public Feature getTreeType(Random rand) {
+		return FEATURE_TREE;
+	}
+
+	public Feature getGrownTreeType(Random rand) {
+		return this.getTreeType(rand);
+	}
+
+	protected final void placeTree(World world, Random rand, int x, int y, int z) {
+		this.getTreeType(rand).generate(world, rand, x, y, z);
+	}
+
+	@Override
+	public String toString() {
+		return this.name;
+	}
+
+	public static LevelTheme fromId(int id) {
+		return values()[id];
+	}
+
+	public static LevelTheme fromName(String name) {
+		return NAME_TO_TYPE.getOrDefault(name, NORMAL);
+	}
+
+	public static LevelTheme fromNameNullable(String name) {
+		return NAME_TO_TYPE.get(name);
+	}
+
+	public static LevelTheme getRandomGen() {
+		Random random = new Random();
+		if (random.nextInt(50) == 0) {
+			return PARADISE;
+		}
+		return NATURAL_THEMES.get(random.nextInt(NATURAL_THEMES.size()));
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageMountains.java
@@ -1,0 +1,84 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+
+public class StageMountains extends TerrainGenStage {
+	private StageMountains(Builder properties) {
+		super("Raising..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			NoiseGenerator mountainNoise = new NoiseGeneratorOctaves(rand, properties.noiseOctaves);
+			NoiseGenerator snowNoise = new NoiseGeneratorOctaves(rand, 2);
+
+			for (int x = 0; x < blocks.width; x++) {
+				progressor.accept(x * 100.0F / (float)(blocks.width - 1));
+				for (int z = 0; z < blocks.length; z++) {
+					int snowLine = (int)(properties.snowLine + snowNoise.generateNoiseNormalized(x * 0.15D, z * 0.15D) * properties.snowLineOffset);
+					int height = (int)(mountainNoise.generateNoiseNormalized(x * properties.noiseScale, z * properties.noiseScale) * properties.heightScale + properties.heightOffset);
+					for (int y = heightmap.get(x, z); y < world.groundLevel + height && y < world.height; y++) {
+						int block = properties.block.blockID;
+						if (y > world.groundLevel + snowLine && y > world.groundLevel + height - 5) {
+							block = properties.snowBlock.blockID;
+						}
+						blocks.set(x, y, z, block);
+					}
+				}
+			}
+		});
+	}
+
+	public static class Builder {
+		private int noiseOctaves = 8;
+		private double noiseScale = 1.0D;
+		private double heightScale = 80.0D;
+		private int heightOffset = 0;
+		private int snowLine = 32;
+		private int snowLineOffset = 8;
+		private Block block = Block.stone;
+		private Block snowBlock = Block.blockSnow;
+
+		public Builder noiseOctaves(int noiseOctaves) {
+			this.noiseOctaves = noiseOctaves;
+			return this;
+		}
+
+		public Builder noiseScale(double noiseScale) {
+			this.noiseScale = noiseScale;
+			return this;
+		}
+
+		public Builder heightScale(double heightScale) {
+			this.heightScale = heightScale;
+			return this;
+		}
+
+		public Builder heightOffset(int heightOffset) {
+			this.heightOffset = heightOffset;
+			return this;
+		}
+
+		public Builder snowLine(int snowLine) {
+			this.snowLine = snowLine;
+			return this;
+		}
+
+		public Builder snowLineOffset(int snowLineOffset) {
+			this.snowLineOffset = snowLineOffset;
+			return this;
+		}
+
+		public Builder block(Block block) {
+			this.block = block;
+			return this;
+		}
+
+		public Builder snowBlock(Block snowBlock) {
+			this.snowBlock = snowBlock;
+			return this;
+		}
+
+		public StageMountains build() {
+			return new StageMountains(this);
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/game/item/ItemDoor.java
@@ -1,0 +1,78 @@
+package net.minecraft.game.item;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.material.Material;
+import util.MathHelper;
+
+public class ItemDoor extends Item {
+    private Material material;
+
+    public ItemDoor(int var1, Material var2) {
+        super(var1);
+        this.material = var2;
+    }
+
+    public boolean onItemUse(ItemStack var1, World var3, int var4, int var5, int var6, int var7) {
+        if(var7 != 1) {
+            return false;
+        } else {
+            ++var5;
+            Block var8;
+            if(this.material == Material.wood) {
+                var8 = Block.doorWood;
+            } else {
+                var8 = Block.doorSteel;
+            }
+
+            if(!var8.canPlaceBlockAt(var3, var4, var5, var6)) {
+                return false;
+            } else {
+                int var9 = MathHelper.floor_double((double)((var3.playerEntity.rotationYaw + 180.0F) * 4.0F / 360.0F) - 0.5D) & 3;
+                byte var10 = 0;
+                byte var11 = 0;
+                if(var9 == 0) {
+                    var11 = 1;
+                }
+
+                if(var9 == 1) {
+                    var10 = -1;
+                }
+
+                if(var9 == 2) {
+                    var11 = -1;
+                }
+
+                if(var9 == 3) {
+                    var10 = 1;
+                }
+
+                int var12 = (var3.isBlockNormalCube(var4 - var10, var5, var6 - var11) ? 1 : 0) + (var3.isBlockNormalCube(var4 - var10, var5 + 1, var6 - var11) ? 1 : 0);
+                int var13 = (var3.isBlockNormalCube(var4 + var10, var5, var6 + var11) ? 1 : 0) + (var3.isBlockNormalCube(var4 + var10, var5 + 1, var6 + var11) ? 1 : 0);
+                boolean var14 = var3.getBlockId(var4 - var10, var5, var6 - var11) == var8.blockID || var3.getBlockId(var4 - var10, var5 + 1, var6 - var11) == var8.blockID;
+                boolean var15 = var3.getBlockId(var4 + var10, var5, var6 + var11) == var8.blockID || var3.getBlockId(var4 + var10, var5 + 1, var6 + var11) == var8.blockID;
+                boolean var16 = false;
+                if(var14 && !var15) {
+                    var16 = true;
+                } else if(var13 > var12) {
+                    var16 = true;
+                }
+
+                if(var16) {
+                    var9 = var9 - 1 & 3;
+                    var9 += 4;
+                }
+
+                var3.setBlockWithNotify(var4, var5, var6, var8.blockID);
+                var3.setBlockMetadata(var4, var5, var6, var9);
+                var3.setBlockWithNotify(var4, var5 + 1, var6, var8.blockID);
+                var3.setBlockMetadata(var4, var5 + 1, var6, var9 + 8);
+
+                if (var3.survivalWorld) {
+                    --var1.stackSize;
+                }
+                return true;
+            }
+        }
+    }
+}
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageTemplifying.java
@@ -1,0 +1,103 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+
+public class StageTemplifying extends TerrainGenStage {
+	public StageTemplifying() {
+		super("Templifying..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			int templeCount = blocks.width * blocks.length / 1600;
+
+			for (int i = 0; i < templeCount; i++) {
+				progressor.accept(i * 100.0F / templeCount);
+
+				// Location
+				int x = rand.nextInt(blocks.width - 48) + 16;
+				int z = rand.nextInt(blocks.length - 48) + 16;
+				int y = blocks.height - 1;
+				while (y > 0 && blocks.get(x, y, z) == 0) y--;
+				y += rand.nextInt(8) + 2;
+
+				// Dimensions
+				int w = rand.nextInt(11) + 5;
+				int l = rand.nextInt(11) + 5;
+				int h = rand.nextInt(4) + 3;
+				if (y >= blocks.height - h * 3 / 2 || y == 0) continue;
+
+				// Pillars
+				for (int xx = x; xx < x + w; xx++) {
+					for (int zz = z; zz < z + l; zz++) {
+						if ((xx == x || xx == x + w - 1 || zz == z || zz == z + l - 1)) {
+							for (int yy = y; yy < y + h; yy++) {
+								blocks.set(xx, yy, zz, Block.wood.blockID);
+							}
+						}
+
+						if (zz < z + l - 2) {
+							zz++;
+						}
+					}
+
+					if (xx < x + w - 2) {
+						xx++;
+					}
+				}
+
+				// Roof
+				int r = -1;
+				for (int yy = y + h;
+				     yy < blocks.height
+						     && w - r * 2 > 0
+						     && l - r * 2 > 0;
+					 yy++, r++) {
+					for (int xx = x + r; xx < x + w - r; xx++) {
+						for (int zz = z + r; zz < z + l - r; zz++) {
+							if (xx > 0 && xx < blocks.width && zz > 0 && zz < blocks.length) {
+								blocks.set(xx, yy, zz, Block.stairDouble.blockID);
+							}
+						}
+					}
+				}
+
+				// Foundation
+				r = 2;
+				boolean noFoundation = false;
+				for (int yy = y - 1; yy > 0 && !noFoundation; yy--, r++) {
+					noFoundation = true;
+					int minX = x - r / 2;
+					int maxX = x + w + r / 2 - 1;
+					int minZ = z - r / 2;
+					int maxZ = z + l + r / 2 - 1;
+					for (int xx = minX; xx <= maxX; xx++) {
+						for (int zz = minZ; zz <= maxZ; zz++) {
+							if (xx > 0 && xx < blocks.width && zz > 0 && zz < blocks.length) {
+								Block b = Block.blocksList[blocks.get(xx, yy, zz)];
+								if (b == null || !b.isOpaqueCube()) {
+									int block = Block.cobblestone.blockID;
+									if ((r % 2 == 0) == (rand.nextInt(3) == 0)) {
+										block = Block.cobblestoneMossy.blockID;
+									}
+									blocks.set(xx, yy, zz, block);
+									noFoundation = false;
+								}
+							}
+						}
+					}
+				}
+
+				// Chest
+				while (rand.nextInt(5) == 0) {
+					chestPlacer.placeChest(x + 2 + rand.nextInt(w - 3), y, z + 2 + rand.nextInt(l - 3));
+				}
+			}
+		});
+
+		this.setChestSlots(5, 15);
+		this.addChestItem(new ChestItem(Block.brick.blockID, 20));
+		this.addChestItem(new ChestItem(Block.cobblestoneMossy.blockID, 10));
+		this.addChestItem(new ChestItem(Block.brick.blockID, 20));
+		this.addChestItem(new ChestItem(Block.cobblestoneMossy.blockID, 10));
+		this.addChestItem(new ChestItem(Block.brick.blockID, 20));
+		this.addChestItem(new ChestItem(Block.leaves.blockID, 20));
+		this.addChestItem(new ChestItem(Block.obsidian.blockID, 5));
+	}
+}
--- net/minecraft/game/item/ItemPickaxe.java
+++ net/minecraft/game/item/ItemPickaxe.java
@@ -4,7 +4,7 @@
 import net.minecraft.game.level.material.Material;
 
 public final class ItemPickaxe extends ItemTool {
-	private static Block[] blocksEffectiveAgainst = new Block[]{Block.cobblestone, Block.stairDouble, Block.stairSingle, Block.stone, Block.cobblestoneMossy, Block.oreIron, Block.blockSteel, Block.oreCoal, Block.blockGold, Block.oreGold, Block.oreDiamond, Block.blockDiamond};
+	private static Block[] blocksEffectiveAgainst = new Block[]{Block.cobblestone, Block.stairDouble, Block.stairSingle, Block.stone, Block.cobblestoneMossy, Block.oreIron, Block.blockSteel, Block.oreCoal, Block.oreCopper, Block.blockCopper, Block.blockGold, Block.oreGold, Block.oreDiamond, Block.blockDiamond, Block.brick, Block.cog, Block.ironChain, Block.goldChain, Block.copperChain, Block.activator, Block.ironGrate, Block.observer, Block.magneticPlatform, Block.diode, Block.piston, Block.pistonCopper, Block.pistonGold, Block.logicGate, Block.lampInactive, Block.lampActive, Block.stoneOvenIdle, Block.stoneOvenActive};
 	private int harvestLevel;
 
 	public ItemPickaxe(int var1, int var2) {
@@ -13,6 +13,14 @@
 	}
 
 	public final boolean canHarvestBlock(Block var1) {
-		return var1 == Block.obsidian ? this.harvestLevel == 3 : (var1 != Block.blockDiamond && var1 != Block.oreDiamond ? (var1 != Block.blockGold && var1 != Block.oreGold ? (var1 != Block.blockSteel && var1 != Block.oreIron ? (var1.material == Material.rock ? true : var1.material == Material.iron) : this.harvestLevel > 0) : this.harvestLevel >= 2) : this.harvestLevel >= 2);
+		return var1 == Block.obsidian
+				? this.harvestLevel == 3
+				: (var1 != Block.blockDiamond && var1 != Block.oreDiamond
+						? (var1 != Block.blockGold && var1 != Block.oreGold
+								? (var1 != Block.blockSteel && var1 != Block.oreIron
+										? (var1.material == Material.rock || var1.material == Material.iron)
+										: this.harvestLevel > 0)
+								: this.harvestLevel >= 2)
+						: this.harvestLevel >= 2);
 	}
 }
--- net/minecraft/client/model/ModelBiped.java
+++ net/minecraft/client/model/ModelBiped.java
@@ -10,6 +10,7 @@
 	public ModelRenderer bipedLeftArm;
 	public ModelRenderer bipedRightLeg;
 	public ModelRenderer bipedLeftLeg;
+	public boolean isSneaking;
 
 	public ModelBiped() {
 		this(0.0F);
@@ -71,5 +72,33 @@
 		this.bipedLeftArm.rotateAngleZ -= MathHelper.cos(var3 * 0.09F) * 0.05F + 0.05F;
 		this.bipedRightArm.rotateAngleX += MathHelper.sin(var3 * 0.067F) * 0.05F;
 		this.bipedLeftArm.rotateAngleX -= MathHelper.sin(var3 * 0.067F) * 0.05F;
+
+		if(this.isSneaking) {
+			this.bipedBody.rotateAngleX = 0.5F;
+			this.bipedRightLeg.rotateAngleX -= 0.0F;
+			this.bipedLeftLeg.rotateAngleX -= 0.0F;
+			this.bipedRightArm.rotateAngleX += 0.4F;
+			this.bipedLeftArm.rotateAngleX += 0.4F;
+			this.bipedRightLeg.rotationPointZ = 4.0F;
+			this.bipedLeftLeg.rotationPointZ = 4.0F;
+			this.bipedRightLeg.rotationPointY = 9.0F;
+			this.bipedLeftLeg.rotationPointY = 9.0F;
+			this.bipedHead.rotationPointY = 1.0F;
+			this.bipedHeadwear.rotationPointY = 1.0F;
+		} else {
+			this.bipedBody.rotateAngleX = 0.0F;
+			this.bipedRightLeg.rotationPointZ = 0.0F;
+			this.bipedLeftLeg.rotationPointZ = 0.0F;
+			this.bipedRightLeg.rotationPointY = 12.0F;
+			this.bipedLeftLeg.rotationPointY = 12.0F;
+			this.bipedHead.rotationPointY = 0.0F;
+			this.bipedHeadwear.rotationPointY = 0.0F;
+		}
+	}
+
+	public void setFirstPersonHandAngles() {
+		this.bipedRightArm.rotateAngleX = 0.0F;
+		this.bipedRightArm.rotateAngleY = 0.0F;
+		this.bipedRightArm.rotateAngleZ = 0.0F;
 	}
 }
--- net/minecraft/client/gui/Gui.java
+++ net/minecraft/client/gui/Gui.java
@@ -1,6 +1,11 @@
 package net.minecraft.client.gui;
 
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.render.RenderEngine;
 import net.minecraft.client.render.Tessellator;
+import net.minecraft.client.render.entity.RenderItem;
+import net.minecraft.game.item.ItemStack;
+import net.minecraft.game.level.block.Block;
 import org.lwjgl.opengl.GL11;
 
 public class Gui {
@@ -62,12 +67,31 @@
 	}
 
 	public final void drawTexturedModalRect(int var1, int var2, int var3, int var4, int var5, int var6) {
-		Tessellator var7 = Tessellator.instance;
-		var7.startDrawingQuads();
-		var7.addVertexWithUV((float)var1, (float)(var2 + var6), this.zLevel, (float)var3 * 0.00390625F, (float)(var4 + var6) * 0.00390625F);
-		var7.addVertexWithUV((float)(var1 + var5), (float)(var2 + var6), this.zLevel, (float)(var3 + var5) * 0.00390625F, (float)(var4 + var6) * 0.00390625F);
-		var7.addVertexWithUV((float)(var1 + var5), (float)var2, this.zLevel, (float)(var3 + var5) * 0.00390625F, (float)var4 * 0.00390625F);
-		var7.addVertexWithUV((float)var1, (float)var2, this.zLevel, (float)var3 * 0.00390625F, (float)var4 * 0.00390625F);
-		var7.draw();
+		this.drawTexturedModalRect(var1, var2, var3, var4, var5, var6, 256);
+	}
+
+	public final void drawTexturedModalRect(int var1, int var2, int var3, int var4, int var5, int var6, int var7) {
+		Tessellator t = Tessellator.instance;
+		float s = 1.0F / var7;
+		t.startDrawingQuads();
+		t.addVertexWithUV((float)var1, (float)(var2 + var6), this.zLevel, (float)var3 * s, (float)(var4 + var6) * s);
+		t.addVertexWithUV((float)(var1 + var5), (float)(var2 + var6), this.zLevel, (float)(var3 + var5) * s, (float)(var4 + var6) * s);
+		t.addVertexWithUV((float)(var1 + var5), (float)var2, this.zLevel, (float)(var3 + var5) * s, (float)var4 * s);
+		t.addVertexWithUV((float)var1, (float)var2, this.zLevel, (float)var3 * s, (float)var4 * s);
+		t.draw();
+	}
+
+	public final void drawAutosaveIcon(Minecraft mc, int x, int y) {
+		this.zLevel += 100.0F;
+
+		int time = (int)Math.floorMod(System.currentTimeMillis() / 125, 8);
+		int arrowY = y - 20 + (time < 4 ? -time : time - 8);
+
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, mc.renderEngine.getTexture("/gui/autosave-chest.png"));
+		this.drawTexturedModalRect(x - 8, y - 8, 0, 0, 16, 16, 16);
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, mc.renderEngine.getTexture("/gui/autosave-arrow.png"));
+		this.drawTexturedModalRect(x - 8, arrowY, 0, 0, 16, 16, 16);
+
+		this.zLevel -= 100.0F;
 	}
 }
--- net/minecraft/game/item/ItemBlock.java
+++ net/minecraft/game/item/ItemBlock.java
@@ -14,40 +14,48 @@
 		this.setIconIndex(Block.blocksList[var1 + 256].getBlockTextureFromSide(2));
 	}
 
+	public int getIconIndex(ItemStack stack) {
+		return Block.blocksList[this.blockID].getBlockTextureFromSideAndMetadata(2, stack.itemDamage);
+	}
+
 	public final boolean onItemUse(ItemStack var1, World var2, int var3, int var4, int var5, int var6) {
-		if(var6 == 0) {
-			--var4;
-		}
-
-		if(var6 == 1) {
-			++var4;
-		}
-
-		if(var6 == 2) {
-			--var5;
-		}
-
-		if(var6 == 3) {
-			++var5;
-		}
-
-		if(var6 == 4) {
-			--var3;
-		}
-
-		if(var6 == 5) {
-			++var3;
-		}
-
-		if(var1.stackSize == 0) {
+		if (var2.getBlockId(var3, var4, var5) == Block.snow.blockID) {
+			var6 = 1;
+		} else {
+			if(var6 == 0) {
+				--var4;
+			}
+
+			if(var6 == 1) {
+				++var4;
+			}
+
+			if(var6 == 2) {
+				--var5;
+			}
+
+			if(var6 == 3) {
+				++var5;
+			}
+
+			if(var6 == 4) {
+				--var3;
+			}
+
+			if(var6 == 5) {
+				++var3;
+			}
+		}
+
+		if(var1.stackSize == 0 || this.blockID <= 0) {
 			return false;
 		} else if(var3 > 0 && var4 > 0 && var5 > 0 && var3 < var2.width - 1 && var4 < var2.height - 1 && var5 < var2.length - 1) {
 			int var7 = var2.getBlockId(var3, var4, var5);
 			Block var10 = Block.blocksList[var7];
-			if(this.blockID > 0 && var10 == null || var10 == Block.waterMoving || var10 == Block.waterStill || var10 == Block.lavaMoving || var10 == Block.lavaStill || var10 == Block.fire) {
+			if(var10 == null || var10.displace(var2, var3, var4, var5)) {
 				var10 = Block.blocksList[this.blockID];
-				AxisAlignedBB var8 = var10.getCollisionBoundingBoxFromPool(var3, var4, var5);
-				if(var2.checkIfAABBIsClear(var8) && var10.canPlaceBlockAt(var2, var3, var4, var5) && var2.setBlockWithNotify(var3, var4, var5, this.blockID)) {
+				AxisAlignedBB var8 = var10.getCollisionBoundingBoxFromPool(var2, var3, var4, var5);
+				if(var2.checkIfAABBIsClear(var8) && var10.canPlaceBlockAt(var2, var3, var4, var5) && var2.setBlockAndMetadataWithNotify(var3, var4, var5, this.blockID, var1.itemDamage)) {
 					Block.blocksList[this.blockID].onBlockPlaced(var2, var3, var4, var5, var6);
 					float var10001 = (float)var3 + 0.5F;
 					float var10002 = (float)var4 + 0.5F;
@@ -57,7 +65,9 @@
 					float var10005 = (var9.soundVolume + 1.0F) / 2.0F;
 					var9 = var10.stepSound;
 					var2.playSoundAtPlayer(var10001, var10002, var10003, var10004, var10005, var9.soundPitch * 0.8F);
-					--var1.stackSize;
+					if (var2.survivalWorld) {
+						--var1.stackSize;
+					}
 				}
 			}
 
--- net/minecraft/game/entity/animal/EntityAnimal.java
+++ net/minecraft/game/entity/animal/EntityAnimal.java
@@ -8,6 +8,7 @@
 public abstract class EntityAnimal extends EntityCreature {
 	public EntityAnimal(World var1) {
 		super(var1);
+		this.scoreValue = 10;
 	}
 
 	protected final float getBlockPathWeight(int var1, int var2, int var3) {
--- net/minecraft/client/gui/container/Slot.java
+++ net/minecraft/client/gui/container/Slot.java
@@ -33,6 +33,10 @@
 		return true;
 	}
 
+	public final ItemStack getStack() {
+		return this.inventory.getStackInSlot(this.slotIndex);
+	}
+
 	public final void putStack(ItemStack var1) {
 		this.inventory.setInventorySlotContents(this.slotIndex, var1);
 	}
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageCaving.java
@@ -1,0 +1,74 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+import util.DoubleArray3D;
+
+public class StageCaving extends TerrainGenStage {
+	public StageCaving() {
+		super("Caving..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			int chunkSize = 16;
+			int resHorizontal = 4;
+			int resVertical = 4;
+			int noiseWidth = chunkSize / resHorizontal + 1;
+			int noiseLength = chunkSize / resHorizontal + 1;
+			int noiseHeight = blocks.height / resVertical + 1;
+
+			NoiseGenerator caveNoise = new NoiseGeneratorOctaves(rand, 8);
+
+			for (int cx = 0; cx < blocks.width / chunkSize; cx++) {
+				progressor.accept(cx * 100.0F / (blocks.width / chunkSize - 1));
+
+				for (int cz = 0; cz < blocks.length / chunkSize; cz++) {
+					int cbx = cx * chunkSize;
+					int cbz = cz * chunkSize;
+					int cnx = cbx / resHorizontal;
+					int cnz = cbz / resHorizontal;
+
+					DoubleArray3D samples = new DoubleArray3D(noiseWidth, noiseLength, noiseHeight);
+					for (int y = 0; y < noiseHeight; y++) {
+						for (int z = 0; z < noiseLength; z++) {
+							for (int x = 0; x < noiseWidth; x++) {
+								samples.set(x, y, z, caveNoise.generateNoiseNormalized(
+										(x + cnx) * 8.0D,
+										y * 24.0D,
+										(z + cnz) * 8.0D
+								));
+							}
+						}
+					}
+
+					DoubleArray3D lerpedSamples = new DoubleArray3D(chunkSize, chunkSize, blocks.height);
+					for (int y = 0; y < blocks.height; y++) {
+						for (int z = 0; z < chunkSize; z++) {
+							for (int x = 0; x < chunkSize; x++) {
+								lerpedSamples.set(x, y, z, StageRaising3D.lerp3DPoints(samples, x, y, z, resHorizontal, resVertical));
+							}
+						}
+					}
+
+					for (int y = 0; y < blocks.height - 2; y++) {
+						for (int z = 0; z < chunkSize && z + cbz < blocks.length; z++) {
+							for (int x = 0; x < chunkSize && x + cbx < blocks.length; x++) {
+								double sample = lerpedSamples.get(x, y, z);
+
+								double threshold = 0.0D;
+								if (y < 8) {
+									threshold += (8 - y) / 8.0D;
+								}
+								if (y > world.groundLevel - 8) {
+									threshold += (y - world.groundLevel + 8) / 8.0D;
+								}
+								threshold = threshold * 0.75D + 0.25D;
+
+								if (sample > threshold) {
+									blocks.set(x + cbx, y, z + cbz, 0);
+								}
+							}
+						}
+					}
+				}
+			}
+		});
+	}
+}
--- net/minecraft/game/item/recipe/RecipesWeapons.java
+++ net/minecraft/game/item/recipe/RecipesWeapons.java
@@ -19,6 +19,6 @@
 		}
 
 		var1.addRecipe(new ItemStack(Item.bow, 1), new Object[]{" #X", "# X", " #X", Character.valueOf('X'), Item.silk, Character.valueOf('#'), Item.stick});
-		var1.addRecipe(new ItemStack(Item.arrow, 4), new Object[]{"X", "#", "Y", Character.valueOf('Y'), Item.feather, Character.valueOf('X'), Item.ingotIron, Character.valueOf('#'), Item.stick});
+		var1.addRecipe(new ItemStack(Item.arrow, 4), new Object[]{"X", "#", "Y", Character.valueOf('Y'), Item.feather, Character.valueOf('X'), Item.flint, Character.valueOf('#'), Item.stick});
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/EnumSkyBlock.java
@@ -1,0 +1,12 @@
+package net.minecraft.game.level;
+
+public enum EnumSkyBlock {
+	Sky(15),
+	Block(0);
+
+	public final int defaultLightValue;
+
+	private EnumSkyBlock(int var3) {
+		this.defaultLightValue = var3;
+	}
+}
--- /dev/null
+++ util/ByteArray3D.java
@@ -1,0 +1,35 @@
+package util;
+
+public class ByteArray3D {
+	private final byte[] array;
+	public final int width, length, height;
+
+	public ByteArray3D(int width, int length, int height) {
+		this(null, width, length, height);
+	}
+
+	public ByteArray3D(byte[] array, int width, int length, int height) {
+		if (array == null) {
+			array = new byte[width * length * height];
+		} else if (array.length < width * length * height) {
+			throw new IllegalArgumentException("Array is too small!");
+		}
+
+		this.array = array;
+		this.width = width;
+		this.length = length;
+		this.height = height;
+	}
+
+	public int get(int x, int y, int z) {
+		return this.array[(y * this.length + z) * this.width + x] & 255;
+	}
+
+	public void set(int x, int y, int z, int value) {
+		this.array[(y * this.length + z) * this.width + x] = (byte)value;
+	}
+
+	public byte[] getArray() {
+		return array;
+	}
+}
--- net/minecraft/game/level/block/BlockLeavesBase.java
+++ net/minecraft/game/level/block/BlockLeavesBase.java
@@ -6,7 +6,7 @@
 public class BlockLeavesBase extends Block {
 	private boolean graphicsLevel = true;
 
-	protected BlockLeavesBase(int var1, int var2, Material var3, boolean var4) {
+	public BlockLeavesBase(int var1, int var2, Material var3, boolean var4) {
 		super(var1, var2, var3);
 	}
 
--- /dev/null
+++ net/minecraft/client/gui/GuiLoadWorld.java
@@ -1,0 +1,96 @@
+package net.minecraft.client.gui;
+
+import net.minecraft.client.Minecraft;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.function.Consumer;
+
+public class GuiLoadWorld extends GuiScreen {
+	private static final Set<Character> VALID_PATH_CHARACTERS = new HashSet<>();{
+		for (char c : " !#$%&'()+,-.0123456789;=ABCDEFGHIJKLMNOQRSTUVWXYZ[]^_abcdefghijklmnopqrstuvwxyz{}~".toCharArray()) {
+			VALID_PATH_CHARACTERS.add(c);
+		}
+	}
+
+	private final GuiScreen parent;
+
+	public GuiLoadWorld(GuiScreen parent) {
+		this.parent = parent;
+	}
+
+	public void initGui() {
+		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 2 - 36, "Create new world..."));
+		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 2 - 12, "Load existing world..."));
+		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 2 + 12, "Delete world..."));
+		this.controlList.add(new GuiButton(3, this.width / 2 - 100, this.height / 2 + 48, "Back to title"));
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		this.drawDefaultBackground();
+		super.drawScreen(var1, var2, var3);
+		drawCenteredString(this.fontRenderer, "Select world", this.width / 2, 60, 16777215);
+	}
+
+	private void createNewWorld() {
+		File[] files = this.mc.worldSaveLocation.listFiles();
+		if (this.mc.worldSaveLocation.isFile() || files != null && files.length != 0) {
+			this.mc.worldSaveLocation = null;
+			return;
+		}
+
+		this.mc.adventureMode = true;
+		this.mc.displayGuiScreen(new GuiNewLevel(this));
+	}
+
+	private void loadWorld() {
+		try {
+			this.mc.adventureMode = true;
+			if (this.mc.loadWorld()) {
+				this.mc.displayGuiScreen(null);
+			}
+		} catch (IOException e) {
+			e.printStackTrace();
+			this.mc.adventureMode = false;
+			this.mc.worldSaveLocation = null;
+		}
+	}
+
+	private void deleteWorld() {
+		this.mc.adventureMode = true;
+		this.mc.displayGuiScreen(new GuiDeleteWorld(this));
+	}
+
+	private Consumer<String> buttonAction(Runnable action) {
+		return path -> {
+			for (char c : path.toCharArray()) {
+				if (!VALID_PATH_CHARACTERS.contains(c)) {
+					return;
+				}
+			}
+
+			File savesDir = new File(Minecraft.getAppDir(), "inadv-worlds");
+			this.mc.worldSaveLocation = new File(savesDir, path);
+			action.run();
+		};
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		switch (var1.id) {
+			case 0:
+				this.mc.displayGuiScreen(new GuiTextPrompt(this, "Enter world name", buttonAction(this::createNewWorld)));
+				break;
+			case 1:
+				this.mc.displayGuiScreen(new GuiTextPrompt(this, "Enter world name", buttonAction(this::loadWorld)));
+				break;
+			case 2:
+				this.mc.displayGuiScreen(new GuiTextPrompt(this, "Enter world name", buttonAction(this::deleteWorld)));
+				break;
+			case 3:
+				this.mc.displayGuiScreen(this.parent);
+				break;
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/client/gui/GuiSelectBlock.java
@@ -1,0 +1,205 @@
+package net.minecraft.client.gui;
+
+import net.minecraft.client.ItemTooltips;
+import net.minecraft.client.RenderHelper;
+import net.minecraft.client.Session;
+import net.minecraft.client.controller.PlayerControllerCreative;
+import net.minecraft.client.gui.container.GuiInventory;
+import net.minecraft.client.render.entity.RenderItem;
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.ItemStack;
+import net.minecraft.game.level.block.Block;
+import org.lwjgl.Sys;
+import org.lwjgl.input.Keyboard;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL12;
+
+public class GuiSelectBlock extends GuiScreen {
+	private static final RenderItem itemRenderer = RenderItem.instance;
+	private int page = 0;
+
+	public void initGui() {
+		if (this.mc.options.showFPS) {
+			this.controlList.add(new GuiButton(0, 8, this.height - 100, 60, 20, "Morning").withBg(1));
+			this.controlList.add(new GuiButton(1, 8, this.height - 76, 60, 20, "Noon").withBg(1));
+			this.controlList.add(new GuiButton(2, 8, this.height - 52, 60, 20, "Afternoon").withBg(1));
+			this.controlList.add(new GuiButton(3, 8, this.height - 28, 60, 20, "Night").withBg(1));
+		}
+
+		this.controlList.add(new GuiButton(4, this.width / 2 + 130, this.height / 2 - 10, 20, 20, "v").withBg(1));
+		this.controlList.add(new GuiButton(5, this.width / 2 + 130, this.height / 2 - 40, 20, 20, "^").withBg(1));
+	}
+
+	public boolean doesGuiPauseGame() {
+		return false;
+	}
+
+	private int getTileAtSlot(int x, int y) {
+		for (int i = 0; i < Math.min(Session.registeredBlocksList.size() - this.page * 9, 45); i++) {
+			int ix = this.width / 2 + i % 9 * 24 - 111;
+			int iy = this.height / 2 + i / 9 * 24 - 57;
+			if (x < ix || x > ix + 24 || y < iy - 12 || y > iy + 12) continue;
+			return i;
+		}
+		return -1;
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		int tile = this.getTileAtSlot(var1, var2);
+		drawGradientRect(this.width / 2 - 120, this.height / 2 - 90, this.width / 2 + 120, this.height / 2 + 60, -1878719232, -1070583712);
+
+		if (tile >= 0) {
+            int tx = this.width / 2 + tile % 9 * 24 - 108;
+            int ty = this.height / 2 + tile / 9 * 24 - 60;
+            drawGradientRect(tx - 3, ty - 8, tx + 23, ty + 18, -1862270977, -1056964609);
+		}
+
+		String header = "Select block";
+		if (tile >= 0) {
+			Object item = Session.registeredBlocksList.get(tile + page * 9);
+			int id = 0;
+			if (item instanceof Item) {
+				id = ((Item)item).shiftedIndex;
+			} else if (item instanceof Block) {
+				id = ((Block)item).blockID;
+			} else if (item instanceof ItemStack) {
+				id = ((ItemStack)item).itemID;
+			}
+			if (id > 0) {
+				String tooltip = ItemTooltips.get(id);
+				if (tooltip != null && tooltip.length() > 0) {
+					header = tooltip;
+				}
+			}
+		}
+
+		drawCenteredString(this.fontRenderer, header, this.width / 2, this.height / 2 - 80, 16777215);
+
+		GL11.glPushMatrix();
+		GL11.glRotatef(180.0F, 1.0F, 0.0F, 0.0F);
+		RenderHelper.enableStandardItemLighting();
+		GL11.glPopMatrix();
+		GL11.glPushMatrix();
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		GL11.glEnable(GL12.GL_RESCALE_NORMAL);
+
+		for (int i = 0; i < Math.min(Session.registeredBlocksList.size() - this.page * 9, 45); i++) {
+			int tx = this.width / 2 + i % 9 * 24 - 108;
+            int ty = this.height / 2 + i / 9 * 24 - 60;
+			Object registry = Session.registeredBlocksList.get(i + this.page * 9);
+			int id = 0;
+			int damage = 0;
+
+			if (registry instanceof Block) {
+				id = ((Block)registry).blockID;
+			} else if (registry instanceof Item) {
+				id = ((Item)registry).shiftedIndex;
+			} else if (registry instanceof ItemStack) {
+				id = ((ItemStack)registry).itemID;
+				damage = ((ItemStack)registry).itemDamage;
+			}
+
+			if (id > 0) {
+				if (tile == i) {
+					GL11.glPushMatrix();
+					GL11.glTranslatef(tx + 8, ty + 8, 0.0F);
+					GL11.glScalef(1.6F, 1.6F, 1.6F);
+					GL11.glTranslatef(-tx - 8, -ty - 8, 0.0F);
+				}
+
+				itemRenderer.renderItemIntoGUI(this.mc.renderEngine, new ItemStack(id, 1, damage), tx + 1, ty - 2);
+
+				if (tile == i) {
+					GL11.glPopMatrix();
+				}
+			}
+		}
+
+		GL11.glDisable(GL12.GL_RESCALE_NORMAL);
+		RenderHelper.disableStandardItemLighting();
+		GL11.glDisable(GL11.GL_LIGHTING);
+		GL11.glDisable(GL11.GL_DEPTH_TEST);
+		GL11.glPopMatrix();
+		super.drawScreen(var1, var2, var3);
+
+		if (this.mc.options.showFPS) {
+			drawCenteredString(this.fontRenderer, "Change time", 38, this.height - 116, 0xFFFFFF);
+		}
+	}
+
+	protected void drawSlotInventory(int var1, int var2, int var3) {
+		super.drawSlotInventory(var1, var2, var3);
+
+		if (this.hasSelectedButton()) return;
+
+		if (var3 == 0) {
+			int tile = this.getTileAtSlot(var1, var2);
+
+			if (tile >= 0) {
+				Object registry = Session.registeredBlocksList.get(tile + this.page * 9);
+				int id = 0;
+				int damage = 0;
+
+				if (registry instanceof Block) {
+					id = ((Block)registry).blockID;
+				} else if (registry instanceof Item) {
+					id = ((Item)registry).shiftedIndex;
+				} else if (registry instanceof ItemStack) {
+					id = ((ItemStack)registry).itemID;
+					damage = ((ItemStack)registry).itemDamage;
+				}
+
+				for (int i = 0; i < 9; i++) {
+					ItemStack hotbarItem = this.mc.thePlayer.inventory.getStackInSlot(i);
+					if (hotbarItem != null && hotbarItem.itemID == id && hotbarItem.itemDamage == damage) {
+						ItemStack oldItem = this.mc.thePlayer.inventory.getCurrentItem();
+						this.mc.thePlayer.inventory.setInventorySlotContents(this.mc.thePlayer.inventory.currentItem, hotbarItem);
+						this.mc.thePlayer.inventory.setInventorySlotContents(i, oldItem);
+						this.mc.displayGuiScreen(null);
+						return;
+					}
+				}
+
+				int slot = this.mc.thePlayer.inventory.currentItem;
+				this.mc.thePlayer.inventory.setInventorySlotContents(slot, new ItemStack(id, 1, damage));
+			}
+		}
+
+		this.mc.displayGuiScreen(null);
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		if (var1.id >= 0 && var1.id < 4) {
+			this.mc.theWorld.worldTime = var1.id * 4500 - 1000;
+		} else {
+			switch (var1.id) {
+				case 4:
+					this.mouseScrolled(-120);
+					break;
+				case 5:
+					this.mouseScrolled(120);
+					break;
+			}
+		}
+	}
+
+	protected void mouseScrolled(int var1) {
+		int maxPages = (Session.registeredBlocksList.size() - 1) / 9 - 3;
+		page += var1 / -120;
+		if (page < 0) {
+			page = 0;
+		} else if (page >= maxPages) {
+			page = maxPages - 1;
+		}
+	}
+
+	protected void keyTyped(char var1, int var2) {
+		super.keyTyped(var1, var2);
+
+		for(int i = 0; i < 9; ++i) {
+			if(var1 == i + '1') {
+				this.mc.thePlayer.inventory.currentItem = i;
+			}
+		}
+	}
+}
--- net/minecraft/client/gui/GuiIngame.java
+++ net/minecraft/client/gui/GuiIngame.java
@@ -1,11 +1,14 @@
 package net.minecraft.client.gui;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Random;
 import net.minecraft.client.ChatLine;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.RenderHelper;
+import net.minecraft.client.ThreadSaveLevel;
+import net.minecraft.client.controller.PlayerControllerSP;
 import net.minecraft.client.player.EntityPlayerSP;
 import net.minecraft.client.render.entity.RenderItem;
 import net.minecraft.game.entity.player.InventoryPlayer;
@@ -13,8 +16,8 @@
 import org.lwjgl.opengl.GL11;
 
 public final class GuiIngame extends Gui {
-	private static RenderItem itemRenderer = new RenderItem();
-	private List chatMessageList = new ArrayList();
+	private static RenderItem itemRenderer = RenderItem.instance;
+	private List chatMessageList = Collections.synchronizedList(new ArrayList());
 	private Random rand = new Random();
 	private Minecraft mc;
 	private int updateCounter = 0;
@@ -24,6 +27,11 @@
 	}
 
 	public final void renderGameOverlay(float var1) {
+		if (!this.mc.options.showHUD) {
+			this.mc.entityRenderer.setupOverlayRendering();
+			return;
+		}
+
 		ScaledResolution var2 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight);
 		int var3 = var2.getScaledWidth();
 		int var19 = var2.getScaledHeight();
@@ -110,12 +118,18 @@
 
 				for(var13 = 0; var13 < var11 + var12; ++var13) {
 					if(var13 < var11) {
-						this.drawTexturedModalRect(var3 / 2 - 91 + (var13 << 3), var19 - 32 - 9, 16, 18, 9, 9);
+						this.drawTexturedModalRect(var3 / 2 - 91 + (var13 << 3), var19 - 32 - 10, 16, 18, 9, 9);
 					} else {
-						this.drawTexturedModalRect(var3 / 2 - 91 + (var13 << 3), var19 - 32 - 9, 25, 18, 9, 9);
+						this.drawTexturedModalRect(var3 / 2 - 91 + (var13 << 3), var19 - 32 - 10, 25, 18, 9, 9);
 					}
 				}
 			}
+		}
+
+
+		if (this.mc.playerController instanceof PlayerControllerSP) {
+			String text = "Score: &e" + this.mc.thePlayer.getScore;
+			var4.drawStringWithShadow(text, var3 - var4.getStringWidth(text) - 2, 2, 0xFFFFFF);
 		}
 
 		GL11.glDisable(GL11.GL_BLEND);
@@ -151,7 +165,7 @@
 		RenderHelper.disableStandardItemLighting();
 		GL11.glDisable(GL11.GL_NORMALIZE);
 		if(this.mc.options.showFPS) {
-			var4.drawStringWithShadow("Minecraft Indev (" + this.mc.debug + ")", 2, 2, 16777215);
+			var4.drawStringWithShadow(Minecraft.VERSION + " (" + this.mc.debug + ")", 2, 2, 16777215);
 			Minecraft var23 = this.mc;
 			var4.drawStringWithShadow(var23.renderGlobal.getDebugInfoRenders(), 2, 12, 16777215);
 			var23 = this.mc;
@@ -166,25 +180,69 @@
 			drawString(var4, var18, var3 - var4.getStringWidth(var18) - 2, 2, 14737632);
 			var18 = "Allocated memory: " + var27 * 100L / var24 + "% (" + var27 / 1024L / 1024L + "MB)";
 			drawString(var4, var18, var3 - var4.getStringWidth(var18) - 2, 12, 14737632);
+
+			String x = String.format("%.2f", this.mc.thePlayer.posX);
+			String y = String.format("%.2f", this.mc.thePlayer.boundingBox.minY);
+			String z = String.format("%.2f", this.mc.thePlayer.posZ);
+			drawString(var4, "x: ", 2, 50, 16777215);
+			drawString(var4, "y: ", 2, 60, 16777215);
+			drawString(var4, "z: ", 2, 70, 16777215);
+			drawString(var4, x, 50 - var4.getStringWidth(x), 50, 16777215);
+			drawString(var4, y, 50 - var4.getStringWidth(y), 60, 16777215);
+			drawString(var4, z, 50 - var4.getStringWidth(z), 70, 16777215);
+			if (this.mc.adventureMode) {
+				drawString(var4, " @ " + this.mc.worldInfo.levelX, 50, 50, 16777215);
+				drawString(var4, " @ " + this.mc.worldInfo.levelZ, 50, 70, 16777215);
+			}
+			drawString(var4, "dim: ", 2, 85, 16777215);
+			drawString(var4, this.mc.theWorld.width + "x" + this.mc.theWorld.height + "x" + this.mc.theWorld.length, 60, 85, 16777215);
+			drawString(var4, "type: ", 2, 95, 16777215);
+			drawString(var4, String.valueOf(this.mc.theWorld.levelType), 60, 95, 16777215);
+			drawString(var4, "theme: ", 2, 105, 16777215);
+			drawString(var4, String.valueOf(this.mc.theWorld.levelTheme), 60, 105, 16777215);
+			drawString(var4, "structure: ", 2, 115, 16777215);
+			drawString(var4, String.valueOf(this.mc.theWorld.levelStructure), 60, 115, 16777215);
 		} else {
-			var4.drawStringWithShadow("Minecraft Indev", 2, 2, 16777215);
+//			var4.drawStringWithShadow("Minecraft Indev", 2, 2, 16777215);
 		}
 
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		for(var12 = 0; var12 < this.chatMessageList.size() && var12 < 10; ++var12) {
-			if(((ChatLine)this.chatMessageList.get(var12)).updateCounter < 200) {
-				this.chatMessageList.get(var12);
-				var4.drawStringWithShadow((String)null, 2, var19 - 8 - var12 * 9 - 20, 16777215);
+			ChatLine message = (ChatLine)this.chatMessageList.get(var12);
+			if(message.displayTime < 200) {
+				var4.alpha = Math.min((180 - message.displayTime) / 20.0F, 1.0F);
+				var4.drawStringWithShadow(message.content, 2, var19 - 8 - var12 * 9 - 32, 0xFFFFFF);
+				var4.alpha = 1.0F;
 			}
 		}
-
+		GL11.glDisable(GL11.GL_BLEND);
+	}
+
+	public final void drawAutosaveIndicator() {
+		if (this.mc.getAutosaveTime() > 5 && !ThreadSaveLevel.isBusy()) return;
+
+		ScaledResolution dimensions = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight);
+		int width = dimensions.getScaledWidth();
+		this.mc.entityRenderer.setupOverlayRendering();
+
+		this.drawAutosaveIcon(this.mc, width - 40, 40);
 	}
 
 	public final void addChatMessage() {
 		++this.updateCounter;
 
 		for(int var1 = 0; var1 < this.chatMessageList.size(); ++var1) {
-			++((ChatLine)this.chatMessageList.get(var1)).updateCounter;
+			++((ChatLine)this.chatMessageList.get(var1)).displayTime;
 		}
 
+	}
+
+	public void sendChatMessage(String message) {
+		this.chatMessageList.add(0, new ChatLine(message));
+	}
+
+	public void clearChat() {
+		this.chatMessageList.clear();
 	}
 }
--- net/minecraft/client/GameSettings.java
+++ net/minecraft/client/GameSettings.java
@@ -5,36 +5,48 @@
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
+import java.util.HashSet;
+
 import org.lwjgl.input.Keyboard;
 
 public final class GameSettings {
-	private static final String[] RENDER_DISTANCES = new String[]{"FAR", "NORMAL", "SHORT", "TINY"};
+	private static final String[] RENDER_DISTANCES = new String[]{"VERY FAR", "FAR", "NORMAL", "SHORT", "TINY"};
 	private static final String[] DIFFICULTIES = new String[]{"Peaceful", "Easy", "Normal", "Hard"};
-	public boolean music = true;
-	public boolean sound = true;
+	private static final HashSet<Integer> SLIDERS = new HashSet<>(); static {
+		SLIDERS.add(0);
+		SLIDERS.add(1);
+	}
+
+	public float music = 1.0F;
+	public float sound = 1.0F;
 	public boolean invertMouse = false;
 	public boolean showFPS = false;
+	public boolean showHUD = true;
 	public int renderDistance = 0;
 	public boolean fancyGraphics = true;
 	public boolean anaglyph = false;
 	public boolean limitFramerate = false;
+	public boolean advancedOpenGL = false;
 	public KeyBinding keyBindForward = new KeyBinding("Forward", 17);
 	public KeyBinding keyBindLeft = new KeyBinding("Left", 30);
 	public KeyBinding keyBindBack = new KeyBinding("Back", 31);
 	public KeyBinding keyBindRight = new KeyBinding("Right", 32);
 	public KeyBinding keyBindJump = new KeyBinding("Jump", 57);
-	public KeyBinding keyBindInventory = new KeyBinding("Inventory", 23);
+	public KeyBinding keyBindInventory = new KeyBinding("Inventory", 18);
 	public KeyBinding keyBindDrop = new KeyBinding("Drop", 16);
 	private KeyBinding keyBindChat = new KeyBinding("Chat", 20);
 	public KeyBinding keyBindToggleFog = new KeyBinding("Toggle fog", 33);
 	public KeyBinding keyBindSave = new KeyBinding("Save location", 28);
 	public KeyBinding keyBindLoad = new KeyBinding("Load location", 19);
-	public KeyBinding[] keyBindings = new KeyBinding[]{this.keyBindForward, this.keyBindLeft, this.keyBindBack, this.keyBindRight, this.keyBindJump, this.keyBindDrop, this.keyBindInventory, this.keyBindChat, this.keyBindToggleFog, this.keyBindSave, this.keyBindLoad};
+	public KeyBinding keyBindSneak = new KeyBinding("Sneak", 42);
+	public KeyBinding keyBindRecipeGuide = new KeyBinding("Recipe guide", 19);
+	public KeyBinding[] keyBindings = new KeyBinding[]{this.keyBindForward, this.keyBindLeft, this.keyBindBack, this.keyBindRight, this.keyBindJump, this.keyBindDrop, this.keyBindInventory, this.keyBindToggleFog, this.keyBindSave, this.keyBindLoad, this.keyBindSneak, this.keyBindRecipeGuide};
 	private Minecraft mc;
 	private File optionsFile;
-	public int numberOfOptions = 9;
+	public int numberOfOptions = 10;
 	public int difficulty = 2;
 	public boolean thirdPersonView = false;
+	public boolean frontThirdPersonView = false;
 
 	public GameSettings(Minecraft var1, File var2) {
 		this.mc = var1;
@@ -52,50 +64,78 @@
 	}
 
 	public final void setOptionValue(int var1, int var2) {
-		if(var1 == 0) {
-			this.music = !this.music;
-			this.mc.sndManager.onSoundOptionsChanged();
-		}
-
-		if(var1 == 1) {
-			this.sound = !this.sound;
-			this.mc.sndManager.onSoundOptionsChanged();
-		}
-
-		if(var1 == 2) {
-			this.invertMouse = !this.invertMouse;
-		}
-
-		if(var1 == 3) {
-			this.showFPS = !this.showFPS;
-		}
-
-		if(var1 == 4) {
-			this.renderDistance = this.renderDistance + var2 & 3;
-		}
-
-		if(var1 == 5) {
-			this.fancyGraphics = !this.fancyGraphics;
-		}
-
-		if(var1 == 6) {
-			this.anaglyph = !this.anaglyph;
-			this.mc.renderEngine.refreshTextures();
-		}
-
-		if(var1 == 7) {
-			this.limitFramerate = !this.limitFramerate;
-		}
-
-		if(var1 == 8) {
-			this.difficulty = this.difficulty + var2 & 3;
-		}
+        switch (var1) {
+            case 2:
+                this.invertMouse = !this.invertMouse;
+                break;
+            case 3:
+                this.showFPS = !this.showFPS;
+                break;
+            case 4:
+                this.renderDistance = Math.floorMod(this.renderDistance + var2, 5);
+                this.mc.renderGlobal.changeWorld(this.mc.theWorld);
+                break;
+            case 5:
+                this.fancyGraphics = !this.fancyGraphics;
+                break;
+            case 6:
+                this.anaglyph = !this.anaglyph;
+                this.mc.renderEngine.refreshTextures();
+                break;
+            case 7:
+                this.limitFramerate = !this.limitFramerate;
+                break;
+            case 8:
+                this.difficulty = this.difficulty + var2 & 3;
+                break;
+            case 9:
+                this.advancedOpenGL = !this.advancedOpenGL;
+                this.mc.renderGlobal.changeWorld(this.mc.theWorld);
+                break;
+        }
 
 		this.saveOptions();
+	}
+
+	public final void setOptionFloat(int var1, float var2) {
+        switch (var1) {
+            case 0:
+                this.music = var2;
+                this.mc.sndManager.onSoundOptionsChanged();
+                break;
+            case 1:
+                this.sound = var2;
+                this.mc.sndManager.onSoundOptionsChanged();
+                break;
+        }
+	}
+
+	public final boolean isSlider(int var1) {
+		return SLIDERS.contains(var1);
 	}
 
 	public final String setOptionString(int var1) {
-		return var1 == 0 ? "Music: " + (this.music ? "ON" : "OFF") : (var1 == 1 ? "Sound: " + (this.sound ? "ON" : "OFF") : (var1 == 2 ? "Invert mouse: " + (this.invertMouse ? "ON" : "OFF") : (var1 == 3 ? "Show FPS: " + (this.showFPS ? "ON" : "OFF") : (var1 == 4 ? "Render distance: " + RENDER_DISTANCES[this.renderDistance] : (var1 == 5 ? "View bobbing: " + (this.fancyGraphics ? "ON" : "OFF") : (var1 == 6 ? "3d anaglyph: " + (this.anaglyph ? "ON" : "OFF") : (var1 == 7 ? "Limit framerate: " + (this.limitFramerate ? "ON" : "OFF") : (var1 == 8 ? "Difficulty: " + DIFFICULTIES[this.difficulty] : ""))))))));
+		switch (var1) {
+			case 0: return "Music: " + (this.music > 0.0F ? (int)(this.music * 100.0F) + "%" : "OFF");
+			case 1: return "Sound: " + (this.sound > 0.0F ? (int)(this.sound * 100.0F) + "%" : "OFF");
+			case 2: return "Invert mouse: " + (this.invertMouse ? "ON" : "OFF");
+			case 3: return "Show FPS: " + (this.showFPS ? "ON" : "OFF");
+			case 4: return "Render distance: " + RENDER_DISTANCES[this.renderDistance];
+			case 5: return "View bobbing: " + (this.fancyGraphics ? "ON" : "OFF");
+			case 6: return "3d anaglyph: " + (this.anaglyph ? "ON" : "OFF");
+			case 7: return "Limit framerate: " + (this.limitFramerate ? "ON" : "OFF");
+			case 8: return "Difficulty: " + DIFFICULTIES[this.difficulty];
+			case 9: return "Advanced OpenGL: " + (this.advancedOpenGL ? "ON" : "OFF");
+			default: return "";
+		}
+	}
+
+	public final float getOptionFloat(int var1) {
+		switch (var1) {
+			case 0: return this.music;
+			case 1: return this.sound;
+			default: return 0.0F;
+		}
 	}
 
 	private void loadOptions() {
@@ -112,11 +152,11 @@
 
 					String[] var5 = var2.split(":");
 					if(var5[0].equals("music")) {
-						this.music = var5[1].equals("true");
+						this.music = parseFloat(var5[1]);
 					}
 
 					if(var5[0].equals("sound")) {
-						this.sound = var5[1].equals("true");
+						this.sound = parseFloat(var5[1]);
 					}
 
 					if(var5[0].equals("invertYMouse")) {
@@ -147,6 +187,10 @@
 						this.difficulty = Integer.parseInt(var5[1]);
 					}
 
+					if(var5[0].equals("advancedOpenGL")) {
+						this.advancedOpenGL = var5[1].equals("true");
+					}
+
 					for(int var3 = 0; var3 < this.keyBindings.length; ++var3) {
 						if(var5[0].equals("key_" + this.keyBindings[var3].keyDescription)) {
 							this.keyBindings[var3].keyCode = Integer.parseInt(var5[1]);
@@ -160,6 +204,12 @@
 		}
 	}
 
+	private static float parseFloat(String var1) {
+		return var1.equals("true") ? 1.0F
+				: var1.equals("false") ? 0.0F
+				: Float.parseFloat(var1);
+	}
+
 	public final void saveOptions() {
 		try {
 			PrintWriter var1 = new PrintWriter(new FileWriter(this.optionsFile));
@@ -172,6 +222,7 @@
 			var1.println("anaglyph3d:" + this.anaglyph);
 			var1.println("limitFramerate:" + this.limitFramerate);
 			var1.println("difficulty:" + this.difficulty);
+			var1.println("advancedOpenGL:" + this.advancedOpenGL);
 
 			for(int var2 = 0; var2 < this.keyBindings.length; ++var2) {
 				var1.println("key_" + this.keyBindings[var2].keyDescription + ":" + this.keyBindings[var2].keyCode);
@@ -182,5 +233,9 @@
 			System.out.println("Failed to save options");
 			var3.printStackTrace();
 		}
+	}
+
+	public int getRenderDistance() {
+		return 512 >> this.renderDistance;
 	}
 }
--- net/minecraft/game/level/block/BlockFlower.java
+++ net/minecraft/game/level/block/BlockFlower.java
@@ -6,7 +6,7 @@
 import net.minecraft.game.physics.AxisAlignedBB;
 
 public class BlockFlower extends Block {
-	protected BlockFlower(int var1, int var2) {
+	public BlockFlower(int var1, int var2) {
 		super(var1, Material.plants);
 		this.blockIndexInTexture = var2;
 		this.setTickOnLoad(true);
@@ -17,7 +17,7 @@
 		return this.canThisPlantGrowOnThisBlockID(var1.getBlockId(var2, var3 - 1, var4));
 	}
 
-	protected boolean canThisPlantGrowOnThisBlockID(int var1) {
+	public boolean canThisPlantGrowOnThisBlockID(int var1) {
 		return var1 == Block.grass.blockID || var1 == Block.dirt.blockID || var1 == Block.tilledField.blockID;
 	}
 
@@ -28,6 +28,22 @@
 
 	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
 		this.checkFlowerChange(var1, var2, var3, var4);
+
+		if (this.getClass() != BlockFlower.class) return;
+
+		if (this.canBlockStay(var1, var2, var3, var4)
+				&& var1.getBlockId(var2, var3 - 1, var4) == Block.tilledField.blockID
+				&& var1.getBlockMetadata(var2, var3 - 1, var4) > 0
+				&& var1.getBlockLightValue(var2, var3 + 1, var4) >= 9
+				&& var5.nextInt(50) == 0) {
+			int gx = var2 - 1 + var5.nextInt(3);
+			int gz = var4 - 1 + var5.nextInt(3);
+			if (var1.getBlockId(gx, var3, gz) == 0
+					&& this.canBlockStay(var1, gx, var3, gz)
+					&& var1.getBlockId(gx, var3 - 1, gz) == Block.tilledField.blockID) {
+				var1.setBlock(gx, var3, gz, this.blockID);
+			}
+		}
 	}
 
 	private void checkFlowerChange(World var1, int var2, int var3, int var4) {
@@ -42,7 +58,7 @@
 		return (var1.getBlockLightValue(var2, var3, var4) >= 8 || var1.getBlockLightValue(var2, var3, var4) >= 4 && var1.canBlockSeeTheSky(var2, var3, var4)) && this.canThisPlantGrowOnThisBlockID(var1.getBlockId(var2, var3 - 1, var4));
 	}
 
-	public final AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
+	public final AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
 		return null;
 	}
 
--- net/minecraft/game/level/block/BlockSapling.java
+++ net/minecraft/game/level/block/BlockSapling.java
@@ -4,7 +4,7 @@
 import net.minecraft.game.level.World;
 
 public final class BlockSapling extends BlockFlower {
-	protected BlockSapling(int var1, int var2) {
+	public BlockSapling(int var1, int var2) {
 		super(6, 15);
 		this.setBlockBounds(10.0F * 0.01F, 0.0F, 10.0F * 0.01F, 0.9F, 0.8F, 0.9F);
 	}
--- net/minecraft/game/level/block/BlockFurnace.java
+++ net/minecraft/game/level/block/BlockFurnace.java
@@ -10,7 +10,7 @@
 public final class BlockFurnace extends BlockContainer {
 	private final boolean isActive;
 
-	protected BlockFurnace(int var1, boolean var2) {
+	public BlockFurnace(int var1, boolean var2) {
 		super(var1, Material.rock);
 		this.isActive = var2;
 		this.blockIndexInTexture = 45;
@@ -89,10 +89,11 @@
 	}
 
 	public final int getBlockTextureFromSide(int var1) {
-		return var1 == 1 ? Block.stone.blockID : (var1 == 0 ? Block.stone.blockID : (var1 == 3 ? this.blockIndexInTexture - 1 : this.blockIndexInTexture));
+		return var1 == 1 ? Block.stone.blockID : (var1 == 0 ? Block.stone.blockID : (var1 == 3 ? (this.isActive ? this.blockIndexInTexture + 16 : this.blockIndexInTexture - 1) : this.blockIndexInTexture));
 	}
 
 	public final boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+		if (!var1.survivalWorld) return false;
 		TileEntityFurnace var6 = (TileEntityFurnace)var1.getBlockTileEntity(var2, var3, var4);
 		var5.displayGUIFurnace(var6);
 		return true;
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageRaising3D.java
@@ -1,0 +1,226 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+import util.DoubleArray3D;
+
+public class StageRaising3D extends TerrainGenStage {
+	private StageRaising3D(Builder properties) {
+		super("Raising..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			int chunkSize = 16;
+			int resHorizontal = properties.resHorizontal;
+			int resVertical = properties.resVertical;
+			int noiseWidth = chunkSize / resHorizontal + 1;
+			int noiseLength = chunkSize / resHorizontal + 1;
+			int noiseHeight = blocks.height / resVertical + 1;
+			int thresholdHeight = properties.heightOffset - world.waterLevel;
+
+			NoiseGenerator minTargetNoise = new NoiseGeneratorOctaves(rand, 8);
+			NoiseGenerator maxTargetNoise = new NoiseGeneratorOctaves(rand, 8);
+			NoiseGenerator selectorNoise = new NoiseGeneratorOctaves(rand, 4);
+
+			for (int cx = 0; cx < blocks.width / chunkSize; cx++) {
+				progressor.accept(cx * 100.0F / (blocks.width / chunkSize - 1));
+
+				for (int cz = 0; cz < blocks.length / chunkSize; cz++) {
+					int cbx = cx * chunkSize;
+					int cbz = cz * chunkSize;
+					int cnx = cbx / resHorizontal;
+					int cnz = cbz / resHorizontal;
+
+					DoubleArray3D minSamples = new DoubleArray3D(noiseWidth, noiseLength, noiseHeight);
+					DoubleArray3D maxSamples = new DoubleArray3D(noiseWidth, noiseLength, noiseHeight);
+					DoubleArray3D selectionSamples = new DoubleArray3D(noiseWidth, noiseLength, noiseHeight);
+
+					for (int y = 0; y < noiseHeight; y++) {
+						for (int z = 0; z < noiseLength; z++) {
+							for (int x = 0; x < noiseWidth; x++) {
+								double min = minTargetNoise.generateNoiseNormalized(
+										(x + cnx) * properties.noiseScaleHorizontal,
+										y * properties.noiseScaleVertical,
+										(z + cnz) * properties.noiseScaleHorizontal
+								);
+								double max = maxTargetNoise.generateNoiseNormalized(
+										(x + cnx) * properties.noiseScaleHorizontal,
+										y * properties.noiseScaleVertical,
+										(z + cnz) * properties.noiseScaleHorizontal
+								);
+								double selection = selectorNoise.generateNoiseNormalized(
+										(x + cnx) * properties.selectorScaleHorizontal,
+										y * properties.selectorScaleVertical,
+										(z + cnz) * properties.selectorScaleHorizontal
+								);
+
+								minSamples.set(x, y, z, min);
+								maxSamples.set(x, y, z, max);
+								selectionSamples.set(x, y, z, selection);
+							}
+						}
+					}
+
+					DoubleArray3D lerpedMinSamples = new DoubleArray3D(chunkSize, chunkSize, blocks.height);
+					DoubleArray3D lerpedMaxSamples = new DoubleArray3D(chunkSize, chunkSize, blocks.height);
+					DoubleArray3D lerpedSelectionSamples = new DoubleArray3D(chunkSize, chunkSize, blocks.height);
+
+					for (int y = 0; y < blocks.height; y++) {
+						for (int z = 0; z < chunkSize; z++) {
+							for (int x = 0; x < chunkSize; x++) {
+								lerpedMinSamples.set(x, y, z, lerp3DPoints(minSamples, x, y, z, resHorizontal, resVertical));
+								lerpedMaxSamples.set(x, y, z, lerp3DPoints(maxSamples, x, y, z, resHorizontal, resVertical));
+								lerpedSelectionSamples.set(x, y, z, lerp3DPoints(selectionSamples, x, y, z, resHorizontal, resVertical));
+							}
+						}
+					}
+
+					for (int y = 0; y < blocks.height - 2; y++) {
+						for (int z = 0; z < chunkSize && z + cbz < blocks.length; z++) {
+							for (int x = 0; x < chunkSize && x + cbx < blocks.length; x++) {
+								double min = lerpedMinSamples.get(x, y, z);
+								double max = lerpedMaxSamples.get(x, y, z);
+								double selection = lerpedSelectionSamples.get(x, y, z);
+
+								double target = lerp(min, max, Math.min(Math.max(
+										selection / properties.selectorThreshold + 0.5D, 0.0D), 1.0D));
+
+								double threshold = (y - world.waterLevel + properties.heightOffset) / properties.noiseStretch;
+								if (threshold < 0.0D) {
+									threshold *= properties.noiseUnderDamp;
+								}
+								target -= threshold;
+
+								if (target > 0.0D && y > blocks.height - properties.heightRoundoff) {
+									target -= 1.0F - (blocks.height - y) / (double)properties.heightRoundoff;
+								}
+
+								if (target > 0.0D) {
+									if (properties.cliffBlocks
+											&& Math.abs(selection) < properties.selectorThreshold
+											&& Math.abs(min - max) > properties.cliffThreshold) {
+										blocks.set(x + cbx, y, z + cbz, Block.clothRed.blockID);
+									} else {
+										blocks.set(x + cbx, y, z + cbz, Block.clothGreen.blockID);
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		});
+	}
+
+	public static double lerp(double a, double b, double t) {
+		return a + (b - a) * t;
+	}
+
+	public static double lerp3DPoints(DoubleArray3D samples, int x, int y, int z, int resHorizontal, int resVertical) {
+		int nx = x / resHorizontal;
+		int ny = y / resVertical;
+		int nz = z / resHorizontal;
+
+		double n000 = samples.get(nx + 0, ny + 0, nz + 0);
+		double n001 = samples.get(nx + 0, ny + 0, nz + 1);
+		double n010 = samples.get(nx + 0, ny + 1, nz + 0);
+		double n011 = samples.get(nx + 0, ny + 1, nz + 1);
+		double n100 = samples.get(nx + 1, ny + 0, nz + 0);
+		double n101 = samples.get(nx + 1, ny + 0, nz + 1);
+		double n110 = samples.get(nx + 1, ny + 1, nz + 0);
+		double n111 = samples.get(nx + 1, ny + 1, nz + 1);
+
+		double n00 = lerp(n000, n100, (x % resHorizontal) / (double)resHorizontal);
+		double n01 = lerp(n001, n101, (x % resHorizontal) / (double)resHorizontal);
+		double n10 = lerp(n010, n110, (x % resHorizontal) / (double)resHorizontal);
+		double n11 = lerp(n011, n111, (x % resHorizontal) / (double)resHorizontal);
+
+		double n0 = lerp(n00, n10, (y % resVertical) / (double)resVertical);
+		double n1 = lerp(n01, n11, (y % resVertical) / (double)resVertical);
+
+		return lerp(n0, n1, (z % resHorizontal) / (double)resHorizontal);
+	}
+
+	public static class Builder {
+		private int resHorizontal = 4;
+		private int resVertical = 4;
+		private double noiseScaleHorizontal = 5.0D;
+		private double noiseScaleVertical = 5.0D;
+		private double selectorScaleHorizontal = 0.6D;
+		private double selectorScaleVertical = 0.15D;
+		private double selectorThreshold = 0.1D;
+		private double cliffThreshold = 0.25D;
+		private double noiseStretch = 64.0D;
+		private double noiseUnderDamp = 4.0D;
+		private int heightOffset = 0;
+		private int heightRoundoff = 8;
+		private boolean cliffBlocks = true;
+
+		public Builder resHorizontal(int resHorizontal) {
+			this.resHorizontal = resHorizontal;
+			return this;
+		}
+
+		public Builder resVertical(int resVertical) {
+			this.resVertical = resVertical;
+			return this;
+		}
+
+		public Builder noiseScaleHorizontal(double noiseScaleHorizontal) {
+			this.noiseScaleHorizontal = noiseScaleHorizontal;
+			return this;
+		}
+
+		public Builder noiseScaleVertical(double noiseScaleVertical) {
+			this.noiseScaleVertical = noiseScaleVertical;
+			return this;
+		}
+
+		public Builder selectorScaleHorizontal(double selectorScaleHorizontal) {
+			this.selectorScaleHorizontal = selectorScaleHorizontal;
+			return this;
+		}
+
+		public Builder selectorScaleVertical(double selectorScaleVertical) {
+			this.selectorScaleVertical = selectorScaleVertical;
+			return this;
+		}
+
+		public Builder selectorThreshold(double selectorThreshold) {
+			this.selectorThreshold = selectorThreshold;
+			return this;
+		}
+
+		public Builder cliffThreshold(double cliffThreshold) {
+			this.cliffThreshold = cliffThreshold;
+			return this;
+		}
+
+		public Builder noiseStretch(double noiseStretch) {
+			this.noiseStretch = noiseStretch;
+			return this;
+		}
+
+		public Builder noiseUnderDamp(double noiseUnderDamp) {
+			this.noiseUnderDamp = noiseUnderDamp;
+			return this;
+		}
+
+		public Builder heightOffset(int heightOffset) {
+			this.heightOffset = heightOffset;
+			return this;
+		}
+
+		public Builder heightRoundoff(int heightRoundoff) {
+			this.heightRoundoff = heightRoundoff;
+			return this;
+		}
+
+		public Builder cliffBlocks(boolean cliffBlocks) {
+			this.cliffBlocks = cliffBlocks;
+			return this;
+		}
+
+		public StageRaising3D build() {
+			return new StageRaising3D(this);
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageSoiling3D.java
@@ -1,0 +1,88 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+
+public class StageSoiling3D extends TerrainGenStage {
+	public StageSoiling3D(Builder properties) {
+		super("Soiling..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			NoiseGenerator erosionNoise = new NoiseGeneratorOctaves(rand, 8);
+
+			for (int x = 0; x < blocks.width; x++) {
+				progressor.accept(x * 100.0F / (float)(blocks.width - 1));
+				for (int z = 0; z < blocks.length; z++) {
+					int erosion = (int)(erosionNoise.generateNoise(
+							x * properties.erosionScale, z * properties.erosionScale)
+							/ properties.erosionDamp) + properties.erosionOffset;
+
+					int erosionFactor = erosion;
+					for (int y = blocks.height - 1; y > 0; y--) {
+						if (blocks.get(x, y, z) != 0) {
+							if (heightmap.get(x, z) == 0) {
+								heightmap.set(x, z, y);
+							}
+
+							Block block = properties.stone;
+							if (erosionFactor < 0 && blocks.get(x, y, z) == Block.clothGreen.blockID) {
+								block = properties.soil;
+								if (block == Block.dirt && world.skyBrightness > 7 && (y >= blocks.height || blocks.get(x, y + 1, z) == 0)) {
+									block = Block.grass;
+								}
+							}
+
+							blocks.set(x, y, z, block.blockID);
+							erosionFactor++;
+						} else {
+							erosionFactor = erosion;
+						}
+					}
+				}
+			}
+		});
+	}
+
+	public static class Builder {
+		private double erosionScale = 1.0D;
+		private double erosionDamp = 24.0D;
+		private int erosionOffset = -4;
+		private Block soil = Block.dirt;
+		private Block stone = Block.stone;
+
+		public Builder erosionScale(double erosionScale) {
+			this.erosionScale = erosionScale;
+			return this;
+		}
+
+		public Builder erosionDamp(double erosionDamp) {
+			this.erosionDamp = erosionDamp;
+			return this;
+		}
+
+		public Builder erosionOffset(int erosionOffset) {
+			this.erosionOffset = erosionOffset;
+			return this;
+		}
+
+		public Builder soil(Block soil) {
+			this.soil = soil;
+			return this;
+		}
+
+		public Builder stone(Block stone) {
+			this.stone = stone;
+			return this;
+		}
+
+		public Builder applyTheme(LevelTheme theme) {
+			return this
+					.soil(theme.getSoilBlock())
+					.stone(theme.getStoneBlock());
+		}
+
+		public StageSoiling3D build() {
+			return new StageSoiling3D(this);
+		}
+	}
+}
--- net/minecraft/client/render/RenderGlobal.java
+++ net/minecraft/client/render/RenderGlobal.java
@@ -22,17 +22,18 @@
 import net.minecraft.game.level.IWorldAccess;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.block.BlockFluid;
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.physics.MovingObjectPosition;
 import net.minecraft.game.physics.Vec3D;
 import org.lwjgl.BufferUtils;
-import org.lwjgl.opengl.ARBOcclusionQuery;
-import org.lwjgl.opengl.GL11;
-import org.lwjgl.opengl.GL15;
-import org.lwjgl.opengl.GLContext;
+import org.lwjgl.opengl.*;
+import org.lwjgl.util.glu.GLU;
 import util.MathHelper;
 
 public final class RenderGlobal implements IWorldAccess {
+	private static final int chunkSize = 16;
+
 	private World worldObj;
 	private RenderEngine renderEngine;
 	private int glGenList;
@@ -67,7 +68,7 @@
 	public RenderGlobal(Minecraft var1, RenderEngine var2) {
 		this.mc = var1;
 		this.renderEngine = var2;
-		this.glGenList = GL11.glGenLists(2);
+		this.glGenList = GL11.glGenLists(3);
 		this.glRenderListBase = GL11.glGenLists(786432);
 		this.occlusionEnabled = GLContext.getCapabilities().GL_ARB_occlusion_query;
 		if(this.occlusionEnabled) {
@@ -124,6 +125,9 @@
 	}
 
 	public final void loadRenderers() {
+        if (this.worldObj == null) return;
+		this.occlusionEnabled = this.mc.options.advancedOpenGL;
+
 		int var1;
 		if(this.worldRenderers != null) {
 			for(var1 = 0; var1 < this.worldRenderers.length; ++var1) {
@@ -131,9 +135,9 @@
 			}
 		}
 
-		this.renderChunksWide = this.worldObj.width / 16;
-		this.renderChunksTall = this.worldObj.height / 16;
-		this.renderChunksDeep = this.worldObj.length / 16;
+		this.renderChunksWide = (this.worldObj.width + chunkSize - 1) / chunkSize;
+		this.renderChunksTall = (this.worldObj.height + chunkSize - 1) / chunkSize;
+		this.renderChunksDeep = (this.worldObj.length + chunkSize - 1) / chunkSize;
 		this.worldRenderers = new WorldRenderer[this.renderChunksWide * this.renderChunksTall * this.renderChunksDeep];
 		this.sortedWorldRenderers = new WorldRenderer[this.renderChunksWide * this.renderChunksTall * this.renderChunksDeep];
 		var1 = 0;
@@ -143,7 +147,7 @@
 		for(var3 = 0; var3 < this.renderChunksWide; ++var3) {
 			for(int var4 = 0; var4 < this.renderChunksTall; ++var4) {
 				for(int var5 = 0; var5 < this.renderChunksDeep; ++var5) {
-					this.worldRenderers[(var5 * this.renderChunksTall + var4) * this.renderChunksWide + var3] = new WorldRenderer(this.worldObj, var3 << 4, var4 << 4, var5 << 4, 16, this.glRenderListBase + var1);
+					this.worldRenderers[(var5 * this.renderChunksTall + var4) * this.renderChunksWide + var3] = new WorldRenderer(this.worldObj, var3 * chunkSize, var4 * chunkSize, var5 * chunkSize, chunkSize, this.glRenderListBase + var1);
 					if(this.occlusionEnabled) {
 						this.worldRenderers[(var5 * this.renderChunksTall + var4) * this.renderChunksWide + var3].glOcclusionQuery = this.glOcclusionQueryBase.get(var2);
 					}
@@ -166,6 +170,9 @@
 		GL11.glNewList(this.glGenList + 1, GL11.GL_COMPILE);
 		this.oobWaterRenderHeight();
 		GL11.glEndList();
+		GL11.glNewList(this.glGenList + 2, GL11.GL_COMPILE);
+		this.oobHorizonRenderHeight();
+		GL11.glEndList();
 		this.markBlocksForUpdate(0, 0, 0, this.worldObj.width, this.worldObj.height, this.worldObj.length);
 	}
 
@@ -175,10 +182,16 @@
 		this.countEntitiesTotal = 0;
 		this.countEntitiesRendered = 0;
 		this.countEntitiesHidden = 0;
+		int dist = this.mc.options.getRenderDistance();
 
 		for(int var5 = 0; var5 < var4.width; ++var5) {
 			for(int var6 = 0; var6 < var4.depth; ++var6) {
 				for(int var7 = 0; var7 < var4.height; ++var7) {
+					int x = var5 * 8;
+					int y = var6 * 8;
+					int z = var7 * 8;
+					if (this.mc.thePlayer.getDistanceSqToBlock(x, y, z) > dist * dist) continue;
+
 					List var8 = var4.entityGrid[(var7 * var4.depth + var6) * var4.width + var5];
 					if(var8.size() != 0) {
 						int var9 = (var5 << 3) + 4;
@@ -192,9 +205,9 @@
 						float var12 = var10001;
 						boolean var10000;
 						if(var12 >= 0.0F && var13 >= 0.0F && var14 >= 0.0F && var12 < (float)this.worldObj.width && var13 < (float)this.worldObj.height && var14 < (float)this.worldObj.length) {
-							int var17 = (int)(var12 / 16.0F);
-							int var19 = (int)(var13 / 16.0F);
-							int var20 = (int)(var14 / 16.0F);
+							int var17 = (int)(var12 / chunkSize);
+							int var19 = (int)(var13 / chunkSize);
+							int var20 = (int)(var14 / chunkSize);
 							var10000 = this.worldRenderers[(var20 * this.renderChunksTall + var19) * this.renderChunksWide + var17].isInFrustrum && this.worldRenderers[(var20 * this.renderChunksTall + var19) * this.renderChunksWide + var17].isVisible;
 						} else {
 							var10000 = true;
@@ -238,6 +251,11 @@
 	}
 
 	public final int sortAndRender(EntityPlayer var1, int var2) {
+		boolean occlusion = this.occlusionEnabled && var2 == 0;
+		if (var2 < 0) {
+			var2 = 0;
+		}
+
 		if(var2 == 0) {
 			this.renderersLoaded = 0;
 			this.renderersBeingClipped = 0;
@@ -248,7 +266,7 @@
 		float var3 = var1.posX - this.prevSortX;
 		float var4 = var1.posY - this.prevSortY;
 		float var5 = var1.posZ - this.prevSortZ;
-		if(var3 * var3 + var4 * var4 + var5 * var5 > 16.0F) {
+		if(var3 * var3 + var4 * var4 + var5 * var5 > chunkSize) {
 			this.prevSortX = var1.posX;
 			this.prevSortY = var1.posY;
 			this.prevSortZ = var1.posZ;
@@ -256,7 +274,7 @@
 		}
 
 		int var8;
-		if(this.occlusionEnabled && var2 == 0) {
+		if(occlusion) {
 			int var10 = 8;
 			this.checkOcclusionQueryResult(0, 8);
 
@@ -265,7 +283,7 @@
 				this.sortedWorldRenderers[var6].isVisible = true;
 			}
 
-			var8 = 0 + this.renderSortedRenderers(0, 8, var2);
+			var8 = this.renderSortedRenderers(0, 8, var2);
 
 			do {
 				int var9 = var10;
@@ -305,7 +323,7 @@
 				var8 += this.renderSortedRenderers(var9, var10, var2);
 			} while(var10 < this.sortedWorldRenderers.length);
 		} else {
-			var8 = 0 + this.renderSortedRenderers(0, this.sortedWorldRenderers.length, var2);
+			var8 = this.renderSortedRenderers(0, this.sortedWorldRenderers.length, var2);
 		}
 
 		return var8;
@@ -371,6 +389,10 @@
 	}
 
 	public final void renderSky(float var1) {
+		float px = this.mc.thePlayer.lastTickPosX + (this.mc.thePlayer.posX - this.mc.thePlayer.lastTickPosX) * var1;
+		float py = this.mc.thePlayer.lastTickPosY + (this.mc.thePlayer.posY - this.mc.thePlayer.lastTickPosY) * var1;
+		float pz = this.mc.thePlayer.lastTickPosZ + (this.mc.thePlayer.posZ - this.mc.thePlayer.lastTickPosZ) * var1;
+
 		GL11.glDisable(GL11.GL_TEXTURE_2D);
 		Vec3D var2 = this.worldObj.getSkyColor(var1);
 		float var3 = var2.xCoord;
@@ -389,7 +411,7 @@
 		Tessellator var12 = Tessellator.instance;
 		var12.startDrawingQuads();
 		var12.setColorOpaque_F(var3, var4, var9);
-		var9 = (float)(this.worldObj.height + 10);
+		var9 = (float)(Math.max(py, this.worldObj.height) + 10);
 
 		int var10;
 		for(var10 = -2048; var10 < this.worldObj.width + 2048; var10 += 512) {
@@ -401,16 +423,19 @@
 			}
 		}
 
+		GL11.glPushMatrix();
+		GL11.glTranslatef(px, 0.0F, pz);
 		var12.draw();
+		GL11.glPopMatrix();
 		GL11.glEnable(GL11.GL_TEXTURE_2D);
 		GL11.glDisable(GL11.GL_FOG);
 		GL11.glDisable(GL11.GL_ALPHA_TEST);
 		GL11.glEnable(GL11.GL_BLEND);
 		GL11.glBlendFunc(GL11.GL_ONE, GL11.GL_ONE);
 		GL11.glPushMatrix();
-		var3 = this.worldObj.playerEntity.lastTickPosX + (this.worldObj.playerEntity.posX - this.worldObj.playerEntity.lastTickPosX) * var1;
-		var4 = this.worldObj.playerEntity.lastTickPosY + (this.worldObj.playerEntity.posY - this.worldObj.playerEntity.lastTickPosY) * var1;
-		float var6 = this.worldObj.playerEntity.lastTickPosZ + (this.worldObj.playerEntity.posZ - this.worldObj.playerEntity.lastTickPosZ) * var1;
+		var3 = px;
+		var4 = py;
+		float var6 = pz;
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 		GL11.glTranslatef(var3, var4, var6);
 		GL11.glRotatef(0.0F, 0.0F, 0.0F, 1.0F);
@@ -434,21 +459,44 @@
 		GL11.glColor4f(var9, var9, var9, var9);
 		GL11.glCallList(this.glSkyList);
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+
 		GL11.glEnable(GL11.GL_TEXTURE_2D);
-		GL11.glDisable(GL11.GL_BLEND);
-		GL11.glEnable(GL11.GL_ALPHA_TEST);
-		GL11.glEnable(GL11.GL_FOG);
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glDisable(GL11.GL_DEPTH_TEST);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		GL11.glPopMatrix();
+
+		GL11.glEnable(GL11.GL_FOG);
+		GL11.glEnable(GL11.GL_ALPHA_TEST);
+		GL11.glEnable(GL11.GL_DEPTH_TEST);
+		GL11.glDepthMask(true);
+		GL11.glDisable(GL11.GL_BLEND);
+	}
+
+	public final void renderClouds(float var1) {
+		float px = this.mc.thePlayer.lastTickPosX + (this.mc.thePlayer.posX - this.mc.thePlayer.lastTickPosX) * var1;
+		float py = this.mc.thePlayer.lastTickPosY + (this.mc.thePlayer.posY - this.mc.thePlayer.lastTickPosY) * var1;
+		float pz = this.mc.thePlayer.lastTickPosZ + (this.mc.thePlayer.posZ - this.mc.thePlayer.lastTickPosZ) * var1;
+
+		Tessellator var12 = Tessellator.instance;
+		GL11.glEnable(GL11.GL_FOG);
+		GL11.glEnable(GL11.GL_ALPHA_TEST);
+		GL11.glEnable(GL11.GL_DEPTH_TEST);
 		GL11.glDepthMask(true);
 		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/clouds.png"));
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 		Vec3D var11 = this.worldObj.getCloudColor(var1);
-		var4 = var11.xCoord;
-		var6 = var11.yCoord;
-		var3 = var11.zCoord;
+		float var4 = var11.xCoord;
+		float var6 = var11.yCoord;
+		float var3 = var11.zCoord;
+		Vec3D var11a = this.worldObj.getSkyColor(var1);
+		float a = 0.5F + this.mc.options.renderDistance * 0.25F;
+		float var4a = MathHelper.lerp(var11.xCoord, var11a.xCoord, a);
+		float var6a = MathHelper.lerp(var11.yCoord, var11a.yCoord, a);
+		float var3a = MathHelper.lerp(var11.zCoord, var11a.zCoord, a);
 		float var7;
 		if(this.mc.options.anaglyph) {
-			var9 = (var4 * 30.0F + var6 * 59.0F + var3 * 11.0F) / 100.0F;
+			float var9 = (var4 * 30.0F + var6 * 59.0F + var3 * 11.0F) / 100.0F;
 			var7 = (var4 * 30.0F + var6 * 70.0F) / 100.0F;
 			var3 = (var4 * 30.0F + var3 * 70.0F) / 100.0F;
 			var4 = var9;
@@ -456,33 +504,65 @@
 			var3 = var3;
 		}
 
-		var9 = (float)this.worldObj.cloudHeight;
+		float var9 = (float)this.worldObj.cloudHeight + 0.5F;
+		float var9a = var9 + 64.0F * Math.signum(this.worldObj.cloudHeight + 0.5F);
 		var7 = ((float)this.cloudOffsetX + var1) * (0.5F / 1024.0F) * 0.03F;
 		var12.startDrawingQuads();
-		var12.setColorOpaque_F(var4, var6, var3);
 
 		for(int var8 = -2048; var8 < this.worldObj.width + 2048; var8 += 512) {
-			for(var10 = -2048; var10 < this.worldObj.length + 2048; var10 += 512) {
-				var12.addVertexWithUV((float)var8, var9, (float)(var10 + 512), (float)var8 * (0.5F / 1024.0F) + var7, (float)(var10 + 512) * (0.5F / 1024.0F));
-				var12.addVertexWithUV((float)(var8 + 512), var9, (float)(var10 + 512), (float)(var8 + 512) * (0.5F / 1024.0F) + var7, (float)(var10 + 512) * (0.5F / 1024.0F));
-				var12.addVertexWithUV((float)(var8 + 512), var9, (float)var10, (float)(var8 + 512) * (0.5F / 1024.0F) + var7, (float)var10 * (0.5F / 1024.0F));
-				var12.addVertexWithUV((float)var8, var9, (float)var10, (float)var8 * (0.5F / 1024.0F) + var7, (float)var10 * (0.5F / 1024.0F));
-				var12.addVertexWithUV((float)var8, var9, (float)var10, (float)var8 * (0.5F / 1024.0F) + var7, (float)var10 * (0.5F / 1024.0F));
-				var12.addVertexWithUV((float)(var8 + 512), var9, (float)var10, (float)(var8 + 512) * (0.5F / 1024.0F) + var7, (float)var10 * (0.5F / 1024.0F));
-				var12.addVertexWithUV((float)(var8 + 512), var9, (float)(var10 + 512), (float)(var8 + 512) * (0.5F / 1024.0F) + var7, (float)(var10 + 512) * (0.5F / 1024.0F));
-				var12.addVertexWithUV((float)var8, var9, (float)(var10 + 512), (float)var8 * (0.5F / 1024.0F) + var7, (float)(var10 + 512) * (0.5F / 1024.0F));
+			for(int var10 = -2048; var10 < this.worldObj.length + 2048; var10 += 512) {
+				float scaleTop = 1.0F / 4096.0F;
+				float scaleBottom = 1.0F / 2048.0F;
+
+				float var8f = var8 + px;
+				float var10f = var10 + pz;
+				if (a > 0.0F && this.mc.options.renderDistance < 2) {
+					var12.setColorRGBA_F(var4a, var6a, var3a, 1.0F);
+					var12.addVertexWithUV(var8,       var9a, var10 + 512, (var8f + 0)    * scaleTop + var7 + 0.5F, (var10f + 512)  * scaleTop + 0.5F);
+					var12.addVertexWithUV(var8 + 512, var9a, var10 + 512, (var8f + 512)  * scaleTop + var7 + 0.5F, (var10f + 512)  * scaleTop + 0.5F);
+					var12.addVertexWithUV(var8 + 512, var9a, var10,       (var8f + 512)  * scaleTop + var7 + 0.5F, (var10f + 0)    * scaleTop + 0.5F);
+					var12.addVertexWithUV(var8,       var9a, var10,       (var8f + 0)    * scaleTop + var7 + 0.5F, (var10f + 0)    * scaleTop + 0.5F);
+					var12.addVertexWithUV(var8,       var9a, var10,       (var8f + 0)    * scaleTop + var7 + 0.5F, (var10f + 0)    * scaleTop + 0.5F);
+					var12.addVertexWithUV(var8 + 512, var9a, var10,       (var8f + 512)  * scaleTop + var7 + 0.5F, (var10f + 0)    * scaleTop + 0.5F);
+					var12.addVertexWithUV(var8 + 512, var9a, var10 + 512, (var8f + 512)  * scaleTop + var7 + 0.5F, (var10f + 512)  * scaleTop + 0.5F);
+					var12.addVertexWithUV(var8,       var9a, var10 + 512, (var8f + 0)    * scaleTop + var7 + 0.5F, (var10f + 512)  * scaleTop + 0.5F);
+				}
+
+				var12.setColorRGBA_F(var4, var6, var3, 1.0F);
+				var12.addVertexWithUV(var8,       var9, var10 + 512, (var8f + 0)    * scaleBottom + var7, (var10f + 512)  * scaleBottom);
+				var12.addVertexWithUV(var8 + 512, var9, var10 + 512, (var8f + 512)  * scaleBottom + var7, (var10f + 512)  * scaleBottom);
+				var12.addVertexWithUV(var8 + 512, var9, var10,       (var8f + 512)  * scaleBottom + var7, (var10f + 0)    * scaleBottom);
+				var12.addVertexWithUV(var8,       var9, var10,       (var8f + 0)    * scaleBottom + var7, (var10f + 0)    * scaleBottom);
+				var12.addVertexWithUV(var8,       var9, var10,       (var8f + 0)    * scaleBottom + var7, (var10f + 0)    * scaleBottom);
+				var12.addVertexWithUV(var8 + 512, var9, var10,       (var8f + 512)  * scaleBottom + var7, (var10f + 0)    * scaleBottom);
+				var12.addVertexWithUV(var8 + 512, var9, var10 + 512, (var8f + 512)  * scaleBottom + var7, (var10f + 512)  * scaleBottom);
+				var12.addVertexWithUV(var8,       var9, var10 + 512, (var8f + 0)    * scaleBottom + var7, (var10f + 512)  * scaleBottom);
 			}
 		}
 
+		GL11.glPushMatrix();
+		GL11.glTranslated(px, 0.0F, pz);
 		var12.draw();
+		GL11.glPopMatrix();
+		GL11.glDisable(GL11.GL_BLEND);
 	}
 
 	public final void oobGroundRenderer() {
 		float var1 = this.worldObj.getLightBrightness(0, this.worldObj.getGroundLevel(), 0);
-		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/dirt.png"));
-		if(this.worldObj.getGroundLevel() > this.worldObj.getWaterLevel() && this.worldObj.defaultFluid == Block.waterMoving.blockID) {
-			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/grass.png"));
+		String texture;
+		if (this.worldObj.levelTheme.getSoilBlock() == Block.sand) {
+			texture = "/sand.png";
+		} else {
+			texture = "/dirt.png";
+			if(this.worldObj.getGroundLevel() > this.worldObj.getWaterLevel() && this.worldObj.defaultFluid == Block.waterMoving.blockID) {
+				if (this.worldObj.levelTheme.hasSnow()) {
+					texture = "/snow.png";
+				} else {
+					texture = "/grass.png";
+				}
+			}
 		}
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture(texture));
 
 		GL11.glColor4f(var1, var1, var1, 1.0F);
 		GL11.glEnable(GL11.GL_TEXTURE_2D);
@@ -492,23 +572,30 @@
 	private void oobGroundRenderHeight() {
 		Tessellator var1 = Tessellator.instance;
 		float var2 = (float)this.worldObj.getGroundLevel();
+		if (this.worldObj.levelTheme.hasSnow() && var2 > 0.0F && var2 > this.worldObj.getWaterLevel()) {
+			var2 += Block.snow.maxY;
+		}
+
 		int var3 = 128;
+		int var3a = 128;
 		if(128 > this.worldObj.width) {
 			var3 = this.worldObj.width;
 		}
 
-		if(var3 > this.worldObj.length) {
-			var3 = this.worldObj.length;
+		if(128 > this.worldObj.length) {
+			var3a = this.worldObj.length;
 		}
 
 		int var4 = 2048 / var3;
+		int var4a = 2048 / var3a;
 		var1.startDrawingQuads();
 
 		for(int var5 = -var3 * var4; var5 < this.worldObj.width + var3 * var4; var5 += var3) {
-			for(int var6 = -var3 * var4; var6 < this.worldObj.length + var3 * var4; var6 += var3) {
+			for(int var6 = -var3a * var4a; var6 < this.worldObj.length + var3a * var4a; var6 += var3a) {
+				float f;
 				if(var2 < 0.0F || var5 < 0 || var6 < 0 || var5 >= this.worldObj.width || var6 >= this.worldObj.length) {
-					var1.addVertexWithUV((float)var5, var2, (float)(var6 + var3), 0.0F, (float)var3);
-					var1.addVertexWithUV((float)(var5 + var3), var2, (float)(var6 + var3), (float)var3, (float)var3);
+					var1.addVertexWithUV((float)var5, var2, (float)(var6 + var3a), 0.0F, (float)var3a);
+					var1.addVertexWithUV((float)(var5 + var3), var2, (float)(var6 + var3a), (float)var3, (float)var3a);
 					var1.addVertexWithUV((float)(var5 + var3), var2, (float)var6, (float)var3, 0.0F);
 					var1.addVertexWithUV((float)var5, var2, (float)var6, 0.0F, 0.0F);
 				}
@@ -521,8 +608,18 @@
 	public final void oobWaterRenderer() {
 		GL11.glEnable(GL11.GL_TEXTURE_2D);
 		GL11.glEnable(GL11.GL_BLEND);
-		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/water.png"));
-		float var1 = this.worldObj.getLightBrightness(0, this.worldObj.getWaterLevel(), 0);
+		if (this.worldObj.levelTheme.hasSnow()) {
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/ice.png"));
+		} else if (this.worldObj.defaultFluid == Block.lavaMoving.blockID) {
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/lava.png"));
+		} else {
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/water.png"));
+		}
+
+		float var1 = 1.0F;
+		if (this.worldObj.defaultFluid != Block.lavaMoving.blockID) {
+			var1 = this.worldObj.getLightBrightness(0, this.worldObj.getWaterLevel(), 0);
+		}
 		GL11.glColor4f(var1, var1, var1, 1.0F);
 		GL11.glCallList(this.glGenList + 1);
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
@@ -534,31 +631,33 @@
 		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		Tessellator var2 = Tessellator.instance;
 		int var3 = 128;
+		int var3a = 128;
 		if(128 > this.worldObj.width) {
 			var3 = this.worldObj.width;
 		}
 
-		if(var3 > this.worldObj.length) {
-			var3 = this.worldObj.length;
+		if(128 > this.worldObj.length) {
+			var3a = this.worldObj.length;
 		}
 
 		int var4 = 2048 / var3;
+		int var4a = 2048 / var3a;
 		var2.startDrawingQuads();
 		float var5 = Block.waterMoving.minX;
 		float var6 = Block.waterMoving.minZ;
 
 		for(int var7 = -var3 * var4; var7 < this.worldObj.width + var3 * var4; var7 += var3) {
-			for(int var8 = -var3 * var4; var8 < this.worldObj.length + var3 * var4; var8 += var3) {
-				float var9 = var1 + Block.waterMoving.minY;
+			for(int var8 = -var3a * var4a; var8 < this.worldObj.length + var3a * var4a; var8 += var3a) {
+				float var9 = this.worldObj.levelTheme.hasSnow() ? var1 : var1 - BlockFluid.getFluidHeightPercent(0);
 				if(var1 < 0.0F || var7 < 0 || var8 < 0 || var7 >= this.worldObj.width || var8 >= this.worldObj.length) {
-					var2.addVertexWithUV((float)var7 + var5, var9, (float)(var8 + var3) + var6, 0.0F, (float)var3);
-					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)(var8 + var3) + var6, (float)var3, (float)var3);
-					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)var8 + var6, (float)var3, 0.0F);
-					var2.addVertexWithUV((float)var7 + var5, var9, (float)var8 + var6, 0.0F, 0.0F);
-					var2.addVertexWithUV((float)var7 + var5, var9, (float)var8 + var6, 0.0F, 0.0F);
-					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)var8 + var6, (float)var3, 0.0F);
-					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)(var8 + var3) + var6, (float)var3, (float)var3);
-					var2.addVertexWithUV((float)var7 + var5, var9, (float)(var8 + var3) + var6, 0.0F, (float)var3);
+					var2.addVertexWithUV((float)var7 + var5, var9, (float)(var8 + var3a) + var6, 0.0F, (float)var3a);
+					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)(var8 + var3a) + var6, (float)var3, (float)var3a);
+					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)var8 + var6, (float)var3, 0.0F);
+					var2.addVertexWithUV((float)var7 + var5, var9, (float)var8 + var6, 0.0F, 0.0F);
+					var2.addVertexWithUV((float)var7 + var5, var9, (float)var8 + var6, 0.0F, 0.0F);
+					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)var8 + var6, (float)var3, 0.0F);
+					var2.addVertexWithUV((float)(var7 + var3) + var5, var9, (float)(var8 + var3a) + var6, (float)var3, (float)var3a);
+					var2.addVertexWithUV((float)var7 + var5, var9, (float)(var8 + var3a) + var6, 0.0F, (float)var3a);
 				}
 			}
 		}
@@ -567,22 +666,118 @@
 		GL11.glDisable(GL11.GL_BLEND);
 	}
 
-	public final void updateRenderers(EntityPlayer var1) {
-		Collections.sort(this.worldRenderersToUpdate, new RenderSorter(var1));
-		int var2 = this.worldRenderersToUpdate.size() - 1;
-		int var3 = this.worldRenderersToUpdate.size();
-
-		for(int var4 = 0; var4 < var3; ++var4) {
-			WorldRenderer var5 = (WorldRenderer)this.worldRenderersToUpdate.get(var2 - var4);
-			if(var5.distanceToEntitySquared(var1) > 2500.0F && var4 > 4) {
-				return;
-			}
-
-			this.worldRenderersToUpdate.remove(var5);
-			var5.updateRenderer();
-			var5.needsUpdate = false;
-		}
-
+	public final void oobHorizonRender(float var1) {
+		float dist = HorizonShader.getHorizonDistance();
+		float alpha = 1.0F - MathHelper.sqrt_float(this.mc.options.renderDistance) / MathHelper.sqrt_float(3.0F);
+		if (alpha < 0.1F) {
+			return;
+		}
+
+		String horizonType = this.worldObj.levelType.getHorizonType();
+		if (horizonType == null) {
+			return;
+		}
+
+		if (!HorizonShader.isGl20Supported()) {
+			GL11.glDepthRange(1.0D, 1.0D);
+		}
+
+		float px = this.mc.thePlayer.lastTickPosX + (this.mc.thePlayer.posX - this.mc.thePlayer.lastTickPosX) * var1;
+		float py = this.mc.thePlayer.lastTickPosY + (this.mc.thePlayer.posY - this.mc.thePlayer.lastTickPosY) * var1;
+		float pz = this.mc.thePlayer.lastTickPosZ + (this.mc.thePlayer.posZ - this.mc.thePlayer.lastTickPosZ) * var1;
+		int baseLevel = Math.max(Math.max(this.worldObj.waterLevel, this.worldObj.groundLevel), 0);
+		float opy = Math.abs(py - baseLevel) / (HorizonShader.isGl20Supported() ? this.mc.options.getRenderDistance() / 2.0F : 96.0F);
+		float yOffset = (py - baseLevel) * (1.0F - this.mc.options.getRenderDistance() * dist / 512.0F);
+		if ("floating".equals(horizonType)) {
+			yOffset -= this.mc.options.getRenderDistance() * 0.05F;
+		}
+		Vec3D color = this.worldObj.getSkyColor(var1);
+		GL11.glColor4f(color.xCoord, color.yCoord, color.zCoord, alpha * (1.0F - opy * opy));
+		GL13.glActiveTexture(GL13.GL_TEXTURE1);
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("$$/terrain/horizonmask.png"));
+		GL13.glActiveTexture(GL13.GL_TEXTURE0);
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/horizon/" + horizonType + ".png"));
+		GL11.glPushMatrix();
+		GL11.glTranslatef(px, yOffset, pz);
+		HorizonShader.start();
+		GL11.glCallList(this.glGenList + 2);
+		HorizonShader.stop();
+		GL11.glPopMatrix();
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+
+		if (!HorizonShader.isGl20Supported()) {
+			GL11.glDepthRange(0.0D, 1.0D);
+		}
+	}
+
+	private void oobHorizonRenderHeight() {
+		Tessellator t = Tessellator.instance;
+		t.startDrawingQuads();
+
+		int segments = 32;
+		float pi = (float)Math.PI;
+		float pi2 = pi * 2.0F;
+		// Can't use HorizonShader here because it breaks the shader for some reason
+		float d = this.mc.options.getRenderDistance() * (GLContext.getCapabilities().OpenGL20 ? 0.5F : 0.99F);
+
+		float minY = Math.max(Math.max(this.mc.theWorld.waterLevel, this.mc.theWorld.groundLevel), 0);
+		float maxY = minY + d / pi;
+
+		float[] x = new float[segments];
+		float[] z = new float[segments];
+
+		for (int i = 0; i < segments; i++) {
+			float s = MathHelper.sin(i / (float)segments * pi2);
+			float c = MathHelper.cos(i / (float)segments * pi2);
+			x[i] = d * s;
+			z[i] = d * c;
+		}
+
+		for (int i = 0; i < segments; i++) {
+			float minX = x[i];
+			float minZ = z[i];
+			float maxX = x[(i + 1) % segments];
+			float maxZ = z[(i + 1) % segments];
+
+			t.addVertexWithUV(minX, minY, minZ, (float)-i / segments, 1.0F);
+			t.addVertexWithUV(minX, maxY, minZ, (float)-i / segments, 0.0F);
+			t.addVertexWithUV(maxX, maxY, maxZ, (float)-(i + 1) / segments, 0.0F);
+			t.addVertexWithUV(maxX, minY, maxZ, (float)-(i + 1) / segments, 1.0F);
+		}
+
+		t.draw();
+	}
+
+	public final void updateRenderers(EntityPlayer var1, long var1a, boolean var1b) {
+		if (!this.mc.options.limitFramerate) {
+			Collections.sort(this.worldRenderersToUpdate, new RenderSorter(var1));
+			int var2 = this.worldRenderersToUpdate.size() - 1;
+			int var3 = this.worldRenderersToUpdate.size();
+
+			for(int var4 = 0; var4 < var3; ++var4) {
+				WorldRenderer var5 = (WorldRenderer)this.worldRenderersToUpdate.get(var2 - var4);
+				float wrDist = var5.distanceToEntitySquared(var1);
+				if(wrDist > 2500.0F && var4 > 4) {
+					return;
+				}
+
+				if (var5.isInFrustrum) {
+					this.worldRenderersToUpdate.remove(var5);
+					var5.updateRenderer();
+					var5.needsUpdate = false;
+				}
+			}
+		} else {
+			for (WorldRenderer chunk : this.sortedWorldRenderers) {
+				if (!chunk.needsUpdate || !chunk.isInFrustrum) continue;
+
+				chunk.updateRenderer();
+				chunk.needsUpdate = false;
+				this.worldRenderersToUpdate.remove(chunk);
+
+				if (!var1b && var1a - System.nanoTime() < 0L) break;
+			}
+		}
 	}
 
 	public final void drawBlockBreaking(MovingObjectPosition var1, int var2, ItemStack var3) {
@@ -618,6 +813,8 @@
 	}
 
 	public final void drawSelectionBox(MovingObjectPosition var1, int var2) {
+		if (!this.mc.options.showHUD) return;
+
 		GL11.glEnable(GL11.GL_BLEND);
 		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		GL11.glColor4f(0.0F, 0.0F, 0.0F, 0.4F);
@@ -626,7 +823,7 @@
 		GL11.glDepthMask(false);
 		var2 = this.worldObj.getBlockId(var1.blockX, var1.blockY, var1.blockZ);
 		if(var2 > 0) {
-			AxisAlignedBB var3 = Block.blocksList[var2].getSelectedBoundingBoxFromPool(var1.blockX, var1.blockY, var1.blockZ).expand(0.002F, 0.002F, 0.002F);
+			AxisAlignedBB var3 = Block.blocksList[var2].getSelectedBoundingBoxFromPoolWithWorld(this.worldObj, var1.blockX, var1.blockY, var1.blockZ).expand(0.002F, 0.002F, 0.002F);
 			Tessellator var4 = Tessellator.instance;
 			var4.startDrawing(3);
 			var4.addVertex(var3.minX, var3.minY, var3.minZ);
@@ -660,12 +857,12 @@
 	}
 
 	private void markBlocksForUpdate(int var1, int var2, int var3, int var4, int var5, int var6) {
-		var1 /= 16;
-		var2 /= 16;
-		var3 /= 16;
-		var4 /= 16;
-		var5 /= 16;
-		var6 /= 16;
+		var1 /= chunkSize;
+		var2 /= chunkSize;
+		var3 /= chunkSize;
+		var4 /= chunkSize;
+		var5 /= chunkSize;
+		var6 /= chunkSize;
 		if(var1 < 0) {
 			var1 = 0;
 		}
@@ -714,7 +911,7 @@
 
 	public final void clipRenderersByFrustrum(ICamera var1) {
 		for(int var2 = 0; var2 < this.worldRenderers.length; ++var2) {
-			this.worldRenderers[var2].updateInFrustrum(var1);
+			this.worldRenderers[var2].updateInFrustrum(var1, this.worldObj.playerEntity, this.mc.options.getRenderDistance() + 16);
 		}
 
 	}
@@ -774,5 +971,20 @@
 		GL11.glNewList(this.glGenList + 1, GL11.GL_COMPILE);
 		this.oobWaterRenderHeight();
 		GL11.glEndList();
+
+		for (WorldRenderer wr : this.worldRenderers) {
+			if (!wr.needsUpdate) {
+				wr.needsUpdate = true;
+				this.worldRenderersToUpdate.add(wr);
+			}
+		}
+	}
+
+	public void renderAllRenderers() {
+		for (WorldRenderer wr : (List<WorldRenderer>)this.worldRenderersToUpdate) {
+			wr.updateRenderer();
+			wr.isInFrustrum = true;
+			wr.needsUpdate = false;
+		}
 	}
 }
--- /dev/null
+++ net/minecraft/client/render/HorizonShader.java
@@ -1,0 +1,84 @@
+package net.minecraft.client.render;
+
+import org.lwjgl.opengl.GL20;
+import org.lwjgl.opengl.GLContext;
+
+public class HorizonShader {
+	private static final String fs = String.join("\n",
+			"uniform sampler2D tex, mask;",
+			"void main() {",
+			"   vec4 color = texture2D(tex, gl_TexCoord[0].xy);",
+			"   color *= gl_Color;",
+			"   float alpha = texture2D(mask, gl_TexCoord[0].xy).a;",
+			"   gl_FragColor = vec4(color.xyz, color.a * alpha);",
+			"	gl_FragDepth = 1.0;",
+			"}"
+	);
+	private static final String vs = String.join("\n",
+			"void main() {",
+			"   gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * gl_Vertex;",
+			"   gl_FrontColor = gl_Color;",
+			"   gl_TexCoord[0] = gl_MultiTexCoord0;",
+			"}"
+	);
+
+	private static final boolean GL20_SUPPORTED = GLContext.getCapabilities().OpenGL20;
+	private static final int ID;
+
+	public static boolean isGl20Supported() {
+		return GL20_SUPPORTED;
+	}
+
+	public static float getHorizonDistance() {
+		return GL20_SUPPORTED ? 0.5F : 0.99F;
+	}
+
+	static {
+		if (!GL20_SUPPORTED) {
+			ID = 0;
+		} else {
+			int f = GL20.glCreateShader(GL20.GL_FRAGMENT_SHADER);
+			GL20.glShaderSource(f, fs);
+			GL20.glCompileShader(f);
+			if (GL20.glGetShaderi(f, GL20.GL_COMPILE_STATUS) == 0) {
+				String log = GL20.glGetShaderInfoLog(f, 1000);
+				System.err.println("Fragment failure\n" + log);
+			}
+
+			int v = GL20.glCreateShader(GL20.GL_VERTEX_SHADER);
+			GL20.glShaderSource(v, vs);
+			GL20.glCompileShader(v);
+			if (GL20.glGetShaderi(v, GL20.GL_COMPILE_STATUS) == 0) {
+				String log = GL20.glGetShaderInfoLog(v, 1000);
+				System.err.println("Vertex failure\n" + log);
+			}
+
+			ID = GL20.glCreateProgram();
+			GL20.glAttachShader(ID, f);
+			GL20.glAttachShader(ID, v);
+			GL20.glLinkProgram(ID);
+			if (GL20.glGetProgrami(ID, GL20.GL_LINK_STATUS) == 0) {
+				String log = GL20.glGetProgramInfoLog(ID, 1000);
+				System.err.println("Program failure\n" + log);
+			}
+
+			GL20.glDeleteShader(f);
+			GL20.glDeleteShader(v);
+			GL20.glUseProgram(ID);
+
+			GL20.glUniform1i(GL20.glGetUniformLocation(ID, "tex"), 0);
+			GL20.glUniform1i(GL20.glGetUniformLocation(ID, "mask"), 1);
+			GL20.glUseProgram(0);
+		}
+	}
+
+	public static void start() {
+		if (!GL20_SUPPORTED) return;
+		GL20.glUseProgram(ID);
+	}
+
+	public static void stop() {
+		if (!GL20_SUPPORTED) return;
+		GL20.glUseProgram(0);
+	}
+}
--- net/minecraft/client/sound/SoundManager.java
+++ net/minecraft/client/sound/SoundManager.java
@@ -20,7 +20,7 @@
 
 	public final void loadSoundSettings(GameSettings var1) {
 		this.options = var1;
-		if(!this.loaded && (var1.sound || var1.music)) {
+		if(!this.loaded && (var1.sound > 0.0F || var1.music > 0.0F)) {
 			this.tryToSetLibraryAndCodecs();
 		}
 
@@ -28,10 +28,10 @@
 
 	private void tryToSetLibraryAndCodecs() {
 		try {
-			boolean var1 = this.options.sound;
-			boolean var2 = this.options.music;
-			this.options.sound = false;
-			this.options.music = false;
+			float var1 = this.options.sound;
+			float var2 = this.options.music;
+			this.options.sound = 0.0F;
+			this.options.music = 0.0F;
 			this.options.saveOptions();
 			SoundSystemConfig.addLibrary(LibraryLWJGLOpenAL.class);
 			SoundSystemConfig.setCodec("ogg", CodecJOrbis.class);
@@ -48,14 +48,15 @@
 	}
 
 	public final void onSoundOptionsChanged() {
-		if(!this.loaded && (this.options.sound || this.options.music)) {
+		if (!this.loaded && (this.options.sound > 0.0F || this.options.music > 0.0F)) {
 			this.tryToSetLibraryAndCodecs();
 		}
 
-		if(!this.options.music) {
+		if (this.options.music == 0.0F) {
 			this.sndSystem.stop("BgMusic");
+		} else {
+			this.sndSystem.setVolume("BgMusic", this.options.music);
 		}
-
 	}
 
 	public final void closeMinecraft() {
@@ -74,18 +75,22 @@
 	}
 
 	public final void playRandomMusicIfReady(float var1, float var2, float var3) {
-		if(this.loaded && this.options.music) {
+		if(this.loaded && this.options.music > 0.0F) {
 			if(!this.sndSystem.playing("BgMusic")) {
-				SoundPoolEntry var4 = this.soundPoolMusic.getRandomSoundFromSoundPool("calm");
-				this.sndSystem.newStreamingSource(true, "BgMusic", var4.soundUrl, var4.soundName, false, var1, var2, var3, 2, 32.0F);
-				this.sndSystem.play("BgMusic");
+				SoundPoolEntry var4 = this.soundPoolMusic.getRandomSound();
+				if (var4 != null) {
+					this.sndSystem.backgroundMusic("BgMusic", var4.soundUrl, var4.soundName, false);
+					this.sndSystem.setVolume("BgMusic", var2 * this.options.music);
+					this.sndSystem.setPitch("BgMusic", var3);
+					this.sndSystem.play("BgMusic");
+				}
 			}
 
 		}
 	}
 
 	public final void setListener(EntityLiving var1, float var2) {
-		if(this.loaded && this.options.sound) {
+		if(this.loaded && this.options.sound > 0.0F) {
 			if(var1 != null) {
 				float var3 = var1.prevRotationPitch + (var1.rotationPitch - var1.prevRotationPitch) * var2;
 				float var4 = var1.prevRotationYaw + (var1.rotationYaw - var1.prevRotationYaw) * var2;
@@ -107,7 +112,7 @@
 	}
 
 	public final void playSound(String var1, float var2, float var3, float var4, float var5, float var6) {
-		if(this.loaded && this.options.sound) {
+		if(this.loaded && this.options.sound > 0.0F) {
 			SoundPoolEntry var9 = this.soundPoolSounds.getRandomSoundFromSoundPool(var1);
 			if(var9 != null && var5 > 0.0F) {
 				this.latestSoundID = (this.latestSoundID + 1) % 256;
@@ -123,7 +128,7 @@
 					var5 = 1.0F;
 				}
 
-				this.sndSystem.setVolume(var7, var5);
+				this.sndSystem.setVolume(var7, var5 * this.options.sound);
 				this.sndSystem.play(var7);
 			}
 
@@ -131,14 +136,15 @@
 	}
 
 	public final void playSoundFX(String var1, float var2, float var3) {
-		if(this.loaded && this.options.sound) {
+		if(this.loaded && this.options.sound > 0.0F) {
 			SoundPoolEntry var4 = this.soundPoolSounds.getRandomSoundFromSoundPool(var1);
 			if(var4 != null) {
 				this.latestSoundID = (this.latestSoundID + 1) % 256;
 				String var5 = "sound_" + this.latestSoundID;
 				this.sndSystem.newSource(false, var5, var4.soundUrl, var4.soundName, false, 0.0F, 0.0F, 0.0F, 0, 0.0F);
-				this.sndSystem.setPitch(var5, 1.0F);
-				this.sndSystem.setVolume(var5, 0.25F);
+				var2 *= 0.25F;
+				this.sndSystem.setPitch(var5, var3);
+				this.sndSystem.setVolume(var5, var2 * this.options.sound);
 				this.sndSystem.play(var5);
 			}
 
--- net/minecraft/client/gui/GuiIngameMenu.java
+++ net/minecraft/client/gui/GuiIngameMenu.java
@@ -1,18 +1,30 @@
 package net.minecraft.client.gui;
 
+import net.minecraft.client.ThreadSaveLevel;
+
+import java.io.IOException;
+
 public final class GuiIngameMenu extends GuiScreen {
+	private int updateCounter;
+
 	public final void initGui() {
 		this.controlList.clear();
-		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4, "Options..."));
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 24, "Generate new level..."));
-		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 48, "Save level.."));
-		this.controlList.add(new GuiButton(3, this.width / 2 - 100, this.height / 4 + 72, "Load level.."));
-		this.controlList.add(new GuiButton(4, this.width / 2 - 100, this.height / 4 + 120, "Back to game"));
-		if(this.mc.session == null) {
-			((GuiButton)this.controlList.get(2)).enabled = false;
-			((GuiButton)this.controlList.get(3)).enabled = false;
+		if (this.mc.theWorld != null) {
+			this.controlList.add(new GuiButton(4, this.width / 2 - 100, this.height / 4 + 12, "Back to game"));
+			this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 84, "Options..."));
+			this.controlList.add(new GuiButton(6, this.width / 2 - 100, this.height / 4 + 108,
+					this.mc.worldSaveLocation == null ? "Quit to title" : "Save and quit to title"));
+			if (!this.mc.adventureMode && this.mc.worldSaveLocation == null) {
+				this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 36, "Save level..."));
+			}
+		} else if (false) {
+			this.controlList.add(new GuiButton(4, this.width / 2 - 100, this.height / 4 + 12, "Back to game"));
+			this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 36, 98, 20, "Save level..."));
+			this.controlList.add(new GuiButton(3, this.width / 2 + 2, this.height / 4 + 36, 98, 20, "Load level..."));
+			this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 84, 98, 20, "Options..."));
+			this.controlList.add(new GuiButton(1, this.width / 2 + 2, this.height / 4 + 84, 98, 20, "New level..."));
+			this.controlList.add(new GuiButton(6, this.width / 2 - 100, this.height / 4 + 108, "Quit to title"));
 		}
-
 	}
 
 	protected final void actionPerformed(GuiButton var1) {
@@ -24,14 +36,17 @@
 			this.mc.displayGuiScreen(new GuiNewLevel(this));
 		}
 
-		if(this.mc.session != null) {
-			if(var1.id == 2) {
-				this.mc.displayGuiScreen(new GuiSaveLevel(this));
-			}
+		if(var1.id == 2) {
+			this.mc.displayGuiScreen(new GuiTextPrompt(null, "Enter level name", path -> {
+				this.mc.saveLevel(path);
+				if (this.mc.worldSaveLocation != null) {
+					this.mc.ingameGUI.sendChatMessage("&aSaved as &e\"" + path + "\"&a!");
+				}
+			}));
+		}
 
-			if(var1.id == 3) {
-				this.mc.displayGuiScreen(new GuiLoadLevel(this));
-			}
+		if(var1.id == 3) {
+			this.mc.displayGuiScreen(new GuiTextPrompt(this, "Enter level name", this.mc::loadLevel));
 		}
 
 		if(var1.id == 4) {
@@ -39,6 +54,34 @@
 			this.mc.setIngameFocus();
 		}
 
+		if(var1.id == 5) {
+			this.mc.displayGuiScreen(new GuiDeleteWorld(this));
+		}
+
+		if(var1.id == 6) {
+			if (this.mc.adventureMode && !ThreadSaveLevel.isBusy()) {
+				try {
+					this.mc.saveWorld(true);
+				} catch (IOException e) {
+				}
+			}
+			this.mc.setLevel(null);
+			this.mc.displayGuiScreen(null);
+		}
+
+	}
+
+	public void updateScreen() {
+		if (++this.updateCounter == 1 && this.mc.worldSaveLocation != null && !ThreadSaveLevel.isBusy()) {
+			try {
+				if (this.mc.adventureMode) {
+					this.mc.saveWorld(false);
+				} else {
+					this.mc.saveCurrentLevel(false);
+				}
+			} catch (IOException e) {
+			}
+		}
 	}
 
 	public final void drawScreen(int var1, int var2, float var3) {
--- net/minecraft/game/item/recipe/CraftingManager.java
+++ net/minecraft/game/item/recipe/CraftingManager.java
@@ -20,24 +20,60 @@
 		(new RecipesTools()).addRecipes(this);
 		(new RecipesWeapons()).addRecipes(this);
 		(new RecipesIngots()).addRecipes(this);
-		new RecipesFood();
-		this.addRecipe(new ItemStack(Item.bowlSoup), new Object[]{"Y", "X", "#", Character.valueOf('X'), Block.mushroomBrown, Character.valueOf('Y'), Block.mushroomRed, Character.valueOf('#'), Item.bowlEmpty});
-		this.addRecipe(new ItemStack(Item.bowlSoup), new Object[]{"Y", "X", "#", Character.valueOf('X'), Block.mushroomRed, Character.valueOf('Y'), Block.mushroomBrown, Character.valueOf('#'), Item.bowlEmpty});
-		new RecipesCrafting();
-		this.addRecipe(new ItemStack(Block.crate), new Object[]{"###", "# #", "###", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Block.stoneOvenIdle), new Object[]{"###", "# #", "###", Character.valueOf('#'), Block.cobblestone});
-		this.addRecipe(new ItemStack(Block.workbench), new Object[]{"##", "##", Character.valueOf('#'), Block.planks});
+		(new RecipesMechanics()).addRecipes(this);
+		this.addRecipe(new ItemStack(Item.bucketEmpty, 1), "# #", " # ", '#', Item.ingotIron);
+		this.addRecipe(new ItemStack(Item.bowlSoup), "Y", "X", "#", 'X', Block.mushroomBrown, 'Y', Block.mushroomRed, '#', Item.bowlEmpty);
+		this.addRecipe(new ItemStack(Item.bowlSoup), "Y", "X", "#", 'X', Block.mushroomRed, 'Y', Block.mushroomBrown, '#', Item.bowlEmpty);
+		this.addRecipe(new ItemStack(Block.crate), "###", "# #", "###", '#', Block.planks);
+		this.addRecipe(new ItemStack(Block.stoneOvenIdle), "###", "# #", "###", '#', Block.cobblestone);
+		this.addRecipe(new ItemStack(Block.workbench), "##", "##", '#', Block.planks);
+		this.addRecipe(new ItemStack(Item.doorWood, 3), "##", "##", "##", '#', Block.planks);
+		this.addRecipe(new ItemStack(Item.doorSteel, 3), "##", "##", "##", '#', Item.ingotIron);
 		(new RecipesArmor()).addRecipes(this);
-		this.addRecipe(new ItemStack(Block.clothGray, 1), new Object[]{"###", "###", "###", Character.valueOf('#'), Item.silk});
-		this.addRecipe(new ItemStack(Block.tnt, 1), new Object[]{"X#X", "#X#", "X#X", Character.valueOf('X'), Item.gunpowder, Character.valueOf('#'), Block.sand});
-		this.addRecipe(new ItemStack(Block.stairSingle, 3), new Object[]{"###", Character.valueOf('#'), Block.cobblestone});
-		this.addRecipe(new ItemStack(Block.planks, 4), new Object[]{"#", Character.valueOf('#'), Block.wood});
-		this.addRecipe(new ItemStack(Item.stick, 4), new Object[]{"#", "#", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Block.torch, 4), new Object[]{"X", "#", Character.valueOf('X'), Item.coal, Character.valueOf('#'), Item.stick});
-		this.addRecipe(new ItemStack(Item.bowlEmpty, 4), new Object[]{"# #", " # ", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Item.striker, 1), new Object[]{"A ", " B", Character.valueOf('A'), Item.ingotIron, Character.valueOf('B'), Item.flint});
-		this.addRecipe(new ItemStack(Item.bread, 1), new Object[]{"###", Character.valueOf('#'), Item.wheat});
-		this.addRecipe(new ItemStack(Item.painting, 1), new Object[]{"###", "#X#", "###", Character.valueOf('#'), Block.planks, Character.valueOf('X'), Block.clothGray});
+		this.addRecipe(new ItemStack(Block.clothWhite, 1), "##", "##", '#', Item.silk);
+		this.addRecipe(new ItemStack(Block.tnt, 1), "X#X", "#X#", "X#X", 'X', Item.gunpowder, '#', Block.sand);
+		this.addRecipe(new ItemStack(Block.stairSingle, 6), "###", '#', Block.cobblestone);
+		this.addRecipe(new ItemStack(Block.woodStairSingle, 6), "###", '#', Block.planks);
+		this.addRecipe(new ItemStack(Block.planks, 4), "#", '#', Block.wood);
+		this.addRecipe(new ItemStack(Item.stick, 4), "#", "#", '#', Block.planks);
+		this.addRecipe(new ItemStack(Block.torch, 4), "X", "#", 'X', Item.coal, '#', Item.stick);
+		this.addRecipe(new ItemStack(Item.bowlEmpty, 4), "# #", " # ", '#', Block.planks);
+		this.addRecipe(new ItemStack(Item.striker, 1), "A ", " B", 'A', Item.ingotIron, 'B', Item.flint);
+		this.addRecipe(new ItemStack(Item.bread, 1), "###", '#', Item.wheat);
+		this.addRecipe(new ItemStack(Item.painting, 1), "###", "#X#", "###", '#', Block.planks, 'X', Block.clothWhite);
+		this.addRecipe(new ItemStack(Block.blockSnow, 1), "##", "##", '#', Item.snowball);
+		this.addRecipe(new ItemStack(Block.clay, 1), "##", "##", '#', Item.clay);
+		this.addRecipe(new ItemStack(Item.clay, 4), "#", '#', Block.clay);
+		this.addRecipe(new ItemStack(Block.brick, 1), "##", "##", '#', Item.brick);
+		this.addRecipe(new ItemStack(Block.brownMushroomBlock.blockID, 1, 14), "##", "##", '#', Block.mushroomBrown);
+		this.addRecipe(new ItemStack(Block.redMushroomBlock.blockID, 1, 14), "##", "##", '#', Block.mushroomRed);
+
+		for (int i = 0; i < 15; i++) {
+			this.addRecipe(new ItemStack(Block.clothRed.blockID + i, 8), "###", "#X#", "###", '#', Block.clothWhite, 'X', Item.itemsList[Item.dyeRed.shiftedIndex + i]);
+			this.addRecipe(new ItemStack(Block.clothWhite.blockID, 8), "###", "#X#", "###", '#', Block.blocksList[Block.clothRed.blockID + i], 'X', Item.dyeWhite);
+		}
+
+		this.addRecipe(new ItemStack(Item.dyeRed, 1), "X", 'X', Block.plantRed);
+		this.addRecipe(new ItemStack(Item.dyeYellow, 1), "X", 'X', Block.plantYellow);
+		this.addRecipe(new ItemStack(Item.dyeCapri, 1), "X", 'X', Block.plantBlue);
+		this.addRecipe(new ItemStack(Item.dyeWhite, 1), "X", 'X', Block.mushroomRed);
+		this.addRecipe(new ItemStack(Item.dyeWhite, 1), "X", 'X', Block.mushroomBrown);
+		this.addRecipe(new ItemStack(Item.dyeDarkGray, 1), "X", 'X', Item.coal);
+
+		for (String order : new String[] { "AB", "BA" }) {
+			this.addRecipe(new ItemStack(Item.dyeOrange, 2), order, 'A', Item.dyeRed, 'B', Item.dyeYellow);
+			this.addRecipe(new ItemStack(Item.dyeYellow, 2), order, 'A', Item.dyeRed, 'B', Item.dyeGreen);
+			this.addRecipe(new ItemStack(Item.dyeChartreuse, 2), order, 'A', Item.dyeYellow, 'B', Item.dyeGreen);
+			this.addRecipe(new ItemStack(Item.dyeGreen, 2), order, 'A', Item.dyeYellow, 'B', Item.dyeCyan);
+			this.addRecipe(new ItemStack(Item.dyeSpringGreen, 2), order, 'A', Item.dyeGreen, 'B', Item.dyeCyan);
+			this.addRecipe(new ItemStack(Item.dyeCyan, 2), order, 'A', Item.dyeYellow, 'B', Item.dyeCapri);
+			this.addRecipe(new ItemStack(Item.dyeUltramarine, 2), order, 'A', Item.dyeCapri, 'B', Item.dyeViolet);
+			this.addRecipe(new ItemStack(Item.dyeViolet, 2), order, 'A', Item.dyeCapri, 'B', Item.dyeRed);
+			this.addRecipe(new ItemStack(Item.dyeRose, 2), order, 'A', Item.dyeMagenta, 'B', Item.dyeRed);
+			this.addRecipe(new ItemStack(Item.dyeGray, 2), order, 'A', Item.dyeWhite, 'B', Item.dyeDarkGray);
+			this.addRecipe(new ItemStack(Item.dyeMagenta, 2), order, 'A', Item.dyeViolet, 'B', Item.dyeRed);
+			this.addRecipe(new ItemStack(Item.dyePurple, 2), order, 'A', Item.dyeViolet, 'B', Item.dyeMagenta);
+		}
 		Collections.sort(this.recipes, new RecipeSorter(this));
 		System.out.println(this.recipes.size() + " recipes");
 	}
@@ -77,15 +113,15 @@
 				var15 = ((Block)var2[var4 + 1]).blockID;
 			}
 
-			var12.put(var13, Integer.valueOf(var15));
+			var12.put(var13, var15);
 		}
 
 		int[] var14 = new int[var5 * var6];
 
 		for(var15 = 0; var15 < var5 * var6; ++var15) {
 			char var10 = var3.charAt(var15);
-			if(var12.containsKey(Character.valueOf(var10))) {
-				var14[var15] = ((Integer)var12.get(Character.valueOf(var10))).intValue();
+			if(var12.containsKey(var10)) {
+				var14[var15] = ((Integer)var12.get(var10)).intValue();
 			} else {
 				var14[var15] = -1;
 			}
@@ -103,5 +139,17 @@
 		}
 
 		return null;
+	}
+
+	public ItemStack[] getRecipeAsItems(int i) {
+		CraftingRecipe recipe = (CraftingRecipe)recipes.get(i);
+		if (recipe == null) {
+			return null;
+		}
+		return recipe.asItemStacks();
+	}
+
+	public int count() {
+		return this.recipes.size();
 	}
 }
--- net/minecraft/client/controller/PlayerControllerCreative.java
+++ net/minecraft/client/controller/PlayerControllerCreative.java
@@ -2,17 +2,18 @@
 
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.Session;
+import net.minecraft.client.sound.SoundManager;
 import net.minecraft.game.entity.player.EntityPlayer;
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.level.MobSpawner;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.block.StepSound;
 
 public final class PlayerControllerCreative extends PlayerController {
-	private MobSpawner mobSpawner;
-
-	private PlayerControllerCreative(Minecraft var1) {
+	public PlayerControllerCreative(Minecraft var1) {
 		super(var1);
+		this.isInTestMode = true;
 	}
 
 	public final void onRespawn(EntityPlayer var1) {
@@ -33,10 +34,5 @@
 	public final void onWorldChange(World var1) {
 		super.onWorldChange(var1);
 		var1.survivalWorld = false;
-		this.mobSpawner = new MobSpawner(var1);
-	}
-
-	public final void onUpdate() {
-		this.mobSpawner.performSpawning();
 	}
 }
--- /dev/null
+++ net/minecraft/client/GameWindowListener.java
@@ -1,0 +1,26 @@
+package net.minecraft.client;
+
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+
+public final class GameWindowListener extends WindowAdapter {
+	final Minecraft mc;
+	final Thread thread;
+
+	public GameWindowListener(Minecraft var1, Thread var2) {
+		this.mc = var1;
+		this.thread = var2;
+	}
+
+	public void windowClosing(WindowEvent var1) {
+		this.mc.shutdown();
+
+		try {
+			this.thread.join();
+		} catch (InterruptedException var3) {
+			var3.printStackTrace();
+		}
+
+		System.exit(0);
+	}
+}
--- net/minecraft/game/level/block/BlockGrass.java
+++ net/minecraft/game/level/block/BlockGrass.java
@@ -5,12 +5,23 @@
 import net.minecraft.game.level.material.Material;
 
 public final class BlockGrass extends Block {
-	protected BlockGrass(int var1) {
+	public BlockGrass(int var1) {
 		super(2, Material.ground);
 		this.blockIndexInTexture = 3;
 		this.setTickOnLoad(true);
 	}
 
+	@Override
+	public int getBlockTexture(World var1, int var2, int var3, int var4, int var5) {
+		if (var5 > 1) {
+			Material material = var1.getBlockMaterial(var2, var3 + 1, var4);
+			if (material == Material.snow || material == Material.craftedSnow) {
+				return 97;
+			}
+		}
+		return super.getBlockTexture(var1, var2, var3, var4, var5);
+	}
+
 	public final int getBlockTextureFromSide(int var1) {
 		return var1 == 1 ? 0 : (var1 == 0 ? 2 : 3);
 	}
@@ -34,6 +45,9 @@
 	}
 
 	public final int idDropped(int var1, Random var2) {
+		if ((var1 & DROP_FLAG_SILK_TOUCH) != 0) {
+			return super.idDropped(var1, var2);
+		}
 		return Block.dirt.idDropped(0, var2);
 	}
 }
--- net/minecraft/client/render/entity/RenderManager.java
+++ net/minecraft/client/render/entity/RenderManager.java
@@ -82,6 +82,10 @@
 	}
 
 	public final void renderEntity(Entity var1, float var2) {
+		if (var1.notUpdating) {
+			var2 = 1.0F;
+		}
+
 		float var3 = var1.lastTickPosX + (var1.posX - var1.lastTickPosX) * var2;
 		float var4 = var1.lastTickPosY + (var1.posY - var1.lastTickPosY) * var2;
 		float var5 = var1.lastTickPosZ + (var1.posZ - var1.lastTickPosZ) * var2;
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageShafting.java
@@ -1,0 +1,252 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.level.block.Block;
+
+import java.util.*;
+
+public class StageShafting extends TerrainGenStage {
+	public StageShafting() {
+		super("Shafting..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			// Strips (Tunnels along Z)
+			int stripCount = blocks.width * blocks.length * blocks.height / 5000;
+			Set<Tunnel> strips = new TreeSet<>(Comparator.comparingInt(strip -> strip.z));
+			for (int i = 0; i < stripCount; i++) {
+				Tunnel newStrip = null;
+				boolean stripSuitable = false;
+				while (!stripSuitable) {
+					int x = rand.nextInt(world.width - 2) + 1;
+					int y = rand.nextInt(world.groundLevel - 8) + 4;
+					int z = rand.nextInt(world.length - 2) + 1;
+					int length = rand.nextInt(100 - 16) + 16;
+					final Tunnel finalStrip = newStrip = new Tunnel(x, y, z, length);
+					stripSuitable = strips.stream().noneMatch(strip -> strip.stripDistance(finalStrip) < 6);
+				};
+				strips.add(newStrip);
+			}
+
+			// Branches (Tunnels along X)
+			Set<Tunnel> branches = new HashSet<>();
+			Tunnel stripToConnect = null;
+			for (Tunnel strip : strips) {
+				if (stripToConnect == null) {
+					stripToConnect = strip;
+				} else {
+					Tunnel stripA = stripToConnect;
+					Tunnel stripB = strip;
+
+					if (stripA.x > stripB.x) {
+						Tunnel swap = stripA;
+						stripA = stripB;
+						stripB = swap;
+					}
+
+					int length = stripB.x - stripA.x;
+					int skew = stripB.y - stripA.y;
+
+					int minZ = Math.max(stripA.z, stripB.z);
+					int maxZ = Math.min(stripA.z + stripA.length, stripB.z + stripB.length);
+					if (minZ > maxZ) {
+						int swap = minZ;
+						minZ = maxZ;
+						maxZ = swap;
+					}
+
+					if (maxZ - minZ < stripA.length) {
+						minZ = stripA.z;
+						maxZ = stripA.z + stripA.length;
+					}
+
+					int branchCount = rand.nextInt(2);
+					for (int i = 0; i < branchCount; i++) {
+						int x = stripA.x;
+						int y = stripA.y;
+						int z = rand.nextInt(maxZ - minZ) + minZ;
+						branches.add(new Tunnel(x, y, z, length, skew));
+					}
+
+					stripToConnect = null;
+				}
+			}
+
+			// Shafts (Tunnels along Y)
+			Set<Tunnel> shafts = new HashSet<>();
+			for (Tunnel strip : strips) {
+				int shaftCount = rand.nextInt(5) - 3;
+				int x = strip.x;
+				int y = strip.y + 2;
+				for (int i = 0; i < shaftCount; i++) {
+					int z = strip.z + rand.nextInt(strip.length);
+					shafts.add(new Tunnel(x, y, z));
+				}
+			}
+
+			// Place shafts
+			for (Tunnel shaft : shafts) {
+				int sx = shaft.x;
+				int sz = shaft.z;
+				int y;
+				for (y = shaft.y; y < blocks.height && blocks.get(shaft.x, y, shaft.z) != 0; y++) {
+					if (rand.nextInt(5) == 0) {
+						sx += rand.nextInt(3) - 1;
+						sz += rand.nextInt(3) - 1;
+					}
+
+					boolean beam = (y - shaft.y) % 2 == 0;
+					for (int x = sx - 2; x <= sx + 2; x++) {
+						for (int z = sz - 2; z <= sz + 2; z++) {
+							if (x < sx - 1 || x > sx + 1 || z < sz - 1 || z > sz + 1) {
+								int block = Block.planks.blockID;
+								if (((x - sx + 2) + (z - sz + 2)) % 2 == 0) {
+									block = Block.wood.blockID;
+								} else if (beam) {
+									block = Block.cobblestone.blockID;
+								}
+								blocks.set(x, y, z, block);
+							} else {
+								blocks.set(x, y, z, 0);
+							}
+						}
+					}
+				}
+
+				// Entrance hut
+				for (int oy = 0; oy < 7; oy++) {
+					if (oy < 3) {
+						blocks.set(sx - 2, y + oy, sz - 2, Block.wood.blockID);
+						blocks.set(sx - 2, y + oy, sz + 2, Block.wood.blockID);
+						blocks.set(sx + 2, y + oy, sz - 2, Block.wood.blockID);
+						blocks.set(sx + 2, y + oy, sz + 2, Block.wood.blockID);
+					} else {
+						int range = 6 - oy;
+						for (int ox = -range; ox <= range; ox++) {
+							for (int oz = -range; oz <= range; oz++) {
+								int x = sx + ox;
+								int z = sz + oz;
+								blocks.set(x, y + oy, z, Block.stairDouble.blockID);
+							}
+						}
+					}
+				}
+			}
+
+			// Place branches
+			for (Tunnel branch : branches) {
+				for (int x = branch.x; x < branch.x + branch.length; x++) {
+					int skewedY = branch.y + (x - branch.x) * branch.skew / branch.length;
+
+					for (int z = branch.z - 2; z <= branch.z + 2; z++) {
+						for (int y = skewedY - 2; y <= skewedY + 2; y++) {
+							boolean beam = (x - branch.x) % 3 == 2;
+							if (z == branch.z - 2 || z == branch.z + 2) {
+								if (beam) {
+									blocks.set(x, y, z, Block.wood.blockID);
+								} else if (y == skewedY && blocks.get(x, y, z) == Block.stone.blockID) {
+									blocks.set(x, y, z, Block.cobblestone.blockID);
+								}
+							} else if (y == skewedY - 2 || y == skewedY + 2) {
+								if (beam) {
+									blocks.set(x, y, z, Block.planks.blockID);
+								} else if ((z == branch.z - 1 || z == branch.z + 1) && blocks.get(x, y, z) == Block.stone.blockID) {
+									blocks.set(x, y, z, Block.cobblestone.blockID);
+								}
+							} else {
+								blocks.set(x, y, z, 0);
+							}
+						}
+					}
+
+					if (rand.nextInt(200) == 0) {
+						chestPlacer.placeChest(x, skewedY - 1, branch.z - 1 + rand.nextInt(2) * 2);
+					}
+				}
+			}
+
+			// Place strips
+			for (Tunnel strip : strips) {
+				for (int z = strip.z; z < strip.z + strip.length; z++) {
+					for (int x = strip.x - 2; x <= strip.x + 2; x++) {
+						for (int y = strip.y - 2; y <= strip.y + 2; y++) {
+							boolean beam = (z - strip.z) % 3 == 2;
+							if (x == strip.x - 2 || x == strip.x + 2) {
+								if (beam) {
+									blocks.set(x, y, z, Block.wood.blockID);
+								} else if (y == strip.y && blocks.get(x, y, z) == Block.stone.blockID) {
+									blocks.set(x, y, z, Block.cobblestone.blockID);
+								}
+							} else if (y == strip.y - 2 || y == strip.y + 2) {
+								if (beam) {
+									blocks.set(x, y, z, Block.planks.blockID);
+								} else if ((x == strip.x - 1 || x == strip.x + 1) && blocks.get(x, y, z) == Block.stone.blockID) {
+									blocks.set(x, y, z, Block.cobblestone.blockID);
+								}
+							} else {
+								blocks.set(x, y, z, 0);
+							}
+						}
+					}
+
+					if (rand.nextInt(300) == 0) {
+						chestPlacer.placeChest(strip.x - 1 + rand.nextInt(2) * 2, strip.y - 1, z);
+					}
+				}
+			}
+		});
+
+		this.setChestSlots(3, 10);
+		for (int i = 0; i < 3; i++) {
+			this.addChestItem(new ChestItem(Item.pickaxeStone.shiftedIndex, 1, true));
+			this.addChestItem(new ChestItem(Item.pickaxeSteel.shiftedIndex, 1, true));
+			this.addChestItem(new ChestItem(Item.pickaxeStone.shiftedIndex, 1, true));
+			this.addChestItem(new ChestItem(Block.torch.blockID, 16));
+			this.addChestItem(new ChestItem(Block.torch.blockID, 16));
+			this.addChestItem(new ChestItem(Block.torch.blockID, 16));
+			this.addChestItem(new ChestItem(Item.wheat.shiftedIndex, 16));
+			this.addChestItem(new ChestItem(Item.coal.shiftedIndex, 16));
+			this.addChestItem(new ChestItem(Item.coal.shiftedIndex, 16));
+			this.addChestItem(new ChestItem(Item.ingotIron.shiftedIndex, 8));
+			if (i == 1) {
+				this.addChestItem(new ChestItem(Item.diamond.shiftedIndex, 3));
+			}
+		}
+	}
+
+	private static class Tunnel { // Tunnel object
+		final int x, y, z;
+		final int length;
+		final int skew;
+
+		Tunnel(int x, int y, int z) {
+			this(x, y, z, 0, 0);
+		}
+
+		Tunnel(int x, int y, int z, int length) {
+			this(x, y, z, length, 0);
+		}
+
+		Tunnel(int x, int y, int z, int length, int skew) {
+			this.x = x;
+			this.y = y;
+			this.z = z;
+			this.length = length;
+			this.skew = skew;
+		}
+
+		int stripDistance(Tunnel strip) {
+			return Math.abs(this.x - strip.x) + Math.abs(this.y - strip.y);
+		}
+
+		@Override
+		public boolean equals(Object o) {
+			if (this == o) return true;
+			if (o == null || getClass() != o.getClass()) return false;
+			Tunnel tunnel = (Tunnel) o;
+			return x == tunnel.x && y == tunnel.y && z == tunnel.z && length == tunnel.length;
+		}
+
+		@Override
+		public int hashCode() {
+			return Objects.hash(x, y, z, length);
+		}
+	}
+}
--- net/minecraft/game/level/generator/noise/NoiseGeneratorOctaves.java
+++ net/minecraft/game/level/generator/noise/NoiseGeneratorOctaves.java
@@ -5,6 +5,7 @@
 public final class NoiseGeneratorOctaves extends NoiseGenerator {
 	private NoiseGeneratorPerlin[] generatorCollection;
 	private int octaves;
+	private double totFreq = 0.5D;
 
 	public NoiseGeneratorOctaves(Random var1, int var2) {
 		this.octaves = var2;
@@ -12,11 +13,12 @@
 
 		for(int var3 = 0; var3 < var2; ++var3) {
 			this.generatorCollection[var3] = new NoiseGeneratorPerlin(var1);
+			this.totFreq *= 2.0D;
 		}
 
 	}
 
-	public final double generateNoise(double var1, double var3) {
+	public double generateNoise(double var1, double var3) {
 		double var5 = 0.0D;
 		double var7 = 1.0D;
 
@@ -26,5 +28,25 @@
 		}
 
 		return var5;
+	}
+
+	public double generateNoise(double var1, double var3, double var5) {
+		double var7 = 0.0D;
+		double var9 = 1.0D;
+
+		for(int var11 = 0; var11 < this.octaves; ++var11) {
+			var7 += this.generatorCollection[var11].generateNoise(var1 / var9, var3 / var9, var5 / var9) * var9;
+			var9 *= 2.0D;
+		}
+
+		return var7;
+	}
+
+	public double generateNoiseNormalized(double var1, double var3) {
+		return this.generateNoise(var1, var3) / this.totFreq;
+	}
+
+	public double generateNoiseNormalized(double var1, double var3, double var5) {
+		return this.generateNoise(var1, var3, var5) / this.totFreq;
 	}
 }
--- net/minecraft/game/level/MobSpawner.java
+++ net/minecraft/game/level/MobSpawner.java
@@ -19,10 +19,9 @@
 	}
 
 	public final void performSpawning() {
-		int var1 = this.worldObj.width * this.worldObj.length * this.worldObj.height * 20 / 64 / 64 / 64;
-		var1 /= 2;
+		int var1 = this.worldObj.width * this.worldObj.length * this.worldObj.height / 26214;
 		if(this.worldObj.difficultySetting == 0) {
-			var1 = 0 / 4;
+			var1 = 0;
 		}
 
 		if(this.worldObj.difficultySetting == 1) {
@@ -30,11 +29,11 @@
 		}
 
 		if(this.worldObj.difficultySetting == 2) {
-			var1 = (var1 << 2) / 4;
+			var1 = var1 * 2;
 		}
 
 		if(this.worldObj.difficultySetting == 3) {
-			var1 = var1 * 6 / 4;
+			var1 = var1 / 2 * 3;
 		}
 
 		int var2 = this.worldObj.width * this.worldObj.length / 4000;
--- /dev/null
+++ net/minecraft/game/level/block/BlockLogicGate.java
@@ -1,0 +1,89 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.entity.player.EntityPlayer;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+import java.util.function.Predicate;
+
+public class BlockLogicGate extends Block {
+	private static final List<Boolean> lampList = new ArrayList<>();
+
+	public BlockLogicGate(int var1) {
+		super(var1, 84, Material.iron);
+	}
+
+	public int tickRate() {
+		return 0;
+	}
+
+	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
+		if (var5 == 1) {
+			int dir = Math.floorMod(Math.floorDiv((int)var1.playerEntity.rotationYaw - 45, 90), 4);
+			var5 = dir == 0 ? 5 : dir == 1 ? 3 : dir == 2 ? 4 : dir == 3 ? 2 : 2 + var1.random.nextInt(4);
+		}
+		var1.setBlockMetadata(var2, var3, var4, var5);
+	}
+
+	public int getBlockTextureFromSide(int var1) {
+		return var1 == 0 ? 84 : var1 == 1 ? 53 : var1 == 3 ? 118 : 121;
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
+		return var1 == (var2 & 7) ? 118 : var1 == 0 ? 84 : var1 == 1 ? 53 : 121 + (var2 >>> 3 & 7);
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		lampList.clear();
+		int y = var3 + 1;
+		int b;
+		while (var3 < var1.height && ((b = var1.getBlockId(var2, y, var4)) == Block.lampInactive.blockID || b == Block.lampActive.blockID)) {
+			lampList.add(b == Block.lampActive.blockID);
+			y++;
+		}
+
+		if (!lampList.isEmpty()) {
+			int meta = var1.getBlockMetadata(var2, var3, var4);
+			int dir = meta & 7;
+			int mode = (meta >>> 3) & 3;
+			boolean prevCondition = (meta & 128) != 0;
+
+			boolean condition = false;
+			switch (mode) {
+				case 0: condition = !lampList.contains(false); break;
+				case 1: condition = lampList.contains(true); break;
+				case 2: {
+					boolean i = false;
+					for (boolean lamp : lampList) {
+						if (lamp) {
+							condition = true;
+							if (i) {
+								condition = false;
+								break;
+							}
+							i = true;
+						}
+					}
+				}
+			}
+
+			if (prevCondition != condition) {
+				var1.setBlockMetadata(var2, var3, var4, (meta & 127) | (condition ? 128 : 0));
+				var1.transmitPowerInDirection(var2, var3, var4, dir);
+			}
+		}
+	}
+
+	public boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+		int dir = var1.getBlockMetadata(var2, var3, var4) & 7;
+		int mode = (var1.getBlockMetadata(var2, var3, var4) >>> 3) & 7;
+		boolean active = (var1.getBlockMetadata(var2, var3, var4) & 128) != 0;
+		mode = (mode + 1) % 3;
+		var1.setBlockMetadata(var2, var3, var4, dir | mode << 3 | (active ? 128 : 0));
+		this.updateTick(var1, var2, var3, var4, var1.random);
+		return true;
+	}
+}
--- net/minecraft/client/player/MovementInputFromOptions.java
+++ net/minecraft/client/player/MovementInputFromOptions.java
@@ -11,31 +11,12 @@
 	}
 
 	public final void checkKeyForMovementInput(int var1, boolean var2) {
-		byte var3 = -1;
-		if(var1 == this.gameSettings.keyBindForward.keyCode) {
-			var3 = 0;
-		}
-
-		if(var1 == this.gameSettings.keyBindBack.keyCode) {
-			var3 = 1;
-		}
-
-		if(var1 == this.gameSettings.keyBindLeft.keyCode) {
-			var3 = 2;
-		}
-
-		if(var1 == this.gameSettings.keyBindRight.keyCode) {
-			var3 = 3;
-		}
-
-		if(var1 == this.gameSettings.keyBindJump.keyCode) {
-			var3 = 4;
-		}
-
-		if(var3 >= 0) {
-			this.movementKeyStates[var3] = var2;
-		}
-
+		if(var1 == this.gameSettings.keyBindForward.keyCode) this.movementKeyStates[0] = var2;
+		if(var1 == this.gameSettings.keyBindBack.keyCode) this.movementKeyStates[1] = var2;
+		if(var1 == this.gameSettings.keyBindLeft.keyCode) this.movementKeyStates[2] = var2;
+		if(var1 == this.gameSettings.keyBindRight.keyCode) this.movementKeyStates[3] = var2;
+		if(var1 == this.gameSettings.keyBindJump.keyCode) this.movementKeyStates[4] = var2;
+		if(var1 == this.gameSettings.keyBindSneak.keyCode) this.movementKeyStates[5] = var2;
 	}
 
 	public final void resetKeyState() {
@@ -65,5 +46,11 @@
 		}
 
 		this.jump = this.movementKeyStates[4];
+		this.sneak = this.movementKeyStates[5];
+
+		if (this.sneak) {
+			this.moveForward *= 0.3F;
+			this.moveStrafe *= 0.3F;
+		}
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/block/BlockDiode.java
@@ -1,0 +1,59 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.entity.player.EntityPlayer;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+import java.util.HashSet;
+import java.util.Random;
+
+public class BlockDiode extends Block {
+	private static final int[] tickDurations = { 1, 2, 5, 10, 20 };
+
+	public BlockDiode(int var1) {
+		super(var1, 84, Material.iron);
+	}
+
+	private static int getTickDuration(int meta) {
+		return tickDurations[(meta >> 3)];
+	}
+
+	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
+		var1.setBlockMetadata(var2, var3, var4, var5);
+	}
+
+	public int getBlockTextureFromSide(int var1) {
+		return var1 == 3 ? 118 : var1 == 2 ? 53 : var1 < 2 ? 84 : 119;
+	}
+
+	public int getBlockTexture(World var1, int var2, int var3, int var4, int var5) {
+		int dir = var1.getBlockMetadata(var2, var3, var4) & 7;
+		int tick = var1.getBlockMetadata(var2, var3, var4) >>> 3;
+		return var5 == dir ? 118 : var5 == dir / 2 * 2 + 1 - (dir % 2) ? 53 : var5 == 0 ? 84 : 112 + tick;
+	}
+
+	public boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+		int dir = var1.getBlockMetadata(var2, var3, var4) & 7;
+		int tick = var1.getBlockMetadata(var2, var3, var4) >>> 3;
+		tick = (tick + 1) % tickDurations.length;
+		var1.setBlockMetadata(var2, var3, var4, dir | tick << 3);
+		return true;
+	}
+
+	public boolean canReceivePower(World var1, int var2, int var3, int var4, int var5) {
+		int dir = var1.getBlockMetadata(var2, var3, var4) & 7;
+		return var5 == dir / 2 * 2 + 1 - dir % 2;
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+		world.scheduleBlockUpdate(x, y, z, this.blockID, getTickDuration(world.getBlockMetadata(x, y, z)) - 1);
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		int mdir = var1.getBlockMetadata(var2, var3, var4) & 7;
+		var2 += mdir == 4 ? -1 : mdir == 5 ? 1 : 0;
+		var3 += mdir == 0 ? -1 : mdir == 1 ? 1 : 0;
+		var4 += mdir == 2 ? -1 : mdir == 3 ? 1 : 0;
+		var1.transmitPower(new HashSet<>(), var2, var3, var4, mdir);
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/LevelStructure.java
@@ -1,0 +1,93 @@
+package net.minecraft.game.level.generator;
+
+import net.minecraft.game.level.generator.terrain.StageFortifying;
+import net.minecraft.game.level.generator.terrain.StageShafting;
+import net.minecraft.game.level.generator.terrain.StageTemplifying;
+import net.minecraft.game.level.generator.terrain.TerrainGenStage;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+public enum LevelStructure {
+	NONE("None") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[0];
+		}
+
+		@Override
+		public boolean canNaturallyGenerate() {
+			return false;
+		}
+	},
+	FORT("Fort") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageFortifying()
+			};
+		}
+	},
+	MINESHAFT("Mineshaft") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageShafting()
+			};
+		}
+	},
+	TEMPLES("Temples") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageTemplifying()
+			};
+		}
+	};
+
+	private static final Map<String, LevelStructure> NAME_TO_TYPE = Arrays.stream(values())
+			.collect(Collectors.toMap(LevelStructure::toString, Function.identity()));
+	private static final List<LevelStructure> NATURAL_STRUCTURES = Arrays.stream(values())
+			.filter(LevelStructure::canNaturallyGenerate).collect(Collectors.toList());
+
+	public final String name;
+
+	LevelStructure(String name) {
+		this.name = name;
+	}
+
+	public boolean canNaturallyGenerate() {
+		return true;
+	}
+
+	public abstract TerrainGenStage[] getTerrainGenStages(LevelTheme theme);
+
+	@Override
+	public String toString() {
+		return this.name;
+	}
+
+	public static LevelStructure fromId(int id) {
+		return values()[id];
+	}
+
+	public static LevelStructure fromName(String name) {
+		return NAME_TO_TYPE.getOrDefault(name, NONE);
+	}
+
+	public static LevelStructure fromNameNullable(String name) {
+		return NAME_TO_TYPE.get(name);
+	}
+
+	public static LevelStructure getRandomGen() {
+		Random random = new Random();
+		if (random.nextInt(6) != 0) {
+			return NONE;
+		}
+		return NATURAL_STRUCTURES.get(random.nextInt(NATURAL_STRUCTURES.size()));
+	}
+}
--- net/minecraft/game/level/generator/noise/NoiseGeneratorDistort.java
+++ net/minecraft/game/level/generator/noise/NoiseGeneratorDistort.java
@@ -9,7 +9,11 @@
 		this.distort = var2;
 	}
 
-	public final double generateNoise(double var1, double var3) {
+	public double generateNoise(double var1, double var3) {
 		return this.source.generateNoise(var1 + this.distort.generateNoise(var1, var3), var3);
+	}
+
+	public double generateNoise(double var1, double var3, double var5) {
+		return this.source.generateNoise(var1 + this.distort.generateNoise(var1, var3, var5), var3, var5);
 	}
 }
--- net/minecraft/game/level/block/BlockLeaves.java
+++ net/minecraft/game/level/block/BlockLeaves.java
@@ -5,33 +5,46 @@
 import net.minecraft.game.level.material.Material;
 
 public final class BlockLeaves extends BlockLeavesBase {
-	protected BlockLeaves(int var1, int var2) {
+	public BlockLeaves(int var1, int var2) {
 		super(18, 52, Material.leaves, true);
 		this.setTickOnLoad(true);
 	}
 
 	public final void updateTick(World var1, int var2, int var3, int var4, Random var5) {
 		if(!var1.getBlockMaterial(var2, var3 - 1, var4).isSolid()) {
-			for(int var8 = var2 - 2; var8 <= var2 + 2; ++var8) {
-				for(int var6 = var3 - 1; var6 <= var3; ++var6) {
-					for(int var7 = var4 - 2; var7 <= var4 + 2; ++var7) {
+			boolean decay = true;
+
+			checkWood: for(int var8 = var2 - 4; var8 <= var2 + 4; ++var8) {
+				for(int var6 = var3 - 4; var6 <= var3 + 4; ++var6) {
+					for(int var7 = var4 - 4; var7 <= var4 + 4; ++var7) {
 						if(var1.getBlockId(var8, var6, var7) == Block.wood.blockID) {
-							return;
+							decay = false;
+							break checkWood;
 						}
 					}
 				}
 			}
 
-			this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
-			var1.setBlockWithNotify(var2, var3, var4, 0);
+			if (decay) {
+				this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+				var1.setBlockWithNotify(var2, var3, var4, 0);
+				return;
+			}
 		}
-	}
 
-	public final int quantityDropped(Random var1) {
-		return var1.nextInt(10) == 0 ? 1 : 0;
+		int fumesToCheck = var5.nextInt(10) + 1;
+		for (int i = 0; i < fumesToCheck; i++) {
+			int fumesCheckX = var2 + var5.nextInt(9) - 4;
+			int fumesCheckY = var3 + var5.nextInt(9) - 4;
+			int fumesCheckZ = var4 + var5.nextInt(9) - 4;
+			if (var1.getBlockId(fumesCheckX, fumesCheckY, fumesCheckZ) == Block.fumes.blockID) {
+				var1.setBlockWithNotify(fumesCheckX, fumesCheckY, fumesCheckZ, 0);
+			}
+		}
 	}
 
 	public final int idDropped(int var1, Random var2) {
-		return Block.sapling.blockID;
+		return (var1 & DROP_FLAG_SILK_TOUCH) != 0 ? this.blockID
+			: var2.nextInt(10) == 0 ? Block.sapling.blockID : 0;
 	}
 }
--- net/minecraft/client/gui/GuiSaveLevel.java
+++ net/minecraft/client/gui/GuiSaveLevel.java
@@ -33,9 +33,7 @@
 
 	protected final void openLevel(File var1) {
 		try {
-			FileOutputStream var3 = new FileOutputStream(var1);
-			(new PlayerLoader(this.mc, this.mc.loadingScreen)).save(this.mc.theWorld, var3);
-			var3.close();
+			(new PlayerLoader(this.mc, this.mc.loadingScreen)).save(this.mc.theWorld, var1);
 		} catch (IOException var2) {
 			var2.printStackTrace();
 		}
--- net/minecraft/client/render/WorldRenderer.java
+++ net/minecraft/client/render/WorldRenderer.java
@@ -2,6 +2,7 @@
 
 import net.minecraft.client.render.camera.ICamera;
 import net.minecraft.client.render.entity.RenderItem;
+import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.EntityLiving;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.block.Block;
@@ -38,7 +39,7 @@
 		this.posX = var2;
 		this.posY = var3;
 		this.posZ = var4;
-		this.sizeWidth = this.sizeHeight = this.sizeDepth = 16;
+		this.sizeWidth = this.sizeHeight = this.sizeDepth = var5;
 		this.posXPlus = var2 + this.sizeWidth / 2;
 		this.posYPlus = var3 + this.sizeHeight / 2;
 		this.posZPlus = var4 + this.sizeDepth / 2;
@@ -59,9 +60,9 @@
 			int var1 = this.posX;
 			int var2 = this.posY;
 			int var3 = this.posZ;
-			int var4 = this.posX + this.sizeWidth;
-			int var5 = this.posY + this.sizeHeight;
-			int var6 = this.posZ + this.sizeDepth;
+			int var4 = Math.min(this.posX + this.sizeWidth, this.worldObj.width);
+			int var5 = Math.min(this.posY + this.sizeHeight, this.worldObj.height);
+			int var6 = Math.min(this.posZ + this.sizeDepth, this.worldObj.length);
 
 			int var7;
 			for(var7 = 0; var7 < 2; ++var7) {
@@ -137,8 +138,13 @@
 		}
 	}
 
-	public final void updateInFrustrum(ICamera var1) {
-		this.isInFrustrum = var1.isBoundingBoxInFrustrum(this.rendererBoundingBox);
+	public final void updateInFrustrum(ICamera var1, EntityLiving player, int dist) {
+		this.isInFrustrum = this.posX + this.sizeWidth >= player.posX - dist && this.posX <= player.posX + dist
+				&& this.posY + this.sizeHeight >= player.posY - dist && this.posY <= player.posY + dist
+				&& this.posZ + this.sizeDepth >= player.posZ - dist && this.posZ <= player.posZ + dist;
+		if (this.isInFrustrum) {
+			this.isInFrustrum = var1.isBoundingBoxInFrustrum(this.rendererBoundingBox);
+		}
 	}
 
 	public final void callOcclusionQueryList() {
--- net/minecraft/game/level/MetadataChunkBlock.java
+++ net/minecraft/game/level/MetadataChunkBlock.java
@@ -1,6 +1,9 @@
 package net.minecraft.game.level;
 
+import net.minecraft.game.level.block.Block;
+
 final class MetadataChunkBlock {
+	public final EnumSkyBlock skyBlock;
 	public int x;
 	public int y;
 	public int z;
@@ -8,12 +11,165 @@
 	public int maxY;
 	public int maxZ;
 
-	public MetadataChunkBlock(Light var1, int var2, int var3, int var4, int var5, int var6, int var7) {
+	public MetadataChunkBlock(EnumSkyBlock var1, int var2, int var3, int var4, int var5, int var6, int var7) {
+		this.skyBlock = var1;
 		this.x = var2;
 		this.y = var3;
 		this.z = var4;
 		this.maxX = var5;
 		this.maxY = var6;
 		this.maxZ = var7;
+	}
+
+	public void updateLight(World var1) {
+		int var2 = this.maxX - this.x;
+		int var3 = this.maxY - this.y;
+		int var4 = this.maxZ - this.z;
+		int var5 = var2 * var3 * var4;
+		if(true) {
+			for(int var6 = this.x; var6 <= this.maxX; ++var6) {
+				for(int var7 = this.z; var7 <= this.maxZ; ++var7) {
+					for(int var8 = this.y; var8 <= this.maxY; ++var8) {
+						if(var6 >= 0 && var6 < var1.width && var7 >= 0 && var7 < var1.length && var8 >= 0 && var8 < var1.height) {
+							int var9 = var1.getSavedLightValue(this.skyBlock, var6, var8, var7);
+							boolean var10 = false;
+							int var11 = var1.getBlockId(var6, var8, var7);
+							int var12 = Block.lightOpacity[var11];
+							if(var12 == 0) {
+								var12 = 1;
+							}
+
+							int var13 = 0;
+							if(this.skyBlock == EnumSkyBlock.Sky) {
+								if(var1.canBlockSeeTheSky(var6, var8, var7)) {
+									var13 = 15;
+								}
+							} else if(this.skyBlock == EnumSkyBlock.Block) {
+								var13 = Block.lightValue[var11];
+							}
+
+							int var14;
+							int var20;
+							if(var12 >= 15 && var13 == 0) {
+								var20 = 0;
+							} else {
+								var14 = var1.getSavedLightValue(this.skyBlock, var6 - 1, var8, var7);
+								int var15 = var1.getSavedLightValue(this.skyBlock, var6 + 1, var8, var7);
+								int var16 = var1.getSavedLightValue(this.skyBlock, var6, var8 - 1, var7);
+								int var17 = var1.getSavedLightValue(this.skyBlock, var6, var8 + 1, var7);
+								int var18 = var1.getSavedLightValue(this.skyBlock, var6, var8, var7 - 1);
+								int var19 = var1.getSavedLightValue(this.skyBlock, var6, var8, var7 + 1);
+								var20 = var14;
+								if(var15 > var14) {
+									var20 = var15;
+								}
+
+								if(var16 > var20) {
+									var20 = var16;
+								}
+
+								if(var17 > var20) {
+									var20 = var17;
+								}
+
+								if(var18 > var20) {
+									var20 = var18;
+								}
+
+								if(var19 > var20) {
+									var20 = var19;
+								}
+
+								var20 -= var12;
+								if(var20 < 0) {
+									var20 = 0;
+								}
+
+								if(var13 > var20) {
+									var20 = var13;
+								}
+							}
+
+							if(var9 != var20) {
+								var1.setSavedLightValue(this.skyBlock, var6, var8, var7, var20);
+								var14 = var20 - 1;
+								if(var14 < 0) {
+									var14 = 0;
+								}
+
+								var1.neighborLightPropagationChanged(this.skyBlock, var6 - 1, var8, var7, var14);
+								var1.neighborLightPropagationChanged(this.skyBlock, var6, var8 - 1, var7, var14);
+								var1.neighborLightPropagationChanged(this.skyBlock, var6, var8, var7 - 1, var14);
+								if(var6 + 1 >= this.maxX) {
+									var1.neighborLightPropagationChanged(this.skyBlock, var6 + 1, var8, var7, var14);
+								}
+
+								if(var8 + 1 >= this.maxY) {
+									var1.neighborLightPropagationChanged(this.skyBlock, var6, var8 + 1, var7, var14);
+								}
+
+								if(var7 + 1 >= this.maxZ) {
+									var1.neighborLightPropagationChanged(this.skyBlock, var6, var8, var7 + 1, var14);
+								}
+							}
+						}
+					}
+				}
+			}
+
+		}
+	}
+
+	public boolean getLightUpdated(int var1, int var2, int var3, int var4, int var5, int var6) {
+		if(var1 >= this.x && var2 >= this.y && var3 >= this.z && var4 <= this.maxX && var5 <= this.maxY && var6 <= this.maxZ) {
+			return true;
+		} else {
+			byte var7 = 1;
+			if(var1 >= this.x - var7 && var2 >= this.y - var7 && var3 >= this.z - var7 && var4 <= this.maxX + var7 && var5 <= this.maxY + var7 && var6 <= this.maxZ + var7) {
+				int var8 = this.maxX - this.x;
+				int var9 = this.maxY - this.y;
+				int var10 = this.maxZ - this.z;
+				if(var1 > this.x) {
+					var1 = this.x;
+				}
+
+				if(var2 > this.y) {
+					var2 = this.y;
+				}
+
+				if(var3 > this.z) {
+					var3 = this.z;
+				}
+
+				if(var4 < this.maxX) {
+					var4 = this.maxX;
+				}
+
+				if(var5 < this.maxY) {
+					var5 = this.maxY;
+				}
+
+				if(var6 < this.maxZ) {
+					var6 = this.maxZ;
+				}
+
+				int var11 = var4 - var1;
+				int var12 = var5 - var2;
+				int var13 = var6 - var3;
+				int var14 = var8 * var9 * var10;
+				int var15 = var11 * var12 * var13;
+				if(var15 - var14 <= 2) {
+					this.x = var1;
+					this.y = var2;
+					this.z = var3;
+					this.maxX = var4;
+					this.maxY = var5;
+					this.maxZ = var6;
+					return true;
+				}
+			}
+
+			return false;
+		}
 	}
 }
--- net/minecraft/client/effect/EffectRenderer.java
+++ net/minecraft/client/effect/EffectRenderer.java
@@ -16,6 +16,7 @@
 	private List[] fxLayers = new List[3];
 	private RenderEngine renderEngine;
 	private Random rand = new Random();
+	private EntityFX horizonFX;
 
 	public EffectRenderer(World var1, RenderEngine var2) {
 		if(var1 != null) {
@@ -27,7 +28,6 @@
 		for(int var3 = 0; var3 < 3; ++var3) {
 			this.fxLayers[var3] = new ArrayList();
 		}
-
 	}
 
 	public final void addEffect(EntityFX var1) {
@@ -78,7 +78,6 @@
 				var12.draw();
 			}
 		}
-
 	}
 
 	public final void renderLitParticles(float var1) {
--- net/minecraft/game/level/block/BlockOreBlock.java
+++ net/minecraft/game/level/block/BlockOreBlock.java
@@ -3,12 +3,28 @@
 import net.minecraft.game.level.material.Material;
 
 public final class BlockOreBlock extends Block {
-	public BlockOreBlock(int var1, int var2) {
+	public final int conductionChannel;
+
+	public BlockOreBlock(int var1, int var2, int var3) {
 		super(var1, Material.iron);
 		this.blockIndexInTexture = var2;
+		this.conductionChannel = var3;
+		Block.conductive[var1] = this.isConductive();
 	}
 
 	public final int getBlockTextureFromSide(int var1) {
 		return var1 == 1 ? this.blockIndexInTexture - 16 : (var1 == 0 ? this.blockIndexInTexture + 16 : this.blockIndexInTexture);
+	}
+
+	public boolean isConductive() {
+		return this.conductionChannel != 0;
+	}
+
+	public boolean conductWithBlock(Block block) {
+		boolean isOre = block instanceof BlockOreBlock;
+		boolean isChain = block instanceof BlockChain;
+		return isOre && ((BlockOreBlock) block).conductionChannel == this.conductionChannel
+			|| isChain && ((BlockChain) block).conductionChannel == this.conductionChannel
+			|| !isOre && !isChain;
 	}
 }
--- net/minecraft/client/render/EntityRenderer.java
+++ net/minecraft/client/render/EntityRenderer.java
@@ -32,6 +32,8 @@
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.Display;
 import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GLContext;
+import org.lwjgl.opengl.NVFogDistance;
 import org.lwjgl.util.glu.GLU;
 import util.MathHelper;
 
@@ -65,7 +67,7 @@
 	public final void updateRenderer() {
 		this.prevFogColor = this.fogColor;
 		float var1 = this.mc.theWorld.getLightBrightness((int)this.mc.thePlayer.posX, (int)this.mc.thePlayer.posY, (int)this.mc.thePlayer.posZ);
-		float var2 = (float)(3 - this.mc.options.renderDistance) / 3.0F;
+		float var2 = Math.min((float)(4 - this.mc.options.renderDistance) / 3.0F, 1.0F);
 		var1 = var1 * (1.0F - var2) + var2;
 		this.fogColor += (var1 - this.fogColor) * 0.1F;
 		++this.rendererUpdateCount;
@@ -112,7 +114,7 @@
 		}
 	}
 
-	public final void updateCameraAndRender(float var1) {
+	public final void updateCameraAndRender(float var1, long updateStartTime) {
 		if(this.anaglyphEnable && !Display.isActive()) {
 			this.mc.displayInGameMenu();
 		}
@@ -121,18 +123,17 @@
 		int var5;
 		int var6;
 		if(this.mc.inventoryScreen) {
-			Mouse.getDX();
+			this.mc.mouseHelper.mouseXYChange();
 			byte var2 = 0;
-			Mouse.getDY();
 			byte var3 = 0;
-			this.mc.mouseHelper.ungrabMouseCursor();
+//			this.mc.mouseHelper.ungrabMouseCursor();
 			byte var4 = 1;
 			if(this.mc.options.invertMouse) {
 				var4 = -1;
 			}
 
 			var5 = var2 + this.mc.mouseHelper.deltaX;
-			var6 = var3 - this.mc.mouseHelper.deltaY;
+			var6 = var3 + this.mc.mouseHelper.deltaY;
 			if(var2 != 0 || this.entityRendererInt1 != 0) {
 				System.out.println("xxo: " + var2 + ", " + this.entityRendererInt1 + ": " + this.entityRendererInt1 + ", xo: " + var5);
 			}
@@ -179,7 +180,7 @@
 		var5 = Mouse.getX() * var10 / this.mc.displayWidth;
 		var6 = var12 - Mouse.getY() * var12 / this.mc.displayHeight - 1;
 		if(this.mc.theWorld != null) {
-			this.getMouseOver(var1);
+			this.getMouseOver(var1, updateStartTime);
 			this.mc.ingameGUI.renderGameOverlay(var1);
 		} else {
 			GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
@@ -197,6 +198,8 @@
 			this.mc.currentScreen.drawScreen(var5, var6, var1);
 		}
 
+		this.mc.ingameGUI.drawAutosaveIndicator();
+
 		Thread.yield();
 		Display.update();
 	}
@@ -243,7 +246,7 @@
 							this.updateFogColor(0.0F);
 							GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT | GL11.GL_COLOR_BUFFER_BIT);
 							GL11.glEnable(GL11.GL_CULL_FACE);
-							this.farPlaneDistance = (float)(512 >> (this.mc.options.renderDistance << 1));
+							this.farPlaneDistance = (float)(this.mc.options.getRenderDistance());
 							GL11.glMatrixMode(GL11.GL_PROJECTION);
 							GL11.glLoadIdentity();
 							GL11.glOrtho(0.0D, (double)this.mc.displayWidth, 0.0D, (double)this.mc.displayHeight, 10.0D, 10000.0D);
@@ -278,8 +281,8 @@
 							GL11.glTranslatef((float)(-var16.width) / 2.0F, (float)(-var16.height) / 2.0F, (float)(-var16.length) / 2.0F);
 							IsomCamera var24 = new IsomCamera();
 							this.mc.renderGlobal.clipRenderersByFrustrum(var24);
-							this.mc.renderGlobal.updateRenderers(var15);
-							this.setupFog();
+							this.mc.renderGlobal.updateRenderers(var15, 0, true);
+							this.setupFog(1.0F);
 							GL11.glEnable(GL11.GL_FOG);
 							GL11.glFogi(GL11.GL_FOG_MODE, GL11.GL_LINEAR);
 							float var23 = (float)var16.height * 8.0F;
@@ -293,6 +296,11 @@
 							var17.oobGroundRenderer();
 							if(var16.cloudHeight < var16.height) {
 								var17.renderSky(0.0F);
+								GL11.glFogf(GL11.GL_FOG_START, 10000.0F - var23 * 2.0F);
+								GL11.glFogf(GL11.GL_FOG_END, 10000.0F + var23 * 16.0F);
+								var17.renderClouds(0.0F);
+								GL11.glFogf(GL11.GL_FOG_START, 5000.0F - var23);
+								GL11.glFogf(GL11.GL_FOG_END, 5000.0F + var23 * 8.0F);
 							}
 
 							GL11.glEnable(GL11.GL_BLEND);
@@ -304,7 +312,7 @@
 								var17.renderAllRenderLists();
 							}
 
-							if(var16.getGroundLevel() >= 0) {
+							if(var16.getGroundLevel() >= 0 && var16.defaultFluid > 0) {
 								var17.oobWaterRenderer();
 							}
 
@@ -351,7 +359,7 @@
 		return var3;
 	}
 
-	private void getMouseOver(float var1) {
+	private void getMouseOver(float var1, long updateStartTime) {
 		EntityRenderer var7 = this;
 		EntityPlayerSP var9 = this.mc.thePlayer;
 		float var2 = var9.prevRotationPitch + (var9.rotationPitch - var9.prevRotationPitch) * var1;
@@ -424,7 +432,7 @@
 			GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT | GL11.GL_COLOR_BUFFER_BIT);
 			GL11.glEnable(GL11.GL_CULL_FACE);
 			float var27 = var1;
-			this.farPlaneDistance = (float)(512 >> (this.mc.options.renderDistance << 1));
+			this.farPlaneDistance = (float)(this.mc.options.getRenderDistance()) * 2.0F;
 			GL11.glMatrixMode(GL11.GL_PROJECTION);
 			GL11.glLoadIdentity();
 			if(this.mc.options.anaglyph) {
@@ -459,6 +467,7 @@
 			var13 = var34.prevPosX + (var34.posX - var34.prevPosX) * var1;
 			var14 = var34.prevPosY + (var34.posY - var34.prevPosY) * var1;
 			var15 = var34.prevPosZ + (var34.posZ - var34.prevPosZ) * var1;
+			boolean outOfBounds = var13 < 0.0F || var13 > var4.width || var15 < 0.0F || var15 > var4.length || this.mc.options.thirdPersonView;
 			if(!this.mc.options.thirdPersonView) {
 				GL11.glTranslatef(0.0F, 0.0F, -0.1F);
 			} else {
@@ -467,6 +476,12 @@
 				var17 = MathHelper.cos(var34.rotationYaw / 180.0F * (float)Math.PI) * MathHelper.cos(var34.rotationPitch / 180.0F * (float)Math.PI) * 4.0F;
 				var18 = -MathHelper.sin(var34.rotationPitch / 180.0F * (float)Math.PI) * 4.0F;
 
+				if (this.mc.options.frontThirdPersonView) {
+					var25 = -MathHelper.sin((var34.rotationYaw + 180.0F) / 180.0F * (float)Math.PI) * MathHelper.cos(-var34.rotationPitch / 180.0F * (float)Math.PI) * 4.0F;
+					var17 = MathHelper.cos((var34.rotationYaw + 180.0F) / 180.0F * (float)Math.PI) * MathHelper.cos(-var34.rotationPitch / 180.0F * (float)Math.PI) * 4.0F;
+					var18 = -MathHelper.sin(-var34.rotationPitch / 180.0F * (float)Math.PI) * 4.0F;
+				}
+
 				for(int var39 = 0; var39 < 8; ++var39) {
 					var20 = (float)(((var39 & 1) << 1) - 1);
 					var27 = (float)(((var39 >> 1 & 1) << 1) - 1);
@@ -474,7 +489,12 @@
 					var20 *= 0.1F;
 					var27 *= 0.1F;
 					var28 *= 0.1F;
-					MovingObjectPosition var42 = var30.mc.theWorld.rayTraceBlocks(new Vec3D(var13 + var20, var14 + var27, var15 + var28), new Vec3D(var13 - var25 + var20 + var28, var14 - var18 + var27, var15 - var17 + var28));
+					if (this.mc.options.frontThirdPersonView) {
+						var20 *= -1.0F;
+						var27 *= -1.0F;
+						var28 *= -1.0F;
+					}
+					MovingObjectPosition var42 = var30.mc.theWorld.rayTraceBlocks(new Vec3D(var13 + var20, var14 + var27, var15 + var28), new Vec3D(var13 - var25 + var20, var14 - var18 + var27, var15 - var17 + var28));
 					if(var42 != null) {
 						float var40 = var42.hitVec.distance(new Vec3D(var13, var14, var15));
 						if(var40 < var16) {
@@ -486,18 +506,54 @@
 				GL11.glTranslatef(0.0F, 0.0F, -var16);
 			}
 
-			GL11.glRotatef(var34.prevRotationPitch + (var34.rotationPitch - var34.prevRotationPitch) * var27, 1.0F, 0.0F, 0.0F);
-			GL11.glRotatef(var34.prevRotationYaw + (var34.rotationYaw - var34.prevRotationYaw) * var27 + 180.0F, 0.0F, 1.0F, 0.0F);
+			float offset = 180.0F;
+			float pitchDir = 1.0F;
+			if (this.mc.options.frontThirdPersonView) {
+				offset = 0;
+				pitchDir = -1.0F;
+			}
+
+			GL11.glRotatef(var34.prevRotationPitch + (var34.rotationPitch - var34.prevRotationPitch) * var27, pitchDir, 0.0F, 0.0F);
+			GL11.glRotatef(var34.prevRotationYaw + (var34.rotationYaw - var34.prevRotationYaw) * var27 + offset, 0.0F, 1.0F, 0.0F);
 			GL11.glTranslatef(-var13, -var14, -var15);
 			ClippingHelperImplementation.init();
-			this.setupFog();
+			this.setupFog(var1);
 			GL11.glEnable(GL11.GL_FOG);
+			GL11.glEnable(GL11.GL_ALPHA_TEST);
+			GL11.glEnable(GL11.GL_DEPTH_TEST);
 			var5.renderSky(var1);
-			this.setupFog();
+			if (!outOfBounds) {
+				GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+				var5.oobGroundRenderer();
+				if(this.mc.theWorld.defaultFluid > 0) {
+					var5.oobWaterRenderer();
+				}
+			}
+
+			if (!outOfBounds) {
+				GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
+			}
+			var5.renderClouds(var1);
+			GL11.glDisable(GL11.GL_ALPHA_TEST);
+			GL11.glDisable(GL11.GL_DEPTH_TEST);
+			GL11.glEnable(GL11.GL_BLEND);
+			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+			var5.oobHorizonRender(var1);
+			GL11.glDisable(GL11.GL_BLEND);
+			GL11.glEnable(GL11.GL_FOG);
+			this.setupFog(var1);
+			GL11.glEnable(GL11.GL_ALPHA_TEST);
+			GL11.glEnable(GL11.GL_DEPTH_TEST);
+			this.setupFog(var1);
 			Frustrum var26 = new Frustrum();
 			this.mc.renderGlobal.clipRenderersByFrustrum(var26);
-			this.mc.renderGlobal.updateRenderers(var3);
-			this.setupFog();
+
+			int fps = Math.max(Math.min(this.mc.debugFPS, 60), 1);
+			long timeElapsed = System.nanoTime() - updateStartTime;
+			long timeOffset = Math.max((long)(1000000000L / fps / 2) - timeElapsed, 0L);
+			this.mc.renderGlobal.updateRenderers(var3, System.nanoTime() + timeOffset, false);
+
+			this.setupFog(var1);
 			GL11.glEnable(GL11.GL_FOG);
 			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/terrain.png"));
 			RenderHelper.disableStandardItemLighting();
@@ -525,9 +581,8 @@
 			var5.renderEntities(this.orientCamera(var1), var26, var1);
 			var6.renderLitParticles(var1);
 			RenderHelper.disableStandardItemLighting();
-			this.setupFog();
+			this.setupFog(var1);
 			var6.renderParticles(var3, var1);
-			var5.oobGroundRenderer();
 			if(this.mc.objectMouseOver != null && var3.isInsideOfWater()) {
 				GL11.glDisable(GL11.GL_ALPHA_TEST);
 				var5.drawBlockBreaking(this.mc.objectMouseOver, 0, var3.inventory.getCurrentItem());
@@ -535,9 +590,16 @@
 				GL11.glEnable(GL11.GL_ALPHA_TEST);
 			}
 
+			this.setupFog(var1);
 			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
-			this.setupFog();
-			var5.oobWaterRenderer();
+			if (outOfBounds) {
+				var5.oobGroundRenderer();
+				if(this.mc.theWorld.defaultFluid > 0) {
+					var5.oobWaterRenderer();
+				}
+			}
+
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/terrain.png"));
 			GL11.glEnable(GL11.GL_BLEND);
 			GL11.glDisable(GL11.GL_CULL_FACE);
 			GL11.glColorMask(false, false, false, false);
@@ -565,6 +627,10 @@
 				GL11.glEnable(GL11.GL_ALPHA_TEST);
 			}
 
+			if(this.mc.theWorld.levelTheme.hasSnow()) {
+				this.renderSnow(var1);
+			}
+
 			GL11.glDisable(GL11.GL_FOG);
 			GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
 			GL11.glLoadIdentity();
@@ -578,7 +644,7 @@
 				this.setupViewBobbing(var1);
 			}
 
-			if(!this.mc.options.thirdPersonView) {
+			if(!this.mc.options.thirdPersonView && this.mc.options.showHUD) {
 				this.itemRenderer.renderItemInFirstPerson(var1);
 			}
 
@@ -616,7 +682,7 @@
 	private void updateFogColor(float var1) {
 		World var2 = this.mc.theWorld;
 		EntityPlayerSP var3 = this.mc.thePlayer;
-		float var4 = 1.0F / (float)(4 - this.mc.options.renderDistance);
+		float var4 = 1.0F / (float)(5 - this.mc.options.renderDistance);
 		var4 = 1.0F - (float)Math.pow((double)var4, 0.25D);
 		Vec3D var5 = var2.getSkyColor(var1);
 		float var6 = var5.xCoord;
@@ -659,7 +725,7 @@
 		GL11.glClearColor(this.fogColorRed, this.fogColorGreen, this.fogColorBlue, 0.0F);
 	}
 
-	private void setupFog() {
+	private void setupFog(float f) {
 		World var1 = this.mc.theWorld;
 		EntityPlayerSP var2 = this.mc.thePlayer;
 		int var10000 = GL11.GL_FOG_COLOR;
@@ -683,12 +749,81 @@
 				GL11.glFogf(GL11.GL_FOG_DENSITY, 2.0F);
 			}
 		} else {
+			float dist = this.farPlaneDistance / 2.0F;
+			dist *= 1.0F - this.mc.thePlayer.getTravelDistance(f);
 			GL11.glFogi(GL11.GL_FOG_MODE, GL11.GL_LINEAR);
-			GL11.glFogf(GL11.GL_FOG_START, this.farPlaneDistance / 4.0F);
-			GL11.glFogf(GL11.GL_FOG_END, this.farPlaneDistance);
+			GL11.glFogf(GL11.GL_FOG_START, dist / 4.0F);
+			GL11.glFogf(GL11.GL_FOG_END, dist);
+
+			if(GLContext.getCapabilities().GL_NV_fog_distance) {
+				GL11.glFogi(NVFogDistance.GL_FOG_DISTANCE_MODE_NV, NVFogDistance.GL_EYE_RADIAL_NV);
+			}
 		}
 
 		GL11.glEnable(GL11.GL_COLOR_MATERIAL);
 		GL11.glColorMaterial(GL11.GL_FRONT, GL11.GL_AMBIENT);
+	}
+
+	private void renderSnow(float var1) {
+		EntityPlayerSP var2 = this.mc.thePlayer;
+		World var3 = this.mc.theWorld;
+		int var4 = MathHelper.floor_float(var2.posX);
+		int var5 = MathHelper.floor_float(var2.posY);
+		int var6 = MathHelper.floor_float(var2.posZ);
+		Tessellator var7 = Tessellator.instance;
+		GL11.glDisable(GL11.GL_CULL_FACE);
+		GL11.glNormal3f(0.0F, 1.0F, 0.0F);
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/terrain/snow.png"));
+		byte var14 = 8;
+		for(int var15 = var4 - var14; var15 <= var4 + var14; ++var15) {
+			for(int var16 = var6 - var14; var16 <= var6 + var14; ++var16) {
+				int var17 = var3.groundLevel;
+				if (var15 > 0 && var16 > 0 && var15 < var3.width - 1 && var16 < var3.length - 1) {
+					var17 = var3.getHeightValue(var15, var16);
+				}
+				if(var17 < 0) {
+					var17 = 0;
+				}
+
+				int var18 = var5 - var14;
+				int var19 = var5 + var14;
+				if(var18 < var17) {
+					var18 = var17;
+				}
+
+				if(var19 < var17) {
+					var19 = var17;
+				}
+
+				float var20 = 2.0F;
+				if(var18 != var19) {
+					this.random.setSeed((long)(var15 * var15 * 3121 + var15 * 45238971 + var16 * var16 * 418711 + var16 * 13761));
+					float var21 = (float)this.rendererUpdateCount + var1;
+					float var22 = ((float)(this.rendererUpdateCount & 511) + var1) / 512.0F;
+					float var23 = this.random.nextFloat() + var21 * 0.01F * (float)this.random.nextGaussian();
+					float var24 = this.random.nextFloat() + var21 * (float)this.random.nextGaussian() * 0.001F;
+					double var25 = (double)((float)var15 + 0.5F) - var2.posX;
+					double var27 = (double)((float)var16 + 0.5F) - var2.posZ;
+					float var29 = (float)Math.sqrt(var25 * var25 + var27 * var27) / (float)var14;
+					var7.startDrawingQuads();
+					float var30 = var3.getLightBrightness(var15, var3.height, var16);
+					GL11.glColor4f(var30, var30, var30, (1.0F - var29 * var29) * 0.2F);
+					var7.addVertexWithUV((var15 + 0), var18, (var16 + 0), (0.0F * var20 + var23), ((float)var18 * var20 / 8.0F + var22 * var20 + var24));
+					var7.addVertexWithUV((var15 + 1), var18, (var16 + 1), (0.5F * var20 + var23), ((float)var18 * var20 / 8.0F + var22 * var20 + var24));
+					var7.addVertexWithUV((var15 + 1), var19, (var16 + 1), (0.5F * var20 + var23), ((float)var19 * var20 / 8.0F + var22 * var20 + var24));
+					var7.addVertexWithUV((var15 + 0), var19, (var16 + 0), (0.0F * var20 + var23), ((float)var19 * var20 / 8.0F + var22 * var20 + var24));
+					var7.addVertexWithUV((var15 + 0), var18, (var16 + 1), (0.0F * var20 + var23), ((float)var18 * var20 / 8.0F + var22 * var20 + var24));
+					var7.addVertexWithUV((var15 + 1), var18, (var16 + 0), (0.5F * var20 + var23), ((float)var18 * var20 / 8.0F + var22 * var20 + var24));
+					var7.addVertexWithUV((var15 + 1), var19, (var16 + 0), (0.5F * var20 + var23), ((float)var19 * var20 / 8.0F + var22 * var20 + var24));
+					var7.addVertexWithUV((var15 + 0), var19, (var16 + 1), (0.0F * var20 + var23), ((float)var19 * var20 / 8.0F + var22 * var20 + var24));
+					var7.draw();
+				}
+			}
+		}
+
+		GL11.glEnable(GL11.GL_CULL_FACE);
+		GL11.glDisable(GL11.GL_BLEND);
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/block/BlockIce.java
@@ -1,0 +1,44 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.EnumSkyBlock;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+import java.util.Random;
+
+public class BlockIce extends BlockBreakable {
+	public BlockIce(int var1, int var2) {
+		super(var1, var2, Material.ice, false);
+		this.setTickOnLoad(true);
+	}
+
+	public int getRenderBlockPass() {
+		return 1;
+	}
+
+	public boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
+		return super.shouldSideBeRendered(var1, var2, var3, var4, 1 - var5);
+	}
+
+	public void onBlockRemoval(World var1, int var2, int var3, int var4, int var4a) {
+		Material var5 = var1.getBlockMaterial(var2, var3 - 1, var4);
+		if(var5.getIsSolid() || var5.getIsLiquid()) {
+			var1.setBlockWithNotify(var2, var3, var4, Block.waterMoving.blockID);
+			var1.scheduleBlockUpdate(var2, var3, var4, Block.waterMoving.blockID);
+		}
+
+	}
+
+	public int quantityDropped(Random var1) {
+		return 0;
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		if(var1.getSavedLightValue(EnumSkyBlock.Block, var2, var3, var4) > 11 - Block.lightOpacity[this.blockID]) {
+			this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+			var1.setBlockWithNotify(var2, var3, var4, Block.waterMoving.blockID);
+			var1.scheduleBlockUpdate(var2, var3, var4, Block.waterMoving.blockID);
+		}
+
+	}
+}
--- net/minecraft/client/render/entity/RenderItem.java
+++ net/minecraft/client/render/entity/RenderItem.java
@@ -13,6 +13,8 @@
 import util.MathHelper;
 
 public final class RenderItem extends Render {
+	public static final RenderItem instance = new RenderItem();
+
 	private RenderBlocks renderBlocks = new RenderBlocks();
 	private Random random = new Random();
 
@@ -24,7 +26,7 @@
 	public final void renderItemIntoGUI(RenderEngine var1, ItemStack var2, int var3, int var4) {
 		if(var2 != null) {
 			int var9;
-			if(var2.itemID < 256 && Block.blocksList[var2.itemID].getRenderType() == 0) {
+			if(var2.itemID < 256 && Block.blocksList[var2.itemID].has3DIcon()) {
 				var9 = var2.itemID;
 				RenderEngine.bindTexture(var1.getTexture("/terrain.png"));
 				Block var8 = Block.blocksList[var9];
@@ -35,10 +37,10 @@
 				GL11.glRotatef(210.0F, 1.0F, 0.0F, 0.0F);
 				GL11.glRotatef(45.0F, 0.0F, 1.0F, 0.0F);
 				GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-				this.renderBlocks.renderBlockOnInventory(var8);
+				this.renderBlocks.renderBlockOnInventory(var8, var2.itemDamage);
 				GL11.glPopMatrix();
 			} else {
-				if(var2.getItem().getIconIndex() >= 0) {
+				if(var2.getIconIndex() >= 0) {
 					GL11.glDisable(GL11.GL_LIGHTING);
 					if(var2.itemID < 256) {
 						RenderEngine.bindTexture(var1.getTexture("/terrain.png"));
@@ -48,8 +50,8 @@
 
 					int var10000 = var3;
 					int var10001 = var4;
-					int var10002 = var2.getItem().getIconIndex() % 16 << 4;
-					int var10003 = var2.getItem().getIconIndex() / 16 << 4;
+					int var10002 = var2.getIconIndex() % 16 << 4;
+					int var10003 = var2.getIconIndex() / 16 << 4;
 					boolean var6 = true;
 					var6 = true;
 					var4 = var10003;
@@ -81,7 +83,7 @@
 				GL11.glEnable(GL11.GL_DEPTH_TEST);
 			}
 
-			if(var2.itemDamage > 0) {
+			if(var2.itemDamage > 0 && var2.isItemStackDamageable() > 0) {
 				int var9 = 13 - var2.itemDamage * 13 / var2.isItemStackDamageable();
 				int var7 = 255 - var2.itemDamage * 255 / var2.isItemStackDamageable();
 				GL11.glDisable(GL11.GL_LIGHTING);
@@ -135,13 +137,10 @@
 
 		GL11.glTranslatef(var2, var3 + var8, var4);
 		GL11.glEnable(GL11.GL_NORMALIZE);
-		if(var7.itemID < 256 && Block.blocksList[var7.itemID].getRenderType() == 0) {
+		if(var7.itemID < 256 && Block.blocksList[var7.itemID].has3DIcon()) {
 			GL11.glRotatef(var6, 0.0F, 1.0F, 0.0F);
 			this.loadTexture("/terrain.png");
 			var2 = 0.25F;
-			if(!Block.blocksList[var7.itemID].renderAsNormalBlock() && var7.itemID != Block.stairSingle.blockID) {
-				var2 = 0.5F;
-			}
 
 			GL11.glScalef(var2, var2, var2);
 
@@ -154,12 +153,12 @@
 					GL11.glTranslatef(var4, var5, var6);
 				}
 
-				var12.renderBlocks.renderBlockOnInventory(Block.blocksList[var7.itemID]);
+				var12.renderBlocks.renderBlockOnInventory(Block.blocksList[var7.itemID], var7.itemDamage);
 				GL11.glPopMatrix();
 			}
 		} else {
 			GL11.glScalef(0.5F, 0.5F, 0.5F);
-			int var14 = var7.getItem().getIconIndex();
+			int var14 = var7.getIconIndex();
 			if(var7.itemID < 256) {
 				this.loadTexture("/terrain.png");
 			} else {
--- net/minecraft/game/item/ItemAxe.java
+++ net/minecraft/game/item/ItemAxe.java
@@ -3,7 +3,7 @@
 import net.minecraft.game.level.block.Block;
 
 public final class ItemAxe extends ItemTool {
-	private static Block[] blocksEffectiveAgainst = new Block[]{Block.planks, Block.bookShelf, Block.wood, Block.crate};
+	private static Block[] blocksEffectiveAgainst = new Block[]{Block.planks, Block.bookShelf, Block.wood, Block.leaves, Block.crate, Block.workbench, Block.woodStairDouble, Block.woodStairSingle, Block.woodenGrate, Block.brownMushroomBlock, Block.redMushroomBlock};
 
 	public ItemAxe(int var1, int var2) {
 		super(var1, 3, var2, blocksEffectiveAgainst);
--- net/minecraft/client/gui/GuiButton.java
+++ net/minecraft/client/gui/GuiButton.java
@@ -4,50 +4,70 @@
 import org.lwjgl.opengl.GL11;
 
 public class GuiButton extends Gui {
-	private int width;
-	private int height;
-	private int xPosition;
-	private int yPosition;
+	protected int width;
+	protected int height;
+	protected int xPosition;
+	protected int yPosition;
 	public String displayString;
 	public int id;
 	public boolean enabled;
 	public boolean visible;
+	public int bg;
 
 	public GuiButton(int var1, int var2, int var3, String var4) {
 		this(var1, var2, var3, 200, 20, var4);
 	}
 
-	protected GuiButton(int var1, int var2, int var3, int var4, int var5, String var6) {
-		this.width = 200;
-		this.height = 20;
+	public GuiButton(int var1, int var2, int var3, int var4, int var5, String var6) {
 		this.enabled = true;
 		this.visible = true;
 		this.id = var1;
 		this.xPosition = var2;
 		this.yPosition = var3;
 		this.width = var4;
-		this.height = 20;
+		this.height = var5;
 		this.displayString = var6;
 	}
 
-	public final void drawButton(Minecraft var1, int var2, int var3) {
+	public GuiButton withBg(int bg) {
+		this.bg = bg;
+		return this;
+	}
+
+	protected byte getHoverState(boolean var1) {
+		byte var2 = 1;
+		if(!this.enabled) {
+			var2 = 0;
+		} else if(var1) {
+			var2 = 2;
+		}
+
+		return var2;
+	}
+
+	public void drawButton(Minecraft var1, int var2, int var3) {
 		if(this.visible) {
 			FontRenderer var4 = var1.fontRenderer;
-			GL11.glBindTexture(GL11.GL_TEXTURE_2D, var1.renderEngine.getTexture("/gui/gui.png"));
-			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-			byte var5 = 1;
-			boolean var6 = var2 >= this.xPosition && var3 >= this.yPosition && var2 < this.xPosition + this.width && var3 < this.yPosition + this.height;
-			if(!this.enabled) {
-				var5 = 0;
-			} else if(var6) {
-				var5 = 2;
-			}
-
-			this.drawTexturedModalRect(this.xPosition, this.yPosition, 0, 46 + var5 * 20, this.width / 2, this.height);
-			this.drawTexturedModalRect(this.xPosition + this.width / 2, this.yPosition, 200 - this.width / 2, 46 + var5 * 20, this.width / 2, this.height);
+			boolean var5 = var2 >= this.xPosition && var3 >= this.yPosition && var2 < this.xPosition + this.width && var3 < this.yPosition + this.height;
+			byte var6 = this.getHoverState(var5);
+			if (this.bg != 2) {
+				boolean menuBg = this.bg == 1 || var1.theWorld == null && this.bg != 3;
+				if (menuBg) {
+					GL11.glEnable(GL11.GL_BLEND);
+					GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+				}
+				GL11.glBindTexture(GL11.GL_TEXTURE_2D, var1.renderEngine.getTexture(menuBg ? "/gui/guimenu.png" : "/gui/gui.png"));
+				GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+				this.drawTexturedModalRect(this.xPosition, this.yPosition, 0, 46 + var6 * 20, this.width / 2, this.height);
+				this.drawTexturedModalRect(this.xPosition + this.width / 2, this.yPosition, 200 - this.width / 2, 46 + var6 * 20, this.width / 2, this.height);
+			}
+			if (var1.theWorld != null) {
+				GL11.glDisable(GL11.GL_BLEND);
+			}
+			this.mouseDragged(var1, var2, var3);
 			if(!this.enabled) {
 				drawCenteredString(var4, this.displayString, this.xPosition + this.width / 2, this.yPosition + (this.height - 8) / 2, -6250336);
-			} else if(var6) {
+			} else if(var5) {
 				drawCenteredString(var4, this.displayString, this.xPosition + this.width / 2, this.yPosition + (this.height - 8) / 2, 16777120);
 			} else {
 				drawCenteredString(var4, this.displayString, this.xPosition + this.width / 2, this.yPosition + (this.height - 8) / 2, 14737632);
@@ -55,7 +75,13 @@
 		}
 	}
 
-	public final boolean mousePressed(int var1, int var2) {
+	public boolean mousePressed(int var1, int var2) {
 		return this.enabled && var1 >= this.xPosition && var2 >= this.yPosition && var1 < this.xPosition + this.width && var2 < this.yPosition + this.height;
+	}
+
+	public void mouseReleased(int var1, int var2) {
+	}
+
+	protected void mouseDragged(Minecraft var1, int var2, int var3) {
 	}
 }
--- net/minecraft/game/level/block/BlockTNT.java
+++ net/minecraft/game/level/block/BlockTNT.java
@@ -1,6 +1,7 @@
 package net.minecraft.game.level.block;
 
 import java.util.Random;
+
 import net.minecraft.game.entity.misc.EntityTNTPrimed;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.material.Material;
@@ -28,5 +29,14 @@
 		EntityTNTPrimed var6 = new EntityTNTPrimed(var1, (float)var2 + 0.5F, (float)var3 + 0.5F, (float)var4 + 0.5F);
 		var1.spawnEntityInWorld(var6);
 		var1.playSoundAtEntity(var6, "random.fuse", 1.0F, 1.0F);
+	}
+
+	public boolean canReceivePower(World var1, int var2, int var3, int var4, int var5) {
+		return true;
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+		world.setBlockWithNotify(x, y, z, 0);
+		this.onBlockDestroyedByPlayer(world, x, y, z, 0);
 	}
 }
--- net/minecraft/game/level/block/BlockGravel.java
+++ net/minecraft/game/level/block/BlockGravel.java
@@ -8,6 +8,10 @@
 		super(13, 19);
 	}
 
+	public int tickRate() {
+		return 2;
+	}
+
 	public final int idDropped(int var1, Random var2) {
 		return var2.nextInt(10) == 0 ? Item.flint.shiftedIndex : this.blockID;
 	}
--- net/minecraft/game/level/World.java
+++ net/minecraft/game/level/World.java
@@ -1,18 +1,14 @@
 package net.minecraft.game.level;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.TreeSet;
+import java.util.*;
+
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.EntityLiving;
-import net.minecraft.game.level.block.Block;
-import net.minecraft.game.level.block.BlockContainer;
+import net.minecraft.game.level.block.*;
 import net.minecraft.game.level.block.tileentity.TileEntity;
+import net.minecraft.game.level.generator.LevelStructure;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.LevelType;
 import net.minecraft.game.level.material.Material;
 import net.minecraft.game.level.path.Pathfinder;
 import net.minecraft.game.physics.AxisAlignedBB;
@@ -22,11 +18,17 @@
 
 public final class World {
 	private static float[] lightBrightnessTable = new float[16];
+	private static int lightingUpdatesScheduled = 0;
+	private List lightingToUpdate = new ArrayList();
+	public LevelType levelType;
+	public LevelTheme levelTheme;
+	public LevelStructure levelStructure;
 	public int width;
 	public int length;
 	public int height;
 	public byte[] blocks;
 	public byte[] data;
+	public byte[] light;
 	public String name;
 	public String authorName;
 	public long createTime;
@@ -40,6 +42,8 @@
 	public Map map = new HashMap();
 	private List list = new ArrayList();
 	int[] heightMap;
+	private int minHeight;
+	private int lightingUpdatesCounter;
 	public Random random = new Random();
 	private Random rand = new Random();
 	private int randId = this.random.nextInt();
@@ -53,6 +57,7 @@
 	private int updateLCG = 0;
 	private int playTime = 0;
 	public EntityLiving playerEntity;
+	public int renderDistance;
 	public boolean survivalWorld = true;
 	public int skyBrightness = 15;
 	public int skylightSubtracted = 15;
@@ -64,15 +69,13 @@
 	private int[] coords = new int[1048576];
 	private int[] floodedBlocks = new int[1048576];
 	public int difficultySetting = 2;
+	public int simulationDistance = 192;
 
 	public final void load() {
 		if(this.blocks == null) {
 			throw new RuntimeException("The level is corrupt!");
 		} else {
 			this.worldAccesses = new ArrayList();
-			this.heightMap = new int[this.width * this.length];
-			Arrays.fill(this.heightMap, this.height);
-			this.lightUpdates.updateSkylight(0, 0, this.width, this.length);
 			this.random = new Random();
 			this.randId = this.random.nextInt();
 			this.tickList = new ArrayList();
@@ -83,10 +86,10 @@
 		}
 	}
 
-	public final void generate(int var1, int var2, int var3, byte[] var4, byte[] var5) {
-		if(var5 != null && var5.length == 0) {
-			var5 = null;
-		}
+	public final void generate(int var1, int var2, int var3, byte[] var4, byte[] var5, byte[] var5a, int[] var5b) {
+		if(var5 != null && var5.length == 0) var5 = null;
+		if(var5a != null && var5a.length == 0) var5a = null;
+		if(var5b != null && var5b.length == 0) var5b = null;
 
 		this.width = var1;
 		this.length = var3;
@@ -104,13 +107,18 @@
 					} else if(var7 < this.groundLevel - 1) {
 						var8 = Block.bedrock.blockID;
 					} else if(var7 < this.groundLevel) {
-						if(this.groundLevel > this.waterLevel && this.defaultFluid == Block.waterMoving.blockID) {
+						var8 = this.levelTheme.getSoilBlock().blockID;
+						if(var8 == Block.dirt.blockID && this.groundLevel > this.waterLevel && this.defaultFluid == Block.waterMoving.blockID) {
 							var8 = Block.grass.blockID;
-						} else {
-							var8 = Block.dirt.blockID;
 						}
 					} else if(var7 < this.waterLevel) {
-						var8 = this.defaultFluid;
+						if (var7 == this.waterLevel - 1 && this.levelTheme.hasSnow()) {
+							var8 = Block.ice.blockID;
+						} else {
+							var8 = this.defaultFluid;
+						}
+					} else if(var7 < this.groundLevel + 1 && this.levelTheme.hasSnow()) {
+						var8 = Block.snow.blockID;
 					}
 
 					var4[(var7 * this.length + var6) * this.width + var2] = (byte)var8;
@@ -121,41 +129,28 @@
 			}
 		}
 
-		this.heightMap = new int[var1 * var3];
-		Arrays.fill(this.heightMap, this.height);
-		if(var5 == null) {
+		if (var5 == null) {
 			this.data = new byte[var4.length];
-			this.lightUpdates = new Light(this);
-			boolean var10 = true;
-			World var11 = this;
-			var2 = this.skylightSubtracted;
-
-			for(var3 = 0; var3 < var11.width; ++var3) {
-				for(int var12 = 0; var12 < var11.length; ++var12) {
-					int var13;
-					for(var13 = var11.height - 1; var13 > 0 && Block.lightOpacity[var11.getBlockId(var3, var13, var12)] == 0; --var13) {
-					}
-
-					var11.heightMap[var3 + var12 * var11.width] = var13 + 1;
-
-					for(var13 = 0; var13 < var11.height; ++var13) {
-						var6 = (var13 * var11.length + var12) * var11.width + var3;
-						var7 = var11.heightMap[var3 + var12 * var11.width];
-						var7 = var13 >= var7 ? var2 : 0;
-						byte var14 = var11.blocks[var6];
-						if(var7 < Block.lightValue[var14]) {
-							var7 = Block.lightValue[var14];
-						}
-
-						var11.data[var6] = (byte)((var11.data[var6] & 240) + var7);
-					}
-				}
-			}
-
-			var11.lightUpdates.updateBlockLight(0, 0, 0, var11.width, var11.height, var11.length);
 		} else {
 			this.data = var5;
-			this.lightUpdates = new Light(this);
+		}
+
+		if (var5a == null) {
+			this.light = new byte[var4.length];
+		} else {
+			this.light = var5a;
+		}
+
+		if (var5b == null) {
+			this.heightMap = new int[var1 * var3];
+			Arrays.fill(this.heightMap, this.height);
+			this.initLighting();
+		} else {
+			this.heightMap = var5b;
+		}
+
+		if (var5a != null) {
+			this.lightingToUpdate.clear();
 		}
 
 		for(var2 = 0; var2 < this.worldAccesses.size(); ++var2) {
@@ -163,13 +158,12 @@
 		}
 
 		this.tickList.clear();
-		this.findSpawn();
+		this.findSpawn(new Random());
 		this.load();
 		System.gc();
 	}
 
-	public final void findSpawn() {
-		Random var1 = new Random();
+	public final void findSpawn(Random var1) {
 		int var2 = 0;
 
 		while(true) {
@@ -183,10 +177,10 @@
 						++var2;
 						var3 = var1.nextInt(this.width / 2) + this.width / 4;
 						var4 = var1.nextInt(this.length / 2) + this.length / 4;
-						var5 = this.getFirstUncoveredBlock(var3, var4) + 1;
+						var5 = Math.max(this.getFirstUncoveredBlock(var3, var4) + 1, 3);
 						if(var2 == 1000000) {
 							this.xSpawn = var3;
-							this.ySpawn = this.height + 100;
+							this.ySpawn = var5;
 							this.zSpawn = var4;
 							this.rotSpawn = 180.0F;
 							return;
@@ -267,12 +261,12 @@
 					Block var11 = Block.blocksList[this.getBlockId(var3, var9, var10)];
 					AxisAlignedBB var12;
 					if(var11 != null) {
-						var12 = var11.getCollisionBoundingBoxFromPool(var3, var9, var10);
+						var12 = var11.getCollisionBoundingBoxFromPool(this, var3, var9, var10);
 						if(var12 != null && var1.intersectsWith(var12)) {
 							var2.add(var12);
 						}
 					} else if(this.groundLevel < 0 && (var9 < this.groundLevel || var9 < this.waterLevel)) {
-						var12 = Block.bedrock.getCollisionBoundingBoxFromPool(var3, var9, var10);
+						var12 = Block.bedrock.getCollisionBoundingBoxFromPool(this, var3, var9, var10);
 						if(var12 != null && var1.intersectsWith(var12)) {
 							var2.add(var12);
 						}
@@ -286,41 +280,75 @@
 
 	public final void swap(int var1, int var2, int var3, int var4, int var5, int var6) {
 		int var7 = this.getBlockId(var1, var2, var3);
+		int var7a = this.getBlockMetadata(var1, var2, var3);
 		int var8 = this.getBlockId(var4, var5, var6);
-		this.setBlock(var1, var2, var3, var8);
-		this.setBlock(var4, var5, var6, var7);
+		int var8a = this.getBlockMetadata(var4, var5, var6);
+		this.setBlock(var1, var2, var3, 0);
+		this.setBlock(var4, var5, var6, 0);
+		this.setBlockAndMetadata(var1, var2, var3, var8, var8a);
+		this.setBlockAndMetadata(var4, var5, var6, var7, var7a);
 		this.notifyBlocksOfNeighborChange(var1, var2, var3, var8);
 		this.notifyBlocksOfNeighborChange(var4, var5, var6, var7);
 	}
 
 	public final boolean setBlock(int var1, int var2, int var3, int var4) {
+		return this.setBlockAndMetadataFull(var1, var2, var3, var4, 0);
+	}
+
+	public final boolean setBlockWithNotify(int var1, int var2, int var3, int var4) {
+		if(this.setBlock(var1, var2, var3, var4)) {
+			this.notifyBlocksOfNeighborChange(var1, var2, var3, var4);
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	public final void setBlockAndMetadata(int var1, int var2, int var3, int var4, int var5) {
+		this.setBlockAndMetadataFull(var1, var2, var3, var4, var5);
+	}
+
+	private boolean setBlockAndMetadataFull(int var1, int var2, int var3, int var4, int var4a) {
 		if(var1 > 0 && var2 > 0 && var3 > 0 && var1 < this.width - 1 && var2 < this.height - 1 && var3 < this.length - 1) {
 			if(var4 == this.blocks[(var2 * this.length + var3) * this.width + var1]) {
+				this.setBlockMetadata(var1, var2, var3, var4a);
 				return false;
 			} else {
+				int var7 = this.getHeightValue(var1, var3);
 				if(var4 == 0 && (var1 == 0 || var3 == 0 || var1 == this.width - 1 || var3 == this.length - 1) && var2 >= this.groundLevel && var2 < this.waterLevel) {
 					var4 = Block.waterMoving.blockID;
 				}
 
-				byte var5 = this.blocks[(var2 * this.length + var3) * this.width + var1];
-				this.blocks[(var2 * this.length + var3) * this.width + var1] = (byte)var4;
-				this.setBlockMetadata(var1, var2, var3, 0);
+				int i = (var2 * this.length + var3) * this.width + var1;
+				byte var5 = this.blocks[i];
+				byte var5a = this.data[i];
+				this.blocks[i] = (byte)var4;
+				this.setBlockMetadata(var1, var2, var3, var4a);
 				if(var5 != 0) {
-					Block.blocksList[var5].onBlockRemoval(this, var1, var2, var3);
-				}
+					Block.blocksList[var5].onBlockRemoval(this, var1, var2, var3, var5a);
+					var4 = this.blocks[i];
+				}
+
+				if (Block.lightOpacity[var4] != 0) {
+					if (var2 >= var7) {
+						this.relightBlock(var1, var2 + 1, var3);
+					}
+				} else if (var2 == var7 - 1) {
+					this.relightBlock(var1, var2, var3);
+				}
+
+				this.scheduleLightingUpdate(EnumSkyBlock.Sky, var1, var2, var3, var1, var2, var3);
+				this.scheduleLightingUpdate(EnumSkyBlock.Block, var1, var2, var3, var1, var2, var3);
+				this.updateSkylight_do(var1, var3);
 
 				if(var4 != 0) {
 					Block.blocksList[var4].onBlockAdded(this, var1, var2, var3);
 				}
 
-				if(Block.lightOpacity[var5] != Block.lightOpacity[var4] || Block.lightValue[var5] != 0 || Block.lightValue[var4] != 0) {
-					this.lightUpdates.updateSkylight(var1, var3, 1, 1);
-					this.lightUpdates.updateBlockLight(var1, var2, var3, var1 + 1, var2 + 1, var3 + 1);
-				}
-
-				for(var4 = 0; var4 < this.worldAccesses.size(); ++var4) {
-					((IWorldAccess)this.worldAccesses.get(var4)).markBlockAndNeighborsNeedsUpdate(var1, var2, var3);
-				}
+				// setBlockMetadata already does the dirty work
+				// for(var4 = 0; var4 < this.worldAccesses.size(); ++var4) {
+				// 	((IWorldAccess)this.worldAccesses.get(var4)).markBlockAndNeighborsNeedsUpdate(var1, var2, var3);
+				// }
 
 				return true;
 			}
@@ -329,22 +357,21 @@
 		}
 	}
 
-	public final boolean setBlockWithNotify(int var1, int var2, int var3, int var4) {
-		if(this.setBlock(var1, var2, var3, var4)) {
+	public final boolean setBlockAndMetadataWithNotify(int var1, int var2, int var3, int var4, int var5) {
+		boolean notify = this.setBlockAndMetadataFull(var1, var2, var3, var4, var5);
+		if (notify) {
 			this.notifyBlocksOfNeighborChange(var1, var2, var3, var4);
-			return true;
-		} else {
-			return false;
 		}
+		return notify;
 	}
 
 	public final void notifyBlocksOfNeighborChange(int var1, int var2, int var3, int var4) {
-		this.notifyBlockOfNeighborChange(var1 - 1, var2, var3, var4);
-		this.notifyBlockOfNeighborChange(var1 + 1, var2, var3, var4);
-		this.notifyBlockOfNeighborChange(var1, var2 - 1, var3, var4);
-		this.notifyBlockOfNeighborChange(var1, var2 + 1, var3, var4);
-		this.notifyBlockOfNeighborChange(var1, var2, var3 - 1, var4);
-		this.notifyBlockOfNeighborChange(var1, var2, var3 + 1, var4);
+		this.notifyBlockOfNeighborChange(var1 - 1, var2, var3, 5);
+		this.notifyBlockOfNeighborChange(var1 + 1, var2, var3, 4);
+		this.notifyBlockOfNeighborChange(var1, var2 - 1, var3, 1);
+		this.notifyBlockOfNeighborChange(var1, var2 + 1, var3, 0);
+		this.notifyBlockOfNeighborChange(var1, var2, var3 - 1, 3);
+		this.notifyBlockOfNeighborChange(var1, var2, var3 + 1, 2);
 	}
 
 	public final boolean setTileNoUpdate(int var1, int var2, int var3, int var4) {
@@ -353,7 +380,6 @@
 				return false;
 			} else {
 				this.blocks[(var2 * this.length + var3) * this.width + var1] = (byte)var4;
-				this.lightUpdates.updateBlockLight(var1, var2, var3, var1 + 1, var2 + 1, var3 + 1);
 				return true;
 			}
 		} else {
@@ -399,7 +425,7 @@
 	}
 
 	public final void updateEntities() {
-		this.entityMap.updateEntities();
+		this.entityMap.updateEntities(this.simulationDistance, this.playerEntity);
 
 		for(int var1 = 0; var1 < this.list.size(); ++var1) {
 			TileEntity var2 = (TileEntity)this.list.get(var1);
@@ -409,7 +435,235 @@
 	}
 
 	public final void updateLighting() {
-		this.lightUpdates.updateLight();
+		updatingLighting();
+	}
+
+	public final void scheduleLightingUpdate(EnumSkyBlock var1, int var2, int var3, int var4, int var5, int var6, int var7) {
+		++lightingUpdatesScheduled;
+
+		try {
+			if(lightingUpdatesScheduled == 50) {
+				return;
+			}
+
+			int var9 = (var5 + var2) / 2;
+			int var10 = (var7 + var4) / 2;
+
+			int var11 = this.lightingToUpdate.size();
+			int var12;
+			var12 = 5;
+			if(var12 > var11) {
+				var12 = var11;
+			}
+
+			for(int var13 = 0; var13 < var12; ++var13) {
+				MetadataChunkBlock var14 = (MetadataChunkBlock)this.lightingToUpdate.get(this.lightingToUpdate.size() - var13 - 1);
+				if(var14.skyBlock == var1 && var14.getLightUpdated(var2, var3, var4, var5, var6, var7)) {
+					return;
+				}
+			}
+
+			this.lightingToUpdate.add(new MetadataChunkBlock(var1, var2, var3, var4, var5, var6, var7));
+			var12 = 1000000;
+			if(this.lightingToUpdate.size() > 1000000) {
+//				System.out.println("More than " + var12 + " updates, aborting lighting updates");
+//				this.lightingToUpdate.clear();
+			}
+		} finally {
+			--lightingUpdatesScheduled;
+		}
+
+	}
+
+	public void initLighting() {
+		Arrays.fill(this.heightMap, 0);
+		int minHeight = this.height - 1;
+		this.lightingToUpdate.clear();
+
+		for (int x = 0; x < this.width; x++) {
+			for (int z = 0; z < this.length; z++) {
+				this.setHeightValue(x, z, this.height - 1);
+				this.relightBlock(x, this.height - 1, z);
+				minHeight = Math.min(this.minHeight, this.getHeightValue(x, z));
+			}
+		}
+
+		this.minHeight = minHeight;
+
+		for (int x = 0; x < this.width; x++) {
+			for (int z = 0; z < this.length; z++) {
+				this.updateSkylight_do(x, z);
+			}
+		}
+	}
+
+	public int getHeightValue(int var1, int var2) {
+		return this.heightMap[var1 + var2 * this.width];
+	}
+
+	public void setHeightValue(int var1, int var2, int var3) {
+		this.heightMap[var1 + var2 * this.width] = var3;
+	}
+
+	private void updateSkylight_do(int var1, int var2) {
+		if (var1 < 0 || var1 >= this.width || var2 < 0 || var2 >= this.length) return;
+
+		int var3 = this.getHeightValue(var1, var2);
+		this.checkSkylightNeighborHeight(var1 - 1, var2, var3);
+		this.checkSkylightNeighborHeight(var1 + 1, var2, var3);
+		this.checkSkylightNeighborHeight(var1, var2 - 1, var3);
+		this.checkSkylightNeighborHeight(var1, var2 + 1, var3);
+	}
+
+	private void checkSkylightNeighborHeight(int var1, int var2, int var3) {
+		if (var1 < 0 || var1 >= this.width || var2 < 0 || var2 >= this.length || var3 < 0 || var3 >= this.height) return;
+
+		int var4 = this.getHeightValue(var1, var2);
+		if(var4 > var3) {
+			this.scheduleLightingUpdate(EnumSkyBlock.Sky, var1, var3, var2, var1, var4, var2);
+		} else if(var4 < var3) {
+			this.scheduleLightingUpdate(EnumSkyBlock.Sky, var1, var4, var2, var1, var3, var2);
+		}
+	}
+
+	private void relightBlock(int var1, int var2, int var3) {
+		int var4 = this.getHeightValue(var1, var3);
+		int var5 = var4;
+		if(var2 > var4) {
+			var5 = var2;
+		}
+
+		while(var5 > 0 && Block.lightOpacity[this.getBlockId(var1, var5 - 1, var3)] == 0) {
+			var5--;
+		}
+
+		if(var5 != var4) {
+			int dirtyMin = var5;
+			int dirtyMax = var4;
+			if (dirtyMin > dirtyMax) {
+				int dirtySwap = dirtyMax;
+				dirtyMax = dirtyMin;
+				dirtyMin = dirtySwap;
+			}
+
+			for(int j = 0; j < this.worldAccesses.size(); ++j) {
+				((IWorldAccess)this.worldAccesses.get(j)).markBlockRangeNeedsUpdate(var1, dirtyMin, var3, var1, dirtyMax, var3);
+			}
+
+			this.setHeightValue(var1, var3, var5);
+			int var7;
+			int var8;
+			int var9;
+			if(var5 < this.minHeight) {
+				this.minHeight = var5;
+			} else {
+				var7 = this.height - 1;
+
+				for(var8 = 0; var8 < 16; ++var8) {
+					for(var9 = 0; var9 < 16; ++var9) {
+						if(this.getHeightValue(var8, var9) < var7) {
+							var7 = getHeightValue(var8, var9);
+						}
+					}
+				}
+
+				this.minHeight = var7;
+			}
+
+			var7 = var1;
+			var8 = var3;
+			if(var5 < var4) {
+				for(var9 = var5; var9 < var4; ++var9) {
+					this.setSavedLightValue(EnumSkyBlock.Sky, var1, var9, var3, 15);
+				}
+			} else {
+				this.scheduleLightingUpdate(EnumSkyBlock.Sky, var7, var4, var8, var7, var5, var8);
+
+				for(var9 = var4; var9 < var5; ++var9) {
+					this.setSavedLightValue(EnumSkyBlock.Sky, var1, var9, var3, 0);
+				}
+			}
+
+			var9 = 15;
+
+			int var10;
+			for(var10 = var5; var5 > 0 && var9 > 0; this.setSavedLightValue(EnumSkyBlock.Sky, var1, var5, var3, var9)) {
+				--var5;
+				int var11 = Block.lightOpacity[this.getBlockId(var1, var5, var3)];
+				if(var11 == 0) {
+					var11 = 1;
+				}
+
+				var9 -= var11;
+				if(var9 < 0) {
+					var9 = 0;
+				}
+			}
+
+			while(var5 > 0 && Block.lightOpacity[this.getBlockId(var1, var5 - 1, var3)] == 0) {
+				--var5;
+			}
+
+			if(var5 != var10) {
+				if (var5 > var10) {
+					int swap = var5;
+					var5 = var10;
+					var10 = swap;
+				}
+
+				if (var5 > dirtyMin) {
+					var5 = dirtyMin;
+				}
+
+				if (var10 < dirtyMax) {
+					var10 = dirtyMax;
+				}
+
+				this.scheduleLightingUpdate(EnumSkyBlock.Sky, var7 - 1, var5, var8 - 1, var7 + 1, var10, var8 + 1);
+			}
+		}
+	}
+
+	public final boolean updatingLighting() {
+		if(this.lightingUpdatesCounter >= 50) {
+			return false;
+		}
+		++this.lightingUpdatesCounter;
+
+		int var1 = 500;
+
+		while(!this.lightingToUpdate.isEmpty()) {
+			--var1;
+			if(var1 <= 0) {
+				--this.lightingUpdatesCounter;
+				return true;
+			}
+
+			((MetadataChunkBlock)this.lightingToUpdate.remove(this.lightingToUpdate.size() - 1)).updateLight(this);
+		}
+
+		--this.lightingUpdatesCounter;
+		return false;
+	}
+
+	public final void neighborLightPropagationChanged(EnumSkyBlock var1, int var2, int var3, int var4, int var5) {
+		if(var2 >= 0 && var2 < this.width && var3 >= 0 && var3 < this.height && var4 >= 0 && var4 < this.length) {
+			if(var1 == EnumSkyBlock.Sky) {
+				if(this.canBlockSeeTheSky(var2, var3, var4)) {
+					var5 = 15;
+				}
+			} else if(var1 == EnumSkyBlock.Block) {
+				int var6 = this.getBlockId(var2, var3, var4);
+				if(Block.lightValue[var6] > var5) {
+					var5 = Block.lightValue[var6];
+				}
+			}
+
+			if(this.getSavedLightValue(var1, var2, var3, var4) != var5) {
+				this.scheduleLightingUpdate(var1, var2, var3, var4, var2, var3, var4);
+			}
+
+		}
 	}
 
 	public final float getStarBrightness(float var1) {
@@ -497,7 +751,7 @@
 
 	public final int getSkyBrightness() {
 		float var1 = this.getCelestialAngle(1.0F);
-		var1 = MathHelper.cos(var1 * (float)Math.PI * 2.0F) * 1.5F + 0.5F;
+		var1 = MathHelper.cos(var1 * (float)Math.PI * 2.0F) * 2.0F + 0.5F;
 		if(var1 < 0.0F) {
 			var1 = 0.0F;
 		}
@@ -525,12 +779,8 @@
 		}
 
 		int var1 = this.getSkyBrightness();
-		if(this.skylightSubtracted > var1) {
-			this.updateChunkLight(this.skylightSubtracted - 1);
-		}
-
-		if(this.skylightSubtracted < var1) {
-			this.updateChunkLight(this.skylightSubtracted + 1);
+		if(this.skylightSubtracted != var1) {
+			this.updateChunkLight(var1);
 		}
 
 		++this.playTime;
@@ -548,9 +798,9 @@
 		int var4 = this.width - 1;
 		int var5 = this.height - 1;
 		int var6 = this.tickList.size();
-		if(var6 > 200) {
-			var6 = 200;
-		}
+//		if(var6 > 1000) {
+//			var6 = 1000;
+//		}
 
 		int var7;
 		int var10;
@@ -576,16 +826,54 @@
 		var6 = this.updateLCG / 200;
 		this.updateLCG -= var6 * 200;
 
-		for(var7 = 0; var7 < var6; ++var7) {
+		int px = MathHelper.floor_float(playerEntity.posX);
+		int py = MathHelper.floor_float(playerEntity.posY);
+		int pz = MathHelper.floor_float(playerEntity.posZ);
+		int minX = MathHelper.clamp(px - this.simulationDistance, 1, this.width - 2);
+		int minY = MathHelper.clamp(py - this.simulationDistance, 1, this.height - 2);
+		int minZ = MathHelper.clamp(pz - this.simulationDistance, 1, this.length - 2);
+		int maxX = MathHelper.clamp(px + this.simulationDistance, 1, this.width - 2);
+		int maxY = MathHelper.clamp(py + this.simulationDistance, 1, this.height - 2);
+		int maxZ = MathHelper.clamp(pz + this.simulationDistance, 1, this.length - 2);
+		int updateWidth = maxX - minX;
+		int updateHeight = maxY - minY;
+		int updateLength = maxZ - minZ;
+		int updateCount = updateWidth * updateHeight * updateLength / 400;
+
+		for(var7 = 0; var7 < updateCount; ++var7) {
 			this.randId = this.randId * 3 + 1013904223;
 			int var13 = this.randId >> 2;
-			int var14 = var13 & var4;
-			var10 = var13 >> var1 & var3;
-			var13 = var13 >> var1 + var2 & var5;
-			byte var15 = this.blocks[(var13 * this.length + var10) * this.width + var14];
+			int var14 = Math.floorMod(var13, updateWidth) + minX;
+			var10 = Math.floorMod(var13 / updateWidth, updateLength) + minZ;
+			var13 = Math.floorMod(var13 / updateWidth / updateLength, updateHeight) + minY;
+			int var15 = this.blocks[(var13 * this.length + var10) * this.width + var14] & 0xFF;
 			if(Block.tickOnLoad[var15]) {
 				Block.blocksList[var15].updateTick(this, var14, var13, var10, this.random);
 			}
+
+			if(this.levelTheme.hasSnow() && this.rand.nextInt(4) == 0) {
+				this.randId = this.randId * 3 + 1013904223;
+				var6 = this.randId >> 2;
+				int var7a = Math.floorMod(var13, updateWidth) + minX;
+				int var8 = Math.floorMod(var13 / updateWidth, updateLength) + minZ;
+				int var9 = this.height - 1;
+				Block b;
+				while (var9 > 0 && ((b = Block.blocksList[this.getBlockId(var7a, var9 - 1, var8)]) == null
+						|| (!b.material.getIsSolid() && !b.material.getIsLiquid()))) {
+					var9--;
+				}
+
+				if(var9 >= 0 && var9 < this.height && this.getSavedLightValue(EnumSkyBlock.Block, var7a, var9, var8) < 10) {
+					var10 = this.getBlockId(var7a, var9 - 1, var8);
+					if(this.getBlockId(var7a, var9, var8) == 0 && Block.snow.canPlaceBlockAt(this, var7a, var9, var8)) {
+						this.setBlockWithNotify(var7a, var9, var8, Block.snow.blockID);
+					}
+
+					if(var10 == Block.waterStill.blockID && this.getBlockMetadata(var7a, var9 - 1, var8) == 0) {
+						this.setBlockWithNotify(var7a, var9 - 1, var8, Block.ice.blockID);
+					}
+				}
+			}
 		}
 
 	}
@@ -690,38 +978,60 @@
 		return false;
 	}
 
-	public final boolean handleMaterialAcceleration(AxisAlignedBB var1, Material var2) {
+	public final boolean handleMaterialAcceleration(AxisAlignedBB var1, Material var2, Entity var2a) {
 		int var3 = (int)var1.minX;
 		int var4 = (int)var1.maxX + 1;
 		int var5 = (int)var1.minY;
 		int var6 = (int)var1.maxY + 1;
 		int var7 = (int)var1.minZ;
 		int var11 = (int)var1.maxZ + 1;
+		boolean var9a = false;
+		Vec3D var10 = new Vec3D(0.0F, 0.0F, 0.0F);
 
 		for(var3 = var3; var3 < var4; ++var3) {
 			for(int var8 = var5; var8 < var6; ++var8) {
 				for(int var9 = var7; var9 < var11; ++var9) {
-					Block var10 = Block.blocksList[this.getBlockId(var3, var8, var9)];
-					if(var10 != null && var10.material == var2) {
-						return true;
+					Block var10a = Block.blocksList[this.getBlockId(var3, var8, var9)];
+					if(var10a != null && var10a.material == var2) {
+						float var16 = (float)(var8 + 1) - BlockFluid.getFluidHeightPercent(this.getBlockMetadata(var3, var8, var9));
+						if(var6 >= var16) {
+							var9a = true;
+							var10a.velocityToAddToEntity(this, var3, var8, var9, var10);
+						}
 					}
 				}
 			}
 		}
 
-		return false;
+		if(var10.xCoord * var10.xCoord + var10.yCoord * var10.yCoord + var10.zCoord * var10.yCoord > 0.0F) {
+			var10 = var10.normalize();
+			var2a.motionX += var10.xCoord * 0.004F;
+			var2a.motionY += var10.yCoord * 0.004F;
+			var2a.motionZ += var10.zCoord * 0.004F;
+		}
+
+		return var9a;
 	}
 
 	public final void scheduleBlockUpdate(int var1, int var2, int var3, int var4) {
+		this.scheduleBlockUpdate(var1, var2, var3, var4, var4 > 0 ? Block.blocksList[var4].tickRate() : 0);
+	}
+
+	public final void scheduleBlockUpdate(int var1, int var2, int var3, int var4, int var4a) {
 		NextTickListEntry var5 = new NextTickListEntry(var1, var2, var3, var4);
-		if(var4 > 0) {
-			var3 = Block.blocksList[var4].tickRate();
-			var5.scheduledTime = var3;
-		}
-
+		var5.scheduledTime = var4a;
 		this.tickList.add(var5);
 	}
 
+	public boolean isBlockUpdateScheduled(int x, int y, int z, int block) {
+		for (NextTickListEntry tick : (List<NextTickListEntry>)this.tickList) {
+			if (tick.blockID == block && tick.xCoord == x && tick.yCoord == y && tick.zCoord == z) {
+				return true;
+			}
+		}
+		return false;
+	}
+
 	public final boolean checkIfAABBIsClear1(AxisAlignedBB var1) {
 		return this.entityMap.getEntitiesWithinAABB((Entity)null, var1).size() == 0;
 	}
@@ -790,7 +1100,60 @@
 			var3 = this.length - 1;
 		}
 
-		return this.blocks[(var2 * this.length + var3) * this.width + var1] == Block.stairSingle.blockID ? (var2 < this.height - 1 ? (byte)(this.data[((var2 + 1) * this.length + var3) * this.width + var1] & 15) : 15) : (byte)(this.data[(var2 * this.length + var3) * this.width + var1] & 15);
+		if (Block.blocksList[this.getBlockId(var1, var2, var3)] instanceof BlockStep) {
+			if (var2 < this.height - 1) {
+				var2 += 1;
+			} else {
+				return (byte)(15 - this.skylightSubtracted);
+			}
+		}
+
+		return (byte)Math.max(this.getSavedLightValue(EnumSkyBlock.Sky, var1, var2, var3) - (15 - this.skylightSubtracted), this.getSavedLightValue(EnumSkyBlock.Block, var1, var2, var3));
+	}
+
+	public final int getSavedLightValue(EnumSkyBlock var1, int var2, int var3, int var4) {
+		if(var2 < 0) {
+			var2 = 0;
+		} else if(var2 >= this.width) {
+			var2 = this.width - 1;
+		}
+
+		if(var3 < 0) {
+			var3 = 0;
+		} else if(var3 >= this.height) {
+			var3 = this.height - 1;
+		}
+
+		if(var4 < 0) {
+			var4 = 0;
+		} else if(var4 >= this.length) {
+			var4 = this.length - 1;
+		}
+
+		byte light = this.light[(var3 * this.length + var4) * this.width + var2];
+		if (var1 == EnumSkyBlock.Sky) {
+			light >>>= 4;
+		}
+
+		return light & 15;
+	}
+
+	public final void setSavedLightValue(EnumSkyBlock var1, int var2, int var3, int var4, int value) {
+		int i = (var3 * this.length + var4) * this.width + var2;
+		byte light = this.light[i];
+		if (var1 == EnumSkyBlock.Sky) {
+			light &= (byte) 15;
+			light |= (byte) (value << 4);
+		} else {
+			light &= (byte) 240;
+			light |= (byte) (value & 15);
+		}
+
+		this.light[i] = light;
+
+		for(int var7 = 0; var7 < this.worldAccesses.size(); ++var7) {
+			((IWorldAccess)this.worldAccesses.get(var7)).markBlockAndNeighborsNeedsUpdate(var2, var3, var4);
+		}
 	}
 
 	public final byte getBlockMetadata(int var1, int var2, int var3) {
@@ -812,7 +1175,7 @@
 			var3 = this.length - 1;
 		}
 
-		return (byte)(this.data[(var2 * this.length + var3) * this.width + var1] >>> 4 & 15);
+		return this.data[(var2 * this.length + var3) * this.width + var1];
 	}
 
 	public final void setBlockMetadata(int var1, int var2, int var3, int var4) {
@@ -834,7 +1197,7 @@
 			var3 = this.length - 1;
 		}
 
-		this.data[(var2 * this.length + var3) * this.width + var1] = (byte)((this.data[(var2 * this.length + var3) * this.width + var1] & 15) + (var4 << 4));
+		this.data[(var2 * this.length + var3) * this.width + var1] = (byte)var4;
 
 		for(var4 = 0; var4 < this.worldAccesses.size(); ++var4) {
 			((IWorldAccess)this.worldAccesses.get(var4)).markBlockAndNeighborsNeedsUpdate(var1, var2, var3);
@@ -853,6 +1216,10 @@
 	}
 
 	public final MovingObjectPosition rayTraceBlocks(Vec3D var1, Vec3D var2) {
+		return this.rayTraceBlocks(var1, var2, false);
+	}
+
+	public final MovingObjectPosition rayTraceBlocks(Vec3D var1, Vec3D var2, boolean var2a) {
 		if(!Float.isNaN(var1.xCoord) && !Float.isNaN(var1.yCoord) && !Float.isNaN(var1.zCoord)) {
 			if(!Float.isNaN(var2.xCoord) && !Float.isNaN(var2.yCoord) && !Float.isNaN(var2.zCoord)) {
 				int var3 = MathHelper.floor_float(var2.xCoord);
@@ -971,7 +1338,7 @@
 
 					int var21 = this.getBlockId(var6, var7, var8);
 					Block var23 = Block.blocksList[var21];
-					if(var21 > 0 && var23.isCollidable()) {
+					if(var21 > 0 && (var23.isCollidable() || var2a && var23 instanceof BlockFluid && this.getBlockMetadata(var6, var7, var8) == 0)) {
 						MovingObjectPosition var22 = var23.collisionRayTrace(this, var6, var7, var8, var1, var2);
 						if(var22 != null) {
 							return var22;
@@ -989,75 +1356,7 @@
 	}
 
 	public final boolean growTrees(int var1, int var2, int var3) {
-		int var4 = this.random.nextInt(3) + 4;
-		boolean var5 = true;
-		if(var2 > 0 && var2 + var4 + 1 <= this.height) {
-			int var6;
-			int var8;
-			int var9;
-			int var10;
-			for(var6 = var2; var6 <= var2 + 1 + var4; ++var6) {
-				byte var7 = 1;
-				if(var6 == var2) {
-					var7 = 0;
-				}
-
-				if(var6 >= var2 + 1 + var4 - 2) {
-					var7 = 2;
-				}
-
-				for(var8 = var1 - var7; var8 <= var1 + var7 && var5; ++var8) {
-					for(var9 = var3 - var7; var9 <= var3 + var7 && var5; ++var9) {
-						if(var8 >= 0 && var6 >= 0 && var9 >= 0 && var8 < this.width && var6 < this.height && var9 < this.length) {
-							var10 = this.blocks[(var6 * this.length + var9) * this.width + var8] & 255;
-							if(var10 != 0) {
-								var5 = false;
-							}
-						} else {
-							var5 = false;
-						}
-					}
-				}
-			}
-
-			if(!var5) {
-				return false;
-			} else {
-				var6 = this.blocks[((var2 - 1) * this.length + var3) * this.width + var1] & 255;
-				if((var6 == Block.grass.blockID || var6 == Block.dirt.blockID) && var2 < this.height - var4 - 1) {
-					this.setBlockWithNotify(var1, var2 - 1, var3, Block.dirt.blockID);
-
-					int var13;
-					for(var13 = var2 - 3 + var4; var13 <= var2 + var4; ++var13) {
-						var8 = var13 - (var2 + var4);
-						var9 = 1 - var8 / 2;
-
-						for(var10 = var1 - var9; var10 <= var1 + var9; ++var10) {
-							int var12 = var10 - var1;
-
-							for(var6 = var3 - var9; var6 <= var3 + var9; ++var6) {
-								int var11 = var6 - var3;
-								if((Math.abs(var12) != var9 || Math.abs(var11) != var9 || this.random.nextInt(2) != 0 && var8 != 0) && !Block.opaqueCubeLookup[this.getBlockId(var10, var13, var6)]) {
-									this.setBlockWithNotify(var10, var13, var6, Block.leaves.blockID);
-								}
-							}
-						}
-					}
-
-					for(var13 = 0; var13 < var4; ++var13) {
-						if(!Block.opaqueCubeLookup[this.getBlockId(var1, var2 + var13, var3)]) {
-							this.setBlockWithNotify(var1, var2 + var13, var3, Block.wood.blockID);
-						}
-					}
-
-					return true;
-				} else {
-					return false;
-				}
-			}
-		} else {
-			return false;
-		}
+		return this.levelTheme.getGrownTreeType(this.random).generate(this, this.random, var1, var2, var3);
 	}
 
 	public final Entity getPlayerEntity() {
@@ -1587,7 +1886,11 @@
 	}
 
 	public final String debugSkylightUpdates() {
-		return "" + this.tickList.size() + ". L: " + this.lightUpdates.debugLightUpdates();
+		return "" + this.tickList.size() + ". L: " + this.lightingToUpdate.size();
+	}
+
+	public final int getLightingQueue() {
+		return this.lightingToUpdate.size();
 	}
 
 	public final void setLevel() {
@@ -1602,22 +1905,122 @@
 	}
 
 	private void updateChunkLight(int var1) {
-		this.lightUpdates.updateDaylightCycle(var1);
+		this.skylightSubtracted = var1;
+		for(int var5 = 0; var5 < this.worldAccesses.size(); ++var5) {
+			((IWorldAccess)this.worldAccesses.get(var5)).updateAllRenderers();
+		}
 	}
 
 	public final boolean canBlockSeeTheSky(int var1, int var2, int var3) {
-		if(this.heightMap[var1 + var3 * this.width] <= var2) {
-			return true;
-		} else {
-			while(var2 < this.height) {
-				if(Block.opaqueCubeLookup[this.getBlockId(var1, var2, var3)]) {
-					return false;
-				}
-
-				++var2;
-			}
-
-			return true;
+		return var2 >= this.getHeightValue(var1, var3);
+	}
+
+	public final void markBlocksDirty(int var1, int var2, int var3, int var4, int var5, int var6) {
+		for(int var7 = 0; var7 < this.worldAccesses.size(); ++var7) {
+			((IWorldAccess)this.worldAccesses.get(var7)).markBlockRangeNeedsUpdate(var1, var2, var3, var4, var5, var6);
+		}
+
+	}
+
+	public static long powerCoord(int var1, int var2, int var3, int var4) {
+		return (long)((short)var4) << 48 | (long)var1 << 32 | (long)var2 << 16 | (long)var3;
+	}
+
+	public static int powerDir(int x, int y, int z) {
+		int dir = -1;
+		if (y == 0) {
+			if (x == 0) {
+				dir = 3 - ((z + 1) >> 1);
+			} else if (z == 0) {
+				dir = 5 - ((x + 1) >> 1);
+			}
+		} else if (x == 0 && z == 0) {
+			dir = 1 - ((y + 1) >> 1);
+		}
+		return dir;
+	}
+
+	public boolean canPowerTransmit(int x, int y, int z, int xx, int yy, int zz, int dir, boolean gear) {
+		boolean ex = xx == x;
+		boolean ey = yy == y;
+		boolean ez = zz == z;
+		return dir != -1 || gear && this.getBlockId(xx, yy, zz) == Block.cog.blockID &&
+				  (this.isBlockNormalCube(x - 1, y, z) && (!ez || !ey) && xx <= x && !(!ez && !ey)
+				|| this.isBlockNormalCube(x + 1, y, z) && (!ez || !ey) && xx >= x && !(!ez && !ey)
+				|| this.isBlockNormalCube(x, y - 1, z) && (!ex || !ez) && yy <= y && !(!ex && !ez)
+				|| this.isBlockNormalCube(x, y + 1, z) && (!ex || !ez) && yy >= y && !(!ex && !ez)
+				|| this.isBlockNormalCube(x, y, z - 1) && (!ex || !ey) && zz <= z && !(!ex && !ey)
+				|| this.isBlockNormalCube(x, y, z + 1) && (!ex || !ey) && zz >= z && !(!ex && !ey));
+	}
+
+	public void transmitPowerToNeighbors(int x, int y, int z) {
+		Set<Long> poweredBlocks = new HashSet<>();
+		for (int xx = x - 1; xx <= x + 1; xx++) {
+			for (int yy = y - 1; yy <= y + 1; yy++) {
+				for (int zz = z - 1; zz <= z + 1; zz++) {
+					if ((xx != x || yy != y || zz != z)
+							&& (xx == x || yy == y || zz == z)) {
+						int dir = powerDir(xx - x, yy - y, zz - z);
+						if (canPowerTransmit(x, y, z, xx, yy, zz, dir, this.getBlockId(xx, yy, zz) == Block.cog.blockID)) {
+							this.transmitPower(poweredBlocks, xx, yy, zz, dir);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	public void transmitPowerInDirection(int x, int y, int z, int dir) {
+		x += dir == 4 ? -1 : dir == 5 ? 1 : 0;
+		y += dir == 0 ? -1 : dir == 1 ? 1 : 0;
+		z += dir == 2 ? -1 : dir == 3 ? 1 : 0;
+		this.transmitPower(new HashSet<>(), x, y, z, dir);
+	}
+
+	public void transmitPower(Set<Long> poweredBlocks, int startX, int startY, int startZ, int startDir) {
+		Stack<Long> blocksToPower = new Stack<>();
+		blocksToPower.push(powerCoord(startX, startY, startZ, startDir));
+
+		long coordMask = (1L << 16) - 1;
+		long xyzMask = (1L << 48) - 1;
+
+		while (!blocksToPower.isEmpty()) {
+			long coord = blocksToPower.pop();
+			int x = (int)((coord >> 32) & coordMask);
+			int y = (int)((coord >> 16) & coordMask);
+			int z = (int)(coord & coordMask);
+			int dir = (short)((coord >> 48) & coordMask);
+
+			int block = this.getBlockId(x, y, z);
+			if (poweredBlocks.contains(coord & xyzMask)) continue;
+			if (Block.blocksList[block] != null && (Block.conductive[block] || Block.blocksList[block].canReceivePower(this, x, y, z, dir))) {
+				poweredBlocks.add(coord & xyzMask);
+				Block.blocksList[block].onPowerReceived(this, x, y, z, dir);
+			}
+			if (!Block.conductive[block]) continue;
+
+			this.spawnParticle("smoke",
+					x + this.random.nextFloat() * 1.5F - 0.25F,
+					y + this.random.nextFloat() * 1.5F - 0.25F,
+					z + this.random.nextFloat() * 1.5F - 0.25F,
+					0.0F, 0.0F, 0.0F);
+
+			boolean gear = block == Block.cog.blockID;
+
+			for (int xx = x - 1; xx <= x + 1; xx++) {
+				for (int yy = y - 1; yy <= y + 1; yy++) {
+					for (int zz = z - 1; zz <= z + 1; zz++) {
+						if ((xx != x || yy != y || zz != z)
+								&& (xx == x || yy == y || zz == z)) {
+							int pdir = powerDir(xx - x, yy - y, zz - z);
+							if (Block.blocksList[block].conductWithBlock(Block.blocksList[this.getBlockId(xx, yy, zz)])
+									&& canPowerTransmit(x, y, z, xx, yy, zz, pdir, gear)) {
+								blocksToPower.push(powerCoord(xx, yy, zz, pdir));
+							}
+						}
+					}
+				}
+			}
 		}
 	}
 
--- net/minecraft/client/controller/PlayerController.java
+++ net/minecraft/client/controller/PlayerController.java
@@ -38,10 +38,14 @@
 			float var10005 = (var8.soundVolume + 1.0F) / 2.0F;
 			var8 = var5.stepSound;
 			var10000.playSound(var10001, var10002, var10003, var10004, var10005, var8.soundPitch * 0.8F);
-			var5.onBlockDestroyedByPlayer(var4, var1, var2, var3, var6);
+			this.onBlockDestroyed(var1, var2, var3, var4, var5, var6);
 		}
 
 		return var7;
+	}
+
+	public void onBlockDestroyed(int var1, int var2, int var3, World var4, Block var5, int var6) {
+		var5.onBlockDestroyedByPlayer(var4, var1, var2, var3, var6);
 	}
 
 	public void sendBlockRemoving(int var1, int var2, int var3, int var4) {
--- /dev/null
+++ net/minecraft/game/item/ItemBucket.java
@@ -1,0 +1,90 @@
+package net.minecraft.game.item;
+
+import net.minecraft.game.entity.player.EntityPlayer;
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.physics.MovingObjectPosition;
+import net.minecraft.game.physics.Vec3D;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+import util.MathHelper;
+
+public final class ItemBucket extends Item {
+	private int isFull;
+
+	public ItemBucket(int var1, int var2) {
+		super(var1);
+		this.maxStackSize = 1;
+		this.isFull = var2;
+	}
+
+	public final ItemStack onItemRightClick(ItemStack var1, World var2, EntityPlayer var3) {
+		float var4 = var3.prevRotationPitch + (var3.rotationPitch - var3.prevRotationPitch);
+		float var5 = var3.prevRotationYaw + (var3.rotationYaw - var3.prevRotationYaw);
+		float var6 = var3.prevPosX + (var3.posX - var3.prevPosX);
+		float var8 = var3.prevPosY + (var3.posY - var3.prevPosY);
+		float var10 = var3.prevPosZ + (var3.posZ - var3.prevPosZ);
+		Vec3D var12 = new Vec3D(var6, var8, var10);
+		float var17 = MathHelper.cos(-var5 * ((float)Math.PI / 180.0F) - (float)Math.PI);
+		var5 = MathHelper.sin(-var5 * ((float)Math.PI / 180.0F) - (float)Math.PI);
+		float var7 = -MathHelper.cos(-var4 * ((float)Math.PI / 180.0F));
+		var4 = MathHelper.sin(-var4 * ((float)Math.PI / 180.0F));
+		var5 *= var7;
+		var17 *= var7;
+		Vec3D var14 = var12.addVector((float)var5 * 5.0F, (float)var4 * 5.0F, (float)var17 * 5.0F);
+		MovingObjectPosition var13 = var2.rayTraceBlocks(var12, var14, this.isFull == 0);
+		if(var13 == null) {
+			return var1;
+		} else {
+			if(var13.typeOfHit == 0) {
+				int var15 = var13.blockX;
+				int var16 = var13.blockY;
+				int var18 = var13.blockZ;
+				if(this.isFull == 0) {
+					if(var2.getBlockMaterial(var15, var16, var18) == Material.water && var2.getBlockMetadata(var15, var16, var18) == 0) {
+						var2.setBlockWithNotify(var15, var16, var18, 0);
+						return new ItemStack(Item.bucketWater);
+					}
+
+					if(var2.getBlockMaterial(var15, var16, var18) == Material.lava && var2.getBlockMetadata(var15, var16, var18) == 0) {
+						var2.setBlockWithNotify(var15, var16, var18, 0);
+						return new ItemStack(Item.bucketLava);
+					}
+				} else {
+					if(var13.sideHit == 0) {
+						--var16;
+					}
+
+					if(var13.sideHit == 1) {
+						++var16;
+					}
+
+					if(var13.sideHit == 2) {
+						--var18;
+					}
+
+					if(var13.sideHit == 3) {
+						++var18;
+					}
+
+					if(var13.sideHit == 4) {
+						--var15;
+					}
+
+					if(var13.sideHit == 5) {
+						++var15;
+					}
+
+					if(var2.getBlockId(var15, var16, var18) == 0 || !var2.getBlockMaterial(var15, var16, var18).isSolid()) {
+						var2.setBlockAndMetadataWithNotify(var15, var16, var18, this.isFull, 0);
+						if (!var2.survivalWorld) {
+							return var1;
+						}
+						return new ItemStack(Item.bucketEmpty);
+					}
+				}
+			}
+
+			return var1;
+		}
+	}
+}
--- net/minecraft/client/gui/container/GuiContainer.java
+++ net/minecraft/client/gui/container/GuiContainer.java
@@ -2,27 +2,34 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
+import net.minecraft.client.ItemTooltips;
 import net.minecraft.client.RenderHelper;
+import net.minecraft.client.gui.GuiRecipeGuide;
 import net.minecraft.client.gui.GuiScreen;
 import net.minecraft.client.player.EntityPlayerSP;
 import net.minecraft.client.render.RenderEngine;
 import net.minecraft.client.render.entity.RenderItem;
 import net.minecraft.game.IInventory;
 import net.minecraft.game.item.ItemStack;
+import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.GL11;
 
 public abstract class GuiContainer extends GuiScreen {
-	private static RenderItem itemRenderer = new RenderItem();
+	private static RenderItem itemRenderer = RenderItem.instance;
 	private ItemStack itemStack = null;
 	protected int xSize = 176;
 	protected int ySize = 166;
 	protected List inventorySlots = new ArrayList();
+	private int mouseX;
+	private int mouseY;
 
 	public void drawScreen(int var1, int var2, float var3) {
 		this.drawDefaultBackground();
 		int var13 = (this.width - this.xSize) / 2;
 		int var4 = (this.height - this.ySize) / 2;
 		this.drawGuiContainerBackgroundLayer();
+		super.drawScreen(var1, var2, var3);
 		GL11.glPushMatrix();
 		GL11.glRotatef(180.0F, 1.0F, 0.0F, 0.0F);
 		RenderHelper.enableStandardItemLighting();
@@ -31,6 +38,7 @@
 		GL11.glTranslatef((float)var13, (float)var4, 0.0F);
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 		GL11.glEnable(GL11.GL_NORMALIZE);
+		Slot hoverSlot = null;
 
 		for(int var5 = 0; var5 < this.inventorySlots.size(); ++var5) {
 			Slot var6;
@@ -57,6 +65,7 @@
 			}
 
 			if(var6.isAtCursorPos(var1, var2)) {
+				hoverSlot = var6;
 				GL11.glDisable(GL11.GL_LIGHTING);
 				GL11.glDisable(GL11.GL_DEPTH_TEST);
 				int var7 = var6.xPos;
@@ -78,9 +87,24 @@
 		GL11.glDisable(GL11.GL_LIGHTING);
 		GL11.glDisable(GL11.GL_DEPTH_TEST);
 		this.drawGuiContainerForegroundLayer();
-		GL11.glEnable(GL11.GL_LIGHTING);
-		GL11.glEnable(GL11.GL_DEPTH_TEST);
+
+		if (this.itemStack == null && hoverSlot != null && hoverSlot.getStack() != null) {
+			String tooltip = ItemTooltips.get(hoverSlot.getStack().itemID);
+			if (tooltip != null && tooltip.length() > 0) {
+				int tooltipX = var1 - var13 + 12;
+				int tooltipY = var2 - var4 - 12;
+				int tooltipWidth = this.fontRenderer.getStringWidth(tooltip);
+				drawGradientRect(tooltipX - 3, tooltipY - 3, tooltipX + tooltipWidth + 3, tooltipY + 11, -1073741824, -1073741824);
+				this.fontRenderer.drawStringWithShadow(tooltip, tooltipX, tooltipY, -1);
+			}
+		}
+
+//		GL11.glDisable(GL11.GL_LIGHTING);
+//		GL11.glEnable(GL11.GL_DEPTH_TEST);
 		GL11.glPopMatrix();
+
+		this.mouseX = var1;
+		this.mouseY = var2;
 	}
 
 	protected void drawGuiContainerForegroundLayer() {
@@ -143,7 +167,7 @@
 
 					ItemStack var9;
 					if(!var11.isItemValid(this.itemStack)) {
-						if(var12.itemID == this.itemStack.itemID) {
+						if(var12.itemID == this.itemStack.itemID && var12.itemDamage == this.itemStack.itemDamage) {
 							var9 = this.itemStack;
 							if(var9.getItem().getItemStackLimit() > 1) {
 								var6 = var12.stackSize;
@@ -169,7 +193,7 @@
 						return;
 					}
 
-					if(var12.itemID != this.itemStack.itemID) {
+					if(var12.itemID != this.itemStack.itemID || var12.itemDamage != this.itemStack.itemDamage) {
 						if(this.itemStack.stackSize > var11.inventory.getInventoryStackLimit()) {
 							return;
 						}
@@ -177,10 +201,6 @@
 						var11.putStack(this.itemStack);
 						this.itemStack = var12;
 					} else {
-						if(var12.itemID != this.itemStack.itemID) {
-							return;
-						}
-
 						if(var3 == 0) {
 							var6 = this.itemStack.stackSize;
 							if(var6 > var11.inventory.getInventoryStackLimit() - var12.stackSize) {
@@ -200,10 +220,6 @@
 
 							var12.stackSize += var6;
 						} else {
-							if(var3 != 1) {
-								return;
-							}
-
 							var6 = 1;
 							if(1 > var11.inventory.getInventoryStackLimit() - var12.stackSize) {
 								var6 = var11.inventory.getInventoryStackLimit() - var12.stackSize;
@@ -244,13 +260,36 @@
 			}
 		}
 
+		super.drawSlotInventory(var1, var2, var3);
+	}
+
+	private boolean func_20081_a(Slot var1, int var2, int var3) {
+		int var4 = (this.width - this.xSize) / 2;
+		int var5 = (this.height - this.ySize) / 2;
+		var2 -= var4;
+		var3 -= var5;
+		return var2 >= var1.xPos - 1 && var2 < var1.xPos + 16 + 1 && var3 >= var1.yPos - 1 && var3 < var1.yPos + 16 + 1;
+	}
+
+	protected Slot getSlotAtPosition(int var1, int var2) {
+		for(int var3 = 0; var3 < this.inventorySlots.size(); ++var3) {
+			Slot var4 = (Slot)this.inventorySlots.get(var3);
+			if(this.func_20081_a(var4, var1, var2)) {
+				return var4;
+			}
+		}
+
+		return null;
 	}
 
 	protected final void keyTyped(char var1, int var2) {
 		if(var2 == 1 || var2 == this.mc.options.keyBindInventory.keyCode) {
 			this.mc.displayGuiScreen((GuiScreen)null);
+		} else if (var2 == this.mc.options.keyBindRecipeGuide.keyCode) {
+			Slot hoverSlot = getSlotAtPosition(this.mouseX, this.mouseY);
+			if (hoverSlot != null)
+				this.mc.displayGuiScreen(new GuiRecipeGuide(hoverSlot.getStack()));
 		}
-
 	}
 
 	public void onGuiClosed() {
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeatureTree.java
@@ -1,0 +1,83 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+
+import java.util.Random;
+
+public class FeatureTree implements Feature {
+	@Override
+	public boolean generate(World world, Random random, int var1, int var2, int var3) {
+		int var4 = random.nextInt(3) + 4;
+		boolean var5 = true;
+		if(var2 > 0 && var2 + var4 + 1 <= world.height
+				&& var1 > 0 && var1 < world.width - 1
+				&& var3 > 0 && var3 < world.length - 1) {
+			int var6;
+			int var8;
+			int var9;
+			int var10;
+			for(var6 = var2; var6 <= var2 + 1 + var4; ++var6) {
+				byte var7 = 1;
+				if(var6 == var2) {
+					var7 = 0;
+				}
+
+				if(var6 >= var2 + 1 + var4 - 2) {
+					var7 = 2;
+				}
+
+				for(var8 = var1 - var7; var8 <= var1 + var7 && var5; ++var8) {
+					for(var9 = var3 - var7; var9 <= var3 + var7 && var5; ++var9) {
+						if(var8 >= 0 && var6 >= 0 && var9 >= 0 && var8 < world.width && var6 < world.height && var9 < world.length) {
+							var10 = world.getBlockId(var8, var6, var9);
+							if(var10 != 0 && var10 != Block.snow.blockID) {
+								var5 = false;
+							}
+						} else {
+							var5 = false;
+						}
+					}
+				}
+			}
+
+			if(!var5) {
+				return false;
+			} else {
+				var6 = world.getBlockId(var1, var2 - 1, var3);
+				if((var6 == Block.grass.blockID || var6 == Block.dirt.blockID) && var2 < world.height - var4 - 1) {
+					world.setBlockWithNotify(var1, var2 - 1, var3, Block.dirt.blockID);
+
+					int var13;
+					for(var13 = var2 - 3 + var4; var13 <= var2 + var4; ++var13) {
+						var8 = var13 - (var2 + var4);
+						var9 = 1 - var8 / 2;
+
+						for(var10 = var1 - var9; var10 <= var1 + var9; ++var10) {
+							int var12 = var10 - var1;
+
+							for(var6 = var3 - var9; var6 <= var3 + var9; ++var6) {
+								int var11 = var6 - var3;
+								if((Math.abs(var12) != var9 || Math.abs(var11) != var9 || random.nextInt(2) != 0 && var8 != 0) && !Block.opaqueCubeLookup[world.getBlockId(var10, var13, var6)]) {
+									world.setBlockWithNotify(var10, var13, var6, Block.leaves.blockID);
+								}
+							}
+						}
+					}
+
+					for(var13 = 0; var13 < var4; ++var13) {
+						if(!Block.opaqueCubeLookup[world.getBlockId(var1, var2 + var13, var3)]) {
+							world.setBlockWithNotify(var1, var2 + var13, var3, Block.wood.blockID);
+						}
+					}
+
+					return true;
+				} else {
+					return false;
+				}
+			}
+		} else {
+			return false;
+		}
+	}
+}
--- net/minecraft/client/ThreadDownloadResources.java
+++ net/minecraft/client/ThreadDownloadResources.java
@@ -1,13 +1,9 @@
 package net.minecraft.client;
 
-import java.io.BufferedReader;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
+import java.io.*;
 import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.StandardCopyOption;
 import java.util.ArrayList;
 
 public final class ThreadDownloadResources extends Thread {
@@ -27,6 +23,8 @@
 
 	public final void run() {
         try {
+			this.loadAllPackedResources();
+
             ArrayList<String> list = new ArrayList<String>();
             URL url = new URL("http://www.minecraft.net/resources/");
             BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(url.openStream()));
@@ -64,13 +62,9 @@
                         int index = s4.indexOf("/");
                         String substring = s4.substring(0, index);
                         String substring2 = s4.substring(index + 1);
-                        if (substring.equalsIgnoreCase("sound")) {
-                            minecraft.sndManager.addSound(substring2, file2);
-                        }
-                        else if (substring.equalsIgnoreCase("newsound")) {
-                            minecraft.sndManager.addSound(substring2, file2);
-                        }
-                        else if (substring.equalsIgnoreCase("music")) {
+                        if (substring.equalsIgnoreCase("sound") || substring.equalsIgnoreCase("newsound")) {
+                            minecraft.sndManager.addSound(substring2, file2);
+                        } else if (substring.equalsIgnoreCase("music") || substring.equalsIgnoreCase("newmusic")) {
                             minecraft.sndManager.addMusic(substring2, file2);
                         }
                     }
@@ -86,6 +80,41 @@
         catch (IOException ex) {
             ex.printStackTrace();
         }
+	}
+
+	private void loadAllPackedResources() throws IOException {
+		try (InputStream resourceListStream = this.getClass().getResourceAsStream("/resources.txt")) {
+			if (resourceListStream == null) {
+				return;
+			}
+
+			try (BufferedReader reader = new BufferedReader(new InputStreamReader(resourceListStream))) {
+				String line;
+				while ((line = reader.readLine()) != null) {
+					loadPackedResource(line, line.replaceFirst("/resources/", ""));
+				}
+			}
+		}
+	}
+
+	private void loadPackedResource(String inPath, String outPath) throws IOException {
+		try (InputStream stream = this.getClass().getResourceAsStream(inPath)) {
+			if (stream == null) {
+				throw new IOException("Resource " + inPath + " is invalid.");
+			}
+
+			File file = new File(this.resourcesFolder, outPath);
+			file.mkdirs();
+			Files.copy(stream, file.toPath(), StandardCopyOption.REPLACE_EXISTING);
+			int index = outPath.indexOf("/");
+            String substring = outPath.substring(0, index);
+            String substring2 = outPath.substring(index + 1);
+			if (substring.equalsIgnoreCase("sound") || substring.equalsIgnoreCase("newsound")) {
+                this.mc.sndManager.addSound(substring2, file);
+            } else if (substring.equalsIgnoreCase("music") || substring.equalsIgnoreCase("newmusic")) {
+                this.mc.sndManager.addMusic(substring2, file);
+            }
+		}
 	}
 
 	private void downloadResource(URL var1, File var2) throws IOException {
--- net/minecraft/game/level/block/BlockWorkbench.java
+++ net/minecraft/game/level/block/BlockWorkbench.java
@@ -5,7 +5,7 @@
 import net.minecraft.game.level.material.Material;
 
 public final class BlockWorkbench extends Block {
-	protected BlockWorkbench(int var1) {
+	public BlockWorkbench(int var1) {
 		super(58, Material.wood);
 		this.blockIndexInTexture = 59;
 	}
@@ -15,6 +15,7 @@
 	}
 
 	public final boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+		if (!var1.survivalWorld) return false;
 		var5.displayWorkbenchGUI();
 		return true;
 	}
--- net/minecraft/client/Timer.java
+++ net/minecraft/client/Timer.java
@@ -51,5 +51,6 @@
 		}
 
 		this.renderPartialTicks = this.elapsedPartialTicks;
+		this.timerSpeed = 1.0F;
 	}
 }
--- net/minecraft/game/level/block/BlockTorch.java
+++ net/minecraft/game/level/block/BlockTorch.java
@@ -8,12 +8,12 @@
 import net.minecraft.game.physics.Vec3D;
 
 public final class BlockTorch extends Block {
-	protected BlockTorch(int var1, int var2) {
+	public BlockTorch(int var1, int var2) {
 		super(50, 80, Material.circuits);
 		this.setTickOnLoad(true);
 	}
 
-	public final AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
+	public final AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
 		return null;
 	}
 
--- /dev/null
+++ net/minecraft/client/gui/GuiWorldDialog.java
@@ -1,0 +1,15 @@
+package net.minecraft.client.gui;
+
+import javax.swing.*;
+import java.io.File;
+
+final class GuiWorldDialog extends Thread {
+	private GuiLoadWorld screen;
+
+	GuiWorldDialog(GuiLoadWorld var1) {
+		this.screen = var1;
+	}
+
+	public final void run() {
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeatureBigMushroom.java
@@ -1,0 +1,160 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+
+import java.util.Random;
+
+public class FeatureBigMushroom implements Feature {
+    private final int mushroomType;
+
+    public FeatureBigMushroom() {
+        this(-1);
+    }
+
+    public FeatureBigMushroom(int mushroomType) {
+        this.mushroomType = mushroomType;
+    }
+
+    public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+        int var6 = var2.nextInt(2);
+        if(this.mushroomType >= 0) {
+            var6 = this.mushroomType;
+        }
+
+        int var7 = var2.nextInt(3) + 4;
+        boolean var8 = true;
+        if(var4 >= 1) {
+            if(var4 + var7 + 1 < var1.height && var3 - 3 > 0 && var3 + 3 < var1.width - 1 && var5 - 3 > 0 && var5 + 3 < var1.length - 1) {
+                int var9;
+                int var11;
+                int var12;
+                int var13;
+                for(var9 = var4; var9 <= var4 + 1 + var7; ++var9) {
+                    byte var10 = 3;
+                    if(var9 == var4) {
+                        var10 = 0;
+                    }
+
+                    for(var11 = var3 - var10; var11 <= var3 + var10 && var8; ++var11) {
+                        for(var12 = var5 - var10; var12 <= var5 + var10 && var8; ++var12) {
+                            if(var9 >= 0) {
+                                var13 = var1.getBlockId(var11, var9, var12);
+                                if(var13 != 0 && var13 != Block.leaves.blockID) {
+                                    var8 = false;
+                                }
+                                continue;
+                            }
+
+                            var8 = false;
+                        }
+                    }
+                }
+
+                if(!var8) {
+                    return false;
+                }
+
+                if(!(this.mushroomType < 0 ? Block.sapling : Block.mushroomBrown).canPlaceBlockAt(var1, var3, var4, var5)) {
+                    return false;
+                }
+
+                var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
+                var9 = var4 + var7;
+                if(var6 == 1) {
+                    var9 = var4 + var7 - 3;
+                }
+
+                int var15;
+                for(var15 = var9; var15 <= var4 + var7; ++var15) {
+                    var11 = 1;
+                    if(var15 < var4 + var7) {
+                        ++var11;
+                    }
+
+                    if(var6 == 0) {
+                        var11 = 3;
+                    }
+
+                    for(var12 = var3 - var11; var12 <= var3 + var11; ++var12) {
+                        for(var13 = var5 - var11; var13 <= var5 + var11; ++var13) {
+                            int var14 = 5;
+                            if(var12 == var3 - var11) {
+                                --var14;
+                            }
+
+                            if(var12 == var3 + var11) {
+                                ++var14;
+                            }
+
+                            if(var13 == var5 - var11) {
+                                var14 -= 3;
+                            }
+
+                            if(var13 == var5 + var11) {
+                                var14 += 3;
+                            }
+
+                            if(var6 == 0 || var15 < var4 + var7) {
+                                if((var12 == var3 - var11 || var12 == var3 + var11) && (var13 == var5 - var11 || var13 == var5 + var11)) {
+                                    continue;
+                                }
+
+                                if(var12 == var3 - (var11 - 1) && var13 == var5 - var11) {
+                                    var14 = 1;
+                                }
+
+                                if(var12 == var3 - var11 && var13 == var5 - (var11 - 1)) {
+                                    var14 = 1;
+                                }
+
+                                if(var12 == var3 + (var11 - 1) && var13 == var5 - var11) {
+                                    var14 = 3;
+                                }
+
+                                if(var12 == var3 + var11 && var13 == var5 - (var11 - 1)) {
+                                    var14 = 3;
+                                }
+
+                                if(var12 == var3 - (var11 - 1) && var13 == var5 + var11) {
+                                    var14 = 7;
+                                }
+
+                                if(var12 == var3 - var11 && var13 == var5 + (var11 - 1)) {
+                                    var14 = 7;
+                                }
+
+                                if(var12 == var3 + (var11 - 1) && var13 == var5 + var11) {
+                                    var14 = 9;
+                                }
+
+                                if(var12 == var3 + var11 && var13 == var5 + (var11 - 1)) {
+                                    var14 = 9;
+                                }
+                            }
+
+                            if(var14 == 5 && var15 < var4 + var7) {
+                                var14 = 0;
+                            }
+
+                            if((var14 != 0 || var4 >= var4 + var7 - 1) && !Block.opaqueCubeLookup[var1.getBlockId(var12, var15, var13)]) {
+                                var1.setBlockAndMetadata(var12, var15, var13, Block.brownMushroomBlock.blockID + var6, var14);
+                            }
+                        }
+                    }
+                }
+
+                for(var15 = 0; var15 < var7; ++var15) {
+                    var11 = var1.getBlockId(var3, var4 + var15, var5);
+                    if(!Block.opaqueCubeLookup[var11]) {
+                        var1.setBlockAndMetadata(var3, var4 + var15, var5, Block.brownMushroomBlock.blockID + var6, 10);
+                    }
+                }
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
--- net/minecraft/client/controller/PlayerControllerSP.java
+++ net/minecraft/client/controller/PlayerControllerSP.java
@@ -5,10 +5,12 @@
 import net.minecraft.client.sound.SoundManager;
 import net.minecraft.game.item.Item;
 import net.minecraft.game.item.ItemStack;
+import net.minecraft.game.item.ItemTool;
 import net.minecraft.game.level.MobSpawner;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.block.Block;
 import net.minecraft.game.level.block.StepSound;
+import util.MathHelper;
 
 public final class PlayerControllerSP extends PlayerController {
 	private int curBlockX = -1;
@@ -26,18 +28,24 @@
 
 	public final boolean sendBlockRemoved(int var1, int var2, int var3) {
 		int var4 = this.mc.theWorld.getBlockId(var1, var2, var3);
-		byte var5 = this.mc.theWorld.getBlockMetadata(var1, var2, var3);
+		int var5 = this.mc.theWorld.getBlockMetadata(var1, var2, var3) & 0xFF;
 		boolean var6 = super.sendBlockRemoved(var1, var2, var3);
+		boolean canHarvest = this.mc.thePlayer.canHarvestBlock(Block.blocksList[var4]);
 		EntityPlayerSP var7 = this.mc.thePlayer;
 		ItemStack var9 = var7.inventory.getCurrentItem();
 		if(var9 != null) {
-			Item.itemsList[var9.itemID].onBlockDestroyed(var9);
+			Item item = var9.getItem();
+			item.onBlockDestroyed(var9);
+			if (item instanceof ItemTool && ((ItemTool) item).silkTouch) {
+				var5 |= Block.DROP_FLAG_SILK_TOUCH;
+			}
+
 			if(var9.stackSize == 0) {
 				this.mc.thePlayer.destroyCurrentEquippedItem();
 			}
 		}
 
-		if(var6 && this.mc.thePlayer.canHarvestBlock(Block.blocksList[var4])) {
+		if(var6 && canHarvest) {
 			Block.blocksList[var4].dropBlockAsItem(this.mc.theWorld, var1, var2, var3, var5);
 		}
 
@@ -66,7 +74,8 @@
 				var4 = this.mc.theWorld.getBlockId(var1, var2, var3);
 				if(var4 != 0) {
 					Block var6 = Block.blocksList[var4];
-					this.curBlockDamage += var6.blockStrength(this.mc.thePlayer);
+					float strength = var6.blockStrength(this.mc.thePlayer);
+					this.curBlockDamage += strength;
 					if(this.blockDestroySoundCounter % 4.0F == 0.0F && var6 != null) {
 						SoundManager var10000 = this.mc.sndManager;
 						String var10001 = var6.stepSound.stepSoundDir2();
@@ -85,7 +94,7 @@
 						this.curBlockDamage = 0.0F;
 						this.prevBlockDamage = 0.0F;
 						this.blockDestroySoundCounter = 0.0F;
-						this.blockHitWait = 5;
+						this.blockHitWait = MathHelper.clamp(Math.round((1.0F - strength) * 5.0F), 0, 5);
 					}
 
 				}
--- net/minecraft/game/level/block/BlockBreakable.java
+++ net/minecraft/game/level/block/BlockBreakable.java
@@ -6,7 +6,7 @@
 public class BlockBreakable extends Block {
 	private boolean localFlag;
 
-	protected BlockBreakable(int var1, int var2, Material var3, boolean var4) {
+	public BlockBreakable(int var1, int var2, Material var3, boolean var4) {
 		super(var1, var2, var3);
 		this.localFlag = var4;
 	}
@@ -15,7 +15,7 @@
 		return false;
 	}
 
-	public final boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
+	public boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
 		int var6 = var1.getBlockId(var2, var3, var4);
 		return !this.localFlag && var6 == this.blockID ? false : super.shouldSideBeRendered(var1, var2, var3, var4, var5);
 	}
--- /dev/null
+++ net/minecraft/client/ThreadSaveLevel.java
@@ -1,0 +1,105 @@
+package net.minecraft.client;
+
+import com.mojang.nbt.NBTBase;
+import com.mojang.nbt.NBTTagCompound;
+
+import java.io.DataOutputStream;
+import java.io.File;
+import java.nio.file.Files;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.zip.GZIPOutputStream;
+
+public class ThreadSaveLevel extends Thread {
+    private static ThreadSaveLevel instance;
+
+    private final BlockingQueue<WorldSaveInfo> saveQueue = new LinkedBlockingQueue<>();
+    private final Minecraft mc;
+    private volatile WorldSaveInfo busySave;
+
+    public ThreadSaveLevel(Minecraft mc) {
+        this.mc = mc;
+    }
+
+    public void run() {
+        try {
+            while (true) {
+                WorldSaveInfo save = this.busySave = saveQueue.take();
+
+                try(DataOutputStream stream = new DataOutputStream(
+                        new GZIPOutputStream(
+                                Files.newOutputStream(save.file.toPath())))) {
+                    NBTBase.writeTag(save.data, stream);
+                    try {
+                        save.onSave.run();
+                    } catch (Exception e) {
+                        mc.ingameGUI.sendChatMessage("&cSomething went wrong after saving!");
+                        System.err.println("Error with post-save callback!");
+                        e.printStackTrace();
+                    }
+                } catch (Exception e) {
+                    mc.ingameGUI.sendChatMessage("&cFailed to write level to file!");
+                    System.err.println("Error writing level data!");
+                    e.printStackTrace();
+                }
+
+                this.busySave = null;
+            }
+        } catch (InterruptedException ignored) {
+        }
+        this.busySave = null;
+    }
+
+    public static void queue(NBTTagCompound data, File file, Runnable onSave) throws InterruptedException {
+        instance.saveQueue.add(new WorldSaveInfo(data, file, onSave));
+    }
+
+    public static void init(Minecraft mc) {
+        if (instance != null) return;
+        instance = new ThreadSaveLevel(mc);
+        instance.setDaemon(true);
+        instance.setName("Level saving thread");
+        instance.start();
+    }
+
+    public static boolean isBusy() {
+        return instance.isAlive() && instance.busySave != null;
+    }
+
+    public static boolean isBusyWithFile(File file) {
+        if (!instance.isAlive()) return false;
+        WorldSaveInfo busySave = instance.busySave;
+        return busySave != null && isSameBusyFile(busySave.file, file)
+                || instance.saveQueue.stream().anyMatch(i -> isSameBusyFile(i.file, file));
+    }
+
+    private static boolean isSameBusyFile(File a, File b) {
+        String aName = a.getName();
+        int aExtStart = aName.indexOf('.');
+        if (aExtStart != -1) {
+            aName = aName.substring(0, aExtStart);
+        }
+        a = new File(a.getParent(), aName);
+
+        String bName = b.getName();
+        int bExtStart = bName.indexOf('.');
+        if (bExtStart != -1) {
+            bName = bName.substring(0, bExtStart);
+        }
+        b = new File(b.getParent(), bName);
+
+        return a.equals(b);
+    }
+
+    private static class WorldSaveInfo {
+        public final NBTTagCompound data;
+        public final File file;
+        public final Runnable onSave;
+
+        private WorldSaveInfo(NBTTagCompound data, File file, Runnable onSave) {
+            this.data = data;
+            this.file = file;
+            this.onSave = onSave;
+        }
+    }
+}
--- /dev/null
+++ net/minecraft/game/level/block/BlockLamp.java
@@ -1,0 +1,33 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+import java.util.Random;
+
+public class BlockLamp extends Block {
+	private final int nextState;
+
+	public BlockLamp(int var1, int var2, int var3) {
+		super(var1, var2, Material.glass);
+		this.nextState = var3;
+	}
+
+	public boolean canReceivePower(World var1, int var2, int var3, int var4, int var5) {
+		return true;
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+		world.setBlockWithNotify(x, y, z, this.nextState);
+
+		int b = 0;
+		while (--y > 0 && (b = world.getBlockId(x, y, z)) == Block.lampInactive.blockID || b == Block.lampActive.blockID);
+		if (b == Block.logicGate.blockID) {
+			world.scheduleBlockUpdate(x, y, z, b);
+		}
+	}
+
+	public int idDropped(int var1, Random var2) {
+		return Block.lampInactive.blockID;
+	}
+}
--- net/minecraft/game/item/recipe/RecipesArmor.java
+++ net/minecraft/game/item/recipe/RecipesArmor.java
@@ -6,7 +6,7 @@
 
 public final class RecipesArmor {
 	private String[][] recipePatterns = new String[][]{{"XXX", "X X"}, {"X X", "XXX", "XXX"}, {"XXX", "X X", "X X"}, {"X X", "X X"}};
-	private Object[][] recipeItems = new Object[][]{{Block.clothGray, Block.fire, Item.ingotIron, Item.diamond, Item.ingotGold}, {Item.helmetLeather, Item.helmetChain, Item.helmetSteel, Item.helmetDiamond, Item.helmetGold}, {Item.plateLeather, Item.plateChain, Item.plateSteel, Item.plateDiamond, Item.plateGold}, {Item.legsLeather, Item.legsChain, Item.legsSteel, Item.legsDiamond, Item.legsGold}, {Item.bootsLeather, Item.bootsChain, Item.bootsSteel, Item.bootsDiamond, Item.bootsGold}};
+	private Object[][] recipeItems = new Object[][]{{Block.clothWhite, Block.fire, Item.ingotIron, Item.diamond, Item.ingotGold}, {Item.helmetLeather, Item.helmetChain, Item.helmetSteel, Item.helmetDiamond, Item.helmetGold}, {Item.plateLeather, Item.plateChain, Item.plateSteel, Item.plateDiamond, Item.plateGold}, {Item.legsLeather, Item.legsChain, Item.legsSteel, Item.legsDiamond, Item.legsGold}, {Item.bootsLeather, Item.bootsChain, Item.bootsSteel, Item.bootsDiamond, Item.bootsGold}};
 
 	public final void addRecipes(CraftingManager var1) {
 		for(int var2 = 0; var2 < this.recipeItems[0].length; ++var2) {
--- net/minecraft/game/level/block/BlockDirt.java
+++ net/minecraft/game/level/block/BlockDirt.java
@@ -3,7 +3,7 @@
 import net.minecraft.game.level.material.Material;
 
 public final class BlockDirt extends Block {
-	protected BlockDirt(int var1, int var2) {
+	public BlockDirt(int var1, int var2) {
 		super(3, 2, Material.ground);
 	}
 }
--- net/minecraft/client/player/EntityPlayerSP.java
+++ net/minecraft/client/player/EntityPlayerSP.java
@@ -36,7 +36,21 @@
 	}
 
 	public final void onLivingUpdate() {
+		boolean prevJump = this.movementInput.jump;
 		this.movementInput.updatePlayerMoveState();
+		if(this.movementInput.sneak && this.ySize < 0.2F) {
+			this.ySize = 0.2F;
+		}
+
+		if(!this.worldObj.survivalWorld && this.movementInput.jump && !prevJump) {
+			if(this.flyToggleTimer == 0) {
+				this.flyToggleTimer = 7;
+			} else {
+				this.flying = !this.flying;
+				this.flyToggleTimer = 0;
+			}
+		}
+
 		super.onLivingUpdate();
 	}
 
@@ -91,6 +105,8 @@
 			}
 		}
 
+		this.mc.worldInfo.readFromNBT(var1.getCompoundTag("WorldInfo"));
+
 	}
 
 	protected final String getEntityString() {
@@ -115,5 +131,38 @@
 
 	public final void onItemPickup(Entity var1) {
 		this.mc.effectRenderer.addEffect(new EntityPickupFX(this.mc.theWorld, var1, this, -0.5F));
+	}
+
+	protected boolean flyUp() {
+		return this.movementInput.jump;
+	}
+
+	protected boolean flyDown() {
+		return this.movementInput.sneak;
+	}
+
+	public boolean isSneaking() {
+		return this.movementInput.sneak;
+	}
+
+	public final float getTravelDistance(float var1) {
+		if (!this.mc.adventureMode) return 0.0F;
+		float d = 12.0F;
+		float o = 1.0F + 8.0F / d;
+		float x = this.lastTickPosX + (this.posX - this.lastTickPosX) * var1;
+		float z = this.lastTickPosZ + (this.posZ - this.lastTickPosZ) * var1;
+		x = Math.abs(x - this.worldObj.width / 2.0F);
+		z = Math.abs(z - this.worldObj.length / 2.0F);
+		x = this.worldObj.width / 2.0F - x;
+		z = this.worldObj.width / 2.0F - z;
+		x /= d;
+		z /= d;
+		x += o;
+		z += o;
+		if (x < 0.0F) x = 0.0F; if (x > 1.0F) x = 1.0F;
+		if (z < 0.0F) z = 0.0F; if (z > 1.0F) z = 1.0F;
+		x = 1.0F - x;
+		z = 1.0F - z;
+		return Math.max(x, z);
 	}
 }
--- /dev/null
+++ net/minecraft/client/gui/GuiAutosaveInfo.java
@@ -1,0 +1,29 @@
+package net.minecraft.client.gui;
+
+import net.minecraft.client.GuiMainMenu;
+import org.lwjgl.opengl.GL11;
+
+public class GuiAutosaveInfo extends GuiScreen {
+    public void initGui() {
+        this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 2 + 50, "OK").withBg(3));
+    }
+
+    public void drawScreen(int var1, int var2, float var3) {
+        this.drawDefaultBackground();
+        GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/dirt.png"));
+        drawGradientRect(this.width / 2 - 121, this.height / 2 - 81, this.width / 2 + 121, this.height / 2 + 91, 0xFFAAAAAA, 0xFFAAAAAA);
+        GL11.glColor4f(0.5F, 0.5F, 0.5F, 1.0F);
+        this.drawTexturedModalRect(this.width / 2 - 120, this.height / 2 - 80, 0, 0, 240, 170, 32);
+        GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+        this.drawAutosaveIcon(this.mc, this.width / 2, this.height / 2 - 45);
+        drawString(this.fontRenderer, "When you see this icon above displayed,", this.width / 2 - 100, this.height / 2 - 22, 0xFFFFFF);
+        drawString(this.fontRenderer, "the game is saving your data.", this.width / 2 - 100, this.height / 2 - 10, 0xFFFFFF);
+        drawString(this.fontRenderer, "Please do not close the game", this.width / 2 - 100, this.height / 2 + 10, 0xFFFFFF);
+        drawString(this.fontRenderer, "while this icon is on-screen.", this.width / 2 - 100, this.height / 2 + 22, 0xFFFFFF);
+        super.drawScreen(var1, var2, var3);
+    }
+
+    protected void actionPerformed(GuiButton var1) {
+        this.mc.displayGuiScreen(new GuiMainMenu());
+    }
+}
--- com/mojang/nbt/NBTTagCompound.java
+++ com/mojang/nbt/NBTTagCompound.java
@@ -70,6 +70,10 @@
 		this.tagMap.put(var1, (new NBTTagByteArray(var2)).setKey(var1));
 	}
 
+	public final void setIntArray(String var1, int[] var2) {
+		this.tagMap.put(var1, (new NBTTagIntArray(var2)).setKey(var1));
+	}
+
 	public final void setCompoundTag(String var1, NBTTagCompound var2) {
 		this.tagMap.put(var1, var2.setKey(var1));
 	}
@@ -108,6 +112,10 @@
 
 	public final byte[] getByteArray(String var1) {
 		return !this.tagMap.containsKey(var1) ? new byte[0] : ((NBTTagByteArray)this.tagMap.get(var1)).byteArray;
+	}
+
+	public final int[] getIntArray(String var1) {
+		return !this.tagMap.containsKey(var1) ? new int[0] : ((NBTTagIntArray)this.tagMap.get(var1)).intArray;
 	}
 
 	public final NBTTagCompound getCompoundTag(String var1) {
--- net/minecraft/game/level/block/BlockGears.java
+++ net/minecraft/game/level/block/BlockGears.java
@@ -1,15 +1,24 @@
 package net.minecraft.game.level.block;
 
 import java.util.Random;
+
+import net.minecraft.game.level.World;
 import net.minecraft.game.level.material.Material;
 import net.minecraft.game.physics.AxisAlignedBB;
 
 public final class BlockGears extends Block {
-	protected BlockGears(int var1, int var2) {
+	public BlockGears(int var1, int var2) {
 		super(55, 62, Material.circuits);
 	}
 
-	public final AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
+	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
+		if (!this.canPlaceBlockAt(var1, var2, var3, var4)) {
+			this.dropBlockAsItem(var1, var2, var3, var4, 0);
+			var1.setBlockWithNotify(var2, var3, var4, 0);
+		}
+	}
+
+	public final AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
 		return null;
 	}
 
@@ -30,6 +39,47 @@
 	}
 
 	public final boolean isCollidable() {
-		return false;
+		return true;
+	}
+
+	public boolean isConductive() {
+		return true;
+	}
+
+	public boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
+		return true;
+	}
+
+	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
+		return var1.isBlockNormalCube(var2 - 1, var3, var4)
+				|| var1.isBlockNormalCube(var2 + 1, var3, var4)
+				|| var1.isBlockNormalCube(var2, var3 - 1, var4)
+				|| var1.isBlockNormalCube(var2, var3 + 1, var4)
+				|| var1.isBlockNormalCube(var2, var3, var4 - 1)
+				|| var1.isBlockNormalCube(var2, var3, var4 + 1);
+	}
+
+	private static boolean isFloorOnlyGear(World var1, int var2, int var3, int var4) {
+		return (var1.getBlockId(var2, var3, var4) == Block.cog.blockID
+				&& !var1.isBlockNormalCube(var2 - 1, var3, var4)
+				&& !var1.isBlockNormalCube(var2 + 1, var3, var4)
+				&& !var1.isBlockNormalCube(var2, var3, var4 - 1)
+				&& !var1.isBlockNormalCube(var2, var3, var4 + 1));
+	}
+
+	public static boolean showFloorGear(World world, int x, int y, int z, int offset) {
+		return isFloorOnlyGear(world, x, y, z) && getAttachedBlock(world, x, y + offset, z) != null
+			|| isFloorOnlyGear(world, x + 1, y, z) && getAttachedBlock(world, x + 1, y + offset, z) != null
+			|| isFloorOnlyGear(world, x - 1, y, z) && getAttachedBlock(world, x - 1, y + offset, z) != null
+			|| isFloorOnlyGear(world, x, y, z + 1) && getAttachedBlock(world, x, y + offset, z + 1) != null
+			|| isFloorOnlyGear(world, x, y, z - 1) && getAttachedBlock(world, x, y + offset, z - 1) != null;
+	}
+
+	public static Block getAttachedBlock(World world, int x, int y, int z) {
+		Block block = Block.blocksList[world.getBlockId(x, y, z)];
+		if (block == null) return null;
+		if (block.isOpaqueCube()) return block;
+		if (block instanceof BlockChain || block instanceof BlockGears) return block;
+		return null;
 	}
 }
--- net/minecraft/game/level/generator/noise/NoiseGeneratorPerlin.java
+++ net/minecraft/game/level/generator/noise/NoiseGeneratorPerlin.java
@@ -42,24 +42,26 @@
 		return ((var0 & 1) == 0 ? var8 : -var8) + ((var0 & 2) == 0 ? var10 : -var10);
 	}
 
-	public final double generateNoise(double var1, double var3) {
-		double var10 = 0.0D;
-		double var8 = var3;
+	public double generateNoise(double var1, double var3) {
+		return this.generateNoise(var1, var3, 0.0D);
+	}
+
+	public double generateNoise(double var1, double var3, double var5) {
 		int var2 = MathHelper.floor_double(var1) & 255;
 		int var21 = MathHelper.floor_double(var3) & 255;
-		int var4 = MathHelper.floor_double(0.0D) & 255;
-		double var6 = var1 - (double)MathHelper.floor_double(var1);
-		var8 -= (double)MathHelper.floor_double(var8);
-		var10 = 0.0D - (double)MathHelper.floor_double(0.0D);
+		int var4 = MathHelper.floor_double(var5) & 255;
+		double var6 = var1 - MathHelper.floor_double(var1);
+		double var8 = var3 - MathHelper.floor_double(var3);
+		double var10 = var5 - MathHelper.floor_double(var5);
 		double var15 = generateNoise(var6);
 		double var17 = generateNoise(var8);
 		double var19 = generateNoise(var10);
-		int var5 = this.permutations[var2] + var21;
-		int var12 = this.permutations[var5] + var4;
-		var5 = this.permutations[var5 + 1] + var4;
+		int var0 = this.permutations[var2] + var21;
+		int var12 = this.permutations[var0] + var4;
+		var0 = this.permutations[var0 + 1] + var4;
 		var2 = this.permutations[var2 + 1] + var21;
 		var21 = this.permutations[var2] + var4;
 		var2 = this.permutations[var2 + 1] + var4;
-		return lerp(var19, lerp(var17, lerp(var15, grad(this.permutations[var12], var6, var8, var10), grad(this.permutations[var21], var6 - 1.0D, var8, var10)), lerp(var15, grad(this.permutations[var5], var6, var8 - 1.0D, var10), grad(this.permutations[var2], var6 - 1.0D, var8 - 1.0D, var10))), lerp(var17, lerp(var15, grad(this.permutations[var12 + 1], var6, var8, var10 - 1.0D), grad(this.permutations[var21 + 1], var6 - 1.0D, var8, var10 - 1.0D)), lerp(var15, grad(this.permutations[var5 + 1], var6, var8 - 1.0D, var10 - 1.0D), grad(this.permutations[var2 + 1], var6 - 1.0D, var8 - 1.0D, var10 - 1.0D))));
+		return lerp(var19, lerp(var17, lerp(var15, grad(this.permutations[var12], var6, var8, var10), grad(this.permutations[var21], var6 - 1.0D, var8, var10)), lerp(var15, grad(this.permutations[var0], var6, var8 - 1.0D, var10), grad(this.permutations[var2], var6 - 1.0D, var8 - 1.0D, var10))), lerp(var17, lerp(var15, grad(this.permutations[var12 + 1], var6, var8, var10 - 1.0D), grad(this.permutations[var21 + 1], var6 - 1.0D, var8, var10 - 1.0D)), lerp(var15, grad(this.permutations[var0 + 1], var6, var8 - 1.0D, var10 - 1.0D), grad(this.permutations[var2 + 1], var6 - 1.0D, var8 - 1.0D, var10 - 1.0D))));
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/block/BlockGrate.java
@@ -1,0 +1,39 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+import net.minecraft.game.physics.AxisAlignedBB;
+
+public class BlockGrate extends Block {
+	public BlockGrate(int var1, int var2, Material var3) {
+		super(var1, var2, var3);
+	}
+
+	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
+		if ((var0.getBlockMetadata(var1, var2, var3) & 1) == 1) {
+			return null;
+		}
+		return super.getCollisionBoundingBoxFromPool(var0, var1, var2, var3);
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
+		return (var2 & 1) == 1 ? this.blockIndexInTexture + 16 : this.blockIndexInTexture;
+	}
+
+	public boolean isOpaqueCube() {
+		return false;
+	}
+
+	public boolean isConductive() {
+		return this.material == Material.iron;
+	}
+
+	public boolean canReceivePower(World var1, int var2, int var3, int var4, int var5) {
+		return this.material != Material.wood;
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+		world.setBlockMetadata(x, y, z, ~world.getBlockMetadata(x, y, z) & 1);
+		world.notifyBlocksOfNeighborChange(x, y, z, this.blockID);
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/WorldInfo.java
@@ -1,0 +1,57 @@
+package net.minecraft.game.level;
+
+import com.mojang.nbt.NBTTagCompound;
+import net.minecraft.game.level.generator.LevelStructure;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.LevelType;
+
+public class WorldInfo {
+	public long levelX;
+	public long levelZ;
+	public int levelWidth;
+	public int levelLength;
+	public int levelHeight;
+	public LevelType levelType;
+	public LevelTheme levelTheme;
+	public LevelStructure levelStructure;
+	public LevelType currentLevelType;
+	public LevelTheme currentLevelTheme;
+	public LevelStructure currentLevelStructure;
+	public int worldTime;
+	public int playerScore;
+	public boolean creative;
+
+	public void readFromNBT(NBTTagCompound nbt) {
+		this.levelX = nbt.getLong("LevelX");
+		this.levelZ = nbt.getLong("LevelZ");
+		this.levelWidth = nbt.getInteger("LevelWidth");
+		this.levelLength = nbt.getInteger("LevelLength");
+		this.levelHeight = nbt.getInteger("LevelHeight");
+		this.levelType = LevelType.fromNameNullable(nbt.getString("LevelType"));
+		this.levelTheme = LevelTheme.fromNameNullable(nbt.getString("LevelTheme"));
+		this.levelStructure = LevelStructure.fromNameNullable(nbt.getString("LevelStructure"));
+		this.currentLevelType = LevelType.fromName(nbt.getString("CurrentLevelType"));
+		this.currentLevelTheme = LevelTheme.fromName(nbt.getString("CurrentLevelTheme"));
+		this.currentLevelStructure = LevelStructure.fromName(nbt.getString("CurrentLevelStructure"));
+		this.worldTime = nbt.getInteger("WorldTime");
+		this.playerScore = nbt.getInteger("PlayerScore");
+		this.creative = nbt.getBoolean("Creative");
+	}
+
+	public void writeToNBT(NBTTagCompound nbt) {
+		nbt.setLong("LevelX", this.levelX);
+		nbt.setLong("LevelZ", this.levelZ);
+		nbt.setInteger("LevelWidth", this.levelWidth);
+		nbt.setInteger("LevelLength", this.levelLength);
+		nbt.setInteger("LevelHeight", this.levelHeight);
+		nbt.setInteger("WorldTime", this.worldTime);
+		nbt.setInteger("PlayerScore", this.playerScore);
+		nbt.setBoolean("Creative", this.creative);
+		if (this.levelType != null) nbt.setString("LevelType", this.levelType.toString());
+		if (this.levelTheme != null) nbt.setString("LevelTheme", this.levelTheme.toString());
+		if (this.levelStructure != null) nbt.setString("LevelStructure", this.levelStructure.toString());
+		if (this.currentLevelType != null) nbt.setString("CurrentLevelType", this.currentLevelType.toString());
+		if (this.currentLevelTheme != null) nbt.setString("CurrentLevelTheme", this.currentLevelTheme.toString());
+		if (this.currentLevelStructure != null) nbt.setString("CurrentLevelStructure", this.currentLevelStructure.toString());
+	}
+}
--- /dev/null
+++ net/minecraft/game/item/recipe/RecipesMechanics.java
@@ -1,0 +1,27 @@
+package net.minecraft.game.item.recipe;
+
+import net.minecraft.game.item.ItemStack;
+import static net.minecraft.game.level.block.Block.*;
+import static net.minecraft.game.item.Item.*;
+
+public class RecipesMechanics {
+	public final void addRecipes(CraftingManager cm) {
+		cm.addRecipe(new ItemStack(wrench), "C C", "C|C", " | ", 'C', ingotIron, '|', ingotCopper);
+		cm.addRecipe(new ItemStack(cog, 16), " X ", "X X", " X ", 'X', ingotIron);
+		cm.addRecipe(new ItemStack(activator), "###", "#X#", "###", '#', cobblestone, 'X', ingotCopper);
+		cm.addRecipe(new ItemStack(woodenGrate, 4), "X X", " X ", "X X", 'X', planks);
+		cm.addRecipe(new ItemStack(ironGrate, 4), "X X", " X ", "X X", 'X', ingotIron);
+		cm.addRecipe(new ItemStack(goldenGrate, 4), "X X", " X ", "X X", 'X', ingotGold);
+		cm.addRecipe(new ItemStack(observer), "## ", "XXO", "## ", '#', cobblestone, 'X', ingotCopper, 'O', glass);
+		cm.addRecipe(new ItemStack(lampInactive, 4), " O ", "OXO", " O ", 'O', glass, 'X', ingotCopper);
+		cm.addRecipe(new ItemStack(piston), "###", "|C|", "|C|", '#', planks, '|', cobblestone, 'C', ingotCopper);
+		cm.addRecipe(new ItemStack(pistonCopper), "###", "|C|", "|C|", '#', ingotCopper, '|', cobblestone, 'C', ingotCopper);
+		cm.addRecipe(new ItemStack(pistonGold), "###", "|C|", "|C|", '#', ingotGold, '|', cobblestone, 'C', ingotCopper);
+		cm.addRecipe(new ItemStack(diode), " # ", "XOX", " # ", '#', cobblestone, 'X', ingotCopper, 'O', ingotGold);
+		cm.addRecipe(new ItemStack(magneticPlatform, 4), "###", "XXX", "###", '#', cobblestone, 'X', diamond);
+		cm.addRecipe(new ItemStack(logicGate), "#X#", "XOX", "#X#", '#', cobblestone, 'X', ingotCopper, 'O', ingotGold);
+		cm.addRecipe(new ItemStack(copperChain, 8), "###", '#', ingotCopper);
+		cm.addRecipe(new ItemStack(ironChain, 8), "###", '#', ingotIron);
+		cm.addRecipe(new ItemStack(goldChain, 8), "###", '#', ingotGold);
+	}
+}
--- net/minecraft/game/level/LevelLoader.java
+++ net/minecraft/game/level/LevelLoader.java
@@ -1,16 +1,15 @@
 package net.minecraft.game.level;
 
-import com.mojang.nbt.NBTBase;
 import com.mojang.nbt.NBTTagCompound;
 import com.mojang.nbt.NBTTagList;
 import com.mojang.nbt.NBTTagShort;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
+
+import java.io.*;
+import java.nio.file.Files;
 import java.util.Iterator;
 import java.util.zip.GZIPOutputStream;
 import net.minecraft.client.LoadingScreenRenderer;
+import net.minecraft.client.ThreadSaveLevel;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.EntityPainting;
 import net.minecraft.game.entity.animal.EntityPig;
@@ -25,6 +24,9 @@
 import net.minecraft.game.level.block.tileentity.TileEntity;
 import net.minecraft.game.level.block.tileentity.TileEntityChest;
 import net.minecraft.game.level.block.tileentity.TileEntityFurnace;
+import net.minecraft.game.level.generator.LevelStructure;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.LevelType;
 import util.IProgressUpdate;
 
 public abstract class LevelLoader {
@@ -63,6 +65,7 @@
 		var9.authorName = var2.getString("Author");
 		var9.name = var2.getString("Name");
 		var9.createTime = var2.getLong("CreatedOn");
+		var9.survivalWorld = !var2.getBoolean("Creative");
 		var9.cloudColor = var4.getInteger("CloudColor");
 		var9.skyColor = var4.getInteger("SkyColor");
 		var9.fogColor = var4.getInteger("FogColor");
@@ -81,7 +84,10 @@
 		var9.defaultFluid = var4.getByte("SurroundingWaterType");
 		var9.worldTime = var4.getShort("TimeOfDay");
 		var9.skylightSubtracted = var9.getSkyBrightness();
-		var9.generate(var6, var8, var7, var3.getByteArray("Blocks"), var3.getByteArray("Data"));
+		var9.levelType = LevelType.fromName(var4.getString("LevelType"));
+		var9.levelTheme = LevelTheme.fromName(var4.getString("LevelTheme"));
+		var9.levelStructure = LevelStructure.fromName(var4.getString("LevelStructure"));
+		var9.generate(var6, var8, var7, var3.getByteArray("Blocks"), var3.getByteArray("Data"), var3.getByteArray("Light"), var3.getIntArray("Heightmap"));
 		if(this.guiLoading != null) {
 			this.guiLoading.displayLoadingString("Preparing entities..");
 		}
@@ -133,7 +139,11 @@
 		return (Entity)(var2.equals("Pig") ? new EntityPig(var1) : (var2.equals("Sheep") ? new EntitySheep(var1) : (var2.equals("Creeper") ? new EntityCreeper(var1) : (var2.equals("Skeleton") ? new EntitySkeleton(var1) : (var2.equals("Spider") ? new EntitySpider(var1) : (var2.equals("Zombie") ? new EntityZombie(var1) : (var2.equals("Giant") ? new EntityGiantZombie(var1) : (var2.equals("Item") ? new EntityItem(var1) : (var2.equals("Painting") ? new EntityPainting(var1) : null)))))))));
 	}
 
-	public final void save(World var1, OutputStream var2) throws IOException {
+	public final void save(World var1, File var2) throws IOException {
+		this.save(var1, var2, () -> {});
+	}
+
+	public final void save(World var1, File var2, Runnable onSave) throws IOException {
 		if(this.guiLoading != null) {
 			this.guiLoading.displayProgressMessage("Saving level");
 		}
@@ -153,12 +163,17 @@
 		var3.setByte("SurroundingGroundType", (byte)Block.grass.blockID);
 		var3.setByte("SurroundingWaterType", (byte)var1.defaultFluid);
 		var3.setShort("TimeOfDay", (short)var1.worldTime);
+		var3.setString("LevelType", var1.levelType.toString());
+		var3.setString("LevelTheme", var1.levelTheme.toString());
+		var3.setString("LevelStructure", var1.levelStructure.toString());
 		NBTTagCompound var4 = new NBTTagCompound();
 		var4.setShort("Width", (short)var1.width);
 		var4.setShort("Length", (short)var1.length);
 		var4.setShort("Height", (short)var1.height);
 		var4.setByteArray("Blocks", var1.blocks);
 		var4.setByteArray("Data", var1.data);
+		var4.setByteArray("Light", var1.light);
+		var4.setIntArray("Heightmap", var1.heightMap);
 		NBTTagList var5 = new NBTTagList();
 		var5.setTag(new NBTTagShort((short)var1.xSpawn));
 		var5.setTag(new NBTTagShort((short)var1.ySpawn));
@@ -168,6 +183,7 @@
 		var15.setString("Author", var1.authorName);
 		var15.setString("Name", var1.name);
 		var15.setLong("CreatedOn", var1.createTime);
+		var15.setBoolean("Creative", !var1.survivalWorld);
 		if(this.guiLoading != null) {
 			this.guiLoading.displayLoadingString("Preparing entities..");
 		}
@@ -207,14 +223,10 @@
 			this.guiLoading.displayLoadingString("Writing..");
 		}
 
-		NBTTagCompound var13 = var18;
-		DataOutputStream var14 = new DataOutputStream(new GZIPOutputStream(var2));
-
 		try {
-			NBTBase.writeTag(var13, var14);
-		} finally {
-			var14.close();
+			ThreadSaveLevel.queue(var18, var2, onSave);
+		} catch (InterruptedException e) {
+			System.err.println("Threading stuff acted up. Could not save!");
 		}
-
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeatureTaiga2.java
@@ -1,0 +1,100 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+
+import java.util.Random;
+
+public class FeatureTaiga2 implements Feature {
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		int var6 = var2.nextInt(4) + 6;
+		int var7 = 1 + var2.nextInt(2);
+		int var8 = var6 - var7;
+		int var9 = 2 + var2.nextInt(2);
+		boolean var10 = true;
+		if(var4 >= 1 && var4 + var6 + 1 <= var1.height
+				&& var3 > 0 && var3 < var1.width - 1
+				&& var5 > 0 && var5 < var1.length - 1) {
+			int var11;
+			int var13;
+			int var15;
+			int var21;
+			for(var11 = var4; var11 <= var4 + 1 + var6 && var10; ++var11) {
+				boolean var12 = true;
+				if(var11 - var4 < var7) {
+					var21 = 0;
+				} else {
+					var21 = var9;
+				}
+
+				for(var13 = var3 - var21; var13 <= var3 + var21 && var10; ++var13) {
+					for(int var14 = var5 - var21; var14 <= var5 + var21 && var10; ++var14) {
+						if(var11 >= 0 && var11 < var1.height) {
+							var15 = var1.getBlockId(var13, var11, var14);
+							if(var15 != 0 && var15 != Block.leaves.blockID && var15 != Block.snow.blockID) {
+								var10 = false;
+							}
+						} else {
+							var10 = false;
+						}
+					}
+				}
+			}
+
+			if(!var10) {
+				return false;
+			} else {
+				var11 = var1.getBlockId(var3, var4 - 1, var5);
+				if((var11 == Block.grass.blockID || var11 == Block.dirt.blockID) && var4 < var1.height - var6 - 1) {
+					var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
+					var21 = var2.nextInt(2);
+					var13 = 1;
+					byte var22 = 0;
+
+					int var16;
+					int var17;
+					for(var15 = 0; var15 <= var8; ++var15) {
+						var16 = var4 + var6 - var15;
+
+						for(var17 = var3 - var21; var17 <= var3 + var21; ++var17) {
+							int var18 = var17 - var3;
+
+							for(int var19 = var5 - var21; var19 <= var5 + var21; ++var19) {
+								int var20 = var19 - var5;
+								if((Math.abs(var18) != var21 || Math.abs(var20) != var21 || var21 <= 0) && !Block.opaqueCubeLookup[var1.getBlockId(var17, var16, var19)]) {
+									var1.setBlock(var17, var16, var19, Block.leaves.blockID);
+								}
+							}
+						}
+
+						if(var21 >= var13) {
+							var21 = var22;
+							var22 = 1;
+							++var13;
+							if(var13 > var9) {
+								var13 = var9;
+							}
+						} else {
+							++var21;
+						}
+					}
+
+					var15 = var2.nextInt(3);
+
+					for(var16 = 0; var16 < var6 - var15; ++var16) {
+						var17 = var1.getBlockId(var3, var4 + var16, var5);
+						if(var17 == 0 || var17 == Block.leaves.blockID || var17 == Block.snow.blockID) {
+							var1.setBlock(var3, var4 + var16, var5, Block.wood.blockID);
+						}
+					}
+
+					return true;
+				} else {
+					return false;
+				}
+			}
+		} else {
+			return false;
+		}
+	}
+}
--- net/minecraft/game/level/block/BlockGlass.java
+++ net/minecraft/game/level/block/BlockGlass.java
@@ -8,7 +8,10 @@
 		super(20, 49, var3, false);
 	}
 
-	public final int quantityDropped(Random var1) {
+	public int idDropped(int var1, Random var2) {
+		if ((var1 & DROP_FLAG_SILK_TOUCH) != 0) {
+			return super.idDropped(var1, var2);
+		}
 		return 0;
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/block/BlockMagnetPlatform.java
@@ -1,0 +1,40 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.World;
+
+public class BlockMagnetPlatform extends BlockSand {
+	public BlockMagnetPlatform(int var1, int var2) {
+		super(var1, var2);
+	}
+
+	public int tickRate() {
+		return 6;
+	}
+
+	public int getBlockTextureFromSide(int var1) {
+		return var1 < 2 ? 84 : this.blockIndexInTexture;
+	}
+
+	protected int fallDirection(World var1, int var2, int var3, int var4) {
+		return (var1.getBlockMetadata(var2, var3, var4) & 1) == 0 ? -1 : 1;
+	}
+
+	protected boolean passGrates() {
+		return false;
+	}
+
+	public boolean isConductive() {
+		return true;
+	}
+
+	public boolean canReceivePower(World var1, int var2, int var3, int var4, int var5) {
+		return true;
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+		int meta = world.getBlockMetadata(x, y, z) & 255;
+		meta ^= 1;
+		world.setBlockMetadata(x, y, z, meta);
+		world.scheduleBlockUpdate(x, y, z, this.blockID);
+	}
+}
--- net/minecraft/game/level/generator/noise/NoiseGenerator.java
+++ net/minecraft/game/level/generator/noise/NoiseGenerator.java
@@ -2,4 +2,14 @@
 
 public abstract class NoiseGenerator {
 	public abstract double generateNoise(double var1, double var3);
+
+	public abstract double generateNoise(double var1, double var3, double var5);
+
+	public double generateNoiseNormalized(double var1, double var3) {
+		return this.generateNoise(var1, var3);
+	}
+
+	public double generateNoiseNormalized(double var1, double var3, double var5) {
+		return this.generateNoise(var1, var3, var5);
+	}
 }
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageRaising.java
@@ -1,0 +1,252 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorDistort;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorPerlin;
+import util.MathHelper;
+
+public final class StageRaising extends TerrainGenStage {
+	private StageRaising(Builder properties) {
+		super("Raising..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			int finalGroundLevel = world.levelType.modifyGroundLevel(world.groundLevel, world.waterLevel);
+
+			NoiseGenerator minTargetNoise = new NoiseGeneratorOctaves(rand, properties.noiseOctaves);
+			NoiseGenerator maxTargetNoise = new NoiseGeneratorOctaves(rand, properties.noiseOctaves);
+			if (properties.distortNoise) {
+				minTargetNoise = new NoiseGeneratorDistort(minTargetNoise, new NoiseGeneratorOctaves(rand, 8));
+				maxTargetNoise = new NoiseGeneratorDistort(maxTargetNoise, new NoiseGeneratorOctaves(rand, 8));
+			}
+
+			NoiseGenerator selectorNoise = properties.doSelection ? new NoiseGeneratorOctaves(rand, 6) : null;
+			NoiseGenerator islandOffsetNoise = properties.island && !properties.archipelago ? new NoiseGeneratorOctaves(rand, 2) : null;
+			NoiseGenerator selectionSmoothnessNoise = properties.doSelection ? new NoiseGeneratorOctaves(rand, 8) : null;
+			NoiseGenerator archipelagoNoise = properties.island && properties.archipelago ? new NoiseGeneratorOctaves(rand, 4) : null;
+
+			NoiseGenerator mosaicXNoise = new NoiseGeneratorPerlin(rand);
+			NoiseGenerator mosaicZNoise = new NoiseGeneratorPerlin(rand);
+
+			for (int x = 0; x < blocks.width; x++) {
+				progressor.accept(x * 100.0F / (float)(blocks.width - 1));
+
+				for (int z = 0; z < blocks.length; z++) {
+					int nx = x;
+					if (properties.mosaicScale > 1.0D) {
+						nx = (int)((double)x / properties.mosaicScale + mosaicXNoise.generateNoise(x / properties.mosaicSmoothness, z / properties.mosaicSmoothness) * properties.mosaicOffset) * properties.mosaicScale;
+						nx = MathHelper.clamp(nx, 0, blocks.width - 1);
+					}
+
+					int nz = z;
+					if (properties.mosaicScale > 1.0D) {
+						nz = (int)((double)z / properties.mosaicScale + mosaicZNoise.generateNoise(x / properties.mosaicSmoothness, z / properties.mosaicSmoothness) * properties.mosaicOffset) * properties.mosaicScale;
+						nz = MathHelper.clamp(nz, 0, blocks.length - 1);
+					}
+
+					double centreDistX = Math.abs(((double)nx / (blocks.width - 1.0D) - 0.5D) * 2.0D);
+					double centreSmoothX = (Math.abs(nx - blocks.width / 2) - blocks.width / 2 + 16) / 16.0D;
+					double centreDistZ = Math.abs(((double)nz / (blocks.length - 1.0D) - 0.5D) * 2.0D);
+					double centreSmoothZ = (Math.abs(nz - blocks.length / 2) - blocks.length / 2 + 16) / 16.0D;
+					double centreSmooth = Math.max(centreSmoothX, centreSmoothZ);
+					centreSmooth = Math.min(Math.max(centreSmooth * 1.25D, 0.0D), 1.0D);
+
+					double height;
+					if (properties.doSelection) {
+						assert selectorNoise != null && selectionSmoothnessNoise != null;
+
+						double minTarget = minTargetNoise.generateNoise(nx * properties.noiseScale, nz * properties.noiseScale) / properties.minDamp;
+						double maxTarget = maxTargetNoise.generateNoise(nx * properties.noiseScale, nz * properties.noiseScale) / properties.maxDamp;
+						if (properties.absHeight) {
+							minTarget = Math.abs(minTarget);
+							maxTarget = Math.abs(maxTarget);
+						}
+						minTarget += properties.minBoost;
+						maxTarget += properties.maxBoost;
+
+						double selectionSmoothness = properties.selectionSmoothness.getValue(nx, nz, selectionSmoothnessNoise);
+						double selection = selectorNoise.generateNoise(nx * properties.selectorScale, nz * properties.selectorScale) / 8.0D;
+
+						double target = selectionSmoothness <= 0.0D
+								? selection > properties.selectionThreshold ? minTarget : maxTarget
+								: maxTarget + (minTarget - maxTarget) * Math.min(Math.max(
+										(selection - properties.selectionThreshold - selectionSmoothness / 2.0D) / selectionSmoothness, 0.0D), 1.0D);
+
+						height = Math.max(minTarget, target) / 2.0D;
+					} else {
+						height = minTargetNoise.generateNoise(nx * properties.noiseScale, nz * properties.noiseScale) / properties.minDamp + properties.minBoost;
+					}
+
+					if (properties.island) {
+						double islandDist;
+						if (properties.archipelago) {
+							assert archipelagoNoise != null;
+							islandDist = archipelagoNoise.generateNoise(nx * 0.1D, nz * 0.1D) / 8.0D + 0.75D;
+
+							if (islandDist > 1.0D) {
+								islandDist = 1.0D;
+							}
+
+							if (islandDist < 0.0D) {
+								islandDist = 0.0D;
+							}
+						} else {
+							assert islandOffsetNoise != null;
+
+							islandDist = Math.sqrt(centreDistX * centreDistX + centreDistZ * centreDistZ) * 1.2D;
+							double islandOffset = islandOffsetNoise.generateNoise(nx * 0.05D, nz * 0.05D) / 4.0D + 1.0D;
+							islandDist = Math.min(islandDist, islandOffset);
+							islandDist = Math.max(islandDist, Math.max(centreDistX, centreDistZ));
+							if (islandDist > 1.0D) {
+								islandDist = 1.0D;
+							}
+
+							if (islandDist < 0.0D) {
+								islandDist = 0.0D;
+							}
+
+							islandDist *= islandOffset;
+						}
+						height = height * (1.0D - islandDist) - islandDist * 10.0D + 5.0D;
+						if (height < 0.0D) {
+							height -= height * height * 0.2D;
+						}
+					} else if (height < 0.0D) {
+						height /= properties.underDamp;
+					}
+
+					if (centreSmooth > 0.0D && !properties.island && properties.centerSmooth) {
+						height *= 1.0D - centreSmooth;
+						height += (finalGroundLevel - world.waterLevel - 1) * centreSmooth;
+					}
+
+					heightmap.set(x, z, heightmap.get(x, z) + (int)height);
+				}
+			}
+		});
+	}
+
+	public static class Builder {
+		private boolean island;
+		private boolean archipelago;
+		private boolean centerSmooth = true;
+		private int mosaicScale = 1;
+		private double mosaicOffset = 1.0D;
+		private double mosaicSmoothness = 8.0D;
+		private double noiseScale = 1.3D;
+		private double selectorScale = 1.0D;
+		private double minDamp = 6.0D;
+		private double minBoost = -4.0D;
+		private double maxDamp = 5.0D;
+		private double maxBoost = 6.0D;
+		private double selectionThreshold = 0.0D;
+		private NoiseModifierAccess selectionSmoothness = NoiseModifierAccess.constant(0.0D);
+		private boolean doSelection = true;
+		private double underDamp = 1.25D;
+		private int noiseOctaves = 8;
+		private boolean distortNoise = true;
+		private boolean absHeight = false;
+
+		public Builder island(boolean island) {
+			this.island = island;
+			return this;
+		}
+
+		public Builder archipelago(boolean archipelago) {
+			this.archipelago = archipelago;
+			return this;
+		}
+
+		public Builder centerSmooth(boolean centerSmooth) {
+			this.centerSmooth = centerSmooth;
+			return this;
+		}
+
+		public Builder noiseScale(double noiseScale) {
+			this.noiseScale = noiseScale;
+			return this;
+		}
+
+		public Builder selectorScale(double selectorScale) {
+			this.selectorScale = selectorScale;
+			return this;
+		}
+
+		public Builder minDamp(double minDamp) {
+			this.minDamp = minDamp;
+			return this;
+		}
+
+		public Builder minBoost(double minBoost) {
+			this.minBoost = minBoost;
+			return this;
+		}
+
+		public Builder maxDamp(double maxDamp) {
+			this.maxDamp = maxDamp;
+			return this;
+		}
+
+		public Builder maxBoost(double maxBoost) {
+			this.maxBoost = maxBoost;
+			return this;
+		}
+
+		public Builder selectionThreshold(double selectionThreshold) {
+			this.selectionThreshold = selectionThreshold;
+			return this;
+		}
+
+		public Builder selectionSmoothness(double selectionSmoothness) {
+			this.selectionSmoothness = NoiseModifierAccess.constant(selectionSmoothness);
+			return this;
+		}
+
+		public Builder selectionSmoothness(NoiseModifierAccess selectionSmoothness) {
+			this.selectionSmoothness = selectionSmoothness;
+			return this;
+		}
+
+		public Builder doSelection(boolean doSelection) {
+			this.doSelection = doSelection;
+			return this;
+		}
+
+		public Builder underDamp(double underDamp) {
+			this.underDamp = underDamp;
+			return this;
+		}
+
+		public Builder noiseOctaves(int noiseOctaves) {
+			this.noiseOctaves = noiseOctaves;
+			return this;
+		}
+
+		public Builder distortNoise(boolean distortNoise) {
+			this.distortNoise = distortNoise;
+			return this;
+		}
+
+		public Builder absHeight(boolean absHeight) {
+			this.absHeight = absHeight;
+			return this;
+		}
+
+		public Builder mosaicScale(int mosaicScale) {
+			this.mosaicScale = mosaicScale;
+			return this;
+		}
+
+		public Builder mosaicOffset(double mosaicOffset) {
+			this.mosaicOffset = mosaicOffset;
+			return this;
+		}
+
+		public Builder mosaicSmoothness(double mosaicSmoothness) {
+			this.mosaicSmoothness = mosaicSmoothness;
+			return this;
+		}
+
+		public StageRaising build() {
+			return new StageRaising(this);
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/client/ItemTooltips.java
@@ -1,0 +1,200 @@
+package net.minecraft.client;
+
+public class ItemTooltips {
+    private static final String[] TOOLTIPS = new String[1024];
+
+    public static String get(int id) {
+        return TOOLTIPS[id];
+    }
+
+    static {
+        TOOLTIPS[0] = "???";
+        TOOLTIPS[1] = "Stone";
+        TOOLTIPS[2] = "Grass";
+        TOOLTIPS[3] = "Dirt";
+        TOOLTIPS[4] = "Cobblestone";
+        TOOLTIPS[5] = "Planks";
+        TOOLTIPS[6] = "Sapling";
+        TOOLTIPS[7] = "Bedrock";
+        TOOLTIPS[8] = "Flowing Water";
+        TOOLTIPS[9] = "Still Water";
+        TOOLTIPS[10] = "Flowing Lava";
+        TOOLTIPS[11] = "Still Lava";
+        TOOLTIPS[12] = "Sand";
+        TOOLTIPS[13] = "Gravel";
+        TOOLTIPS[14] = "Gold Ore";
+        TOOLTIPS[15] = "Iron Ore";
+        TOOLTIPS[16] = "Coal Ore";
+        TOOLTIPS[17] = "Wood";
+        TOOLTIPS[18] = "Leaves";
+        TOOLTIPS[19] = "Sponge";
+        TOOLTIPS[20] = "Glass";
+        TOOLTIPS[21] = "Red Cloth";
+        TOOLTIPS[22] = "Orange Cloth";
+        TOOLTIPS[23] = "Yellow Cloth";
+        TOOLTIPS[24] = "Chartreuse Cloth";
+        TOOLTIPS[25] = "Green Cloth";
+        TOOLTIPS[26] = "Spring Green Cloth";
+        TOOLTIPS[27] = "Cyan Cloth";
+        TOOLTIPS[28] = "Capri Cloth";
+        TOOLTIPS[29] = "Ultramarine Cloth";
+        TOOLTIPS[30] = "Violet Cloth";
+        TOOLTIPS[31] = "Purple Cloth";
+        TOOLTIPS[32] = "Magenta Cloth";
+        TOOLTIPS[33] = "Rose Cloth";
+        TOOLTIPS[34] = "Dark Gray Cloth";
+        TOOLTIPS[35] = "Gray Cloth";
+        TOOLTIPS[36] = "White Cloth";
+        TOOLTIPS[37] = "Dandelion";
+        TOOLTIPS[38] = "Rose";
+        TOOLTIPS[39] = "Brown Mushroom";
+        TOOLTIPS[40] = "Red Mushroom";
+        TOOLTIPS[41] = "Block of Gold";
+        TOOLTIPS[42] = "Block of Iron";
+        TOOLTIPS[43] = "Double Stone Slab";
+        TOOLTIPS[44] = "Stone Slab";
+        TOOLTIPS[45] = "Bricks";
+        TOOLTIPS[46] = "TNT";
+        TOOLTIPS[47] = "Bookshelf";
+        TOOLTIPS[48] = "Mossy Cobblestone";
+        TOOLTIPS[49] = "Obsidian";
+        TOOLTIPS[50] = "Torch";
+        TOOLTIPS[51] = "Fire";
+        TOOLTIPS[52] = "Infinite Water Source";
+        TOOLTIPS[53] = "Infinite Lava Source";
+        TOOLTIPS[54] = "Chest";
+        TOOLTIPS[55] = "Gear";
+        TOOLTIPS[56] = "Diamond Ore";
+        TOOLTIPS[57] = "Block of Diamond";
+        TOOLTIPS[58] = "Crafting Table";
+        TOOLTIPS[59] = "Crops";
+        TOOLTIPS[60] = "Farmland";
+        TOOLTIPS[61] = "Furnace";
+        TOOLTIPS[62] = "Lit Furnace";
+        TOOLTIPS[63] = "Snow Layer";
+        TOOLTIPS[64] = "Ice";
+        TOOLTIPS[65] = "Snow Block";
+        TOOLTIPS[66] = "Cactus";
+        TOOLTIPS[67] = "Cornflower";
+        TOOLTIPS[68] = "Double Wooden Slab";
+        TOOLTIPS[69] = "Wooden Slab";
+        TOOLTIPS[70] = "Activator";
+        TOOLTIPS[71] = "Iron Grate";
+        TOOLTIPS[72] = "Observer";
+        TOOLTIPS[73] = "Copper Ore";
+        TOOLTIPS[74] = "Block of Copper";
+        TOOLTIPS[75] = "Copper Lamp";
+        TOOLTIPS[76] = "Lit Copper Lamp";
+        TOOLTIPS[77] = "Wooden Piston";
+        TOOLTIPS[78] = "Copper Piston";
+        TOOLTIPS[79] = "Golden Piston";
+        TOOLTIPS[80] = "Diode";
+        TOOLTIPS[81] = "Gravistone";
+        TOOLTIPS[82] = "Wooden Grate";
+        TOOLTIPS[83] = "Logic Gate";
+        TOOLTIPS[84] = "Wooden Door";
+        TOOLTIPS[85] = "Iron Door";
+        TOOLTIPS[86] = "Mud";
+        TOOLTIPS[87] = "Brown Mushroom Block";
+        TOOLTIPS[88] = "Red Mushroom Block";
+        TOOLTIPS[89] = "Fumes";
+        TOOLTIPS[90] = "Clay";
+        TOOLTIPS[91] = "Iron Chain";
+        TOOLTIPS[92] = "Golden Chain";
+        TOOLTIPS[93] = "Copper Chain";
+        TOOLTIPS[94] = "Golden Grate";
+
+        TOOLTIPS[256] = "Iron Shovel";
+        TOOLTIPS[257] = "Iron Pickaxe";
+        TOOLTIPS[258] = "Iron Axe";
+        TOOLTIPS[259] = "Flint and Steel";
+        TOOLTIPS[260] = "Apple";
+        TOOLTIPS[261] = "Bow";
+        TOOLTIPS[262] = "Arrow";
+        TOOLTIPS[263] = "Coal";
+        TOOLTIPS[264] = "Diamond";
+        TOOLTIPS[265] = "Iron Ingot";
+        TOOLTIPS[266] = "Gold Ingot";
+        TOOLTIPS[267] = "Iron Sword";
+        TOOLTIPS[268] = "Wooden Sword";
+        TOOLTIPS[269] = "Wooden Shovel";
+        TOOLTIPS[270] = "Wooden Pickaxe";
+        TOOLTIPS[271] = "Wooden Axe";
+        TOOLTIPS[272] = "Stone Sword";
+        TOOLTIPS[273] = "Stone Shovel";
+        TOOLTIPS[274] = "Stone Pickaxe";
+        TOOLTIPS[275] = "Stone Axe";
+        TOOLTIPS[276] = "Diamond Sword";
+        TOOLTIPS[277] = "Diamond Shovel";
+        TOOLTIPS[278] = "Diamond Pickaxe";
+        TOOLTIPS[279] = "Diamond Axe";
+        TOOLTIPS[280] = "Stick";
+        TOOLTIPS[281] = "Bowl";
+        TOOLTIPS[282] = "Mushroom Stew";
+        TOOLTIPS[283] = "Golden Sword";
+        TOOLTIPS[284] = "Golden Shovel";
+        TOOLTIPS[285] = "Golden Pickaxe";
+        TOOLTIPS[286] = "Golden Axe";
+        TOOLTIPS[287] = "String";
+        TOOLTIPS[288] = "Feather";
+        TOOLTIPS[289] = "Gunpowder";
+        TOOLTIPS[290] = "Wooden Hoe";
+        TOOLTIPS[291] = "Stone Hoe";
+        TOOLTIPS[292] = "Iron Hoe";
+        TOOLTIPS[293] = "Diamond Hoe";
+        TOOLTIPS[294] = "Golden Hoe";
+        TOOLTIPS[295] = "Seeds";
+        TOOLTIPS[296] = "Wheat";
+        TOOLTIPS[297] = "Bread";
+        TOOLTIPS[298] = "Leather Cap";
+        TOOLTIPS[299] = "Leather Tunic";
+        TOOLTIPS[300] = "Leather Pants";
+        TOOLTIPS[301] = "Leather Boots";
+        TOOLTIPS[302] = "Chainmail Helmet";
+        TOOLTIPS[303] = "Chainmail Chestplate";
+        TOOLTIPS[304] = "Chainmail Leggings";
+        TOOLTIPS[305] = "Chainmail Boots";
+        TOOLTIPS[306] = "Iron Helmet";
+        TOOLTIPS[307] = "Iron Chestplate";
+        TOOLTIPS[308] = "Iron Leggings";
+        TOOLTIPS[309] = "Iron Boots";
+        TOOLTIPS[310] = "Diamond Helmet";
+        TOOLTIPS[311] = "Diamond Chestplate";
+        TOOLTIPS[312] = "Diamond Leggings";
+        TOOLTIPS[313] = "Diamond Boots";
+        TOOLTIPS[314] = "Golden Helmet";
+        TOOLTIPS[315] = "Golden Chestplate";
+        TOOLTIPS[316] = "Golden Leggings";
+        TOOLTIPS[317] = "Golden Boots";
+        TOOLTIPS[318] = "Flint";
+        TOOLTIPS[319] = "Raw Porkchop";
+        TOOLTIPS[320] = "Cooked Porkchop";
+        TOOLTIPS[321] = "Painting";
+        TOOLTIPS[322] = "Snowball";
+        TOOLTIPS[323] = "Red Dye";
+        TOOLTIPS[324] = "Orange Dye";
+        TOOLTIPS[325] = "Yellow Dye";
+        TOOLTIPS[326] = "Chartreuse Dye";
+        TOOLTIPS[327] = "Green Dye";
+        TOOLTIPS[328] = "Spring Green Dye";
+        TOOLTIPS[329] = "Cyan Dye";
+        TOOLTIPS[330] = "Capri Dye";
+        TOOLTIPS[331] = "Ultramarine Dye";
+        TOOLTIPS[332] = "Violet Dye";
+        TOOLTIPS[333] = "Purple Dye";
+        TOOLTIPS[334] = "Magenta Dye";
+        TOOLTIPS[335] = "Rose Dye";
+        TOOLTIPS[336] = "Dark Gray Dye";
+        TOOLTIPS[337] = "Gray Dye";
+        TOOLTIPS[338] = "White Dye";
+        TOOLTIPS[339] = "Copper Ingot";
+        TOOLTIPS[340] = "Bucket";
+        TOOLTIPS[341] = "Water Bucket";
+        TOOLTIPS[342] = "Lava Bucket";
+        TOOLTIPS[343] = "Wrench";
+        TOOLTIPS[344] = "Wooden Door";
+        TOOLTIPS[345] = "Iron Door";
+        TOOLTIPS[346] = "Clay Ball";
+        TOOLTIPS[347] = "Brick";
+    }
+}
--- /dev/null
+++ net/minecraft/client/gui/GuiFileSelection.java
@@ -1,0 +1,752 @@
+package net.minecraft.client.gui;
+
+import net.minecraft.client.ThreadSaveLevel;
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.block.BlockFlower;
+import net.minecraft.game.level.generator.LevelStructure;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.LevelType;
+import net.minecraft.game.level.material.Material;
+import org.lwjgl.opengl.GL11;
+import util.MathHelper;
+
+import java.io.File;
+import java.io.FilenameFilter;
+import java.text.SimpleDateFormat;
+import java.util.*;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.PriorityBlockingQueue;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Predicate;
+
+public class GuiFileSelection extends GuiScreen {
+    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm");
+
+    private final GuiScreen parent;
+    private final File directory;
+    private final String title;
+    private final Function<File, FileInfo> infoProvider;
+
+    private Consumer<File> callbackExisting;
+    private Consumer<String> callbackNonExisting;
+    private Consumer<File> callbackDeletion;
+    private FilenameFilter filenameFilter;
+    private String nonExistingTitle;
+    private Predicate<String> inputValidifier = s -> true;
+
+    private ThreadProvideFileInfo infoProviderThread;
+    private File[] files = null;
+    private File selection = null;
+    private int scroll;
+    private int maxScroll;
+    private float prevSmoothScroll;
+    private float smoothScroll;
+    private boolean deleting;
+
+    public GuiFileSelection(GuiScreen parent, File directory, String title, Function<File, FileInfo> infoProvider) {
+        this.parent = parent;
+        this.directory = directory;
+        this.title = title;
+        this.nonExistingTitle = title;
+        this.infoProvider = infoProvider;
+    }
+
+    public GuiFileSelection callbackExisting(Consumer<File> callbackExisting) {
+        this.callbackExisting = callbackExisting;
+        return this;
+    }
+
+    public GuiFileSelection callbackNonExisting(Consumer<String> callbackNonExisting) {
+        this.callbackNonExisting = callbackNonExisting;
+        return this;
+    }
+
+    public GuiFileSelection callbackDeletion(Consumer<File> callbackDeletion) {
+        this.callbackDeletion = callbackDeletion;
+        return this;
+    }
+
+    public GuiFileSelection filenameFilter(FilenameFilter filenameFilter) {
+        this.filenameFilter = filenameFilter;
+        return this;
+    }
+
+    public GuiFileSelection nonExistingTitle(String nonExistingTitle) {
+        this.nonExistingTitle = nonExistingTitle;
+        return this;
+    }
+
+    public GuiFileSelection inputValidifier(Predicate<String> inputValidifier) {
+        this.inputValidifier = inputValidifier;
+        return this;
+    }
+
+    public void initGui() {
+        if (this.directory.isDirectory()) {
+            this.files = this.directory.listFiles(this.filenameFilter);
+            if (this.files != null) {
+                Arrays.sort(this.files);
+                if (this.infoProviderThread == null) {
+                    this.infoProviderThread = new ThreadProvideFileInfo(this.infoProvider);
+                    for (File file : this.files) {
+                        this.infoProviderThread.getFileInfo(file);
+                    }
+                    this.infoProviderThread.start();
+                }
+            }
+        }
+
+        this.controlList.add(new GuiButton(0, this.width / 2 - 155, this.height - 25, 100, 20, "Back"));
+        this.controlList.add(new GuiButton(1, this.width / 2 - 50, this.height - 25, 100, 20, "Create New"));
+        this.controlList.add(new GuiButton(2, this.width / 2 + 55, this.height - 25, 100, 20, "Deleting: " + (this.deleting ? "ON" : "OFF")));
+        this.controlList.add(new GuiButton(3, this.width / 2 - 70, 5, 20, 20, "^"));
+        this.controlList.add(new GuiButton(4, this.width / 2 + 50, 5, 20, 20, "v"));
+    }
+
+    public void updateScreen() {
+        this.prevSmoothScroll = this.smoothScroll;
+        this.smoothScroll = MathHelper.lerp(this.smoothScroll, this.scroll, 0.5F);
+        this.mc.renderEngine.updateDynamicTextures();
+    }
+
+    public void drawScreen(int var1, int var2, float var3) {
+        this.selection = null;
+        int scroll = (int)MathHelper.lerp(this.prevSmoothScroll, this.smoothScroll, var3);
+
+        int headerHeight = 30;
+        int headerHeightScaled = this.mc.displayHeight / this.height * headerHeight;
+        this.drawDefaultBackground();
+        if (this.deleting) {
+            drawGradientRect(0, 0, this.width, this.height, 0x3FFF0000, 0x3FFF0000);
+        }
+        drawGradientRect(0, 0, this.width, headerHeight, 0x7F000000, 0x7F000000);
+        drawGradientRect(0, this.height - headerHeight, this.width, this.height, 0x7F000000, 0x7F000000);
+        super.drawScreen(var1, var2, var3);
+        drawCenteredString(this.fontRenderer, this.title, this.width / 2, 10, 0xFFFFFF);
+
+        if (this.files != null && this.files.length > 0) {
+            int height = 40;
+            int padding = 10;
+            int wf = 5;
+            this.maxScroll = this.files.length * (height + padding) + padding;
+            GL11.glEnable(GL11.GL_SCISSOR_TEST);
+            GL11.glScissor(0, headerHeightScaled, this.mc.displayWidth, this.mc.displayHeight - headerHeightScaled * 2);
+            for (int i = 0; i < this.files.length; i++) {
+                int offsetY = i * (height + padding) + padding + headerHeight - scroll;
+                if (offsetY + height < headerHeight || offsetY > this.height - headerHeight) continue;
+
+                File file = this.files[i];
+                FileInfo fi = this.infoProviderThread != null ? this.infoProviderThread.getFileInfo(file) : null;
+
+                int backColor = 0x7F000000;
+                boolean hovered = false;
+                if (var1 > this.width / wf && var1 < this.width * (wf - 1) / wf
+                        && var2 > headerHeight && var2 < this.height - headerHeight
+                        && var2 > offsetY && var2 < offsetY + height) {
+                    this.selection = file;
+                    int borderColor = 0xFFFFFFFF;
+                    backColor = deleting ? 0x7F7F0000 : 0x7F30396E;
+                    hovered = true;
+                    drawGradientRect(this.width / wf - 1, offsetY - 1, this.width / wf, offsetY + height + 1, borderColor, borderColor);
+                    drawGradientRect(this.width * (wf - 1) / wf, offsetY - 1, this.width * (wf - 1) / wf + 1, offsetY + height + 1, borderColor, borderColor);
+                    drawGradientRect(this.width / wf, offsetY - 1, this.width * (wf - 1) / wf, offsetY, borderColor, borderColor);
+                    drawGradientRect(this.width / wf, offsetY + height, this.width * (wf - 1) / wf, offsetY + height + 1, borderColor, borderColor);
+                }
+
+                drawGradientRect(this.width / wf, offsetY, this.width * (wf - 1) / wf, offsetY + height, backColor, backColor);
+
+                String time = DATE_FORMAT.format(new Date(fi == null ? file.lastModified() : fi.lastModified));
+                long fileSizeInt = fi != null ? fi.fileSize : file.length();
+                boolean megabytes = fileSizeInt > 1000000;
+                String fileSize = megabytes
+                        ? (double) (fileSizeInt * 10 / 1024 / 1024) / 10.0D + "MB"
+                        : (double) (fileSizeInt * 10 / 1024) / 10.0D + "KB";
+                this.fontRenderer.alpha = 0.5F;
+                GL11.glEnable(GL11.GL_BLEND);
+                this.fontRenderer.drawString(time, this.width * (wf - 1) / wf - 4 - this.fontRenderer.getStringWidth(time), offsetY + 6, 0xFFFFFF);
+                this.fontRenderer.drawString(fileSize, this.width * (wf - 1) / wf - 4 - this.fontRenderer.getStringWidth(fileSize), offsetY + 16, 0xFFFFFF);
+                GL11.glDisable(GL11.GL_BLEND);
+                this.fontRenderer.alpha = 1.0F;
+
+                if (fi != null) {
+                    String description = fi.levelType.prefixThemeName()
+                            ? fi.levelTheme + " " + fi.levelType
+                            : fi.levelType + " " + fi.levelTheme;
+                    if (fi.levelStructure != LevelStructure.NONE) {
+                        description += " + " + fi.levelStructure;
+                    }
+                    drawString(this.fontRenderer, description, this.width / wf + 42, offsetY + 16, 0xCCCCCC);
+
+                    description = (fi.creative ? "Creative" : "Survival") + ", "
+                            + fi.width + "x" + fi.height + "x" + fi.length;
+                    drawString(this.fontRenderer, description, this.width / wf + 42, offsetY + 26, 0xCCCCCC);
+
+                    GL11.glPushMatrix();
+                    GL11.glTranslatef(this.width / wf + 4, offsetY + 4, 0.0F);
+                    GL11.glScalef(0.5F, 0.5F, 0.5F);
+                    this.drawLevelIcon(fi);
+                    GL11.glPopMatrix();
+                } else {
+                    drawString(this.fontRenderer, "Loading...", this.width / wf + 42, offsetY + 16, 0xCCCCCC);
+                    drawGradientRect(this.width / wf + 4, offsetY + 4, this.width / wf + 36, offsetY + 36, 0xFF000000, 0xFF000000);
+                }
+
+                String name = file.getName();
+                int extensionIndex = name.lastIndexOf('.');
+                if (extensionIndex != -1) {
+                    name = name.substring(0, extensionIndex);
+                }
+
+                drawString(this.fontRenderer, name, this.width / wf + 42, offsetY + 6, hovered ? 0xFFFFAA : 0xFFFFFF);
+
+                if (ThreadSaveLevel.isBusyWithFile(file)) {
+                    drawGradientRect(this.width / wf, offsetY, this.width * (wf - 1) / wf, offsetY + height, 0xBF000000, 0xBF000000);
+                    this.drawAutosaveIcon(this.mc, this.width / wf + 20, offsetY + 28);
+                }
+            }
+            GL11.glDisable(GL11.GL_SCISSOR_TEST);
+        } else {
+            drawCenteredString(this.fontRenderer, "Empty!", this.width / 2, this.height / 2 - 4, 0xFFFFFF);
+            this.maxScroll = 0;
+        }
+
+        this.maxScroll -= this.height - headerHeight * 2;
+        this.maxScroll = Math.max(this.maxScroll, 0);
+        this.scroll = Math.min(this.scroll, this.maxScroll);
+    }
+
+    private void drawLevelIcon(FileInfo fileInfo) {
+        LevelType type = fileInfo.levelType;
+        LevelTheme theme = fileInfo.levelTheme;
+
+        int sky = theme.getSkyColor();
+        int fog = theme.getFogColor();
+
+        drawGradientRect(0, 0, 64, 64, 255 << 24 | sky, 255 << 24 | fog);
+
+        Block stone = theme.getStoneBlock();
+        Block soil = theme.getSoilBlock();
+        Block ground = soil == Block.dirt && theme.growGrassOnDirt() ? theme.hasSnow() ? Block.blockSnow : Block.grass : soil;
+        Block sandBeach = theme.getSandBeachBlock();
+        if (sandBeach == null) sandBeach = ground;
+        Block gravelBeach = theme.getGravelBeachBlock();
+        if (gravelBeach == null) gravelBeach = ground;
+        Block liquid = theme.getStillFluid();
+        if (liquid != null && liquid.material == Material.water && theme.hasSnow()) liquid = Block.ice;
+        Block sapling = ground == Block.sand ? Block.cactus
+                : ((BlockFlower)Block.sapling).canThisPlantGrowOnThisBlockID(ground.blockID)
+                    || ((BlockFlower)Block.sapling).canThisPlantGrowOnThisBlockID(sandBeach.blockID)
+                    || ((BlockFlower)Block.sapling).canThisPlantGrowOnThisBlockID(gravelBeach.blockID) ? Block.sapling
+                : null;
+        Block flower = theme.hasSnow()
+                || !(Block.plantRed.canThisPlantGrowOnThisBlockID(ground.blockID)
+                        || Block.plantRed.canThisPlantGrowOnThisBlockID(sandBeach.blockID)
+                        || Block.plantRed.canThisPlantGrowOnThisBlockID(gravelBeach.blockID)) ? null
+                : theme.getMushroomCount() > theme.getFlowerCount() ? Block.mushroomBrown
+                : theme.getFlowerCount() == 0 ? null
+                : Block.plantRed;
+        int liquidZ = liquid == null || Block.lightValue[liquid.blockID] == 0 ? 0 : 1;
+
+        GL11.glEnable(GL11.GL_TEXTURE_2D);
+        GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/terrain.png"));
+
+        switch (type) {
+            case FLOATING:
+                this.drawBlock(24, 40, soil);
+                this.drawBlock(16, 32, ground);
+                this.drawBlock(32, 32, ground);
+                drawGradientRect(0, 0, 64, 64, 127 << 24 | sky, 127 << 24 | fog);
+                this.drawBlock(0, 8, sapling);
+                this.drawBlock(12, 10, flower);
+                this.drawBlock(40, 0, sapling);
+                this.drawBlock(32, 2, flower);
+                this.drawBlock(56, 4, flower, 8, 16);
+                this.drawBlock(0, 32, soil);
+                this.drawBlock(0, 24, ground);
+                this.drawBlock(8, 24, ground);
+                this.drawBlock(48, 24, soil);
+                this.drawBlock(32, 16, ground);
+                this.drawBlock(48, 16, ground);
+                if (liquid != null) {
+                    GL11.glEnable(GL11.GL_BLEND);
+                    this.zLevel = liquidZ;
+                    this.drawBlock(0, 60, liquid, 16, 4);
+                    this.drawBlock(16, 60, liquid, 16, 4);
+                    this.drawBlock(32, 60, liquid, 16, 4);
+                    this.drawBlock(48, 60, liquid, 16, 4);
+                    this.zLevel = 0;
+                    GL11.glDisable(GL11.GL_BLEND);
+                }
+                break;
+
+            case FLAT:
+                this.drawBlock(4, 32, sapling);
+                this.drawBlock(28, 36, sapling);
+                this.drawBlock(40, 32, sapling);
+                this.drawBlock(12, 36, flower);
+                this.drawBlock(36, 36, flower);
+                this.drawBlock(0, 48, ground);
+                this.drawBlock(16, 48, ground);
+                this.drawBlock(32, 48, ground);
+                this.drawBlock(48, 48, ground);
+                break;
+
+            case INLAND:
+                this.drawBlock(0, 16, sapling);
+                this.drawBlock(36, 16, sapling);
+                this.drawBlock(46, 18, sapling);
+                this.drawBlock(6, 20, flower);
+                this.drawBlock(40, 22, flower);
+                this.drawBlock(0, 48, soil);
+                this.drawBlock(16, 48, soil);
+                this.drawBlock(32, 48, soil);
+                this.drawBlock(48, 48, soil);
+                this.drawBlock(0, 32, ground);
+                this.drawBlock(32, 32, ground);
+                this.drawBlock(48, 32, ground);
+                this.drawBlock(16, 40, gravelBeach);
+                this.drawBlock(32, 40, sandBeach, 16, 8);
+                break;
+
+            case MOUNTAINS:
+                this.drawBlock(24, 8, sapling);
+                this.drawBlock(48, 0, sapling);
+                this.drawBlock(-2, 4, flower, 16, 12);
+                this.drawBlock(24, 24, ground);
+                this.drawBlock(24, 40, soil);
+                this.drawBlock(32, 16, stone);
+                this.drawBlock(48, 16, stone);
+                this.drawBlock(32, 32, stone);
+                this.drawBlock(48, 32, stone);
+                this.drawBlock(32, 0, ground);
+                this.drawBlock(48, 8, ground);
+                this.drawBlock(0, 16, ground, 8, 16);
+                this.drawBlock(0, 32, soil, 8, 16);
+                drawGradientRect(0, 0, 64, 64, 127 << 24 | sky, 127 << 24 | fog);
+                this.drawBlock(4, 24, sapling);
+                this.drawBlock(34, 34, sapling);
+                this.drawBlock(48, 32, sapling);
+                this.drawBlock(42, 38, flower);
+                this.drawBlock(0, 28, flower);
+                this.drawBlock(0, 56, soil, 16, 8);
+                this.drawBlock(0, 40, ground);
+                this.drawBlock(16, 56, soil, 16, 8);
+                this.drawBlock(32, 48, ground);
+                this.drawBlock(48, 48, ground);
+                this.drawBlock(48, 56, ground, 16, 8);
+                drawGradientRect(16, 50, 32, 56, 0x33000000, 0x55000000);
+                drawGradientRect(0, 56, 48, 64, 0x55000000, 0x77000000);
+                if (liquid != null) {
+                    GL11.glEnable(GL11.GL_BLEND);
+                    this.zLevel = liquidZ;
+                    this.drawBlock(0, 56, liquid, 16, 8);
+                    this.drawBlock(16, 56, liquid, 16, 8);
+                    this.drawBlock(16, 50, liquid, 16, 6);
+                    this.drawBlock(32, 56, liquid, 16, 8);
+                    this.zLevel = 0;
+                    GL11.glDisable(GL11.GL_BLEND);
+                }
+                break;
+
+            case MARSH:
+                this.drawBlock(0, 32, sapling);
+                this.drawBlock(36, 36, sapling);
+                this.drawBlock(48, 32, sapling);
+                this.drawBlock(8, 36, flower, 16, 12);
+                this.drawBlock(44, 36, flower);
+                this.drawBlock(0, 48, ground);
+                this.drawBlock(16, 56, gravelBeach, 16, 8);
+                this.drawBlock(32, 48, ground);
+                this.drawBlock(32, 56, sandBeach, 16, 8);
+                this.drawBlock(48, 48, ground);
+                if (liquid != null) {
+                    drawGradientRect(0, 58, 64, 64, 0x33000000, 0x77000000);
+                    GL11.glEnable(GL11.GL_BLEND);
+                    this.zLevel = liquidZ;
+                    this.drawBlock(0, 58, liquid, 16, 6);
+                    this.drawBlock(16, 58, liquid, 16, 6);
+                    this.drawBlock(32, 58, liquid, 16, 6);
+                    this.drawBlock(48, 58, liquid, 16, 6);
+                    this.zLevel = 0;
+                    GL11.glDisable(GL11.GL_BLEND);
+                }
+                break;
+
+            case EXTREME_HILLS:
+            case WILD_CLIFFS:
+                this.drawBlock(16, 24, stone);
+                this.drawBlock(32, 24, stone);
+                this.drawBlock(48, 24, stone);
+                this.drawBlock(16, 40, stone);
+                this.drawBlock(32, 40, stone);
+                this.drawBlock(48, 40, stone);
+                this.drawBlock(16, 56, stone, 16, 8);
+                this.drawBlock(32, 56, stone, 16, 8);
+                this.drawBlock(48, 56, stone, 16, 8);
+                this.drawBlock(16, 16, ground);
+                this.drawBlock(32, 8, ground);
+                drawGradientRect(0, 0, 64, 64, 127 << 24 | sky, 127 << 24 | fog);
+
+            case CLIFFS:
+                this.drawBlock(2, 10, sapling);
+                this.drawBlock(46, 2, sapling);
+                this.drawBlock(8, 12, flower);
+                this.drawBlock(54, 4, flower, 10, 16);
+                this.drawBlock(0, 24, ground);
+                this.drawBlock(8, 24, ground);
+                this.drawBlock(0, 32, stone);
+                this.drawBlock(0, 48, stone);
+                this.drawBlock(56, 32, stone, 8, 16);
+                this.drawBlock(56, 48, stone, 8, 16);
+                this.drawBlock(48, 16, ground);
+                if (type != LevelType.EXTREME_HILLS) {
+                    this.drawBlock(0, 56, sandBeach, 16, 8);
+                    this.drawBlock(16, 56, sandBeach, 16, 8);
+                    this.drawBlock(48, 56, gravelBeach, 16, 8);
+                } else {
+                    this.drawBlock(0, 48, ground);
+                    this.drawBlock(16, 56, ground, 16, 8);
+                    this.drawBlock(32, 56, ground, 16, 8);
+                    this.drawBlock(48, 48, ground);
+                    this.drawBlock(28, 40, sapling);
+                }
+                if (liquid != null && type != LevelType.EXTREME_HILLS) {
+                    drawGradientRect(0, 52, 64, 64, 0x33000000, 0x77000000);
+                    GL11.glEnable(GL11.GL_BLEND);
+                    this.zLevel = liquidZ;
+                    this.drawBlock(0, 52, liquid, 16, 12);
+                    this.drawBlock(16, 52, liquid, 16, 12);
+                    this.drawBlock(32, 52, liquid, 16, 12);
+                    this.drawBlock(48, 52, liquid, 16, 12);
+                    this.zLevel = 0;
+                    GL11.glDisable(GL11.GL_BLEND);
+                }
+                break;
+
+            case VALLEY:
+                this.drawBlock(32, 0, Block.blockSnow);
+                this.drawBlock(24, 16, stone);
+                this.drawBlock(40, 16, stone);
+                this.drawBlock(16, 32, stone);
+                this.drawBlock(32, 32, stone);
+                this.drawBlock(48, 32, stone);
+                drawGradientRect(0, 0, 64, 64, 127 << 24 | sky, 127 << 24 | fog);
+                this.drawBlock(0, 16, Block.blockSnow);
+                this.drawBlock(0, 24, stone);
+                this.drawBlock(16, 24, stone);
+                this.drawBlock(0, 40, stone);
+                this.drawBlock(8, 40, stone);
+                this.drawBlock(24, 40, stone);
+                this.drawBlock(56, 32, stone, 8, 16);
+                this.drawBlock(40, 32, sapling);
+                this.drawBlock(48, 36, flower);
+                this.drawBlock(0, 56, gravelBeach, 16, 8);
+                this.drawBlock(16, 56, sandBeach, 16, 8);
+                this.drawBlock(32, 48, ground);
+                this.drawBlock(48, 48, ground);
+                if (liquid != null) {
+                    drawGradientRect(0, 52, 64, 64, 0x33000000, 0x77000000);
+                    GL11.glEnable(GL11.GL_BLEND);
+                    this.zLevel = liquidZ;
+                    this.drawBlock(0, 52, liquid, 16, 12);
+                    this.drawBlock(16, 52, liquid, 16, 12);
+                    this.drawBlock(32, 52, liquid, 16, 12);
+                    this.drawBlock(48, 52, liquid, 16, 12);
+                    this.zLevel = 0;
+                    GL11.glDisable(GL11.GL_BLEND);
+                }
+                break;
+
+            case PLAINS:
+                this.drawBlock(2, 24, sapling);
+                this.drawBlock(28, 36, sapling);
+                this.drawBlock(44, 24, sapling);
+                this.drawBlock(12, 28, flower);
+                this.drawBlock(36, 36, flower);
+                this.drawBlock(0, 40, ground);
+                this.drawBlock(16, 40, ground, 8, 16);
+                this.drawBlock(48, 40, ground);
+                this.drawBlock(0, 48, sandBeach);
+                this.drawBlock(16, 48, ground);
+                this.drawBlock(32, 48, ground);
+                this.drawBlock(48, 48, gravelBeach);
+                this.drawBlock(0, 56, soil, 16, 8);
+                this.drawBlock(48, 56, soil, 16, 8);
+                break;
+
+            case ARCHIPELAGO:
+                this.drawBlock(2, 20, sapling);
+                this.drawBlock(46, 18, sapling);
+                this.drawBlock(0, 20, flower);
+                this.drawBlock(0, 32, ground);
+                this.drawBlock(48, 32, ground);
+                this.drawBlock(0, 40, sandBeach);
+                this.drawBlock(8, 40, sandBeach);
+                this.drawBlock(40, 40, gravelBeach);
+                this.drawBlock(48, 40, gravelBeach);
+                this.drawBlock(0, 48, sandBeach);
+                this.drawBlock(16, 48, sandBeach);
+                this.drawBlock(32, 48, sandBeach);
+                this.drawBlock(48, 48, sandBeach);
+                if (liquid != null) {
+                    drawGradientRect(0, 48, 64, 64, 0x33000000, 0x77000000);
+                    GL11.glEnable(GL11.GL_BLEND);
+                    this.zLevel = liquidZ;
+                    this.drawBlock(0, 48, liquid);
+                    this.drawBlock(16, 48, liquid);
+                    this.drawBlock(32, 48, liquid);
+                    this.drawBlock(48, 48, liquid);
+                    this.zLevel = 0;
+                    GL11.glDisable(GL11.GL_BLEND);
+                }
+                break;
+
+            case CAVERNS:
+                this.drawBlock(16, 16, stone);
+                this.drawBlock(32, 16, stone);
+                this.drawBlock(48, 16, stone);
+                this.drawBlock(0, 32, stone);
+                this.drawBlock(16, 32, stone);
+                this.drawBlock(32, 32, stone);
+                this.drawBlock(48, 32, stone);
+                this.drawBlock(16, 48, stone);
+                this.drawBlock(48, 48, stone);
+                drawGradientRect(0, 8, 64, 64, 191 << 24, 191 << 24);
+                this.drawBlock(4, 0, sapling);
+                this.drawBlock(30, 0, sapling);
+                this.drawBlock(40, 0, sapling);
+                this.drawBlock(0, 8, ground);
+                this.drawBlock(16, 8, ground);
+                this.drawBlock(32, 8, ground);
+                this.drawBlock(48, 8, ground);
+                this.drawBlock(0, 16, stone, 16, 8);
+                this.drawBlock(16, 16, stone, 16, 8);
+                this.drawBlock(32, 16, stone, 16, 8);
+                this.drawBlock(48, 16, stone, 16, 8);
+                this.drawBlock(0, 16, stone);
+                this.drawBlock(0, 32, stone, 8, 8);
+                this.drawBlock(0, 48, stone);
+                this.drawBlock(16, 48, stone, 8, 16);
+                this.drawBlock(24, 56, stone, 16, 8);
+                this.drawBlock(32, 48, stone);
+                this.drawBlock(32, 32, stone, 8, 16);
+                this.drawBlock(24, 16, stone);
+                this.drawBlock(48, 56, stone, 16, 8);
+                this.drawBlock(48, 16, stone, 8, 16);
+                break;
+
+            case RUBYLANDS:
+                this.drawBlock(24, 0, sapling);
+                this.drawBlock(24, 16, soil);
+                this.drawBlock(40, 16, soil);
+                this.drawBlock(56, 16, soil, 8, 16);
+                this.drawBlock(24, 24, stone);
+                this.drawBlock(40, 24, stone);
+                this.drawBlock(56, 24, stone, 8, 16);
+                this.drawBlock(48, 32, stone);
+                this.drawBlock(24, 8, ground);
+                this.drawBlock(40, 0, ground);
+                this.drawBlock(48, 0, ground);
+                drawGradientRect(0, 0, 64, 64, 127 << 24 | sky, 127 << 24 | fog);
+                this.drawBlock(0, 16, sapling);
+                this.drawBlock(46, 34, sapling);
+                this.drawBlock(30, 24, sapling);
+                this.drawBlock(12, 28, flower);
+                this.drawBlock(24, 30, flower);
+                this.drawBlock(0, 48, soil);
+                this.drawBlock(16, 48, soil);
+                this.drawBlock(32, 48, soil);
+                this.drawBlock(0, 32, ground);
+                this.drawBlock(16, 40, ground);
+                this.drawBlock(32, 40, ground);
+                this.drawBlock(48, 48, ground);
+                break;
+
+            case MOSAIC:
+                this.drawBlock(0, 16, sapling);
+                this.drawBlock(16, 32, flower);
+                this.drawBlock(32, 0, sapling);
+                this.drawBlock(48, 16, flower);
+                this.drawBlock(0, 48, soil);
+                this.drawBlock(32, 32, soil);
+                this.drawBlock(32, 48, soil);
+                this.drawBlock(48, 48, soil);
+                this.drawBlock(0, 32, ground);
+                this.drawBlock(16, 48, ground);
+                this.drawBlock(32, 16, ground);
+                this.drawBlock(48, 32, ground);
+                break;
+
+            case ISLAND:
+            default:
+                this.drawBlock(14, 20, sapling);
+                this.drawBlock(28, 18, sapling);
+                this.drawBlock(24, 20, flower);
+                this.drawBlock(16, 32, ground);
+                this.drawBlock(32, 32, ground);
+                this.drawBlock(8, 40, sandBeach);
+                this.drawBlock(24, 40, sandBeach);
+                this.drawBlock(40, 40, gravelBeach);
+                this.drawBlock(0, 48, sandBeach);
+                this.drawBlock(16, 48, sandBeach);
+                this.drawBlock(32, 48, sandBeach);
+                this.drawBlock(48, 48, sandBeach);
+                if (liquid != null) {
+                    drawGradientRect(0, 48, 64, 64, 0x33000000, 0x77000000);
+                    GL11.glEnable(GL11.GL_BLEND);
+                    this.zLevel = liquidZ;
+                    this.drawBlock(0, 48, liquid);
+                    this.drawBlock(16, 48, liquid);
+                    this.drawBlock(32, 48, liquid);
+                    this.drawBlock(48, 48, liquid);
+                    this.zLevel = 0;
+                    GL11.glDisable(GL11.GL_BLEND);
+                }
+                break;
+        }
+
+        GL11.glBindTexture(GL11.GL_TEXTURE_2D, 0);
+
+        int darkness = (255 - Math.min(theme.getSkyBrightness(), 15) * 17) << 24;
+        drawGradientRect(0, 0, 64, 64, darkness, darkness);
+    }
+
+    private void drawBlock(int x, int y, Block block) {
+        this.drawBlock(x, y, block, 16, 16);
+    }
+
+    private void drawBlock(int x, int y, Block block, int w, int h) {
+        if (block == null) return;
+        int texture = block.getBlockTextureFromSide(2);
+        int tx = texture % 16 * 16;
+        int ty = texture / 16 * 16;
+        this.drawTexturedModalRect(x, y, tx, ty, w, h);
+    }
+
+    public void onGuiClosed() {
+        if (this.infoProviderThread != null) {
+            this.infoProviderThread.running = false;
+            this.infoProviderThread = null;
+        }
+    }
+
+    protected void actionPerformed(GuiButton var1) {
+        switch (var1.id) {
+            case 0:
+                this.mc.displayGuiScreen(this.parent);
+                break;
+            case 1:
+                this.mc.displayGuiScreen(new GuiTextPrompt(this.parent, this.nonExistingTitle, this.callbackNonExisting, this.inputValidifier));
+                break;
+            case 2:
+                this.deleting = !this.deleting;
+                var1.displayString = "Deleting: " + (this.deleting ? "ON" : "OFF");
+                break;
+            case 3:
+                this.mouseScrolled(300);
+                break;
+            case 4:
+                this.mouseScrolled(-300);
+                break;
+        }
+    }
+
+    protected void mouseScrolled(int delta) {
+        this.scroll += delta / -6;
+        this.scroll = MathHelper.clamp(this.scroll, 0, this.maxScroll);
+    }
+
+    protected void drawSlotInventory(int var1, int var2, int var3) {
+        super.drawSlotInventory(var1, var2, var3);
+        if (var3 == 0 && this.selection != null) {
+            if (ThreadSaveLevel.isBusyWithFile(this.selection)) {
+                this.mc.sndManager.playSoundFX("random.wood click", 1.0F, 0.5F);
+            } else {
+                this.mc.sndManager.playSoundFX("random.click", 1.0F, 1.0F);
+                (this.deleting ? this.callbackDeletion : this.callbackExisting).accept(this.selection);
+            }
+        }
+    }
+
+    public static class FileInfo {
+        public static final FileInfo FALLBACK = new FileInfo(
+                LevelType.ISLAND,
+                LevelTheme.NORMAL,
+                LevelStructure.NONE,
+                0,
+                0,
+                0,
+                false,
+                0,
+                0
+        );
+
+        public final LevelType levelType;
+        public final LevelTheme levelTheme;
+        public final LevelStructure levelStructure;
+        public final int width;
+        public final int height;
+        public final int length;
+        public final boolean creative;
+        public final long lastModified;
+        public final long fileSize;
+
+        public FileInfo(LevelType levelType, LevelTheme levelTheme, LevelStructure levelStructure, int width, int height, int length, boolean creative, long lastModified, long fileSize) {
+            this.levelType = levelType;
+            this.levelTheme = levelTheme;
+            this.levelStructure = levelStructure;
+            this.width = width;
+            this.height = height;
+            this.length = length;
+            this.creative = creative;
+            this.lastModified = lastModified;
+            this.fileSize = fileSize;
+        }
+    }
+
+    private static class ThreadProvideFileInfo extends Thread {
+        public volatile boolean running;
+        private final Map<File, FileInfo> fileInfoMap = Collections.synchronizedMap(new HashMap<>());
+        private final BlockingQueue<File> filesToProcess = new PriorityBlockingQueue<>(11, Comparator.comparingLong(File::length));
+        private final Function<File, FileInfo> fileInfoProvider;
+        private volatile File processingFile;
+
+        public ThreadProvideFileInfo(Function<File, FileInfo> fileInfoProvider) {
+            this.fileInfoProvider = fileInfoProvider;
+        }
+
+        public void run() {
+            this.running = true;
+            try {
+                while (this.running) {
+                    File file = this.processingFile = filesToProcess.take();
+                    if (ThreadSaveLevel.isBusyWithFile(file)) {
+                        this.processingFile = null;
+                        continue;
+                    }
+
+                    FileInfo fileInfo = this.fileInfoProvider.apply(file);
+                    if (fileInfo == null) {
+                        fileInfo = FileInfo.FALLBACK;
+                    }
+                    this.fileInfoMap.put(file, fileInfo);
+                    this.processingFile = null;
+                }
+            } catch (InterruptedException ignored) {
+            }
+            this.running = false;
+        }
+
+        public FileInfo getFileInfo(File file) {
+            FileInfo fileInfo = this.fileInfoMap.get(file);
+            if (fileInfo == null
+                    && !filesToProcess.contains(file)
+                    && file != this.processingFile
+                    && !ThreadSaveLevel.isBusyWithFile(file)) {
+                filesToProcess.add(file);
+            }
+            return fileInfo;
+        }
+    }
+}
--- net/minecraft/game/entity/player/InventoryPlayer.java
+++ net/minecraft/game/entity/player/InventoryPlayer.java
@@ -14,6 +14,13 @@
 		this.player = var1;
 	}
 
+	public InventoryPlayer(EntityPlayer var1, InventoryPlayer var2) {
+		this.player = var1;
+		this.mainInventory = var2.mainInventory;
+		this.armorInventory = var2.armorInventory;
+		this.currentItem = var2.currentItem;
+	}
+
 	public final ItemStack getCurrentItem() {
 		return this.mainInventory[this.currentItem];
 	}
@@ -59,10 +66,11 @@
 	}
 
 	public final boolean storePartialItemStack(ItemStack var1) {
-		if(var1.itemDamage == 0) {
+		if(var1.itemDamage == 0 || true) {
 			int var4 = var1.stackSize;
 			int var3 = var1.itemID;
 			int var6 = var3;
+			int var6a = var1.itemDamage;
 			InventoryPlayer var5 = this;
 			int var7 = 0;
 
@@ -74,7 +82,7 @@
 					break;
 				}
 
-				if(var5.mainInventory[var7] != null && var5.mainInventory[var7].itemID == var6) {
+				if(var5.mainInventory[var7] != null && var5.mainInventory[var7].itemID == var6 && var5.mainInventory[var7].itemDamage == var6a) {
 					var8 = var5.mainInventory[var7];
 					if(var5.mainInventory[var7].stackSize < var8.getItem().getItemStackLimit() && var5.mainInventory[var7].stackSize < 64) {
 						var10001 = var7;
@@ -94,7 +102,7 @@
 				var10001 = var4;
 			} else {
 				if(this.mainInventory[var9] == null) {
-					this.mainInventory[var9] = new ItemStack(var3, 0);
+					this.mainInventory[var9] = new ItemStack(var3, 0, var6a);
 				}
 
 				var3 = var4;
--- com/mojang/nbt/NBTBase.java
+++ com/mojang/nbt/NBTBase.java
@@ -71,6 +71,8 @@
 			return new NBTTagList();
 		case 10:
 			return new NBTTagCompound();
+		case 11:
+			return new NBTTagIntArray();
 		default:
 			return null;
 		}
--- net/minecraft/game/level/block/BlockCrops.java
+++ net/minecraft/game/level/block/BlockCrops.java
@@ -7,14 +7,14 @@
 import net.minecraft.game.level.World;
 
 public final class BlockCrops extends BlockFlower {
-	protected BlockCrops(int var1, int var2) {
+	public BlockCrops(int var1, int var2) {
 		super(59, 88);
 		this.blockIndexInTexture = 88;
 		this.setTickOnLoad(true);
 		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.25F, 1.0F);
 	}
 
-	protected final boolean canThisPlantGrowOnThisBlockID(int var1) {
+	public final boolean canThisPlantGrowOnThisBlockID(int var1) {
 		return var1 == Block.tilledField.blockID;
 	}
 
--- net/minecraft/game/item/ItemHoe.java
+++ net/minecraft/game/item/ItemHoe.java
@@ -17,10 +17,10 @@
 		if(var3 > 0 && var4 > 0 && var5 > 0 && var3 < var2.width - 1 && var4 < var2.height - 1 && var5 < var2.length - 1) {
 			var6 = var2.getBlockId(var3, var4, var5);
 			Material var7 = var2.getBlockMaterial(var3, var4 + 1, var5);
-			if((var7.isSolid() || var6 != Block.grass.blockID) && var6 != Block.dirt.blockID) {
+			if(var7.isSolid() || (var6 != Block.grass.blockID && var6 != Block.dirt.blockID && var6 != Block.mud.blockID)) {
 				return false;
 			} else {
-				Block var12 = Block.tilledField;
+				Block var12 = var6 == Block.mud.blockID ? Block.dirt : Block.tilledField;
 				float var10001 = (float)var3 + 0.5F;
 				float var10002 = (float)var4 + 0.5F;
 				float var10003 = (float)var5 + 0.5F;
--- net/minecraft/game/item/Item.java
+++ net/minecraft/game/item/Item.java
@@ -4,9 +4,11 @@
 import net.minecraft.game.entity.player.EntityPlayer;
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.material.Material;
 
 public class Item {
 	protected static Random rand = new Random();
+
 	public static Item[] itemsList = new Item[1024];
 	public static Item shovel;
 	public static Item pickaxeSteel;
@@ -73,12 +75,38 @@
 	public static Item porkRaw;
 	public static Item porkCooked;
 	public static Item painting;
+	public static Item snowball = (new Item(66)).setIconIndex(56);
+	public static Item dyeRed = (new Item(67)).setIconIndex(240);
+	public static Item dyeOrange = (new Item(68)).setIconIndex(241);
+	public static Item dyeYellow = (new Item(69)).setIconIndex(242);
+	public static Item dyeChartreuse = (new Item(70)).setIconIndex(243);
+	public static Item dyeGreen = (new Item(71)).setIconIndex(244);
+	public static Item dyeSpringGreen = (new Item(72)).setIconIndex(245);
+	public static Item dyeCyan = (new Item(73)).setIconIndex(246);
+	public static Item dyeCapri = (new Item(74)).setIconIndex(247);
+	public static Item dyeUltramarine = (new Item(75)).setIconIndex(248);
+	public static Item dyeViolet = (new Item(76)).setIconIndex(249);
+	public static Item dyePurple = (new Item(77)).setIconIndex(250);
+	public static Item dyeMagenta = (new Item(78)).setIconIndex(251);
+	public static Item dyeRose = (new Item(79)).setIconIndex(252);
+	public static Item dyeDarkGray = (new Item(80)).setIconIndex(253);
+	public static Item dyeGray = (new Item(81)).setIconIndex(254);
+	public static Item dyeWhite = (new Item(82)).setIconIndex(255);
+	public static Item ingotCopper = (new Item(83)).setIconIndex(22);
+	public static Item bucketEmpty = (new ItemBucket(84, 0)).setIconIndex(57);
+	public static Item bucketWater = (new ItemBucket(85, Block.waterMoving.blockID)).setIconIndex(73);
+	public static Item bucketLava = (new ItemBucket(86, Block.lavaMoving.blockID)).setIconIndex(89);
+	public static Item wrench = (new ItemWrench(87)).setIconIndex(54);
+	public static Item doorWood = (new ItemDoor(88, Material.wood)).setIconIndex(43);
+	public static Item doorSteel = (new ItemDoor(89, Material.iron)).setIconIndex(44);
+	public static Item clay = (new Item(90)).setIconIndex(42);
+	public static Item brick = (new Item(91)).setIconIndex(58);
 	public final int shiftedIndex;
 	protected int maxStackSize = 64;
-	protected int maxDamage = 32;
-	protected int iconIndex;
+	protected int maxDamage = 0;
+	protected int icon;
 
-	protected Item(int var1) {
+	public Item(int var1) {
 		this.shiftedIndex = var1 + 256;
 		if(itemsList[var1 + 256] != null) {
 			System.out.println("CONFLICT @ " + var1);
@@ -88,12 +116,12 @@
 	}
 
 	public final Item setIconIndex(int var1) {
-		this.iconIndex = var1;
+		this.icon = var1;
 		return this;
 	}
 
-	public final int getIconIndex() {
-		return this.iconIndex;
+	public int getIconIndex(ItemStack stack) {
+		return this.icon;
 	}
 
 	public boolean onItemUse(ItemStack var1, World var2, int var3, int var4, int var5, int var6) {
@@ -134,331 +162,399 @@
 		ItemSpade var10000 = new ItemSpade(0, 2);
 		byte var1 = 82;
 		ItemSpade var0 = var10000;
-		var0.iconIndex = var1;
+		var0.icon = var1;
 		shovel = var0;
+
 		ItemPickaxe var15 = new ItemPickaxe(1, 2);
 		var1 = 98;
 		ItemPickaxe var2 = var15;
-		var2.iconIndex = var1;
+		var2.icon = var1;
 		pickaxeSteel = var2;
+
 		ItemAxe var16 = new ItemAxe(2, 2);
 		var1 = 114;
 		ItemAxe var3 = var16;
-		var3.iconIndex = var1;
+		var3.icon = var1;
 		axeSteel = var3;
+
 		ItemFlintAndSteel var17 = new ItemFlintAndSteel(3);
 		var1 = 5;
 		ItemFlintAndSteel var4 = var17;
-		var4.iconIndex = var1;
+		var4.icon = var1;
 		striker = var4;
+
 		ItemFood var18 = new ItemFood(4, 4);
 		var1 = 4;
 		ItemFood var5 = var18;
-		var5.iconIndex = var1;
+		var5.icon = var1;
+
 		ItemBow var19 = new ItemBow(5);
 		var1 = 21;
 		ItemBow var6 = var19;
-		var6.iconIndex = var1;
+		var6.icon = var1;
 		bow = var6;
+
 		Item var20 = new Item(6);
 		var1 = 37;
 		Item var7 = var20;
-		var7.iconIndex = var1;
+		var7.icon = var1;
 		arrow = var7;
+
 		var20 = new Item(7);
 		var1 = 7;
 		var7 = var20;
-		var7.iconIndex = var1;
+		var7.icon = var1;
 		coal = var7;
+
 		var20 = new Item(8);
 		var1 = 55;
 		var7 = var20;
-		var7.iconIndex = var1;
+		var7.icon = var1;
 		diamond = var7;
+
 		var20 = new Item(9);
 		var1 = 23;
 		var7 = var20;
-		var7.iconIndex = var1;
+		var7.icon = var1;
 		ingotIron = var7;
+
 		var20 = new Item(10);
 		var1 = 39;
 		var7 = var20;
-		var7.iconIndex = var1;
+		var7.icon = var1;
 		ingotGold = var7;
+
 		ItemSword var21 = new ItemSword(11, 2);
 		var1 = 66;
 		ItemSword var8 = var21;
-		var8.iconIndex = var1;
+		var8.icon = var1;
 		swordSteel = var8;
+
 		var21 = new ItemSword(12, 0);
 		var1 = 64;
 		var8 = var21;
-		var8.iconIndex = var1;
+		var8.icon = var1;
 		swordWood = var8;
+
 		var10000 = new ItemSpade(13, 0);
 		var1 = 80;
 		var0 = var10000;
-		var0.iconIndex = var1;
+		var0.icon = var1;
 		shovelWood = var0;
+
 		var15 = new ItemPickaxe(14, 0);
 		var1 = 96;
 		var2 = var15;
-		var2.iconIndex = var1;
+		var2.icon = var1;
 		pickaxeWood = var2;
+
 		var16 = new ItemAxe(15, 0);
 		var1 = 112;
 		var3 = var16;
-		var3.iconIndex = var1;
+		var3.icon = var1;
 		axeWood = var3;
+
 		var21 = new ItemSword(16, 1);
 		var1 = 65;
 		var8 = var21;
-		var8.iconIndex = var1;
+		var8.icon = var1;
 		swordStone = var8;
+
 		var10000 = new ItemSpade(17, 1);
 		var1 = 81;
 		var0 = var10000;
-		var0.iconIndex = var1;
+		var0.icon = var1;
 		shovelStone = var0;
+
 		var15 = new ItemPickaxe(18, 1);
 		var1 = 97;
 		var2 = var15;
-		var2.iconIndex = var1;
+		var2.icon = var1;
 		pickaxeStone = var2;
+
 		var16 = new ItemAxe(19, 1);
 		var1 = 113;
 		var3 = var16;
-		var3.iconIndex = var1;
+		var3.icon = var1;
 		axeStone = var3;
-		var21 = new ItemSword(20, 3);
+
+		var21 = new ItemSword(20, 4);
 		var1 = 67;
 		var8 = var21;
-		var8.iconIndex = var1;
+		var8.icon = var1;
 		swordDiamond = var8;
-		var10000 = new ItemSpade(21, 3);
+
+		var10000 = new ItemSpade(21, 4);
 		var1 = 83;
 		var0 = var10000;
-		var0.iconIndex = var1;
+		var0.icon = var1;
 		shovelDiamond = var0;
-		var15 = new ItemPickaxe(22, 3);
+
+		var15 = new ItemPickaxe(22, 4);
 		var1 = 99;
 		var2 = var15;
-		var2.iconIndex = var1;
+		var2.icon = var1;
 		pickaxeDiamond = var2;
-		var16 = new ItemAxe(23, 3);
+
+		var16 = new ItemAxe(23, 4);
 		var1 = 115;
 		var3 = var16;
-		var3.iconIndex = var1;
+		var3.icon = var1;
 		axeDiamond = var3;
+
 		var20 = new Item(24);
 		var1 = 53;
 		var7 = var20;
-		var7.iconIndex = var1;
+		var7.icon = var1;
 		stick = var7;
+
 		var20 = new Item(25);
 		var1 = 71;
 		var7 = var20;
-		var7.iconIndex = var1;
+		var7.icon = var1;
 		bowlEmpty = var7;
+
 		ItemSoup var22 = new ItemSoup(26, 10);
 		var1 = 72;
 		ItemSoup var9 = var22;
-		var9.iconIndex = var1;
+		var9.icon = var1;
 		bowlSoup = var9;
-		var21 = new ItemSword(27, 0);
+
+		var21 = new ItemSword(27, 3);
 		var1 = 68;
 		var8 = var21;
-		var8.iconIndex = var1;
+		var8.icon = var1;
 		swordGold = var8;
-		var10000 = new ItemSpade(28, 0);
+
+		var10000 = new ItemSpade(28, 3);
 		var1 = 84;
 		var0 = var10000;
-		var0.iconIndex = var1;
+		var0.icon = var1;
 		shovelGold = var0;
-		var15 = new ItemPickaxe(29, 0);
+		((ItemTool)shovelGold).silkTouch = true;
+
+		var15 = new ItemPickaxe(29, 3);
 		var1 = 100;
 		var2 = var15;
-		var2.iconIndex = var1;
+		var2.icon = var1;
 		pickaxeGold = var2;
-		var16 = new ItemAxe(30, 0);
+		((ItemTool)pickaxeGold).silkTouch = true;
+
+		var16 = new ItemAxe(30, 3);
 		var1 = 116;
 		var3 = var16;
-		var3.iconIndex = var1;
+		var3.icon = var1;
 		axeGold = var3;
+		((ItemTool)axeGold).silkTouch = true;
+
 		var20 = new Item(31);
 		var1 = 8;
 		var7 = var20;
-		var7.iconIndex = var1;
+		var7.icon = var1;
 		silk = var7;
+
 		var20 = new Item(32);
 		var1 = 24;
 		var7 = var20;
-		var7.iconIndex = var1;
+		var7.icon = var1;
 		feather = var7;
+
 		var20 = new Item(33);
 		var1 = 40;
 		var7 = var20;
-		var7.iconIndex = var1;
+		var7.icon = var1;
 		gunpowder = var7;
+
 		ItemHoe var23 = new ItemHoe(34, 0);
 		short var11 = 128;
 		ItemHoe var10 = var23;
-		var10.iconIndex = var11;
+		var10.icon = var11;
 		hoeWood = var10;
+
 		var23 = new ItemHoe(35, 1);
 		var11 = 129;
 		var10 = var23;
-		var10.iconIndex = var11;
+		var10.icon = var11;
 		hoeStone = var10;
+
 		var23 = new ItemHoe(36, 2);
 		var11 = 130;
 		var10 = var23;
-		var10.iconIndex = var11;
+		var10.icon = var11;
 		hoeSteel = var10;
-		var23 = new ItemHoe(37, 3);
+
+		var23 = new ItemHoe(37, 4);
 		var11 = 131;
 		var10 = var23;
-		var10.iconIndex = var11;
+		var10.icon = var11;
 		hoeDiamond = var10;
-		var23 = new ItemHoe(38, 4);
+
+		var23 = new ItemHoe(38, 3);
 		var11 = 132;
 		var10 = var23;
-		var10.iconIndex = var11;
+		var10.icon = var11;
 		hoeGold = var10;
+
 		ItemSeeds var24 = new ItemSeeds(39, Block.crops.blockID);
 		var1 = 9;
 		ItemSeeds var12 = var24;
-		var12.iconIndex = var1;
+		var12.icon = var1;
 		seeds = var12;
+
 		var20 = new Item(40);
 		var1 = 25;
 		var7 = var20;
-		var7.iconIndex = var1;
+		var7.icon = var1;
 		wheat = var7;
+
 		var18 = new ItemFood(41, 5);
 		var1 = 41;
 		var5 = var18;
-		var5.iconIndex = var1;
+		var5.icon = var1;
 		bread = var5;
+
 		ItemArmor var25 = new ItemArmor(42, 0, 0, 0);
 		var1 = 0;
 		ItemArmor var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		helmetLeather = var13;
+
 		var25 = new ItemArmor(43, 0, 0, 1);
 		var1 = 16;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		plateLeather = var13;
+
 		var25 = new ItemArmor(44, 0, 0, 2);
 		var1 = 32;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		legsLeather = var13;
+
 		var25 = new ItemArmor(45, 0, 0, 3);
 		var1 = 48;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		bootsLeather = var13;
+
 		var25 = new ItemArmor(46, 1, 1, 0);
 		var1 = 1;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		helmetChain = var13;
+
 		var25 = new ItemArmor(47, 1, 1, 1);
 		var1 = 17;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		plateChain = var13;
+
 		var25 = new ItemArmor(48, 1, 1, 2);
 		var1 = 33;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		legsChain = var13;
+
 		var25 = new ItemArmor(49, 1, 1, 3);
 		var1 = 49;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		bootsChain = var13;
+
 		var25 = new ItemArmor(50, 2, 2, 0);
 		var1 = 2;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		helmetSteel = var13;
+
 		var25 = new ItemArmor(51, 2, 2, 1);
 		var1 = 18;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		plateSteel = var13;
+
 		var25 = new ItemArmor(52, 2, 2, 2);
 		var1 = 34;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		legsSteel = var13;
+
 		var25 = new ItemArmor(53, 2, 2, 3);
 		var1 = 50;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		bootsSteel = var13;
+
 		var25 = new ItemArmor(54, 3, 3, 0);
 		var1 = 3;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		helmetDiamond = var13;
+
 		var25 = new ItemArmor(55, 3, 3, 1);
 		var1 = 19;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		plateDiamond = var13;
+
 		var25 = new ItemArmor(56, 3, 3, 2);
 		var1 = 35;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		legsDiamond = var13;
+
 		var25 = new ItemArmor(57, 3, 3, 3);
 		var1 = 51;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		bootsDiamond = var13;
+
 		var25 = new ItemArmor(58, 1, 4, 0);
 		var1 = 4;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		helmetGold = var13;
+
 		var25 = new ItemArmor(59, 1, 4, 1);
 		var1 = 20;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		plateGold = var13;
+
 		var25 = new ItemArmor(60, 1, 4, 2);
 		var1 = 36;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		legsGold = var13;
+
 		var25 = new ItemArmor(61, 1, 4, 3);
 		var1 = 52;
 		var13 = var25;
-		var13.iconIndex = var1;
+		var13.icon = var1;
 		bootsGold = var13;
+
 		var20 = new Item(62);
 		var1 = 6;
 		var7 = var20;
-		var7.iconIndex = var1;
+		var7.icon = var1;
 		flint = var7;
+
 		var18 = new ItemFood(63, 3);
 		var1 = 87;
 		var5 = var18;
-		var5.iconIndex = var1;
+		var5.icon = var1;
 		porkRaw = var5;
+
 		var18 = new ItemFood(64, 8);
 		var1 = 88;
 		var5 = var18;
-		var5.iconIndex = var1;
+		var5.icon = var1;
 		porkCooked = var5;
+
 		ItemPainting var26 = new ItemPainting(65);
 		var1 = 26;
 		ItemPainting var14 = var26;
-		var14.iconIndex = var1;
+		var14.icon = var1;
 		painting = var14;
 	}
 }
--- net/minecraft/client/render/RenderBlocks.java
+++ net/minecraft/client/render/RenderBlocks.java
@@ -2,13 +2,18 @@
 
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.block.BlockChain;
+import net.minecraft.game.level.block.BlockDoor;
+import net.minecraft.game.level.block.BlockGears;
 import net.minecraft.game.level.material.Material;
 import org.lwjgl.opengl.GL11;
 
 public final class RenderBlocks {
 	private World blockAccess;
 	private int overrideBlockTexture = -1;
+	private float inflation = 0.0F;
 	private boolean renderAllFaces = false;
+	private boolean flipTexture = false;
 
 	public RenderBlocks(World var1) {
 		this.blockAccess = var1;
@@ -31,79 +36,12 @@
 
 	public final boolean renderBlockByRenderType(Block var1, int var2, int var3, int var4) {
 		int var5 = var1.getRenderType();
+		var1.setBoundsForRender(this.blockAccess, var2, var3, var4);
 		Tessellator var6;
 		float var10;
 		boolean var26;
 		if(var5 == 0) {
-			var6 = Tessellator.instance;
-			var26 = false;
-			if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3 - 1, var4, 0)) {
-				var10 = var1.getBlockBrightness(this.blockAccess, var2, var3 - 1, var4);
-				if(Block.lightValue[var1.blockID] > 0) {
-					var10 = 1.0F;
-				}
-
-				var6.setColorOpaque_F(0.5F * var10, 0.5F * var10, 0.5F * var10);
-				this.renderBlockBottom(var1, (float)var2, (float)var3, (float)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 0));
-				var26 = true;
-			}
-
-			if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3 + 1, var4, 1)) {
-				var10 = var1.getBlockBrightness(this.blockAccess, var2, var3 + 1, var4);
-				if(Block.lightValue[var1.blockID] > 0) {
-					var10 = 1.0F;
-				}
-
-				var6.setColorOpaque_F(var10 * 1.0F, var10 * 1.0F, var10 * 1.0F);
-				this.renderBlockTop(var1, (float)var2, (float)var3, (float)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 1));
-				var26 = true;
-			}
-
-			if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3, var4 - 1, 2)) {
-				var10 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4 - 1);
-				if(Block.lightValue[var1.blockID] > 0) {
-					var10 = 1.0F;
-				}
-
-				var6.setColorOpaque_F(0.8F * var10, 0.8F * var10, 0.8F * var10);
-				this.renderBlockNorth(var1, var2, var3, var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 2));
-				var26 = true;
-			}
-
-			if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3, var4 + 1, 3)) {
-				var10 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4 + 1);
-				if(Block.lightValue[var1.blockID] > 0) {
-					var10 = 1.0F;
-				}
-
-				var6.setColorOpaque_F(0.8F * var10, 0.8F * var10, 0.8F * var10);
-				this.renderBlockSouth(var1, var2, var3, var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 3));
-				var26 = true;
-			}
-
-			if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2 - 1, var3, var4, 4)) {
-				var10 = var1.getBlockBrightness(this.blockAccess, var2 - 1, var3, var4);
-				if(Block.lightValue[var1.blockID] > 0) {
-					var10 = 1.0F;
-				}
-
-				var6.setColorOpaque_F(0.6F * var10, 0.6F * var10, 0.6F * var10);
-				this.renderBlockWest(var1, var2, var3, var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 4));
-				var26 = true;
-			}
-
-			if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2 + 1, var3, var4, 5)) {
-				var10 = var1.getBlockBrightness(this.blockAccess, var2 + 1, var3, var4);
-				if(Block.lightValue[var1.blockID] > 0) {
-					var10 = 1.0F;
-				}
-
-				var6.setColorOpaque_F(0.6F * var10, 0.6F * var10, 0.6F * var10);
-				this.renderBlockEast(var1, var2, var3, var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 5));
-				var26 = true;
-			}
-
-			return var26;
+			return renderStandardBlock(var1, var2, var3, var4);
 		} else {
 			float var11;
 			float var22;
@@ -409,32 +347,171 @@
 						var13 = ((float)var23 + 15.99F) / 256.0F;
 						var14 = (float)var9 / 256.0F;
 						var15 = ((float)var9 + 15.99F) / 256.0F;
-						if(this.blockAccess.isBlockNormalCube(var3 - 1, var4, var5)) {
-							var6.addVertexWithUV((float)var3 + 0.05F, (float)(var4 + 1) + 2.0F / 16.0F, (float)(var5 + 1) + 2.0F / 16.0F, var10, var22);
-							var6.addVertexWithUV((float)var3 + 0.05F, (float)var4 - 2.0F / 16.0F, (float)(var5 + 1) + 2.0F / 16.0F, var10, var20);
-							var6.addVertexWithUV((float)var3 + 0.05F, (float)var4 - 2.0F / 16.0F, (float)var5 - 2.0F / 16.0F, var11, var20);
-							var6.addVertexWithUV((float)var3 + 0.05F, (float)(var4 + 1) + 2.0F / 16.0F, (float)var5 - 2.0F / 16.0F, var11, var22);
-						}
-
-						if(this.blockAccess.isBlockNormalCube(var3 + 1, var4, var5)) {
-							var6.addVertexWithUV((float)(var3 + 1) - 0.05F, (float)var4 - 2.0F / 16.0F, (float)(var5 + 1) + 2.0F / 16.0F, var11, var20);
-							var6.addVertexWithUV((float)(var3 + 1) - 0.05F, (float)(var4 + 1) + 2.0F / 16.0F, (float)(var5 + 1) + 2.0F / 16.0F, var11, var22);
-							var6.addVertexWithUV((float)(var3 + 1) - 0.05F, (float)(var4 + 1) + 2.0F / 16.0F, (float)var5 - 2.0F / 16.0F, var10, var22);
-							var6.addVertexWithUV((float)(var3 + 1) - 0.05F, (float)var4 - 2.0F / 16.0F, (float)var5 - 2.0F / 16.0F, var10, var20);
-						}
-
-						if(this.blockAccess.isBlockNormalCube(var3, var4, var5 - 1)) {
-							var6.addVertexWithUV((float)(var3 + 1) + 2.0F / 16.0F, (float)var4 - 2.0F / 16.0F, (float)var5 + 0.05F, var13, var15);
-							var6.addVertexWithUV((float)(var3 + 1) + 2.0F / 16.0F, (float)(var4 + 1) + 2.0F / 16.0F, (float)var5 + 0.05F, var13, var14);
-							var6.addVertexWithUV((float)var3 - 2.0F / 16.0F, (float)(var4 + 1) + 2.0F / 16.0F, (float)var5 + 0.05F, var12, var14);
-							var6.addVertexWithUV((float)var3 - 2.0F / 16.0F, (float)var4 - 2.0F / 16.0F, (float)var5 + 0.05F, var12, var15);
-						}
-
-						if(this.blockAccess.isBlockNormalCube(var3, var4, var5 + 1)) {
-							var6.addVertexWithUV((float)(var3 + 1) + 2.0F / 16.0F, (float)(var4 + 1) + 2.0F / 16.0F, (float)(var5 + 1) - 0.05F, var12, var14);
-							var6.addVertexWithUV((float)(var3 + 1) + 2.0F / 16.0F, (float)var4 - 2.0F / 16.0F, (float)(var5 + 1) - 0.05F, var12, var15);
-							var6.addVertexWithUV((float)var3 - 2.0F / 16.0F, (float)var4 - 2.0F / 16.0F, (float)(var5 + 1) - 0.05F, var13, var15);
-							var6.addVertexWithUV((float)var3 - 2.0F / 16.0F, (float)(var4 + 1) + 2.0F / 16.0F, (float)(var5 + 1) - 0.05F, var13, var14);
+						int beamState = 0;
+						Block chain = null;
+
+						Block attachment = null;
+						if((attachment = BlockGears.getAttachedBlock(this.blockAccess, var3 - 1, var4, var5)) != null) {
+							beamState |= 1 << 0;
+							if (attachment.isOpaqueCube()) {
+								var6.addVertexWithUV((float) var3 + 0.05F, (float) (var4 + 1) + 2.0F / 16.0F, (float) (var5 + 1) + 2.0F / 16.0F, var10, var22);
+								var6.addVertexWithUV((float) var3 + 0.05F, (float) var4 - 2.0F / 16.0F, (float) (var5 + 1) + 2.0F / 16.0F, var10, var20);
+								var6.addVertexWithUV((float) var3 + 0.05F, (float) var4 - 2.0F / 16.0F, (float) var5 - 2.0F / 16.0F, var11, var20);
+								var6.addVertexWithUV((float) var3 + 0.05F, (float) (var4 + 1) + 2.0F / 16.0F, (float) var5 - 2.0F / 16.0F, var11, var22);
+							} else if (attachment instanceof BlockChain) {
+								chain = attachment;
+							} else if (attachment instanceof BlockGears) {
+								beamState |= 1 << 1;
+							}
+						}
+
+						if((attachment = BlockGears.getAttachedBlock(this.blockAccess, var3 + 1, var4, var5)) != null) {
+							beamState |= 1 << 1;
+							if (attachment.isOpaqueCube()) {
+								var6.addVertexWithUV((float) (var3 + 1) - 0.05F, (float) var4 - 2.0F / 16.0F, (float) (var5 + 1) + 2.0F / 16.0F, var11, var20);
+								var6.addVertexWithUV((float) (var3 + 1) - 0.05F, (float) (var4 + 1) + 2.0F / 16.0F, (float) (var5 + 1) + 2.0F / 16.0F, var11, var22);
+								var6.addVertexWithUV((float) (var3 + 1) - 0.05F, (float) (var4 + 1) + 2.0F / 16.0F, (float) var5 - 2.0F / 16.0F, var10, var22);
+								var6.addVertexWithUV((float) (var3 + 1) - 0.05F, (float) var4 - 2.0F / 16.0F, (float) var5 - 2.0F / 16.0F, var10, var20);
+							} else if (attachment instanceof BlockChain) {
+								chain = attachment;
+							} else if (attachment instanceof BlockGears) {
+								beamState |= 1 << 0;
+							}
+						}
+
+						if((attachment = BlockGears.getAttachedBlock(this.blockAccess, var3, var4 - 1, var5)) != null && BlockGears.showFloorGear(this.blockAccess, var3, var4, var5, -1)) {
+							beamState |= 1 << 2;
+							if (attachment.isOpaqueCube()) {
+								var6.addVertexWithUV((float) var3 - 2.0F / 16.0F, (float) var4 + 0.05F, (float) (var5 + 1) + 2.0F / 16.0F, var11, var22);
+								var6.addVertexWithUV((float) (var3 + 1) + 2.0F / 16.0F, (float) var4 + 0.05F, (float) (var5 + 1) + 2.0F / 16.0F, var11, var20);
+								var6.addVertexWithUV((float) (var3 + 1) + 2.0F / 16.0F, (float) var4 + 0.05F, (float) var5 - 2.0F / 16.0F, var10, var20);
+								var6.addVertexWithUV((float) var3 - 2.0F / 16.0F, (float) var4 + 0.05F, (float) var5 - 2.0F / 16.0F, var10, var22);
+							} else if (attachment instanceof BlockChain) {
+								chain = attachment;
+							} else if (attachment instanceof BlockGears) {
+								beamState |= 1 << 3;
+							}
+						}
+
+						if((attachment = BlockGears.getAttachedBlock(this.blockAccess, var3, var4 + 1, var5)) != null && BlockGears.showFloorGear(this.blockAccess, var3, var4, var5, 1)) {
+							beamState |= 1 << 3;
+							if (attachment.isOpaqueCube()) {
+								var6.addVertexWithUV((float) (var3 + 1) + 2.0F / 16.0F, (float) (var4 + 1) - 0.05F, (float) (var5 + 1) + 2.0F / 16.0F, var10, var22);
+								var6.addVertexWithUV((float) var3 - 2.0F / 16.0F, (float) (var4 + 1) - 0.05F, (float) (var5 + 1) + 2.0F / 16.0F, var10, var20);
+								var6.addVertexWithUV((float) var3 - 2.0F / 16.0F, (float) (var4 + 1) - 0.05F, (float) var5 - 2.0F / 16.0F, var11, var20);
+								var6.addVertexWithUV((float) (var3 + 1) + 2.0F / 16.0F, (float) (var4 + 1) - 0.05F, (float) var5 - 2.0F / 16.0F, var11, var22);
+							} else if (attachment instanceof BlockChain) {
+								chain = attachment;
+							} else if (attachment instanceof BlockGears) {
+								beamState |= 1 << 2;
+							}
+						}
+
+						if((attachment = BlockGears.getAttachedBlock(this.blockAccess, var3, var4, var5 - 1)) != null) {
+							beamState |= 1 << 4;
+							if (attachment.isOpaqueCube()) {
+								var6.addVertexWithUV((float) (var3 + 1) + 2.0F / 16.0F, (float) var4 - 2.0F / 16.0F, (float) var5 + 0.05F, var13, var15);
+								var6.addVertexWithUV((float) (var3 + 1) + 2.0F / 16.0F, (float) (var4 + 1) + 2.0F / 16.0F, (float) var5 + 0.05F, var13, var14);
+								var6.addVertexWithUV((float) var3 - 2.0F / 16.0F, (float) (var4 + 1) + 2.0F / 16.0F, (float) var5 + 0.05F, var12, var14);
+								var6.addVertexWithUV((float) var3 - 2.0F / 16.0F, (float) var4 - 2.0F / 16.0F, (float) var5 + 0.05F, var12, var15);
+							} else if (attachment instanceof BlockChain) {
+								chain = attachment;
+							} else if (attachment instanceof BlockGears) {
+								beamState |= 1 << 5;
+							}
+						}
+
+						if((attachment = BlockGears.getAttachedBlock(this.blockAccess, var3, var4, var5 + 1)) != null) {
+							beamState |= 1 << 5;
+							if (attachment.isOpaqueCube()) {
+								var6.addVertexWithUV((float) (var3 + 1) + 2.0F / 16.0F, (float) (var4 + 1) + 2.0F / 16.0F, (float) (var5 + 1) - 0.05F, var12, var14);
+								var6.addVertexWithUV((float) (var3 + 1) + 2.0F / 16.0F, (float) var4 - 2.0F / 16.0F, (float) (var5 + 1) - 0.05F, var12, var15);
+								var6.addVertexWithUV((float) var3 - 2.0F / 16.0F, (float) var4 - 2.0F / 16.0F, (float) (var5 + 1) - 0.05F, var13, var15);
+								var6.addVertexWithUV((float) var3 - 2.0F / 16.0F, (float) (var4 + 1) + 2.0F / 16.0F, (float) (var5 + 1) - 0.05F, var13, var14);
+							} else if (attachment instanceof BlockChain) {
+								chain = attachment;
+							} else if (attachment instanceof BlockGears) {
+								beamState |= 1 << 4;
+							}
+						}
+
+						float sftN = 6.0F / 16.0F;
+						float sftP = 10.0F / 16.0F;
+						float iftN = 7.0F / 16.0F;
+						float iftP = 9.0F / 16.0F;
+
+						int chainTexture = chain != null ? chain.blockIndexInTexture : Block.ironChain.blockIndexInTexture;
+
+						if (chain == null ? beamState == 3 << 0 : ((beamState >> 0) & 3) == 3) {
+							this.overrideBlockTexture = chainTexture;
+							Block.cog.setBlockBounds(0.0F, sftN, sftN, 1.0F, sftP, sftP);
+							this.renderStandardBlock(Block.cog, var3, var4, var5);
+
+							if (chain == null) {
+								this.overrideBlockTexture = Block.blockSteel.blockIndexInTexture - 16;
+								Block.cog.setBlockBounds(0.0F, iftN, iftN, 1.0F, iftP, iftP);
+								this.renderStandardBlock(Block.cog, var3, var4, var5);
+							}
+
+							this.overrideBlockTexture = -1;
+							Block.cog.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+						}
+
+						if (chain == null ? beamState == 3 << 2 : ((beamState >> 2) & 3) == 3) {
+							this.overrideBlockTexture = chainTexture;
+							Block.cog.setBlockBounds(sftN, 0.0F, sftN, sftP, 1.0F, sftP);
+							this.renderStandardBlock(Block.cog, var3, var4, var5);
+
+							if (chain == null) {
+								this.overrideBlockTexture = Block.blockSteel.blockIndexInTexture - 16;
+								Block.cog.setBlockBounds(iftN, 0.0F, iftN, iftP, 1.0F, iftP);
+								this.renderStandardBlock(Block.cog, var3, var4, var5);
+							}
+
+							this.overrideBlockTexture = -1;
+							Block.cog.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+						}
+
+						if (chain == null ? beamState == 3 << 4 : ((beamState >> 4) & 3) == 3) {
+							this.overrideBlockTexture = chainTexture;
+							Block.cog.setBlockBounds(sftN, sftN, 0.0F, sftP, sftP, 1.0F);
+							this.renderStandardBlock(Block.cog, var3, var4, var5);
+
+							if (chain == null) {
+								this.overrideBlockTexture = Block.blockSteel.blockIndexInTexture - 16;
+								Block.cog.setBlockBounds(iftN, iftN, 0.0F, iftP, iftP, 1.0F);
+								this.renderStandardBlock(Block.cog, var3, var4, var5);
+							}
+
+							this.overrideBlockTexture = -1;
+							Block.cog.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+						}
+
+						return true;
+					} else if (var5 == 7) {
+						this.renderBlockDoor(var1, var2, var3, var4);
+						return true;
+					} else if (var5 == 8) {
+						this.renderBlockChain((BlockChain)var1, var2, var3, var4);
+						return true;
+					} else if (var5 == 9) {
+						boolean rendered = this.renderStandardBlock(var1, var2, var3, var4);
+						if (!rendered) return false;
+
+						int grateType = this.blockAccess.getBlockMetadata(var2, var3, var4) >> 4 & 3;
+						if (grateType == 1) {
+							this.overrideBlockTexture = Block.ironGrate.blockIndexInTexture + 16;
+						} else if (grateType == 2) {
+							this.overrideBlockTexture = Block.woodenGrate.blockIndexInTexture + 16;
+						} else if (grateType == 3) {
+							this.overrideBlockTexture = Block.goldenGrate.blockIndexInTexture + 16;
+						}
+
+						if (this.overrideBlockTexture != -1) {
+							this.inflation = 0.005F;
+							this.renderStandardBlock(var1, var2, var3, var4);
+							this.inflation = 0.0F;
+							this.overrideBlockTexture = -1;
 						}
 
 						return true;
@@ -446,6 +523,80 @@
 		}
 	}
 
+	private boolean renderStandardBlock(Block var1, int var2, int var3, int var4) {
+		Tessellator var6 = Tessellator.instance;
+		float var10;
+		boolean var26 = false;
+
+		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3 - 1, var4, 0)) {
+			var10 = var1.getBlockBrightness(this.blockAccess, var2, var3 - 1, var4);
+			if(Block.lightValue[var1.blockID] > 0) {
+				var10 = 1.0F;
+			}
+
+			var6.setColorOpaque_F(0.5F * var10, 0.5F * var10, 0.5F * var10);
+			this.renderBlockBottom(var1, (float)var2, (float)var3, (float)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 0));
+			var26 = true;
+		}
+
+		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3 + 1, var4, 1)) {
+			var10 = var1.getBlockBrightness(this.blockAccess, var2, var3 + 1, var4);
+			if(Block.lightValue[var1.blockID] > 0) {
+				var10 = 1.0F;
+			}
+
+			var6.setColorOpaque_F(var10 * 1.0F, var10 * 1.0F, var10 * 1.0F);
+			this.renderBlockTop(var1, (float)var2, (float)var3, (float)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 1));
+			var26 = true;
+		}
+
+		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3, var4 - 1, 2)) {
+			var10 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4 - 1);
+			if(Block.lightValue[var1.blockID] > 0) {
+				var10 = 1.0F;
+			}
+
+			var6.setColorOpaque_F(0.8F * var10, 0.8F * var10, 0.8F * var10);
+			this.renderBlockNorth(var1, var2, var3, var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 2));
+			var26 = true;
+		}
+
+		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3, var4 + 1, 3)) {
+			var10 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4 + 1);
+			if(Block.lightValue[var1.blockID] > 0) {
+				var10 = 1.0F;
+			}
+
+			var6.setColorOpaque_F(0.8F * var10, 0.8F * var10, 0.8F * var10);
+			this.renderBlockSouth(var1, var2, var3, var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 3));
+			var26 = true;
+		}
+
+		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2 - 1, var3, var4, 4)) {
+			var10 = var1.getBlockBrightness(this.blockAccess, var2 - 1, var3, var4);
+			if(Block.lightValue[var1.blockID] > 0) {
+				var10 = 1.0F;
+			}
+
+			var6.setColorOpaque_F(0.6F * var10, 0.6F * var10, 0.6F * var10);
+			this.renderBlockWest(var1, var2, var3, var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 4));
+			var26 = true;
+		}
+
+		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2 + 1, var3, var4, 5)) {
+			var10 = var1.getBlockBrightness(this.blockAccess, var2 + 1, var3, var4);
+			if(Block.lightValue[var1.blockID] > 0) {
+				var10 = 1.0F;
+			}
+
+			var6.setColorOpaque_F(0.6F * var10, 0.6F * var10, 0.6F * var10);
+			this.renderBlockEast(var1, var2, var3, var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 5));
+			var26 = true;
+		}
+
+		return var26;
+	}
+
 	private void renderBlockTorch(Block var1, float var2, float var3, float var4, float var5, float var6) {
 		Tessellator var7 = Tessellator.instance;
 		int var19 = var1.getBlockTextureFromSide(0);
@@ -581,6 +732,151 @@
 		var6.addVertexWithUV(var10, var4 + 1.0F, var12, var14, var8);
 	}
 
+	private void renderBlockDoor(Block var1, int var2, int var3, int var4) {
+		Tessellator var5 = Tessellator.instance;
+		BlockDoor var6 = (BlockDoor)var1;
+		float var8 = 0.5F;
+		float var9 = 1.0F;
+		float var10 = 0.6F;
+		float var11 = 0.8F;
+		float var12 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
+		float var13 = Math.max(var1.getBlockBrightness(this.blockAccess, var2, var3 - 1, var4), var12);
+		if(Block.lightValue[var1.blockID] > 0) {
+			var13 = 1.0F;
+		}
+
+		var5.setColorOpaque_F(var8 * var13, var8 * var13, var8 * var13);
+		this.renderBlockBottom(var1, var2, var3, var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 0));
+		var13 = Math.max(var1.getBlockBrightness(this.blockAccess, var2, var3 + 1, var4), var12);
+		if(Block.lightValue[var1.blockID] > 0) {
+			var13 = 1.0F;
+		}
+
+		var5.setColorOpaque_F(var9 * var13, var9 * var13, var9 * var13);
+		this.renderBlockTop(var1, var2, var3, var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 1));
+		var13 = Math.max(var1.getBlockBrightness(this.blockAccess, var2 + 1, var3, var4), var12);
+		if(Block.lightValue[var1.blockID] > 0) {
+			var13 = 1.0F;
+		}
+
+		var5.setColorOpaque_F(var10 * var13, var10 * var13, var10 * var13);
+		int var14 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 4);
+		if(var14 < 0) {
+			this.flipTexture = true;
+			var14 = -var14;
+		}
+
+		this.renderBlockEast(var1, var2, var3, var4, var14);
+		this.flipTexture = false;
+		var13 = Math.max(var1.getBlockBrightness(this.blockAccess, var2 - 1, var3, var4), var12);
+		if(Block.lightValue[var1.blockID] > 0) {
+			var13 = 1.0F;
+		}
+
+		var5.setColorOpaque_F(var10 * var13, var10 * var13, var10 * var13);
+		var14 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 5);
+		if(var14 < 0) {
+			this.flipTexture = true;
+			var14 = -var14;
+		}
+
+		this.renderBlockWest(var1, var2, var3, var4, var14);
+		this.flipTexture = false;
+		var13 = Math.max(var1.getBlockBrightness(this.blockAccess, var2, var3, var4 - 1), var12);
+		if(Block.lightValue[var1.blockID] > 0) {
+			var13 = 1.0F;
+		}
+
+		var5.setColorOpaque_F(var11 * var13, var11 * var13, var11 * var13);
+		var14 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 2);
+		if(var14 < 0) {
+			this.flipTexture = true;
+			var14 = -var14;
+		}
+
+		this.renderBlockNorth(var1, var2, var3, var4, var14);
+		this.flipTexture = false;
+		var13 = Math.max(var1.getBlockBrightness(this.blockAccess, var2, var3, var4 + 1), var12);
+		if(Block.lightValue[var1.blockID] > 0) {
+			var13 = 1.0F;
+		}
+
+		var5.setColorOpaque_F(var11 * var13, var11 * var13, var11 * var13);
+		var14 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 3);
+		if(var14 < 0) {
+			this.flipTexture = true;
+			var14 = -var14;
+		}
+
+		this.renderBlockSouth(var1, var2, var3, var4, var14);
+		this.flipTexture = false;
+	}
+
+	private void renderBlockChain(BlockChain var1, int var2, int var3, int var4) {
+		var1.setBlockBounds(
+			6.0F / 16.0F, 6.0F / 16.0F, 6.0F / 16.0F,
+			10.0F / 16.0F, 10.0F / 16.0F, 10.0F / 16.0F
+		);
+		this.renderStandardBlock(var1, var2, var3, var4);
+		Block neighbor;
+
+		neighbor = Block.blocksList[this.blockAccess.getBlockId(var2, var3 + 1, var4)];
+		if (neighbor != null && (Block.conductive[neighbor.blockID] && var1.conductWithBlock(neighbor) || neighbor.canReceivePower(this.blockAccess, var2, var3 + 1, var4, 0))) {
+			var1.setBlockBounds(
+				6.0F / 16.0F, 10.0F / 16.0F, 6.0F / 16.0F,
+				10.0F / 16.0F, 16.0F / 16.0F, 10.0F / 16.0F
+			);
+			this.renderStandardBlock(var1, var2, var3, var4);
+		}
+
+		neighbor = Block.blocksList[this.blockAccess.getBlockId(var2, var3 - 1, var4)];
+		if (neighbor != null && (Block.conductive[neighbor.blockID] && var1.conductWithBlock(neighbor) || neighbor.canReceivePower(this.blockAccess, var2, var3 - 1, var4, 1))) {
+			var1.setBlockBounds(
+				6.0F / 16.0F, 0.0F / 16.0F, 6.0F / 16.0F,
+				10.0F / 16.0F, 6.0F / 16.0F, 10.0F / 16.0F
+			);
+			this.renderStandardBlock(var1, var2, var3, var4);
+		}
+
+		neighbor = Block.blocksList[this.blockAccess.getBlockId(var2, var3, var4 + 1)];
+		if (neighbor != null && (Block.conductive[neighbor.blockID] && var1.conductWithBlock(neighbor) || neighbor.canReceivePower(this.blockAccess, var2, var3, var4 + 1, 2))) {
+			var1.setBlockBounds(
+				6.0F / 16.0F, 6.0F / 16.0F, 10.0F / 16.0F,
+				10.0F / 16.0F, 10.0F / 16.0F, 16.0F / 16.0F
+			);
+			this.renderStandardBlock(var1, var2, var3, var4);
+		}
+
+		neighbor = Block.blocksList[this.blockAccess.getBlockId(var2, var3, var4 - 1)];
+		if (neighbor != null && (Block.conductive[neighbor.blockID] && var1.conductWithBlock(neighbor) || neighbor.canReceivePower(this.blockAccess, var2, var3, var4 - 1, 3))) {
+			var1.setBlockBounds(
+				6.0F / 16.0F, 6.0F / 16.0F, 0.0F / 16.0F,
+				10.0F / 16.0F, 10.0F / 16.0F, 6.0F / 16.0F
+			);
+			this.renderStandardBlock(var1, var2, var3, var4);
+		}
+
+		neighbor = Block.blocksList[this.blockAccess.getBlockId(var2 + 1, var3, var4)];
+		if (neighbor != null && (Block.conductive[neighbor.blockID] && var1.conductWithBlock(neighbor) || neighbor.canReceivePower(this.blockAccess, var2 + 1, var3, var4, 4))) {
+			var1.setBlockBounds(
+				10.0F / 16.0F, 6.0F / 16.0F, 6.0F / 16.0F,
+				16.0F / 16.0F, 10.0F / 16.0F, 10.0F / 16.0F
+			);
+			this.renderStandardBlock(var1, var2, var3, var4);
+		}
+
+		neighbor = Block.blocksList[this.blockAccess.getBlockId(var2 - 1, var3, var4)];
+		if (neighbor != null && (Block.conductive[neighbor.blockID] && var1.conductWithBlock(neighbor) || neighbor.canReceivePower(this.blockAccess, var2 - 1, var3, var4, 5))) {
+			var1.setBlockBounds(
+				0.0F / 16.0F, 6.0F / 16.0F, 6.0F / 16.0F,
+				6.0F / 16.0F, 10.0F / 16.0F, 10.0F / 16.0F
+			);
+			this.renderStandardBlock(var1, var2, var3, var4);
+		}
+
+		var1.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+	}
+
 	private float materialNotWater(int var1, int var2, int var3) {
 		return this.blockAccess.getBlockMaterial(var1, var2, var3) != Material.water ? 1.0F : (float)this.blockAccess.getBlockMetadata(var1, var2, var3) / 9.0F;
 	}
@@ -593,15 +889,15 @@
 
 		int var7 = (var5 & 15) << 4;
 		var5 &= 240;
-		float var8 = (float)var7 / 256.0F;
-		float var14 = ((float)var7 + 15.99F) / 256.0F;
-		float var9 = (float)var5 / 256.0F;
-		float var13 = ((float)var5 + 15.99F) / 256.0F;
-		float var10 = var2 + var1.minX;
-		var2 += var1.maxX;
-		var3 += var1.minY;
-		float var11 = var4 + var1.minZ;
-		float var12 = var4 + var1.maxZ;
+		float var8 = var7 / 256.0F + var1.minX / 16.0F;
+		float var14 = (var7 - 0.01F) / 256.0F + var1.maxX / 16.0F;
+		float var9 = var5 / 256.0F + var1.minZ / 16.0F;
+		float var13 = (var5 - 0.01F) / 256.0F + var1.maxZ / 16.0F;
+		float var10 = var2 + var1.minX - this.inflation;
+		var2 += var1.maxX + this.inflation;
+		var3 += var1.minY - this.inflation;
+		float var11 = var4 + var1.minZ - this.inflation;
+		float var12 = var4 + var1.maxZ + this.inflation;
 		var6.addVertexWithUV(var10, var3, var12, var8, var13);
 		var6.addVertexWithUV(var10, var3, var11, var8, var9);
 		var6.addVertexWithUV(var2, var3, var11, var14, var9);
@@ -616,15 +912,15 @@
 
 		int var7 = (var5 & 15) << 4;
 		var5 &= 240;
-		float var8 = (float)var7 / 256.0F;
-		float var14 = ((float)var7 + 15.99F) / 256.0F;
-		float var9 = (float)var5 / 256.0F;
-		float var13 = ((float)var5 + 15.99F) / 256.0F;
-		float var10 = var2 + var1.minX;
-		var2 += var1.maxX;
-		var3 += var1.maxY;
-		float var11 = var4 + var1.minZ;
-		float var12 = var4 + var1.maxZ;
+		float var8 = var7 / 256.0F + var1.minX / 16.0F;
+		float var14 = (var7 - 0.01F) / 256.0F + var1.maxX / 16.0F;
+		float var9 = var5 / 256.0F + var1.minZ / 16.0F;
+		float var13 = (var5 - 0.01F) / 256.0F + var1.maxZ / 16.0F;
+		float var10 = var2 + var1.minX - this.inflation;
+		var2 += var1.maxX + this.inflation;
+		var3 += var1.maxY + this.inflation;
+		float var11 = var4 + var1.minZ - this.inflation;
+		float var12 = var4 + var1.maxZ + this.inflation;
 		var6.addVertexWithUV(var2, var3, var12, var14, var13);
 		var6.addVertexWithUV(var2, var3, var11, var14, var9);
 		var6.addVertexWithUV(var10, var3, var11, var8, var9);
@@ -639,8 +935,8 @@
 
 		int var7 = (var5 & 15) << 4;
 		var5 &= 240;
-		float var8 = (float)var7 / 256.0F;
-		float var16 = ((float)var7 + 15.99F) / 256.0F;
+		float var8 = var7 / 256.0F + (1.0F - var1.maxX) / 16.0F;
+		float var16 = (var7 - 0.01F) / 256.0F + (1.0F - var1.minX) / 16.0F;
 		float var9;
 		float var15;
 		if(var1.minY >= 0.0F && var1.maxY <= 1.0F) {
@@ -651,11 +947,17 @@
 			var15 = ((float)var5 + 15.99F) / 256.0F;
 		}
 
-		float var10 = (float)var2 + var1.minX;
-		float var13 = (float)var2 + var1.maxX;
-		float var11 = (float)var3 + var1.minY;
-		float var14 = (float)var3 + var1.maxY;
-		float var12 = (float)var4 + var1.minZ;
+		if (this.flipTexture) {
+			float swap = var8;
+			var8 = var16;
+			var16 = swap;
+		}
+
+		float var10 = (float)var2 + var1.minX - this.inflation;
+		float var13 = (float)var2 + var1.maxX + this.inflation;
+		float var11 = (float)var3 + var1.minY - this.inflation;
+		float var14 = (float)var3 + var1.maxY + this.inflation;
+		float var12 = (float)var4 + var1.minZ - this.inflation;
 		var6.addVertexWithUV(var10, var14, var12, var16, var9);
 		var6.addVertexWithUV(var13, var14, var12, var8, var9);
 		var6.addVertexWithUV(var13, var11, var12, var8, var15);
@@ -670,8 +972,8 @@
 
 		int var7 = (var5 & 15) << 4;
 		var5 &= 240;
-		float var8 = (float)var7 / 256.0F;
-		float var16 = ((float)var7 + 15.99F) / 256.0F;
+		float var8 = var7 / 256.0F + var1.minX / 16.0F;
+		float var16 = (var7 - 0.01F) / 256.0F + var1.maxX / 16.0F;
 		float var9;
 		float var15;
 		if(var1.minY >= 0.0F && var1.maxY <= 1.0F) {
@@ -682,11 +984,17 @@
 			var15 = ((float)var5 + 15.99F) / 256.0F;
 		}
 
-		float var10 = (float)var2 + var1.minX;
-		float var13 = (float)var2 + var1.maxX;
-		float var11 = (float)var3 + var1.minY;
-		float var14 = (float)var3 + var1.maxY;
-		float var12 = (float)var4 + var1.maxZ;
+		if (this.flipTexture) {
+			float swap = var8;
+			var8 = var16;
+			var16 = swap;
+		}
+
+		float var10 = (float)var2 + var1.minX - this.inflation;
+		float var13 = (float)var2 + var1.maxX + this.inflation;
+		float var11 = (float)var3 + var1.minY - this.inflation;
+		float var14 = (float)var3 + var1.maxY + this.inflation;
+		float var12 = (float)var4 + var1.maxZ + this.inflation;
 		var6.addVertexWithUV(var10, var14, var12, var8, var9);
 		var6.addVertexWithUV(var10, var11, var12, var8, var15);
 		var6.addVertexWithUV(var13, var11, var12, var16, var15);
@@ -701,8 +1009,8 @@
 
 		int var7 = (var5 & 15) << 4;
 		var5 &= 240;
-		float var8 = (float)var7 / 256.0F;
-		float var16 = ((float)var7 + 15.99F) / 256.0F;
+		float var8 = var7 / 256.0F + var1.minZ / 16.0F;
+		float var16 = (var7 - 0.01F) / 256.0F + var1.maxZ / 16.0F;
 		float var9;
 		float var15;
 		if(var1.minY >= 0.0F && var1.maxY <= 1.0F) {
@@ -713,11 +1021,17 @@
 			var15 = ((float)var5 + 15.99F) / 256.0F;
 		}
 
-		float var13 = (float)var2 + var1.minX;
-		float var10 = (float)var3 + var1.minY;
-		float var14 = (float)var3 + var1.maxY;
-		float var11 = (float)var4 + var1.minZ;
-		float var12 = (float)var4 + var1.maxZ;
+		if (this.flipTexture) {
+			float swap = var8;
+			var8 = var16;
+			var16 = swap;
+		}
+
+		float var13 = (float)var2 + var1.minX - this.inflation;
+		float var10 = (float)var3 + var1.minY - this.inflation;
+		float var14 = (float)var3 + var1.maxY + this.inflation;
+		float var11 = (float)var4 + var1.minZ - this.inflation;
+		float var12 = (float)var4 + var1.maxZ + this.inflation;
 		var6.addVertexWithUV(var13, var14, var12, var16, var9);
 		var6.addVertexWithUV(var13, var14, var11, var8, var9);
 		var6.addVertexWithUV(var13, var10, var11, var8, var15);
@@ -732,8 +1046,8 @@
 
 		int var7 = (var5 & 15) << 4;
 		var5 &= 240;
-		float var8 = (float)var7 / 256.0F;
-		float var16 = ((float)var7 + 15.99F) / 256.0F;
+		float var8 = var7 / 256.0F + (1.0F - var1.maxZ) / 16.0F;
+		float var16 = (var7 - 0.01F) / 256.0F + (1.0F - var1.minZ) / 16.0F;
 		float var9;
 		float var15;
 		if(var1.minY >= 0.0F && var1.maxY <= 1.0F) {
@@ -744,45 +1058,52 @@
 			var15 = ((float)var5 + 15.99F) / 256.0F;
 		}
 
-		float var13 = (float)var2 + var1.maxX;
-		float var10 = (float)var3 + var1.minY;
-		float var14 = (float)var3 + var1.maxY;
-		float var11 = (float)var4 + var1.minZ;
-		float var12 = (float)var4 + var1.maxZ;
+		if (this.flipTexture) {
+			float swap = var8;
+			var8 = var16;
+			var16 = swap;
+		}
+
+		float var13 = (float)var2 + var1.maxX + this.inflation;
+		float var10 = (float)var3 + var1.minY - this.inflation;
+		float var14 = (float)var3 + var1.maxY + this.inflation;
+		float var11 = (float)var4 + var1.minZ - this.inflation;
+		float var12 = (float)var4 + var1.maxZ + this.inflation;
 		var6.addVertexWithUV(var13, var10, var12, var8, var15);
 		var6.addVertexWithUV(var13, var10, var11, var16, var15);
 		var6.addVertexWithUV(var13, var14, var11, var16, var9);
 		var6.addVertexWithUV(var13, var14, var12, var8, var9);
 	}
 
-	public final void renderBlockOnInventory(Block var1) {
+	public final void renderBlockOnInventory(Block var1, int meta) {
 		Tessellator var2 = Tessellator.instance;
 		int var3 = var1.getRenderType();
-		if(var3 == 0) {
+		var1.resetBlockBounds();
+		if(var3 == 0 || var3 == 9) {
 			GL11.glTranslatef(-0.5F, -0.5F, -0.5F);
 			var2.startDrawingQuads();
 			Tessellator.setNormal(0.0F, -1.0F, 0.0F);
-			this.renderBlockBottom(var1, 0.0F, 0.0F, 0.0F, var1.getBlockTextureFromSide(0));
+			this.renderBlockBottom(var1, 0.0F, 0.0F, 0.0F, var1.getBlockTextureFromSideAndMetadata(0, meta));
 			var2.draw();
 			var2.startDrawingQuads();
 			Tessellator.setNormal(0.0F, 1.0F, 0.0F);
-			this.renderBlockTop(var1, 0.0F, 0.0F, 0.0F, var1.getBlockTextureFromSide(1));
+			this.renderBlockTop(var1, 0.0F, 0.0F, 0.0F, var1.getBlockTextureFromSideAndMetadata(1, meta));
 			var2.draw();
 			var2.startDrawingQuads();
 			Tessellator.setNormal(0.0F, 0.0F, -1.0F);
-			this.renderBlockNorth(var1, 0, 0, 0, var1.getBlockTextureFromSide(2));
+			this.renderBlockNorth(var1, 0, 0, 0, var1.getBlockTextureFromSideAndMetadata(2, meta));
 			var2.draw();
 			var2.startDrawingQuads();
 			Tessellator.setNormal(0.0F, 0.0F, 1.0F);
-			this.renderBlockSouth(var1, 0, 0, 0, var1.getBlockTextureFromSide(3));
+			this.renderBlockSouth(var1, 0, 0, 0, var1.getBlockTextureFromSideAndMetadata(3, meta));
 			var2.draw();
 			var2.startDrawingQuads();
 			Tessellator.setNormal(-1.0F, 0.0F, 0.0F);
-			this.renderBlockWest(var1, 0, 0, 0, var1.getBlockTextureFromSide(4));
+			this.renderBlockWest(var1, 0, 0, 0, var1.getBlockTextureFromSideAndMetadata(4, meta));
 			var2.draw();
 			var2.startDrawingQuads();
 			Tessellator.setNormal(1.0F, 0.0F, 0.0F);
-			this.renderBlockEast(var1, 0, 0, 0, var1.getBlockTextureFromSide(5));
+			this.renderBlockEast(var1, 0, 0, 0, var1.getBlockTextureFromSideAndMetadata(5, meta));
 			var2.draw();
 			GL11.glTranslatef(0.5F, 0.5F, 0.5F);
 		} else if(var3 == 1) {
@@ -795,14 +1116,11 @@
 			Tessellator.setNormal(0.0F, -1.0F, 0.0F);
 			this.renderBlockCrops(var1, -1, -0.5F, -0.5F, -0.5F);
 			var2.draw();
-		} else {
-			if(var3 == 2) {
-				var2.startDrawingQuads();
-				Tessellator.setNormal(0.0F, -1.0F, 0.0F);
-				this.renderBlockTorch(var1, -0.5F, -0.5F, -0.5F, 0.0F, 0.0F);
-				var2.draw();
-			}
-
+		} else if(var3 == 2) {
+			var2.startDrawingQuads();
+			Tessellator.setNormal(0.0F, -1.0F, 0.0F);
+			this.renderBlockTorch(var1, -0.5F, -0.5F, -0.5F, 0.0F, 0.0F);
+			var2.draw();
 		}
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/block/BlockPiston.java
@@ -1,0 +1,150 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+public class BlockPiston extends Block {
+	private final int pullType;
+
+	public BlockPiston(int var1, int var2, int var3) {
+		super(var1, var2, Material.iron);
+		this.pullType = var3;
+	}
+
+	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
+		var1.setBlockMetadata(var2, var3, var4, var5);
+	}
+
+	public int getBlockTextureFromSide(int var1) {
+		return var1 == 3 ? this.blockIndexInTexture - 1 : this.blockIndexInTexture;
+	}
+
+	public int getBlockTexture(World var1, int var2, int var3, int var4, int var5) {
+		return var5 == var1.getBlockMetadata(var2, var3, var4) ? this.blockIndexInTexture - 1 : this.blockIndexInTexture;
+	}
+
+	public boolean canReceivePower(World var1, int var2, int var3, int var4, int var5) {
+		return true;
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+		int pushStatus = this.tryPush(world, x, y, z);
+		float pitch = 0.6F + this.pullType * 0.2F + world.random.nextFloat() * 0.1F;
+		if (pushStatus == 0 && this.tryPull(world, x, y, z)) {
+			world.playSoundAtPlayer(x + 0.5F, y + 0.5F, z + 0.5F, "tile.piston.in", 0.5F, pitch);
+		} else if (pushStatus >= 0) {
+			world.playSoundAtPlayer(x + 0.5F, y + 0.5F, z + 0.5F, "tile.piston.out", 0.5F, pitch);
+		} else {
+			world.playSoundAtPlayer(x + 0.5F, y + 0.5F, z + 0.5F, "fire.ignite", 1.0F, 0.5F);
+		}
+	}
+
+	private int tryPush(World var1, int var2, int var3, int var4) {
+		int dir = var1.getBlockMetadata(var2, var3, var4);
+		int dx = dir == 4 ? -1 : dir == 5 ? 1 : 0;
+		int dy = dir == 0 ? -1 : dir == 1 ? 1 : 0;
+		int dz = dir == 2 ? -1 : dir == 3 ? 1 : 0;
+		int bx = var2 + dx;
+		int by = var3 + dy;
+		int bz = var4 + dz;
+		Block b = null;
+		int pushCount = 0;
+
+		while (bx > 0 && by > 0 && bz > 0 && bx < var1.width - 1 && by < var1.height - 1 && bz < var1.length - 1
+				&& (b = Block.blocksList[var1.getBlockId(bx, by, bz)]) != null
+				&& !(b instanceof BlockContainer)
+				&& (b.getPistonPushBehavior() == Block.PISTON_PUSH_MOVE)) {
+			bx += dx;
+			by += dy;
+			bz += dz;
+			pushCount++;
+
+			if (pushCount > 12) {
+				return -1;
+			}
+		}
+
+		if (b != null && b.getPistonPushBehavior() != Block.PISTON_PUSH_MOVE) {
+			if (b.getPistonPushBehavior() == Block.PISTON_PUSH_IMMOVABLE || b instanceof BlockContainer) {
+				return -1;
+			}
+
+			if (b.getPistonPushBehavior() == Block.PISTON_PUSH_DISPLACE) {
+				if (var1.getBlockId(bx + dx, by + dy, bz + dz) != 0) {
+					boolean displaced = false;
+
+					int odx = var1.random.nextInt(2) * 2 - 1;
+					int ody = var1.random.nextInt(2) * 2 - 1;
+					int odz = var1.random.nextInt(2) * 2 - 1;
+
+					for (int d = 0; d < 6; d++) {
+						int ox = bx + (d == 0 ? 1 : d == 1 ? -1 : 0) * odx;
+						int oy = by + (d == 4 ? 1 : d == 5 ? -1 : 0) * ody;
+						int oz = bz + (d == 2 ? 1 : d == 3 ? -1 : 0) * odz;
+
+						if (var1.getBlockId(ox, oy, oz) == 0) {
+							var1.swap(bx, by, bz, ox, oy, oz);
+							displaced = true;
+							break;
+						}
+					}
+
+					if (!displaced) {
+						return -1;
+					}
+				} else {
+					var1.swap(bx, by, bz, bx + dx, by + dy, bz + dz);
+				}
+			}
+
+			b.dropBlockAsItem(var1, bx, by, bz, var1.getBlockMetadata(bx, by, bz));
+			var1.setBlock(bx, by, bz, 0);
+		}
+
+		if (pushCount > 0) {
+			var1.setTileNoUpdate(bx, by, bz, 0);
+			while (bx - dx != var2 || by - dy != var3 || bz - dz != var4) {
+				var1.swap(bx, by, bz, bx - dx, by - dy, bz - dz);
+				bx -= dx;
+				by -= dy;
+				bz -= dz;
+			}
+		}
+
+		return pushCount > 0 ? 1 : 0;
+	}
+
+	private boolean tryPull(World var1, int var2, int var3, int var4) {
+		if (this.pullType <= 0) return false;
+
+		int dir = var1.getBlockMetadata(var2, var3, var4);
+		int dx = dir == 4 ? -1 : dir == 5 ? 1 : 0;
+		int dy = dir == 0 ? -1 : dir == 1 ? 1 : 0;
+		int dz = dir == 2 ? -1 : dir == 3 ? 1 : 0;
+		int bx = var2 + dx;
+		int by = var3 + dy;
+		int bz = var4 + dz;
+		Block b = Block.blocksList[var1.getBlockId(bx, by, bz)];
+		if (b != null) {
+			var1.setTileNoUpdate(bx, by, bz, 0);
+			b.dropBlockAsItem(var1, bx, by, bz, var1.getBlockMetadata(bx, by, bz));
+		}
+		boolean hasPulled = false;
+		int pullLimit = 12;
+
+		while (bx > 0 && by > 0 && bz > 0 && bx < var1.width - 1 && by < var1.height - 1 && bz < var1.length - 1
+				&& (b = Block.blocksList[var1.getBlockId(bx + dx, by + dy, bz + dz)]) != null
+				&& !(b instanceof BlockContainer)
+				&& (b.getPistonPushBehavior() == Block.PISTON_PUSH_MOVE)) {
+			var1.swap(bx, by, bz, bx + dx, by + dy, bz + dz);
+			bx += dx;
+			by += dy;
+			bz += dz;
+			hasPulled = true;
+
+			if (this.pullType < 2 || --pullLimit <= 0) break;
+		}
+
+		return hasPulled;
+	}
+}
--- net/minecraft/client/LoadingScreenRenderer.java
+++ net/minecraft/client/LoadingScreenRenderer.java
@@ -27,7 +27,7 @@
 
 	public final void displayProgressMessage(String var1) {
 		if(!this.mc.running) {
-			throw new MinecraftError();
+			return;
 		} else {
 			this.title = var1;
 			ScaledResolution var3 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight);
@@ -45,7 +45,7 @@
 
 	public final void displayLoadingString(String var1) {
 		if(!this.mc.running) {
-			throw new MinecraftError();
+			return;
 		} else {
 			this.start = 0L;
 			this.text = var1;
@@ -56,7 +56,7 @@
 
 	public final void setLoadingProgress(int var1) {
 		if(!this.mc.running) {
-			throw new MinecraftError();
+			return;
 		} else {
 			long var2 = System.currentTimeMillis();
 			if(var2 - this.start >= 20L) {
--- /dev/null
+++ net/minecraft/game/level/block/BlockSnowBlock.java
@@ -1,0 +1,31 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.level.EnumSkyBlock;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+import java.util.Random;
+
+public class BlockSnowBlock extends Block {
+	public BlockSnowBlock(int var1, int var2) {
+		super(var1, var2, Material.craftedSnow);
+		this.setTickOnLoad(true);
+	}
+
+	public int idDropped(int var1, Random var2) {
+		return Item.snowball.shiftedIndex;
+	}
+
+	public int quantityDropped(Random var1) {
+		return 4;
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		if(var1.getSavedLightValue(EnumSkyBlock.Block, var2, var3, var4) > 11) {
+			this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+			var1.setBlockWithNotify(var2, var3, var4, 0);
+		}
+
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/block/BlockClay.java
@@ -1,0 +1,29 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+import java.util.Random;
+
+public class BlockClay extends Block {
+    private static boolean silkTouched;
+
+    public BlockClay(int var1, int var2, Material var3) {
+        super(var1, var2, var3);
+    }
+
+    public int idDropped(int var1, Random var2) {
+        return silkTouched ? this.blockID : Item.clay.shiftedIndex;
+    }
+
+    public int quantityDropped(Random var1) {
+        return silkTouched ? 1 : 4;
+    }
+
+    public void dropBlockAsItemWithChance(World var1, int var2, int var3, int var4, int var5, float var6) {
+        silkTouched = (var5 & DROP_FLAG_SILK_TOUCH) != 0;
+        super.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, var6);
+        silkTouched = false;
+    }
+}
--- /dev/null
+++ net/minecraft/game/level/generator/feature/Feature.java
@@ -1,0 +1,9 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+
+import java.util.Random;
+
+public interface Feature {
+	boolean generate(World world, Random rand, int x, int y, int z);
+}
--- net/minecraft/client/sound/SoundPool.java
+++ net/minecraft/client/sound/SoundPool.java
@@ -11,6 +11,7 @@
 public final class SoundPool {
 	private Random rand = new Random();
 	private Map nameToSoundPoolEntriesMapping = new HashMap();
+	private List allSoundPoolEntries = new ArrayList();
 	private int numberOfSoundPoolEntries = 0;
 
 	public final SoundPoolEntry addSound(String var1, File var2) {
@@ -27,6 +28,7 @@
 
 			SoundPoolEntry var5 = new SoundPoolEntry(var3, var2.toURI().toURL());
 			((List)this.nameToSoundPoolEntriesMapping.get(var1)).add(var5);
+			this.allSoundPoolEntries.add(var5);
 			++this.numberOfSoundPoolEntries;
 			return var5;
 		} catch (MalformedURLException var4) {
@@ -38,5 +40,9 @@
 	public final SoundPoolEntry getRandomSoundFromSoundPool(String var1) {
 		List var2 = (List)this.nameToSoundPoolEntriesMapping.get(var1);
 		return var2 == null ? null : (SoundPoolEntry)var2.get(this.rand.nextInt(var2.size()));
+	}
+
+	public SoundPoolEntry getRandomSound() {
+		return this.allSoundPoolEntries.size() == 0 ? null : (SoundPoolEntry)this.allSoundPoolEntries.get(this.rand.nextInt(this.allSoundPoolEntries.size()));
 	}
 }
--- net/minecraft/client/render/entity/Render.java
+++ net/minecraft/client/render/entity/Render.java
@@ -94,6 +94,7 @@
 				float var6 = var2;
 				Render var27 = this;
 				GL11.glEnable(GL11.GL_BLEND);
+				GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 				RenderEngine var10 = this.renderManager.renderEngine;
 				RenderEngine.bindTexture(var10.getTexture("%%/shadow.png"));
 				World var11 = this.renderManager.worldObj;
@@ -104,7 +105,7 @@
 					for(int var13 = (int)(var7 - 2.0F); var13 <= (int)var7; ++var13) {
 						for(int var14 = (int)(var8 - var12); var14 <= (int)(var8 + var12); ++var14) {
 							int var15 = var11.getBlockId(var29, var13 - 1, var14);
-							if(var15 > 0 && var11.getBlockLightValue(var29, var13, var14) > 3) {
+							if(var15 > 0 && var11.getBlockLightValue(var29, var13, var14) > 3 && Block.blocksList[var15].material.isSolid()) {
 								Block var16 = Block.blocksList[var15];
 								Tessellator var25 = Tessellator.instance;
 								var34 = (var9 - (var7 - (float)var13) / 2.0F) * 0.5F * var27.renderManager.worldObj.getLightBrightness(var29, var13, var14);
--- net/minecraft/client/gui/GuiLoadLevel.java
+++ net/minecraft/client/gui/GuiLoadLevel.java
@@ -71,8 +71,6 @@
 	}
 
 	public void initGui() {
-		(new Thread(this)).start();
-
 		for(int var1 = 0; var1 < 5; ++var1) {
 			this.controlList.add(new GuiButton(var1, this.width / 2 - 100, this.height / 6 + var1 * 24, "---"));
 			((GuiButton)this.controlList.get(var1)).visible = false;
@@ -81,27 +79,32 @@
 		this.controlList.add(new GuiButton(5, this.width / 2 - 100, this.height / 6 + 120 + 12, "Load file..."));
 		this.controlList.add(new GuiButton(6, this.width / 2 - 100, this.height / 6 + 168, "Cancel"));
 		((GuiButton)this.controlList.get(5)).visible = false;
+
+		if (!this.frozen) {
+			this.frozen = true;
+			GuiLevelDialog var2 = new GuiLevelDialog(this);
+			var2.setDaemon(true);
+			var2.start();
+		}
 	}
 
 	protected final void actionPerformed(GuiButton var1) {
-		if(!this.frozen) {
-			if(var1.enabled) {
-				if(this.loaded && var1.id < 5) {
-					this.openLevel(var1.id);
-				}
-
-				if(this.finished || this.loaded && var1.id == 5) {
-					this.frozen = true;
-					GuiLevelDialog var2 = new GuiLevelDialog(this);
-					var2.setDaemon(true);
-					var2.start();
-				}
-
-				if(this.finished || this.loaded && var1.id == 6) {
-					this.mc.displayGuiScreen(this.parent);
-				}
-
-			}
+		if(var1.enabled) {
+			if(this.loaded && var1.id < 5) {
+				this.openLevel(var1.id);
+			}
+
+			if(this.finished || this.loaded && var1.id == 5) {
+				this.frozen = true;
+				GuiLevelDialog var2 = new GuiLevelDialog(this);
+				var2.setDaemon(true);
+				var2.start();
+			}
+
+			if(this.finished || this.loaded && var1.id == 6) {
+				this.mc.displayGuiScreen(this.parent);
+			}
+
 		}
 	}
 
@@ -116,11 +119,7 @@
 
 	public final void drawScreen(int var1, int var2, float var3) {
 		this.drawDefaultBackground();
-		drawCenteredString(this.fontRenderer, this.title, this.width / 2, 20, 16777215);
-		if(!this.loaded) {
-			drawCenteredString(this.fontRenderer, this.status, this.width / 2, this.height / 2 - 4, 16777215);
-		}
-
+		drawCenteredString(this.fontRenderer, this.title, this.width / 2, this.height / 2 - 4, 16777215);
 		super.drawScreen(var1, var2, var3);
 	}
 
@@ -137,6 +136,10 @@
 
 	static File a(GuiLoadLevel var0, File var1) {
 		return var0.selectedFile = var1;
+	}
+
+	static void b(GuiLoadLevel var0) {
+		var0.mc.displayGuiScreen(var0.parent);
 	}
 
 	static boolean unknown(GuiLoadLevel var0, boolean var1) {
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageEroding.java
@@ -1,0 +1,27 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorDistort;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+
+public final class StageEroding extends TerrainGenStage {
+	public StageEroding() {
+		super("Eroding..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			NoiseGenerator selectorNoise = new NoiseGeneratorDistort(new NoiseGeneratorOctaves(rand, 8), new NoiseGeneratorOctaves(rand, 8));
+			NoiseGenerator heightNoise = new NoiseGeneratorDistort(new NoiseGeneratorOctaves(rand, 8), new NoiseGeneratorOctaves(rand, 8));
+
+			for (int x = 0; x < blocks.width; x++) {
+				progressor.accept(x * 100.0F / (float)(blocks.width - 1));
+
+				for (int z = 0; z < blocks.length; z++) {
+					double selection = selectorNoise.generateNoise(x << 1, z << 1) / 8.0D;
+					int height = heightNoise.generateNoise(x << 1, z << 1) > 0.0D ? 1 : 0;
+
+					if (selection > 2.0D) {
+						heightmap.set(x, z, ((heightmap.get(x, z) - height) / 2 << 1) + height);
+					}
+				}
+			}
+		});
+	}
+}
--- net/minecraft/game/level/block/BlockFire.java
+++ net/minecraft/game/level/block/BlockFire.java
@@ -9,13 +9,15 @@
 	private int[] chanceToEncourageFire = new int[256];
 	private int[] abilityToCatchFire = new int[256];
 
-	protected BlockFire(int var1, int var2) {
+	public BlockFire(int var1, int var2) {
 		super(51, 31, Material.fire);
 		this.setBurnRate(Block.planks.blockID, 5, 20);
 		this.setBurnRate(Block.wood.blockID, 5, 5);
 		this.setBurnRate(Block.leaves.blockID, 30, 60);
 		this.setBurnRate(Block.bookShelf.blockID, 30, 20);
 		this.setBurnRate(Block.tnt.blockID, 15, 100);
+		this.setBurnRate(Block.woodStairSingle.blockID, 5, 20);
+		this.setBurnRate(Block.woodStairDouble.blockID, 5, 20);
 
 		for(var1 = 0; var1 < 16; ++var1) {
 			this.setBurnRate(Block.clothRed.blockID + var1, 30, 60);
@@ -29,7 +31,7 @@
 		this.abilityToCatchFire[var1] = var3;
 	}
 
-	public final AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
+	public final AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
 		return null;
 	}
 
@@ -272,5 +274,9 @@
 		} else {
 			return false;
 		}
+	}
+
+	public boolean displace(World world, int x, int y, int z) {
+		return true;
 	}
 }
--- net/minecraft/game/physics/AxisAlignedBB.java
+++ net/minecraft/game/physics/AxisAlignedBB.java
@@ -160,6 +160,17 @@
 		this.maxZ += var3;
 	}
 
+	public final AxisAlignedBB getOffsetBoundingBox(float var1, float var2, float var3) {
+		return new AxisAlignedBB(
+			this.minX + var1,
+			this.minY + var2,
+			this.minZ + var3,
+			this.maxX + var1,
+			this.maxY + var2,
+			this.maxZ + var3
+		);
+	}
+
 	public final AxisAlignedBB copy() {
 		return new AxisAlignedBB(this.minX, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);
 	}
--- net/minecraft/game/level/block/tileentity/TileEntityFurnace.java
+++ net/minecraft/game/level/block/tileentity/TileEntityFurnace.java
@@ -3,6 +3,7 @@
 import com.mojang.nbt.NBTTagCompound;
 import com.mojang.nbt.NBTTagList;
 import net.minecraft.game.IInventory;
+import net.minecraft.game.entity.player.EntityPlayer;
 import net.minecraft.game.item.Item;
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.level.World;
@@ -137,6 +138,15 @@
 						++this.furnaceItemStacks[2].stackSize;
 					}
 
+					int smeltValue = var3 == Item.porkCooked.shiftedIndex ? 10
+							: var3 == Item.ingotIron.shiftedIndex ? 15
+							: var3 == Item.ingotGold.shiftedIndex ? 25
+							: var3 == Item.ingotCopper.shiftedIndex ? 25
+							: var3 == Item.diamond.shiftedIndex ? 50
+							: 0;
+
+					((EntityPlayer)this.worldObj.playerEntity).getScore += smeltValue;
+
 					--this.furnaceItemStacks[0].stackSize;
 					if(this.furnaceItemStacks[0].stackSize <= 0) {
 						this.furnaceItemStacks[0] = null;
@@ -173,12 +183,22 @@
 			return false;
 		} else {
 			int var1 = smeltItem(this.furnaceItemStacks[0].getItem().shiftedIndex);
-			return var1 < 0 ? false : (this.furnaceItemStacks[2] == null ? true : (this.furnaceItemStacks[2].itemID != var1 ? false : (this.furnaceItemStacks[2].stackSize < 64 ? true : this.furnaceItemStacks[2].stackSize < Item.itemsList[var1].getItemStackLimit())));
+			return var1 >= 0 && this.furnaceItemStacks[2] == null || var1 >= 0 && this.furnaceItemStacks[2].itemID == var1 && this.furnaceItemStacks[2].stackSize < Item.itemsList[var1].getItemStackLimit();
 		}
 	}
 
 	private static int smeltItem(int var0) {
-		return var0 == Block.oreIron.blockID ? Item.ingotIron.shiftedIndex : (var0 == Block.oreGold.blockID ? Item.ingotGold.shiftedIndex : (var0 == Block.oreDiamond.blockID ? Item.diamond.shiftedIndex : (var0 == Block.sand.blockID ? Block.glass.blockID : (var0 == Item.porkRaw.shiftedIndex ? Item.porkCooked.shiftedIndex : (var0 == Block.cobblestone.blockID ? Block.stone.blockID : -1)))));
+		return var0 == Block.oreIron.blockID ? Item.ingotIron.shiftedIndex
+				: var0 == Block.oreCopper.blockID ? Item.ingotCopper.shiftedIndex
+				: var0 == Block.oreGold.blockID ? Item.ingotGold.shiftedIndex
+				: var0 == Block.oreDiamond.blockID ? Item.diamond.shiftedIndex
+				: var0 == Block.sand.blockID ? Block.glass.blockID
+				: var0 == Item.porkRaw.shiftedIndex ? Item.porkCooked.shiftedIndex
+				: var0 == Block.cobblestone.blockID ? Block.stone.blockID
+				: var0 == Block.cactus.blockID ? Item.dyeGreen.shiftedIndex
+				: var0 == Block.wood.blockID ? Item.coal.shiftedIndex
+				: var0 == Item.clay.shiftedIndex ? Item.brick.shiftedIndex
+				: -1;
 	}
 
 	private static int getItemBurnTime(ItemStack var0) {
--- /dev/null
+++ net/minecraft/game/item/ItemWrench.java
@@ -1,0 +1,33 @@
+package net.minecraft.game.item;
+
+import net.minecraft.game.entity.EntityLiving;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.block.BlockChain;
+
+public class ItemWrench extends Item {
+	public ItemWrench(int var1) {
+		super(var1);
+	}
+
+	public boolean onItemUse(ItemStack var1, World var2, int var3, int var4, int var5, int var6) {
+		Block block = Block.blocksList[var2.getBlockId(var3, var4, var5)];
+		if (block != null) {
+			var2.playSoundAtPlayer(var3 + 0.5F, var4 + 0.5F, var5 + 0.5F, "random.wrench", 0.5F, 0.9F + rand.nextFloat() * 0.2F);
+			block.onPowerReceived(var2, var3, var4, var5, var6);
+
+			if (block instanceof BlockChain) {
+				EntityLiving player = var2.playerEntity;
+				float dx = var3 + 0.5F - player.posX;
+				float dy = var4 + 0.5F - player.posY;
+				float dz = var5 + 0.5F - player.posZ;
+				player.motionX = dx / 4.0F;
+				player.motionY = dy / 4.0F;
+				player.motionZ = dz / 4.0F;
+			}
+
+			return true;
+		}
+		return false;
+	}
+}
--- /dev/null
+++ net/minecraft/client/ScreenShotHelper.java
@@ -1,0 +1,78 @@
+package net.minecraft.client;
+
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.nio.ByteBuffer;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import javax.imageio.ImageIO;
+import org.lwjgl.BufferUtils;
+import org.lwjgl.opengl.GL11;
+
+public class ScreenShotHelper {
+	private static DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss");
+	private static ByteBuffer buffer;
+
+	public static String saveScreenshot(File var0, int var1, int var2) {
+		return func_35879_a(var0, (String)null, var1, var2);
+	}
+
+	public static String func_35879_a(File var0, String str, int var1, int var2) {
+		try {
+			File var3 = new File(var0, "screenshots");
+			var3.mkdirs();
+			if(buffer == null || buffer.capacity() < var1 * var2 * 3) {
+				buffer = BufferUtils.createByteBuffer(var1 * var2 * 3);
+			}
+
+			GL11.glPixelStorei(GL11.GL_PACK_ALIGNMENT, 1);
+			GL11.glPixelStorei(GL11.GL_UNPACK_ALIGNMENT, 1);
+			buffer.clear();
+			GL11.glReadPixels(0, 0, var1, var2, GL11.GL_RGB, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)buffer);
+			buffer.clear();
+			String var4 = dateFormat.format(new Date());
+			int var6 = 1;
+
+			while(true) {
+				File var5 = new File(var3, str != null ? str : var4 + (var6 == 1 ? "" : "_" + var6) + ".png");
+				if(!var5.exists()) {
+					if (!var5.createNewFile()) {
+						return "Failed to save: could not create new file";
+					}
+
+					byte[] pixelData = new byte[var1 * var2 * 3];
+					buffer.get(pixelData);
+
+					new Thread(() -> {
+						int[] imageData = new int[var1 * var2];
+						for(int var7 = 0; var7 < var1; ++var7) {
+							for(int var8 = 0; var8 < var2; ++var8) {
+								int var9 = var7 + (var2 - var8 - 1) * var1;
+								int var10 = pixelData[var9 * 3 + 0] & 255;
+								int var11 = pixelData[var9 * 3 + 1] & 255;
+								int var12 = pixelData[var9 * 3 + 2] & 255;
+								int var13 = -16777216 | var10 << 16 | var11 << 8 | var12;
+								imageData[var7 + var8 * var1] = var13;
+							}
+						}
+
+						BufferedImage var15 = new BufferedImage(var1, var2, 1);
+						var15.setRGB(0, 0, var1, var2, imageData, 0, var1);
+						try {
+							ImageIO.write(var15, "png", var5);
+						} catch (Exception e) {
+							e.printStackTrace();
+						}
+					}).start();
+					return "Saving screenshot as " + var5.getName();
+				}
+
+				++var6;
+			}
+		} catch (Exception var14) {
+			var14.printStackTrace();
+			return "Failed to save: " + var14;
+		}
+	}
+}
--- net/minecraft/client/gui/FontRenderer.java
+++ net/minecraft/client/gui/FontRenderer.java
@@ -11,10 +11,35 @@
 import org.lwjgl.opengl.GL11;
 
 public final class FontRenderer {
+	private static final float OO = 0.0F;
+	private static final float VV = 1.0F / 3.0F;
+	private static final float AA = 2.0F / 3.0F;
+	private static final float FF = 1.0F;
+
+	private static final float[][] COLORS = {
+			{ OO, OO, OO },
+			{ OO, OO, AA },
+			{ OO, AA, OO },
+			{ OO, AA, AA },
+			{ AA, OO, OO },
+			{ AA, OO, AA },
+			{ AA, AA, OO },
+			{ AA, AA, AA },
+			{ VV, VV, VV },
+			{ VV, VV, FF },
+			{ VV, FF, VV },
+			{ VV, FF, FF },
+			{ FF, VV, VV },
+			{ FF, VV, FF },
+			{ FF, FF, VV },
+			{ FF, FF, FF },
+	};
+
 	private int[] charWidth = new int[256];
 	private int fontTextureName = 0;
 	private int fontDisplayLists;
 	private IntBuffer buffer = BufferUtils.createIntBuffer(1024);
+	public float alpha = 1.0F;
 
 	public FontRenderer(GameSettings var1, String var2, RenderEngine var3) {
 		BufferedImage var4;
@@ -115,6 +140,7 @@
 
 	private void renderString(String var1, int var2, int var3, int var4, boolean var5) {
 		if(var1 != null) {
+			boolean colorMod = false;
 			char[] var8 = var1.toCharArray();
 			if(var5) {
 				var4 = (var4 & 16579836) >> 2;
@@ -124,7 +150,7 @@
 			float var6 = (float)(var4 >> 16 & 255) / 255.0F;
 			float var7 = (float)(var4 >> 8 & 255) / 255.0F;
 			float var9 = (float)(var4 & 255) / 255.0F;
-			GL11.glColor4f(var6, var7, var9, 1.0F);
+			GL11.glColor4f(var6, var7, var9, this.alpha);
 			this.buffer.clear();
 			GL11.glPushMatrix();
 			GL11.glTranslatef((float)var2, (float)var3, 0.0F);
@@ -136,12 +162,13 @@
 						var11 = 15;
 					}
 
-					this.buffer.put(this.fontDisplayLists + 256 + var11 + (var5 ? 16 : 0));
-					if(this.buffer.remaining() == 0) {
-						this.buffer.flip();
-						GL11.glCallLists(this.buffer);
-						this.buffer.clear();
-					}
+					this.buffer.flip();
+					GL11.glCallLists(this.buffer);
+					this.buffer.clear();
+
+					float[] color = COLORS[var11];
+					GL11.glColor4f(var6 * color[0], var7 * color[1], var9 * color[2], this.alpha);
+					colorMod = true;
 				}
 
 				this.buffer.put(this.fontDisplayLists + var8[var10]);
@@ -155,7 +182,9 @@
 			this.buffer.flip();
 			GL11.glCallLists(this.buffer);
 			GL11.glPopMatrix();
+			if (colorMod) GL11.glColor3f(1.0F, 1.0F, 1.0F);
 		}
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 	}
 
 	public final int getStringWidth(String var1) {
--- /dev/null
+++ net/minecraft/game/level/block/BlockSnow.java
@@ -1,0 +1,87 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.entity.misc.EntityItem;
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.ItemStack;
+import net.minecraft.game.level.EnumSkyBlock;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+import net.minecraft.game.physics.AxisAlignedBB;
+
+import java.util.Random;
+
+public class BlockSnow extends Block {
+	public BlockSnow(int var1, int var2) {
+		super(var1, var2, Material.snow);
+		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 2.0F / 16.0F, 1.0F);
+		this.setTickOnLoad(true);
+	}
+
+	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
+		return null;
+	}
+
+	public boolean isOpaqueCube() {
+		return false;
+	}
+
+	public boolean renderAsNormalBlock() {
+		return false;
+	}
+
+	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
+		int var5 = var1.getBlockId(var2, var3 - 1, var4);
+		return var5 != 0 && Block.blocksList[var5].isOpaqueCube() ? var1.getBlockMaterial(var2, var3 - 1, var4).getIsSolid() : false;
+	}
+
+	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
+		this.canSnowStay(var1, var2, var3, var4);
+	}
+
+	private boolean canSnowStay(World var1, int var2, int var3, int var4) {
+		if(!this.canPlaceBlockAt(var1, var2, var3, var4)) {
+			this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+			var1.setBlockWithNotify(var2, var3, var4, 0);
+			return false;
+		} else {
+			return true;
+		}
+	}
+
+	public void harvestBlock(World var1, int var2, int var3, int var4, int var5) {
+		int var6 = Item.snowball.shiftedIndex;
+		float var7 = 0.7F;
+		float var8 = (var1.random.nextFloat() * var7) + (1.0F - var7) * 0.5F;
+		float var10 = (var1.random.nextFloat() * var7) + (1.0F - var7) * 0.5F;
+		float var12 = (var1.random.nextFloat() * var7) + (1.0F - var7) * 0.5F;
+		EntityItem var14 = new EntityItem(var1, var2 + var8, var3 + var10, var4 + var12, new ItemStack(var6));
+		var14.delayBeforeCanPickup = 10;
+		var1.spawnEntityInWorld(var14);
+		var1.setBlockWithNotify(var2, var3, var4, 0);
+	}
+
+	public int idDropped(int var1, Random var2) {
+		return Item.snowball.shiftedIndex;
+	}
+
+	public int quantityDropped(Random var1) {
+		return 0;
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		if(var1.getSavedLightValue(EnumSkyBlock.Block, var2, var3, var4) > 11) {
+			this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+			var1.setBlockWithNotify(var2, var3, var4, 0);
+		}
+
+	}
+
+	public boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
+		Material var6 = var1.getBlockMaterial(var2, var3, var4);
+		return var5 == 1 ? true : (var6 == this.material ? false : super.shouldSideBeRendered(var1, var2, var3, var4, var5));
+	}
+
+	public boolean displace(World world, int x, int y, int z) {
+		return true;
+	}
+}
--- net/minecraft/client/PlayerLoader.java
+++ net/minecraft/client/PlayerLoader.java
@@ -15,6 +15,6 @@
 	}
 
 	protected final Entity loadEntity(World var1, String var2) {
-		return (Entity)(var2.equals("LocalPlayer") ? new EntityPlayerSP(this.mc, var1, this.mc.session) : super.loadEntity(var1, var2));
+		return var2.equals("LocalPlayer") && !this.mc.adventureMode ? new EntityPlayerSP(this.mc, var1, this.mc.session) : super.loadEntity(var1, var2);
 	}
 }
--- /dev/null
+++ net/minecraft/client/gui/GuiDeleteWorld.java
@@ -1,0 +1,32 @@
+package net.minecraft.client.gui;
+
+public class GuiDeleteWorld extends GuiScreen {
+	private final GuiScreen parentScreen;
+
+	public GuiDeleteWorld(GuiScreen parent) {
+		this.parentScreen = parent;
+	}
+
+	public void initGui() {
+		this.controlList.add(new GuiButton(0, this.width / 2 + 5, this.height / 2, 100, 20, "No"));
+		this.controlList.add(new GuiButton(1, this.width / 2 - 105, this.height / 2, 100, 20, "Yes"));
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		this.drawDefaultBackground();
+		drawCenteredString(this.fontRenderer, "Are you sure you want to delete your world?", this.width / 2, this.height / 2 - 32, 0xFFFFFF);
+		drawCenteredString(this.fontRenderer, "It will be gone forever!", this.width / 2, this.height / 2 - 20, 0xFFFFFF);
+		super.drawScreen(var1, var2, var3);
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		if (var1.id == 1) {
+			this.mc.deleteWorld();
+			this.mc.displayGuiScreen(this.mc.theWorld == null ? this.parentScreen : null);
+			this.mc.setLevel(null);
+			return;
+		}
+
+		this.mc.displayGuiScreen(this.parentScreen);
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeaturePalmTree.java
@@ -1,0 +1,72 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+
+import java.util.Random;
+
+public class FeaturePalmTree implements Feature {
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		int ground = var1.getBlockId(var3, var4 - 1, var5);
+		if (ground != Block.grass.blockID) {
+			return false;
+		}
+
+		int height = var2.nextInt(3) + 2;
+		int height2 = var2.nextInt(3) + 1;
+		int height3 = var2.nextInt(3);
+		int heightTotal = height + height2 + height3;
+
+		for (int y = var4; y < var4 + heightTotal; y++) {
+			int range = y < var4 + heightTotal - 2 ? 1 : 2;
+			for (int x = var3 - range; x <= var3 + range; x++) {
+				for (int z = var5 - range; z <= var5 + range; z++) {
+					if (x <= 0 || y <= 0 || z <= 0
+							|| x > var1.width || y > var1.height || z > var1.length
+							|| var1.getBlockId(x, y, z) != 0) {
+						return false;
+					}
+				}
+			}
+		}
+
+		var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
+
+		{
+			int dir = var2.nextInt(4);
+			int dirX = dir == 0 ? 1 : dir == 2 ? -1 : 0;
+			int dirZ = dir == 1 ? 1 : dir == 3 ? -1 : 0;
+
+			for (int y = 0; y < heightTotal; y++) {
+				if (y == height || y == height + height2) {
+					var3 += dirX;
+					var5 += dirZ;
+				}
+				var1.setBlock(var3, var4 + y, var5, Block.wood.blockID);
+			}
+		}
+
+		var4 += heightTotal;
+		if (var1.getBlockId(var3, var4, var5) == 0) {
+			var1.setBlock(var3, var4, var5, Block.leaves.blockID);
+		}
+
+		for (int dirX = -1; dirX <= 1; dirX++) {
+			for (int dirZ = -1; dirZ <= 1; dirZ++) {
+				if (dirX == 0 && dirZ == 0) continue;
+				int length = dirX != 0 && dirZ != 0 ? 4 : 5;
+
+				for (int i = 1; i < length; i++) {
+					if (i <= 2 && var1.getBlockId(var3 + dirX * i, var4, var5 + dirZ * i) == 0) {
+						var1.setBlock(var3 + dirX * i, var4, var5 + dirZ * i, Block.leaves.blockID);
+					}
+					if (i >= 2 && var1.getBlockId(var3 + dirX * i, var4 - 1, var5 + dirZ * i) == 0) {
+						var1.setBlock(var3 + dirX * i, var4 - 1, var5 + dirZ * i, Block.leaves.blockID);
+					}
+				}
+			}
+		}
+
+		return true;
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/block/BlockFumes.java
@@ -1,0 +1,150 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+import net.minecraft.game.physics.AxisAlignedBB;
+
+import java.util.ArrayList;
+import java.util.Random;
+
+public class BlockFumes extends Block {
+    public BlockFumes(int var1, int var2) {
+        super(var1, var2, Material.air);
+        this.setTickOnLoad(true);
+    }
+
+    public void updateTick(World world, int x, int y, int z, Random random) {
+        ArrayList<Byte> followOffsets = new ArrayList<>();
+        for (int ox = -2; ox <= 2; ox++) {
+            for (int oy = -2; oy <= 2; oy++) {
+                for (int oz = -2; oz <= 2; oz++) {
+                    if (ox * ox + oy * oy + oz * oz < 4) {
+                        continue;
+                    }
+
+                    int far = world.getBlockId(x + ox, y + oy, z + oz);
+                    int near = world.getBlockId(x + ox / 2, y + oy / 2, z + oz / 2);
+                    if (far == this.blockID && near == 0) {
+                        followOffsets.add((byte) ((ox / 2 + 1) | (oy / 2 + 1) << 2 | (oz / 2 + 1) << 4));
+                    }
+                }
+            }
+        }
+
+        int destX;
+        int destY;
+        int destZ;
+
+        if (followOffsets.isEmpty()) {
+            destX = x + random.nextInt(3) - 1;
+            destY = y + random.nextInt(3) / 2 * (random.nextInt(2) * 2 - 1);
+            destZ = z + random.nextInt(3) - 1;
+        } else {
+            byte followOffset = followOffsets.get(random.nextInt(followOffsets.size()));
+            destX = x + (followOffset & 3) - 1;
+            destY = y + (followOffset >> 2 & 3) - 1;
+            destZ = z + (followOffset >> 4 & 3) - 1;
+        }
+
+        if (destX <= 1 || destX >= world.width - 2
+            || destY <= 1 || destY >= world.height - 2
+            || destZ <= 1 || destZ >= world.length - 2) {
+            return;
+        }
+
+        if (world.getBlockId(destX, destY, destZ) != 0) {
+            return;
+        }
+
+//        world.setTileNoUpdate(x, y, z, 0);
+//        world.setTileNoUpdate(destX, destY, destZ, this.blockID);
+//        if (world.playerEntity.getDistanceSqToBlock(x, y, z) < 1024 || random.nextInt(20) == 0) {
+//            world.markBlocksDirty(x, y, z, x, y, z);
+//            world.markBlocksDirty(destX, destY, destZ, destX, destY, destZ);
+//        }
+        boolean markDirty = world.playerEntity.getDistanceSqToBlock(x, y, z) < 1024 || random.nextInt(20) == 0;
+        quickSwap(world, x, y, z, destX, destY, destZ, markDirty);
+    }
+
+    public boolean isOpaqueCube() {
+        return false;
+    }
+
+    public boolean isCollidable() {
+        return false;
+    }
+
+    public final AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
+        return null;
+    }
+
+    public boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
+        Block block = Block.blocksList[var1.getBlockId(var2, var3, var4)];
+        if (block == null) return true;
+        if (block.isOpaqueCube()) return false;
+        if (block == this) return false;
+        return true;
+    }
+
+    public int getRenderBlockPass() {
+        return 1;
+    }
+
+    public boolean displace(World world, int x, int y, int z) {
+        ArrayList<Integer> checkedPositions = new ArrayList<>();
+        ArrayList<Integer> positionsToCheck = new ArrayList<>();
+        checkedPositions.add((y * world.length + z) * world.width + x);
+        positionsToCheck.add((y * world.length + z) * world.width + x);
+
+        while (!positionsToCheck.isEmpty()) {
+            int pos = positionsToCheck.remove(0);
+            int xx = pos % world.width;
+            int zz = (pos / world.width) % world.length;
+            int yy = pos / world.width / world.length;
+
+            int ddx = world.random.nextInt(2) * 2 - 1;
+            int ddy = world.random.nextInt(2) * 2 - 1;
+            int ddz = world.random.nextInt(2) * 2 - 1;
+
+            for (int dir = 0; dir < 6; dir++) {
+                int ox = xx + (dir == 2 ? ddx : dir == 3 ? -ddx : 0);
+                int oy = yy + (dir == 0 ? ddy : dir == 1 ? -ddy : 0);
+                int oz = zz + (dir == 4 ? ddz : dir == 5 ? -ddz : 0);
+                if (ox <= 0 || oy <= 0 || oz <= 0
+                        || ox >= world.width - 2 || oy >= world.height - 2 || oz >= world.length - 2)
+                    continue;
+
+                if (Math.abs(ox - x) > 8
+                    || Math.abs(oy - y) > 8
+                    || Math.abs(oz - z) > 8)
+                    continue;
+
+                if (world.getBlockId(ox, oy, oz) == 0) {
+                    quickSwap(world, x, y, z, ox, oy, oz, true);
+                    return true;
+                } else if (world.getBlockId(ox, oy, oz) == this.blockID) {
+                    int nextPos = (oy * world.length + oz) * world.width + ox;
+                    if (!checkedPositions.contains(nextPos)) {
+                        positionsToCheck.add(nextPos);
+                    }
+                }
+            }
+
+            checkedPositions.add(pos);
+        }
+
+        return false;
+    }
+
+    private static void quickSwap(World world, int x1, int y1, int z1, int x2, int y2, int z2, boolean markDirty) {
+        int b1 = world.getBlockId(x1, y1, z1);
+        int b2 = world.getBlockId(x2, y2, z2);
+
+        world.setTileNoUpdate(x1, y1, z1, b2);
+        world.setTileNoUpdate(x2, y2, z2, b1);
+        if (markDirty) {
+            world.markBlocksDirty(x1, y1, z1, x1, y1, z1);
+            world.markBlocksDirty(x2, y2, z2, x2, y2, z2);
+        }
+    }
+}
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeatureSwampTree.java
@@ -1,0 +1,143 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.material.Material;
+
+import java.util.Random;
+
+public class FeatureSwampTree implements Feature {
+	private final int minHeight;
+	private final int heightVariance;
+
+	public FeatureSwampTree() {
+		this(5, 4);
+	}
+
+	public FeatureSwampTree(int minHeight, int heightVariance) {
+		this.minHeight = minHeight;
+		this.heightVariance = heightVariance;
+	}
+
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		int var6;
+		for(var6 = var2.nextInt(this.heightVariance) + this.minHeight; var1.getBlockMaterial(var3, var4 - 1, var5) == Material.water; --var4) {
+		}
+
+		boolean var7 = true;
+		if(var4 >= 1) {
+			int var10000 = var4 + var6 + 1;
+			if(var10000 <= var1.height) {
+				int var8;
+				int var10;
+				int var11;
+				int var12;
+				for(var8 = var4; var8 <= var4 + 1 + var6; ++var8) {
+					byte var9 = 1;
+					if(var8 == var4) {
+						var9 = 0;
+					}
+
+					if(var8 >= var4 + 1 + var6 - 2) {
+						var9 = 3;
+					}
+
+					for(var10 = var3 - var9; var10 <= var3 + var9 && var7; ++var10) {
+						for(var11 = var5 - var9; var11 <= var5 + var9 && var7; ++var11) {
+							if(var8 >= 0) {
+								if(var8 < var1.height) {
+									var12 = var1.getBlockId(var10, var8, var11);
+									if(var12 == 0 || var12 == Block.leaves.blockID) {
+										continue;
+									}
+
+									if(var12 != Block.waterStill.blockID && var12 != Block.waterMoving.blockID) {
+										var7 = false;
+										continue;
+									}
+
+									if(var8 > var4) {
+										var7 = false;
+									}
+									continue;
+								}
+							}
+
+							var7 = false;
+						}
+					}
+				}
+
+				if(!var7) {
+					return false;
+				}
+
+				var8 = var1.getBlockId(var3, var4 - 1, var5);
+				if(var8 == Block.grass.blockID || var8 == Block.dirt.blockID) {
+					if(var4 < var1.height - var6 - 1) {
+						var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
+
+						int var13;
+						int var16;
+						for(var16 = var4 - 3 + var6; var16 <= var4 + var6; ++var16) {
+							var10 = var16 - (var4 + var6);
+							var11 = 2 - var10 / 2;
+
+							for(var12 = var3 - var11; var12 <= var3 + var11; ++var12) {
+								var13 = var12 - var3;
+
+								for(int var14 = var5 - var11; var14 <= var5 + var11; ++var14) {
+									int var15 = var14 - var5;
+									if((Math.abs(var13) != var11 || Math.abs(var15) != var11 || var2.nextInt(2) != 0 && var10 != 0) && !Block.opaqueCubeLookup[var1.getBlockId(var12, var16, var14)]) {
+										var1.setBlock(var12, var16, var14, Block.leaves.blockID);
+									}
+								}
+							}
+						}
+
+						for(var16 = 0; var16 < var6; ++var16) {
+							var10 = var1.getBlockId(var3, var4 + var16, var5);
+							if(var10 == 0 || var10 == Block.leaves.blockID || var10 == Block.waterMoving.blockID || var10 == Block.waterStill.blockID) {
+								var1.setBlock(var3, var4 + var16, var5, Block.wood.blockID);
+							}
+						}
+
+						for(var16 = var4 - 3 + var6; var16 <= var4 + var6; ++var16) {
+							var10 = var16 - (var4 + var6);
+							var11 = 2 - var10 / 2;
+
+							for(var12 = var3 - var11; var12 <= var3 + var11; ++var12) {
+								for(var13 = var5 - var11; var13 <= var5 + var11; ++var13) {
+									if(var1.getBlockId(var12, var16, var13) == Block.leaves.blockID && var2.nextInt(4) == 0) {
+										this.func_35265_a(var1, var12, var16, var13, var2);
+									}
+								}
+							}
+						}
+
+						return true;
+					}
+				}
+
+				return false;
+			}
+		}
+
+		return false;
+	}
+
+	private void func_35265_a(World var1, int var2, int var3, int var4, Random random) {
+		var1.setBlock(var2, var3, var4, Block.leaves.blockID);
+		int var6 = 1 + random.nextInt(3);
+
+		while(true) {
+			--var3;
+			if(var1.getBlockId(var2, var3, var4) != 0 || var6 <= 0) {
+				return;
+			}
+
+			var1.setBlock(var2, var3, var4, Block.leaves.blockID);
+			--var6;
+		}
+	}
+}
--- net/minecraft/game/item/ItemTool.java
+++ net/minecraft/game/item/ItemTool.java
@@ -6,14 +6,15 @@
 	private Block[] blocksEffectiveAgainst;
 	private float efficiencyOnProperMaterial = 4.0F;
 	private int damageVsEntity;
+	public boolean silkTouch;
 
 	public ItemTool(int var1, int var2, int var3, Block[] var4) {
 		super(var1);
 		this.blocksEffectiveAgainst = var4;
 		this.maxStackSize = 1;
-		this.maxDamage = 32 << var3;
-		this.efficiencyOnProperMaterial = (float)(var3 + 1 << 1);
-		this.damageVsEntity = var2 + var3;
+		this.maxDamage = 32 << Math.abs(var3);
+		this.efficiencyOnProperMaterial = (Math.abs(var3) + 1 << 1);
+		this.damageVsEntity = var2 + Math.abs(var3);
 	}
 
 	public final float getStrVsBlock(Block var1) {
--- /dev/null
+++ net/minecraft/game/level/generator/LevelType.java
@@ -1,0 +1,693 @@
+package net.minecraft.game.level.generator;
+
+import net.minecraft.game.level.generator.terrain.*;
+
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+public enum LevelType {
+	ISLAND("Island") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder()
+							.island(true)
+							.build(),
+					new StageEroding(),
+					new StageSoiling.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.sandBeachThreshold(-8.0D)
+							.applyTheme(theme)
+							.build()
+			};
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return waterLevel - 9;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return waterLevel;
+		}
+
+		@Override
+		public boolean prefixThemeName() {
+			return true;
+		}
+	},
+	FLOATING("Floating") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder()
+							.centerSmooth(false)
+							.build(),
+					new StageEroding(),
+					new StageSoiling.Builder()
+							.floating(true)
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.applyTheme(theme)
+							.build()
+			};
+		}
+
+		@Override
+		public int getLayerCount(int height) {
+			return (height - 64) / 48 + 1;
+		}
+
+		@Override
+		public int getCloudHeight(int levelHeight, int waterLevel) {
+			return -16;
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return -128;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return groundLevel + 1;
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "floating";
+		}
+
+		@Override
+		public boolean canNaturallyGenerate() {
+			return false;
+		}
+	},
+	FLAT("Flat") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageSoiling.Builder().applyTheme(theme).build(),
+					new StageGrowing.Builder().applyTheme(theme).build()
+			};
+		}
+
+		@Override
+		public int getGenHeight(int levelHeight, int layer) {
+			return 7;
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return 8;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return 0;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return null;
+		}
+
+		@Override
+		public boolean canNaturallyGenerate() {
+			return false;
+		}
+	},
+	INLAND("Inland") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder().build(),
+					new StageEroding(),
+					new StageSoiling.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.applyTheme(theme)
+							.build()
+			};
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "hills";
+		}
+	},
+	MOUNTAINS("Mountains") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder()
+							.noiseScale(0.5D)
+							.selectorScale(1.0D)
+							.minDamp(3.0D)
+							.minBoost(0.0D)
+							.maxDamp(1.0D)
+							.maxBoost(10.0D)
+							.selectionSmoothness(NoiseModifierAccess.variation(1.0D, 1.5D, 0.75D))
+							.selectionThreshold(0.0D)
+							.build(),
+					new StageSoiling.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.applyTheme(theme)
+							.build()
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public boolean doFloodFillToEdge() {
+			return true;
+		}
+
+		@Override
+		public long getMaxLakeSize() {
+			return 0L;
+		}
+
+		@Override
+		public int getLakeRarity() {
+			return 10000;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "mountains";
+		}
+
+		@Override
+		public boolean prefixThemeName() {
+			return true;
+		}
+	},
+	MARSH("Marsh") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder()
+							.noiseScale(1.7D)
+							.minDamp(10.0D)
+							.minBoost(-7.0D)
+							.maxDamp(5.0D)
+							.maxBoost(-3.0D)
+							.selectionThreshold(1.0D)
+							.build(),
+					new StageEroding(),
+					new StageSoiling.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.beachHeightOffset(-2)
+							.applyTheme(theme)
+							.build(),
+					new StageFlooding(theme.getStillFluid())
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return waterLevel - 2;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return waterLevel;
+		}
+
+		@Override
+		public int getLakeRarity() {
+			return 0;
+		}
+
+		@Override
+		public boolean prefixThemeName() {
+			return true;
+		}
+	},
+	CLIFFS("Cliffs") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising3D.Builder()
+							.noiseScaleHorizontal(2.0D)
+							.noiseScaleVertical(2.0D)
+							.selectorScaleHorizontal(0.25D)
+							.selectorScaleVertical(0.05D)
+							.build(),
+					new StageSoiling3D.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.beachHeightOffset(1)
+							.applyTheme(theme)
+							.build(),
+					new StageFlooding(theme.getStillFluid())
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return waterLevel - 2;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return waterLevel;
+		}
+
+		@Override
+		public int getLakeRarity() {
+			return 0;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "hills";
+		}
+
+		@Override
+		public boolean prefixThemeName() {
+			return true;
+		}
+	},
+	WILD_CLIFFS("Wild Cliffs") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising3D.Builder()
+							.build(),
+					new StageSoiling3D.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.beachHeightOffset(1)
+							.applyTheme(theme)
+							.build(),
+					new StageFlooding(theme.getStillFluid())
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return waterLevel - 2;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return waterLevel;
+		}
+
+		@Override
+		public int getLakeRarity() {
+			return 0;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "mountains";
+		}
+
+		@Override
+		public boolean prefixThemeName() {
+			return true;
+		}
+	},
+	VALLEY("Valley") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder()
+							.noiseScale(0.8D)
+							.minDamp(10.0D)
+							.minBoost(-4.0D)
+							.doSelection(false)
+							.build(),
+					new StageSoiling.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageMountains.Builder()
+							.build(),
+					new StageGrowing.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageFlooding(theme.getStillFluid())
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return waterLevel - 2;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return waterLevel;
+		}
+
+		@Override
+		public int getLakeRarity() {
+			return 0;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "mountains";
+		}
+
+		@Override
+		public boolean prefixThemeName() {
+			return true;
+		}
+	},
+	EXTREME_HILLS("Extreme Hills") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising3D.Builder()
+							.cliffBlocks(false)
+							.noiseScaleHorizontal(4.0D)
+							.noiseScaleVertical(4.0D)
+							.selectorScaleHorizontal(0.5D)
+							.selectorScaleVertical(0.15D)
+							.noiseStretch(100.0D)
+							.heightOffset(-8)
+							.heightRoundoff(24)
+							.build(),
+					new StageSoiling3D.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.beachHeightOffset(1)
+							.applyTheme(theme)
+							.build(),
+					new StageFlooding(theme.getStillFluid())
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public int getLakeRarity() {
+			return 0;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "mountains";
+		}
+
+		@Override
+		public boolean prefixThemeName() {
+			return true;
+		}
+	},
+	PLAINS("Plains") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising3D.Builder()
+							.cliffBlocks(false)
+							.noiseScaleHorizontal(3.5D)
+							.noiseScaleVertical(0.5D)
+							.selectorScaleHorizontal(0.35D)
+							.selectorScaleVertical(0.0D)
+							.selectorThreshold(0.25D)
+							.noiseStretch(24.0D)
+							.heightOffset(-4)
+							.build(),
+					new StageSoiling3D.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.beachHeightOffset(1)
+							.applyTheme(theme)
+							.build(),
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "hills";
+		}
+
+		@Override
+		public boolean prefixThemeName() {
+			return true;
+		}
+	},
+	ARCHIPELAGO("Archipelago") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder()
+							.island(true)
+							.archipelago(true)
+							.build(),
+					new StageEroding(),
+					new StageSoiling.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.sandBeachThreshold(-8.0D)
+							.applyTheme(theme)
+							.build()
+			};
+		}
+
+		@Override
+		public int modifyGroundLevel(int groundLevel, int waterLevel) {
+			return waterLevel - 9;
+		}
+
+		@Override
+		public int modifyWaterLevel(int groundLevel, int waterLevel) {
+			return waterLevel;
+		}
+
+		@Override
+		public boolean prefixThemeName() {
+			return true;
+		}
+	},
+	CAVERNS("Caverns") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaising.Builder()
+							.minDamp(8.0D)
+							.maxDamp(8.0D)
+							.build(),
+					new StageEroding(),
+					new StageSoiling.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageGrowing.Builder()
+							.applyTheme(theme)
+							.build(),
+					new StageCaving()
+			};
+		}
+
+		@Override
+		public boolean doEdgeFloodFill() {
+			return false;
+		}
+
+		@Override
+		public String getHorizonType() {
+			return "hills";
+		}
+
+		@Override
+		public int getGenHeight(int levelHeight, int layer) {
+			return levelHeight - 16;
+		}
+
+		@Override
+		public int getCloudHeight(int levelHeight, int waterLevel) {
+			return levelHeight;
+		}
+
+		@Override
+		public boolean prefixThemeName() {
+			return true;
+		}
+	},
+	RUBYLANDS("Rubylands") {
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+					new StageRaisingRD(theme.getSoilBlock())
+			};
+		}
+
+		@Override
+		public int getGenHeight(int levelHeight, int layer) {
+			return levelHeight / 3;
+		}
+
+		@Override
+		public int getCloudHeight(int levelHeight, int waterLevel) {
+			return levelHeight;
+		}
+
+		@Override
+		public boolean prefixThemeName() {
+			return true;
+		}
+	},
+	MOSAIC("Mosaic") {
+		@Override
+		public String getHorizonType() {
+			return "mountains";
+		}
+
+		@Override
+		public TerrainGenStage[] getTerrainGenStages(LevelTheme theme) {
+			return new TerrainGenStage[] {
+				new StageRaising.Builder()
+						.mosaicScale(8)
+						.minDamp(3.0D)
+						.minBoost(-2.0D)
+						.maxDamp(1.5D)
+						.maxBoost(10.0D)
+						.build(),
+				new StageSoiling.Builder()
+						.applyTheme(theme)
+						.build(),
+				new StageGrowing.Builder()
+						.applyTheme(theme)
+						.build()
+			};
+		}
+	};
+
+	private static final Map<String, LevelType> NAME_TO_TYPE = Arrays.stream(values())
+			.collect(Collectors.toMap(LevelType::toString, Function.identity()));
+	private static final List<LevelType> NATURAL_TYPES = Arrays.stream(values())
+			.filter(LevelType::canNaturallyGenerate).collect(Collectors.toList());
+
+	public final String name;
+
+	LevelType(String name) {
+		this.name = name;
+	}
+
+	public boolean canNaturallyGenerate() {
+		return true;
+	}
+
+	public abstract TerrainGenStage[] getTerrainGenStages(LevelTheme theme);
+
+	public int getLayerCount(int height) {
+		return 1;
+	}
+
+	public int getGenHeight(int levelHeight, int layer) {
+		return levelHeight / 2 - (layer * 2 - (getLayerCount(levelHeight) - 1)) * 24;
+	}
+
+	public int getCloudHeight(int levelHeight, int waterLevel) {
+		return waterLevel + 64;
+	}
+
+	public int modifyGroundLevel(int groundLevel, int waterLevel) {
+		return waterLevel + 1;
+	}
+
+	public int modifyWaterLevel(int groundLevel, int waterLevel) {
+		return groundLevel - 16;
+	}
+
+	public boolean doEdgeFloodFill() {
+		return true;
+	}
+
+	public boolean doFloodFillToEdge() {
+		return false;
+	}
+
+	public long getMaxLakeSize() {
+		return 640L;
+	}
+
+	public int getLakeRarity() {
+		return 1000;
+	}
+
+	public String getHorizonType() {
+		return "islands";
+	}
+
+	public boolean prefixThemeName() {
+		return false;
+	}
+
+	public String toString() {
+		return this.name;
+	}
+
+	public static LevelType fromId(int id) {
+		return values()[id];
+	}
+
+	public static LevelType fromName(String name) {
+		return NAME_TO_TYPE.getOrDefault(name, ISLAND);
+	}
+
+	public static LevelType fromNameNullable(String name) {
+		return NAME_TO_TYPE.get(name);
+	}
+
+	public static LevelType getRandomGen() {
+		return NATURAL_TYPES.get(new Random().nextInt(NATURAL_TYPES.size()));
+	}
+}
--- net/minecraft/client/Minecraft.java
+++ net/minecraft/client/Minecraft.java
@@ -1,28 +1,26 @@
 package net.minecraft.client;
 
-import java.awt.Canvas;
-import java.awt.Component;
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.InputStreamReader;
-import java.net.URL;
+import java.awt.*;
+import java.io.*;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.IntBuffer;
-import javax.swing.JOptionPane;
+import java.nio.file.Files;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+import javax.swing.*;
+
+import com.mojang.nbt.NBTBase;
+import com.mojang.nbt.NBTTagCompound;
 import net.minecraft.client.controller.PlayerController;
 import net.minecraft.client.controller.PlayerControllerCreative;
 import net.minecraft.client.controller.PlayerControllerSP;
 import net.minecraft.client.effect.EffectRenderer;
-import net.minecraft.client.gui.FontRenderer;
-import net.minecraft.client.gui.GuiErrorScreen;
-import net.minecraft.client.gui.GuiGameOver;
-import net.minecraft.client.gui.GuiIngame;
-import net.minecraft.client.gui.GuiIngameMenu;
-import net.minecraft.client.gui.GuiScreen;
-import net.minecraft.client.gui.ScaledResolution;
+import net.minecraft.client.gui.*;
 import net.minecraft.client.gui.container.GuiInventory;
-import net.minecraft.client.model.ModelBiped;
 import net.minecraft.client.player.EntityPlayerSP;
 import net.minecraft.client.player.MovementInputFromOptions;
 import net.minecraft.client.render.EntityRenderer;
@@ -41,14 +39,17 @@
 import net.minecraft.game.item.Item;
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.level.World;
+import net.minecraft.game.level.WorldInfo;
 import net.minecraft.game.level.block.Block;
 import net.minecraft.game.level.generator.LevelGenerator;
+import net.minecraft.game.level.generator.LevelStructure;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.LevelType;
 import net.minecraft.game.physics.MovingObjectPosition;
 import org.lwjgl.BufferUtils;
 import org.lwjgl.LWJGLException;
 import org.lwjgl.Sys;
 import org.lwjgl.input.Controllers;
-import org.lwjgl.input.Cursor;
 import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.ContextCapabilities;
@@ -57,7 +58,18 @@
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GLContext;
 
-public final class Minecraft implements Runnable {
+public class Minecraft implements Runnable {
+	public static final String VERSION = "Indev Adventure 20250412";
+	public static final int AUTOSAVE_INTERVAL = 60 * 20;
+
+	public static final Set<Character> VALID_PATH_CHARACTERS; static {
+		HashSet<Character> validPathCharacters = new HashSet<>();
+		for (char c : " !#$%&'()+,-.0123456789;=ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_abcdefghijklmnopqrstuvwxyz{}~".toCharArray()) {
+			validPathCharacters.add(c);
+		}
+		VALID_PATH_CHARACTERS = Collections.unmodifiableSet(validPathCharacters);
+	}
+
 	public PlayerController playerController = new PlayerControllerSP(this);
 	private boolean fullscreen = false;
 	public int displayWidth;
@@ -92,18 +104,23 @@
 	private MinecraftApplet mcApplet;
 	public SoundManager sndManager;
 	public MouseHelper mouseHelper;
-	public File mcDataDir;
+	public static File mcDataDir;
+	public File worldSaveLocation;
 	private String server;
 	private TextureWaterFX textureWaterFX;
 	private TextureLavaFX textureLavaFX;
 	volatile boolean running;
+	public int debugFPS = 60;
 	public String debug;
 	public boolean inventoryScreen;
 	private int prevFrameTime;
 	public boolean inGameHasFocus;
+	public WorldInfo worldInfo = new WorldInfo();
+	public boolean adventureMode;
+	private boolean isTakingScreenshot;
+	private int autosaveTime = AUTOSAVE_INTERVAL;
 
 	public Minecraft(Canvas var1, MinecraftApplet var2, int var3, int var4, boolean var5) {
-		new ModelBiped(0.0F);
 		this.objectMouseOver = null;
 		this.sndManager = new SoundManager();
 		this.server = null;
@@ -123,6 +140,7 @@
 		this.displayWidth = var3;
 		this.displayHeight = var4;
 		this.fullscreen = var5;
+		ThreadSaveLevel.init(this);
 	}
 
 	public final void setServer(String var1, int var2) {
@@ -156,6 +174,20 @@
 	}
 
 	public final void shutdownMinecraftApplet() {
+		if (this.theWorld != null && this.adventureMode) {
+			try {
+				this.saveWorld(true);
+				while (ThreadSaveLevel.isBusy()) {
+					try {
+						Thread.sleep(100);
+					} catch (InterruptedException e) {
+						break;
+					}
+				}
+			} catch (IOException e) {
+			}
+		}
+
 		try {
 			if(this.downloadResourcesThread != null) {
 				this.downloadResourcesThread.closeMinecraft();
@@ -247,33 +279,8 @@
 			String var26 = System.getProperty("user.home", ".");
 			int[] var10001 = EnumOSMappingHelper.osValues;
 			String var4 = System.getProperty("os.name").toLowerCase();
-			File var27;
-			switch(var10001[(var4.contains("win") ? EnumOS.windows : (var4.contains("mac") ? EnumOS.macos : (var4.contains("solaris") ? EnumOS.solaris : (var4.contains("sunos") ? EnumOS.solaris : (var4.contains("linux") ? EnumOS.linux : (var4.contains("unix") ? EnumOS.linux : EnumOS.unknown)))))).ordinal()]) {
-			case 1:
-			case 2:
-				var27 = new File(var26, '.' + var3 + '/');
-				break;
-			case 3:
-				var4 = System.getenv("APPDATA");
-				if(var4 != null) {
-					var27 = new File(var4, "." + var3 + '/');
-				} else {
-					var27 = new File(var26, '.' + var3 + '/');
-				}
-				break;
-			case 4:
-				var27 = new File(var26, "Library/Application Support/" + var3);
-				break;
-			default:
-				var27 = new File(var26, var3 + '/');
-			}
-
-			if(!var27.exists() && !var27.mkdirs()) {
-				throw new RuntimeException("The working directory could not be created: " + var27);
-			}
-
-			this.mcDataDir = var27;
-			this.options = new GameSettings(this, this.mcDataDir);
+			this.worldSaveLocation = new File(getAppDir(), "inadv-world");
+			this.options = new GameSettings(this, getAppDir());
 			this.sndManager.loadSoundSettings(this.options);
 			this.renderEngine = new RenderEngine(this.options);
 			this.renderEngine.registerTextureFX(this.textureLavaFX);
@@ -290,16 +297,16 @@
 			GL11.glViewport(0, 0, this.displayWidth, this.displayHeight);
 			if(this.server != null && this.session != null) {
 				World var31 = new World();
-				var31.generate(8, 8, 8, new byte[512], new byte[512]);
+				var31.generate(8, 8, 8, new byte[512], new byte[512], new byte[512], new int[512]);
 				this.setLevel(var31);
 			} else if(this.theWorld == null) {
-				this.displayGuiScreen(new GuiMainMenu());
+				this.displayGuiScreen(new GuiAutosaveInfo());
 			}
 
 			this.effectRenderer = new EffectRenderer(this.theWorld, this.renderEngine);
 
 			try {
-				var1.downloadResourcesThread = new ThreadDownloadResources(var1.mcDataDir, var1);
+				var1.downloadResourcesThread = new ThreadDownloadResources(getAppDir(), var1);
 				var1.downloadResourcesThread.start();
 			} catch (Exception var14) {
 			}
@@ -316,16 +323,14 @@
 
 		try {
 			while(this.running) {
-				if(this.theWorld != null) {
-					this.theWorld.updateLighting();
-				}
+				long startTime = System.nanoTime();
 
 				if(this.mcCanvas == null && Display.isCloseRequested()) {
 					this.running = false;
 				}
 
 				try {
-					if(this.isGamePaused) {
+					if(this.isGamePaused && this.theWorld != null) {
 						float var29 = this.timer.renderPartialTicks;
 						this.timer.updateTimer();
 						this.timer.renderPartialTicks = var29;
@@ -338,18 +343,23 @@
 						this.runTick();
 					}
 
+					if(this.theWorld != null) {
+						this.theWorld.updatingLighting();
+					}
+
 					this.sndManager.setListener(this.thePlayer, this.timer.renderPartialTicks);
 					GL11.glEnable(GL11.GL_TEXTURE_2D);
 					this.playerController.setPartialTime(this.timer.renderPartialTicks);
-					this.entityRenderer.updateCameraAndRender(this.timer.renderPartialTicks);
+					this.entityRenderer.updateCameraAndRender(this.timer.renderPartialTicks, startTime);
 					if(!Display.isActive()) {
 						if(this.fullscreen) {
 							this.toggleFullscreen();
 						}
 
-						Thread.sleep(10L);
+						if (!this.options.limitFramerate) Display.sync(60);
 					}
 
+					this.screenshotListener();
 					if(this.mcCanvas != null && !this.fullscreen && (this.mcCanvas.getWidth() != this.displayWidth || this.mcCanvas.getHeight() != this.displayHeight)) {
 						this.displayWidth = this.mcCanvas.getWidth();
 						this.displayHeight = this.mcCanvas.getHeight();
@@ -357,7 +367,7 @@
 					}
 
 					if(this.options.limitFramerate) {
-						Thread.sleep(5L);
+						Display.sync(60);
 					}
 
 					++var28;
@@ -369,6 +379,7 @@
 				}
 
 				while(System.currentTimeMillis() >= var23 + 1000L) {
+					this.debugFPS = var28;
 					this.debug = var28 + " fps, " + WorldRenderer.chunksUpdated + " chunk updates";
 					WorldRenderer.chunksUpdated = 0;
 					var23 += 1000L;
@@ -378,7 +389,7 @@
 
 			return;
 		} catch (MinecraftError var19) {
-		} catch (Exception var20) {
+		} catch (Throwable var20) {
 			var20.printStackTrace();
 			return;
 		} finally {
@@ -406,12 +417,7 @@
 			}
 
 			this.inventoryScreen = false;
-
-			try {
-				Mouse.setNativeCursor((Cursor)null);
-			} catch (LWJGLException var2) {
-				var2.printStackTrace();
-			}
+			this.mouseHelper.ungrabMouseCursor();
 		}
 	}
 
@@ -449,9 +455,7 @@
 
 			if(this.objectMouseOver == null) {
 				if(var1 == 0 && !(this.playerController instanceof PlayerControllerCreative)) {
-					this.leftClickCounter = 10;
 				}
-
 			} else {
 				ItemStack var9;
 				if(this.objectMouseOver.typeOfHit == 1) {
@@ -462,7 +466,9 @@
 						var9 = var11.getStackInSlot(var11.currentItem);
 						int var17 = var9 != null ? Item.itemsList[var9.itemID].getDamageVsEntity() : 1;
 						if(var17 > 0) {
-							var14.attackEntityFrom(var12, var17);
+							if (var14.attackEntityFrom(var12, var17) && var14 instanceof EntityLiving && ((EntityLiving) var14).health <= 0) {
+								this.thePlayer.getScore += var14.scoreValue;
+							}
 							var2 = var12.inventory.getCurrentItem();
 							if(var2 != null && var14 instanceof EntityLiving) {
 								EntityLiving var8 = (EntityLiving)var14;
@@ -490,7 +496,9 @@
 					} else {
 						var9 = this.thePlayer.inventory.getCurrentItem();
 						int var16 = this.theWorld.getBlockId(var10, var3, var13);
-						if(var16 > 0 && Block.blocksList[var16].blockActivated(this.theWorld, var10, var3, var13, this.thePlayer)) {
+						if(!Keyboard.isKeyDown(this.options.keyBindSneak.keyCode)
+								&& var16 > 0 && Block.blocksList[var16].blockActivated(this.theWorld, var10, var3, var13, this.thePlayer)) {
+							this.entityRenderer.itemRenderer.equippedItemRender();
 							return;
 						}
 
@@ -629,19 +637,37 @@
 
 								if(Mouse.getEventButton() == 2 && Mouse.getEventButtonState() && this.objectMouseOver != null) {
 									var2 = this.theWorld.getBlockId(this.objectMouseOver.blockX, this.objectMouseOver.blockY, this.objectMouseOver.blockZ);
-									if(var2 == Block.grass.blockID) {
-										var2 = Block.dirt.blockID;
-									}
-
-									if(var2 == Block.stairDouble.blockID) {
-										var2 = Block.stairSingle.blockID;
+									if(!this.playerController.isInTestMode) {
+										if(var2 == Block.grass.blockID) {
+											var2 = Block.dirt.blockID;
+										}
+
+										if(var2 == Block.stairDouble.blockID) {
+											var2 = Block.stairSingle.blockID;
+										}
+
+										if(var2 == Block.woodStairDouble.blockID) {
+											var2 = Block.woodStairSingle.blockID;
+										}
 									}
 
 									if(var2 == Block.bedrock.blockID) {
 										var2 = Block.stone.blockID;
 									}
 
+									if(var2 == Block.doorWood.blockID) {
+										var2 = Item.doorWood.shiftedIndex;
+									}
+
+									if(var2 == Block.doorSteel.blockID) {
+										var2 = Item.doorSteel.shiftedIndex;
+									}
+
+									int prevItem = this.thePlayer.inventory.currentItem;
 									this.thePlayer.inventory.getFirstEmptyStack(var2);
+									if (this.thePlayer.inventory.currentItem == prevItem && this.playerController.isInTestMode) {
+										this.thePlayer.inventory.setInventorySlotContents(prevItem, new ItemStack(var2));
+									}
 								}
 							}
 						} else if(this.currentScreen != null) {
@@ -719,12 +745,28 @@
 										}
 									}
 
+									if(Keyboard.getEventKey() == Keyboard.KEY_F1) {
+										this.options.showHUD = !this.options.showHUD;
+									}
+
+									if(Keyboard.getEventKey() == Keyboard.KEY_F3) {
+										this.options.showFPS = !this.options.showFPS;
+									}
+
 									if(Keyboard.getEventKey() == Keyboard.KEY_F5) {
-										this.options.thirdPersonView = !this.options.thirdPersonView;
+										if (this.options.frontThirdPersonView) {
+											this.options.thirdPersonView = false;
+											this.options.frontThirdPersonView = false;
+										} else if (this.options.thirdPersonView) {
+											this.options.frontThirdPersonView = true;
+										} else {
+											this.options.thirdPersonView = true;
+										}
 									}
 
 									if(Keyboard.getEventKey() == this.options.keyBindInventory.keyCode) {
-										this.displayGuiScreen(new GuiInventory(this.thePlayer.inventory));
+										this.displayGuiScreen(this.playerController.isInTestMode
+												? new GuiSelectBlock() : new GuiInventory(this.thePlayer.inventory));
 									}
 
 									if(Keyboard.getEventKey() == this.options.keyBindDrop.keyCode) {
@@ -768,58 +810,78 @@
 			}
 		}
 
+		this.sndManager.playRandomMusicIfReady(0, 1.0F, 1.0F);
+
 		if(this.theWorld != null) {
+			this.theWorld.renderDistance = this.options.getRenderDistance();
 			this.theWorld.difficultySetting = this.options.difficulty;
+
 			if(!this.isGamePaused) {
 				this.entityRenderer.updateRenderer();
-			}
-
-			if(!this.isGamePaused) {
 				this.renderGlobal.updateClouds();
-			}
-
-			if(!this.isGamePaused) {
 				this.theWorld.updateEntities();
-			}
-
-			if(!this.isGamePaused) {
 				this.theWorld.tick();
-			}
-
-			if(!this.isGamePaused) {
 				this.theWorld.randomDisplayUpdates((int)this.thePlayer.posX, (int)this.thePlayer.posY, (int)this.thePlayer.posZ);
-			}
-
-			if(!this.isGamePaused) {
 				this.effectRenderer.updateEffects();
+
+				if (this.thePlayer.getTravelDistance(0.0F) >= 1.0F && this.thePlayer.ticksExisted > 20) {
+					this.travel();
+				} else if (this.worldSaveLocation != null) {
+					this.autosaveTime--;
+					if (this.autosaveTime <= 0) {
+						this.autosaveTime = AUTOSAVE_INTERVAL;
+                        try {
+							if (this.adventureMode) {
+								this.saveWorld(false);
+							} else {
+								this.saveCurrentLevel(false);
+							}
+                        } catch (IOException e) {
+                            this.ingameGUI.sendChatMessage("&cFailed to save level!");
+                        }
+                    }
+				}
 			}
 		}
-
-	}
-
-	public final void generateLevel(int var1, int var2, int var3, int var4) {
+	}
+
+	public final void startWorld(int width, int length, int height,
+	                             LevelType type, LevelTheme theme, LevelStructure structure) {
+		this.worldInfo.levelX = 0;
+		this.worldInfo.levelZ = 0;
+		this.worldInfo.levelWidth = width;
+		this.worldInfo.levelLength = length;
+		this.worldInfo.levelHeight = height;
+		this.worldInfo.levelType = type;
+		this.worldInfo.levelTheme = theme;
+		this.worldInfo.levelStructure = structure;
+		this.worldInfo.worldTime = 0;
+		this.worldInfo.playerScore = 0;
+		this.generateLevel(width, length, height,
+				type != null ? type : LevelType.getRandomGen(),
+				theme != null ? theme : LevelTheme.getRandomGen(),
+				structure != null ? structure : LevelStructure.getRandomGen());
+		try {
+			this.saveWorld(true);
+		} catch (IOException e) {
+		}
+	}
+
+	public final void generateLevel(int width, int length, int height,
+	                                LevelType type, LevelTheme theme, LevelStructure structure) {
 		this.setLevel((World)null);
 		System.gc();
 		String var5 = this.session != null ? this.session.username : "anonymous";
 		LevelGenerator var6 = new LevelGenerator(this.loadingScreen);
-		var6.islandGen = var3 == 1;
-		var6.floatingGen = var3 == 2;
-		var6.flatGen = var3 == 3;
-		var6.levelType = var4;
-		var1 = 128 << var1;
-		var3 = var1;
-		short var8 = 64;
-		if(var2 == 1) {
-			var1 /= 2;
-			var3 <<= 1;
-		} else if(var2 == 2) {
-			var1 /= 2;
-			var3 = var1;
-			var8 = 256;
-		}
-
-		World var7 = var6.generate(var5, var1, var3, var8);
+		var6.levelType = type;
+		var6.levelTheme = theme;
+		var6.levelStructure = structure;
+		var6.generateHouse = !this.adventureMode || this.worldInfo.levelX == 0 && this.worldInfo.levelZ == 0;
+		var6.spawnMobs = !this.worldInfo.creative;
+		var6.survivalWorld = !this.worldInfo.creative;
+		World var7 = var6.generate(var5, width, length, height);
 		this.setLevel(var7);
+		this.debugFPS = 60;
 	}
 
 	public final void setLevel(World var1) {
@@ -827,18 +889,12 @@
 			this.theWorld.setLevel();
 		}
 
-		try {
-			BufferedReader var2 = new BufferedReader(new InputStreamReader((new URL(this.mcApplet.getDocumentBase() + "?n=" + this.session.username + "&i=" + this.session.sessionId)).openStream()));
-			Integer.parseInt(var2.readLine());
-			var2.close();
-			if(this.mcApplet.getDocumentBase().toString().startsWith("http://www.minecraft.net/") || this.mcApplet.getDocumentBase().toString().startsWith("http://minecraft.net/")) {
-				this.theWorld = var1;
-			}
-		} catch (Throwable var3) {
-		}
-
+		this.theWorld = var1;
 		if(var1 != null) {
+			this.ingameGUI.clearChat();
 			var1.load();
+			this.worldInfo.creative = !var1.survivalWorld;
+			this.playerController = var1.survivalWorld ? new PlayerControllerSP(this) : new PlayerControllerCreative(this);
 			this.playerController.onWorldChange(var1);
 			this.thePlayer = (EntityPlayerSP)var1.findSubclassOf(EntityPlayerSP.class);
 			var1.playerEntity = this.thePlayer;
@@ -864,16 +920,451 @@
 				this.effectRenderer.clearEffects(var1);
 			}
 
-			this.textureWaterFX.textureId = 0;
-			this.textureLavaFX.textureId = 0;
-			int var4 = this.renderEngine.getTexture("/water.png");
-			if(var1.defaultFluid == Block.waterMoving.blockID) {
-				this.textureWaterFX.textureId = var4;
-			} else {
-				this.textureLavaFX.textureId = var4;
-			}
+			this.textureWaterFX.textureId = this.renderEngine.getTexture("/water.png");
+			this.textureLavaFX.textureId = this.renderEngine.getTexture("/lava.png");
+			this.autosaveTime = AUTOSAVE_INTERVAL;
 		}
 
 		System.gc();
+	}
+
+	public final void saveWorld(boolean showLoadingScreen) throws IOException {
+		this.autosaveTime = AUTOSAVE_INTERVAL;
+		this.worldInfo.worldTime = this.theWorld.worldTime;
+		this.worldInfo.playerScore = this.thePlayer.getScore;
+		this.worldInfo.currentLevelType = this.theWorld.levelType;
+		this.worldInfo.currentLevelTheme = this.theWorld.levelTheme;
+		this.worldInfo.currentLevelStructure = this.theWorld.levelStructure;
+		if (!this.worldSaveLocation.isDirectory() && !this.worldSaveLocation.mkdirs()) {
+			this.ingameGUI.sendChatMessage("&cCould not create world directory!");
+			return;
+		}
+
+		// Player
+		NBTTagCompound worldInfoCompound = new NBTTagCompound();
+		this.worldInfo.writeToNBT(worldInfoCompound);
+
+		NBTTagCompound playerCompound = new NBTTagCompound();
+		this.thePlayer.writeToNBT(playerCompound);
+		playerCompound.setCompoundTag("WorldInfo", worldInfoCompound);
+
+		File playerFile = new File(this.worldSaveLocation, "player.dat");
+		try (OutputStream playerStream = Files.newOutputStream(playerFile.toPath());
+			 DataOutputStream playerDataStream = new DataOutputStream(new GZIPOutputStream(playerStream))) {
+			NBTBase.writeTag(playerCompound, playerDataStream);
+		}
+
+		// Level
+		String levelName = this.worldInfo.levelX + "," + this.worldInfo.levelZ;
+		this.saveLevel(this.worldSaveLocation, levelName, showLoadingScreen);
+	}
+
+	public final void saveCurrentLevel(boolean showLoadingScreen) throws IOException {
+		if (this.adventureMode || this.worldSaveLocation == null || this.worldSaveLocation.isDirectory()) return;
+		this.saveLevel(this.worldSaveLocation.getParentFile(), this.worldSaveLocation.getName(), showLoadingScreen);
+	}
+
+	public final void saveLevel(File baseDir, String fileName, boolean showLoadingScreen) throws IOException {
+		this.autosaveTime = AUTOSAVE_INTERVAL;
+		File newLevelFile = new File(baseDir, fileName + ".new");
+		int newLevelFileIndex = 0;
+		while (newLevelFile.exists()) {
+			newLevelFile = new File(baseDir, fileName + ".new" + ++newLevelFileIndex);
+		}
+		final File iHateJavaLambdas = newLevelFile;
+		File levelFile = new File(baseDir, fileName);
+		new PlayerLoader(this, showLoadingScreen ? this.loadingScreen : null)
+				.save(this.theWorld, newLevelFile, () -> {
+					if (!levelFile.exists() || levelFile.delete()) {
+						iHateJavaLambdas.renameTo(levelFile);
+					}
+				});
+	}
+
+	public final boolean loadWorld() throws IOException {
+		if (!this.worldSaveLocation.exists()) return false;
+
+		// Player
+		File playerFile = new File(this.worldSaveLocation, "player.dat");
+		if (!playerFile.exists()) return false;
+
+		NBTTagCompound playerCompound;
+		try (InputStream playerStream = Files.newInputStream(playerFile.toPath())) {
+			try (DataInputStream playerDataStream = new DataInputStream(new GZIPInputStream(playerStream))) {
+				NBTBase playerTag = NBTBase.readTag(playerDataStream);
+				if (!(playerTag instanceof NBTTagCompound)) {
+					return false;
+				}
+				playerCompound = (NBTTagCompound)playerTag;
+			}
+		}
+
+		this.worldInfo.readFromNBT(playerCompound.getCompoundTag("WorldInfo"));
+
+		// Level
+		File levelFile = new File(this.worldSaveLocation, this.worldInfo.levelX + "," + this.worldInfo.levelZ + ".dat");
+		if (levelFile.exists()) {
+			try (InputStream levelStream = Files.newInputStream(levelFile.toPath())) {
+				World world = new PlayerLoader(this, this.loadingScreen).load(levelStream);
+				this.setLevel(world);
+			}
+		}
+
+		if (this.theWorld == null || this.thePlayer == null) {
+			this.generateLevel(this.worldInfo.levelWidth, this.worldInfo.levelLength, this.worldInfo.levelHeight,
+					this.worldInfo.levelType != null ? this.worldInfo.levelType : LevelType.getRandomGen(),
+					this.worldInfo.levelTheme != null ? this.worldInfo.levelTheme : LevelTheme.getRandomGen(),
+					this.worldInfo.levelStructure != null ? this.worldInfo.levelStructure : LevelStructure.getRandomGen());
+			if (this.theWorld == null || this.thePlayer == null) return false;
+		}
+
+		this.thePlayer.readFromNBT(playerCompound);
+		this.theWorld.worldTime = this.worldInfo.worldTime;
+		this.thePlayer.getScore = this.worldInfo.playerScore;
+
+		return true;
+	}
+
+	public void loadWorld(String path) {
+		if (path.isEmpty()) return;
+
+		for (char c : path.toCharArray()) {
+			if (!Minecraft.VALID_PATH_CHARACTERS.contains(c)) {
+				return;
+			}
+		}
+
+		File worldsDir = new File(Minecraft.getAppDir(), "inadv-worlds");
+		this.worldSaveLocation = new File(worldsDir, path);
+
+		File[] files = this.worldSaveLocation.listFiles();
+		if (this.worldSaveLocation.isFile()) return;
+
+		if (files != null && files.length != 0) {
+			this.adventureMode = true;
+			try {
+				if (this.loadWorld()) {
+					this.displayGuiScreen(null);
+				}
+			} catch (IOException e) {
+				e.printStackTrace();
+				this.adventureMode = false;
+				this.worldSaveLocation = null;
+			}
+			return;
+		}
+
+		this.adventureMode = true;
+		this.displayGuiScreen(new GuiNewLevel(this.currentScreen));
+	}
+
+	public void loadLevel(String path) {
+		for (char c : path.toCharArray()) {
+			if (!Minecraft.VALID_PATH_CHARACTERS.contains(c)) {
+				return;
+			}
+		}
+
+		File levelsDir = new File(Minecraft.getAppDir(), "inadv-levels");
+		File levelFile = path.isEmpty() ? null : new File(levelsDir, path + ".mclevel");
+		this.worldSaveLocation = levelFile;
+		if (levelFile == null || !levelFile.exists()) {
+			this.displayGuiScreen(new GuiNewLevel(this.currentScreen));
+			return;
+		}
+		this.loadLevel(levelFile);
+	}
+
+	public void loadLevel(File levelFile) {
+		this.adventureMode = false;
+		this.worldSaveLocation = levelFile;
+		try (FileInputStream var4 = new FileInputStream(levelFile)) {
+			World var2 = (new PlayerLoader(this, this.loadingScreen)).load(var4);
+			this.setLevel(var2);
+			this.displayGuiScreen(null);
+		} catch (IOException var3) {
+			var3.printStackTrace();
+		}
+	}
+
+	public void saveLevel(String path) {
+		for (char c : path.toCharArray()) {
+			if (!Minecraft.VALID_PATH_CHARACTERS.contains(c)) {
+				return;
+			}
+		}
+
+		File levelsDir = new File(Minecraft.getAppDir(), "inadv-levels");
+		File levelFile = new File(levelsDir, path + ".mclevel");
+		if (!levelsDir.mkdirs() && !levelsDir.isDirectory()) return;
+		this.adventureMode = false;
+		this.autosaveTime = AUTOSAVE_INTERVAL;
+
+		try {
+			(new PlayerLoader(this, null)).save(this.theWorld, levelFile);
+		} catch (IOException var3) {
+			var3.printStackTrace();
+			return;
+		}
+		this.worldSaveLocation = levelFile;
+	}
+
+	public void travel() {
+		int x = (int)Math.signum(this.thePlayer.posX);
+		int z = (int)Math.signum(this.thePlayer.posZ);
+		if (Math.abs(this.thePlayer.posX - this.theWorld.width / 2.0F)
+				> Math.abs((this.thePlayer.posZ - this.theWorld.length / 2.0F)
+						* this.theWorld.width / this.theWorld.length)) {
+			z = 0;
+		} else {
+			x = 0;
+		}
+
+		try {
+			this.saveWorld(true);
+		} catch (IOException e) {
+			this.wrapAround(x != 0, z != 0);
+			return;
+		}
+
+		this.worldInfo.worldTime = this.theWorld.worldTime;
+		this.worldInfo.playerScore = this.thePlayer.getScore;
+
+		EntityPlayerSP player = this.thePlayer;
+
+		this.worldInfo.levelX += x;
+		this.worldInfo.levelZ += z;
+
+		boolean levelLoaded = false;
+		File levelFile = new File(this.worldSaveLocation, this.worldInfo.levelX + "," + this.worldInfo.levelZ + ".dat");
+		if (levelFile.exists()) {
+			try (InputStream levelStream = Files.newInputStream(levelFile.toPath())) {
+				World world = new PlayerLoader(this, this.loadingScreen).load(levelStream);
+				this.setLevel(world);
+				levelLoaded = true;
+			} catch (IOException e) {
+			}
+		}
+
+		if (!levelLoaded) {
+			this.generateLevel(this.worldInfo.levelWidth, this.worldInfo.levelLength, this.worldInfo.levelHeight,
+					this.worldInfo.levelType != null ? this.worldInfo.levelType : LevelType.getRandomGen(),
+					this.worldInfo.levelTheme != null ? this.worldInfo.levelTheme : LevelTheme.getRandomGen(),
+					this.worldInfo.levelStructure != null ? this.worldInfo.levelStructure : LevelStructure.getRandomGen());
+		}
+
+		if (this.theWorld.playerEntity != null) {
+			this.theWorld.releaseEntitySkin(this.theWorld.playerEntity);
+			this.theWorld.playerEntity = null;
+		}
+		this.thePlayer = player;
+		this.theWorld.spawnEntityInWorld(this.thePlayer);
+		this.theWorld.playerEntity = this.thePlayer;
+		this.theWorld.worldTime = this.worldInfo.worldTime;
+		this.thePlayer.getScore = this.worldInfo.playerScore;
+		this.wrapAround(x != 0, z != 0);
+		this.playerController.onRespawn(this.thePlayer);
+
+		try {
+			this.saveWorld(true);
+		} catch (IOException e) {
+		}
+	}
+
+	private void wrapAround(boolean x, boolean z) {
+		if (x) {
+			this.thePlayer.posX -= this.theWorld.width;
+			this.thePlayer.posX *= -1.0F;
+			this.thePlayer.posX -= Math.signum(this.thePlayer.posX);
+			this.thePlayer.prevPosX = this.thePlayer.lastTickPosX = this.thePlayer.posX;
+		}
+		if (z) {
+			this.thePlayer.posZ -= this.theWorld.length;
+			this.thePlayer.posZ *= -1.0F;
+			this.thePlayer.posZ -= Math.signum(this.thePlayer.posZ);
+			this.thePlayer.prevPosZ = this.thePlayer.lastTickPosZ = this.thePlayer.posZ;
+		}
+		this.thePlayer.posY = this.thePlayer.prevPosY = this.thePlayer.lastTickPosY
+				= Math.max(this.theWorld.groundLevel, this.theWorld.waterLevel) + this.thePlayer.height / 2.0F;
+		this.thePlayer.ticksExisted = 0;
+		this.thePlayer.setPositionAndRotation(this.thePlayer.posX, this.thePlayer.posY, this.thePlayer.posZ,
+				this.thePlayer.rotationYaw, this.thePlayer.rotationPitch);
+	}
+
+	public void deleteWorld() {
+		if (!this.adventureMode) {
+			if (!this.worldSaveLocation.isFile()) return;
+			this.worldSaveLocation.delete();
+			return;
+		}
+
+		if (!this.worldSaveLocation.isDirectory()) return;
+
+		File[] filesToDelete = this.worldSaveLocation.listFiles();
+		if (filesToDelete == null) {
+			this.worldSaveLocation.delete();
+			return;
+		}
+
+		this.loadingScreen.displayProgressMessage("Deleting world");
+		this.loadingScreen.displayLoadingString("Deleting files..");
+
+		int progress = 0;
+
+		for (File file : filesToDelete) {
+			this.loadingScreen.setLoadingProgress(progress++ * 100 / filesToDelete.length);
+			file.delete();
+		}
+
+		this.worldSaveLocation.delete();
+	}
+
+	public void respawn() {
+		this.thePlayer.getScore = 0;
+
+		if (this.adventureMode && (this.worldInfo.levelX != 0 || this.worldInfo.levelZ != 0)) {
+			try {
+				this.saveWorld(true);
+			} catch (IOException e) {
+			}
+
+			this.worldInfo.levelX = 0;
+			this.worldInfo.levelZ = 0;
+
+			InventoryPlayer inventory = this.thePlayer.inventory;
+			boolean levelLoaded = false;
+			File levelFile = new File(this.worldSaveLocation, "0,0.dat");
+			if (levelFile.exists()) {
+				try (InputStream levelStream = Files.newInputStream(levelFile.toPath())) {
+					World world = new PlayerLoader(this, this.loadingScreen).load(levelStream);
+					this.setLevel(world);
+					levelLoaded = true;
+				} catch (IOException e) {
+				}
+			}
+
+			if (!levelLoaded) {
+				this.generateLevel(this.worldInfo.levelWidth, this.worldInfo.levelLength, this.worldInfo.levelHeight,
+						this.worldInfo.levelType != null ? this.worldInfo.levelType : LevelType.getRandomGen(),
+						this.worldInfo.levelTheme != null ? this.worldInfo.levelTheme : LevelTheme.getRandomGen(),
+						this.worldInfo.levelStructure != null ? this.worldInfo.levelStructure : LevelStructure.getRandomGen());
+			}
+
+			this.thePlayer.inventory = new InventoryPlayer(this.thePlayer, inventory);
+		} else {
+			this.thePlayer.preparePlayerToSpawn();
+			this.thePlayer.isDead = false;
+
+			if (this.adventureMode) {
+				try {
+					this.saveWorld(true);
+				} catch (IOException e) {
+				}
+			}
+		}
+	}
+
+	private void screenshotListener() {
+		if(Keyboard.isKeyDown(Keyboard.KEY_F2)) {
+			if(!this.isTakingScreenshot) {
+				this.isTakingScreenshot = true;
+				this.ingameGUI.sendChatMessage(ScreenShotHelper.saveScreenshot(Minecraft.getAppDir(), this.displayWidth, this.displayHeight));
+			}
+		} else {
+			this.isTakingScreenshot = false;
+		}
+
+	}
+
+	public void shutdown() {
+		this.running = false;
+	}
+
+	public int getAutosaveTime() {
+		return this.autosaveTime;
+	}
+
+	public static void startMainThread(String var0, String var1) {
+		startMainThread(var0, var1, (String)null);
+	}
+
+	public static void startMainThread(String var0, String var1, String var2) {
+		boolean var3 = false;
+		Frame var5 = new Frame("Minecraft");
+		Canvas var6 = new Canvas();
+		var5.setLayout(new BorderLayout());
+		var5.add(var6, "Center");
+		var6.setPreferredSize(new Dimension(854, 480));
+		var5.pack();
+		var5.setLocationRelativeTo((Component)null);
+		MinecraftImpl var7 = new MinecraftImpl(var6, (MinecraftApplet)null, 854, 480, var3, var5);
+		Thread var8 = new Thread(var7, "Minecraft main thread");
+		var8.setPriority(10);
+		var7.appletMode = false;
+		var7.minecraftUri = "www.minecraft.net";
+		if(var0 != null && var1 != null) {
+			var7.session = new Session(var0, var1);
+		} else {
+			var7.session = new Session("Player" + System.currentTimeMillis() % 1000L, "");
+		}
+
+		if(var2 != null) {
+			String[] var9 = var2.split(":");
+			var7.setServer(var9[0], Integer.parseInt(var9[1]));
+		}
+
+		var5.setVisible(true);
+		var5.addWindowListener(new GameWindowListener(var7, var8));
+		var8.start();
+	}
+
+	public static File getAppDir() {
+		if (mcDataDir == null) {
+			String var3 = "minecraft";
+			String var26 = System.getProperty("user.home", ".");
+			int[] var10001 = EnumOSMappingHelper.osValues;
+			String var4 = System.getProperty("os.name").toLowerCase();
+			File var27;
+			switch(var10001[(var4.contains("win") ? EnumOS.windows : (var4.contains("mac") ? EnumOS.macos : (var4.contains("solaris") ? EnumOS.solaris : (var4.contains("sunos") ? EnumOS.solaris : (var4.contains("linux") ? EnumOS.linux : (var4.contains("unix") ? EnumOS.linux : EnumOS.unknown)))))).ordinal()]) {
+				case 1:
+				case 2:
+					var27 = new File(var26, '.' + var3 + '/');
+					break;
+				case 3:
+					var4 = System.getenv("APPDATA");
+					if(var4 != null) {
+						var27 = new File(var4, "." + var3 + '/');
+					} else {
+						var27 = new File(var26, '.' + var3 + '/');
+					}
+					break;
+				case 4:
+					var27 = new File(var26, "Library/Application Support/" + var3);
+					break;
+				default:
+					var27 = new File(var26, var3 + '/');
+			}
+
+			if(!var27.exists() && !var27.mkdirs()) {
+				throw new RuntimeException("The working directory could not be created: " + var27);
+			}
+
+			mcDataDir = var27;
+		}
+		return mcDataDir;
+	}
+
+	public static void main(String[] var0) {
+		String var1 = "Player" + System.currentTimeMillis() % 1000L;
+		if(var0.length > 0) {
+			var1 = var0[0];
+		}
+
+		String var2 = "-";
+		if(var0.length > 1) {
+			var2 = var0[1];
+		}
+
+		startMainThread(var1, var2);
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/StageSoiling.java
@@ -1,0 +1,113 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.block.Block;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+import net.minecraft.game.level.generator.noise.NoiseGeneratorOctaves;
+
+public final class StageSoiling extends TerrainGenStage {
+	private StageSoiling(Builder properties) {
+		super("Soiling..", (blocks, heightmap, rand, world, progressor, chestPlacer) -> {
+			NoiseGenerator erosionNoise = new NoiseGeneratorOctaves(rand, 8);
+			NoiseGenerator floatingFactorNoise = new NoiseGeneratorOctaves(rand, 8);
+
+			for (int x = 0; x < blocks.width; x++) {
+				double centerDistX = Math.abs(((double)x / (blocks.width - 1.0D) - 0.5D) * 2.0D);
+				progressor.accept(x * 100.0F / (float)(blocks.width - 1));
+
+				for (int z = 0; z < blocks.length; z++) {
+					double centerDistZ = Math.abs(((double)z / (blocks.length - 1.0D) - 0.5D) * 2.0D);
+					double centerDist = Math.max(centerDistX, centerDistZ);
+					centerDist = centerDist * centerDist * centerDist;
+
+					int erosion = (int)(erosionNoise.generateNoise(
+							x * properties.erosionScale, z * properties.erosionScale)
+							/ properties.erosionDamp) + properties.erosionOffset;
+					int height = heightmap.get(x, z) + world.waterLevel;
+					int stoneHeight = height + erosion;
+					int finalHeight = Math.max(height, stoneHeight);
+					heightmap.set(x, z, Math.min(Math.max(finalHeight, 1), blocks.height - 2));
+
+					double floatingFactorF = properties.floating ? floatingFactorNoise.generateNoise(
+							x * properties.floatingFactorScale, z * properties.floatingFactorScale) / properties.floatingFactorDamp : 0.0D;
+					int floatingFactor = (int)(Math.sqrt(Math.abs(floatingFactorF)) * Math.signum(floatingFactorF) * 20.0D) + world.waterLevel;
+					floatingFactor = (int)((double)floatingFactor * (1.0D - centerDist) + centerDist * (double)blocks.height);
+					if(floatingFactor > world.waterLevel) {
+						floatingFactor = blocks.height;
+					}
+
+					for (int y = 0; y < blocks.height; y++) {
+						if (blocks.get(x, y, z) == 0 && (!properties.floating || y >= floatingFactor)) {
+							blocks.set(x, y, z,
+									y <= stoneHeight ? properties.stone.blockID
+											: y <= height ? properties.soil.blockID
+											: 0
+							);
+						}
+					}
+				}
+			}
+		});
+	}
+
+	public static class Builder {
+		private boolean floating = false;
+		private double erosionScale = 1.0D;
+		private double erosionDamp = 24.0D;
+		private int erosionOffset = -4;
+		private double floatingFactorScale = 2.3D;
+		private double floatingFactorDamp = 24.0D;
+		private Block soil = Block.dirt;
+		private Block stone = Block.stone;
+
+		public Builder floating(boolean floating) {
+			this.floating = floating;
+			return this;
+		}
+
+		public Builder erosionScale(double erosionScale) {
+			this.erosionScale = erosionScale;
+			return this;
+		}
+
+		public Builder erosionDamp(double erosionDamp) {
+			this.erosionDamp = erosionDamp;
+			return this;
+		}
+
+		public Builder erosionOffset(int erosionOffset) {
+			this.erosionOffset = erosionOffset;
+			return this;
+		}
+
+		public Builder floatingFactorScale(double floatingFactorScale) {
+			this.floatingFactorScale = floatingFactorScale;
+			return this;
+		}
+
+		public Builder floatingFactorDamp(double floatingFactorDamp) {
+			this.floatingFactorDamp = floatingFactorDamp;
+			return this;
+		}
+
+		public Builder soil(Block soil) {
+			this.soil = soil;
+			return this;
+		}
+
+		public Builder stone(Block stone) {
+			this.stone = stone;
+			return this;
+		}
+
+		public Builder applyTheme(LevelTheme theme) {
+			return this
+					.soil(theme.getSoilBlock())
+					.stone(theme.getStoneBlock());
+		}
+
+		public StageSoiling build() {
+			return new StageSoiling(this);
+		}
+	}
+}
--- /dev/null
+++ com/mojang/nbt/NBTTagIntArray.java
@@ -1,0 +1,46 @@
+package com.mojang.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+
+public final class NBTTagIntArray extends NBTBase {
+	public int[] intArray;
+
+	public NBTTagIntArray() {
+	}
+
+	public NBTTagIntArray(int[] var1) {
+		this.intArray = var1;
+	}
+
+	final void writeTagContents(DataOutput var1) throws IOException {
+		var1.writeInt(this.intArray.length);
+		ByteBuffer buffer = ByteBuffer.allocate(this.intArray.length * 4);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asIntBuffer().put(this.intArray);
+		byte[] bytes = buffer.array();
+		var1.write(bytes);
+	}
+
+	final void readTagContents(DataInput var1) throws IOException {
+		int var2 = var1.readInt();
+		this.intArray = new int[var2];
+		byte[] byteArray = new byte[var2 * 4];
+		var1.readFully(byteArray);
+		ByteBuffer buffer = ByteBuffer.wrap(byteArray);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asIntBuffer().get(this.intArray);
+	}
+
+	public final byte getType() {
+		return (byte)11;
+	}
+
+	public final String toString() {
+		return "[" + this.intArray.length + " ints]";
+	}
+}
--- net/minecraft/client/gui/GuiNewLevel.java
+++ net/minecraft/client/gui/GuiNewLevel.java
@@ -1,60 +1,153 @@
 package net.minecraft.client.gui;
 
+import net.minecraft.game.level.generator.LevelStructure;
+import net.minecraft.game.level.generator.LevelTheme;
+import net.minecraft.game.level.generator.LevelType;
+import org.lwjgl.input.Keyboard;
+
+import java.util.Random;
+
 public final class GuiNewLevel extends GuiScreen {
+	private static final Random RANDOM = new Random();
+	private static final String[] SIZE_OPTIONS = {
+			"Tiny (128)",
+			"Small (256)",
+			"Moderate (384)",
+			"Medium (512)",
+			"Large (768)",
+			"Extra Large (864)",
+			"Massive (1024)"
+	};
+	private static final int[] SIZE_VALUES = { 128, 256, 384, 512, 768, 864, 1024 };
+	private static final String[] HEIGHT_OPTIONS = {
+			"Short (64)",
+			"Normal (128)",
+			"Moderate (192)",
+			"Tall (256)",
+			"Very Tall (384)",
+			"Extreme (512)",
+	};
+	private static final int[] HEIGHT_VALUES = { 64, 128, 192, 256, 384, 512 };
+
 	private GuiScreen prevGui;
-	private String[] worldType = new String[]{"Inland", "Island", "Floating", "Flat"};
-	private String[] worldShape = new String[]{"Square", "Long", "Deep"};
-	private String[] worldSize = new String[]{"Small", "Normal", "Huge"};
-	private String[] worldTheme = new String[]{"Normal", "Hell", "Paradise", "Woods"};
-	private int selectedWorldType = 1;
-	private int selectedWorldShape = 0;
-	private int selectedWorldSize = 1;
+	private int selectedWorldType = LevelType.ISLAND.ordinal();
 	private int selectedWorldTheme = 0;
+	private int selectedWorldStructure = 0;
+	private GuiSliderGeneric sizeSlider;
+	private GuiSliderGeneric heightSlider;
 
 	public GuiNewLevel(GuiScreen var1) {
 		this.prevGui = var1;
 	}
 
 	public final void initGui() {
-		this.controlList.clear();
-		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4, "Type: "));
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 24, "Shape:"));
-		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 48, "Size: "));
+		if (this.mc.adventureMode) {
+			this.selectedWorldType = -1;
+			this.selectedWorldTheme = -1;
+			this.selectedWorldStructure = -1;
+		}
+
+		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 132, 97, 20, "Survival"));
+		this.controlList.add(new GuiButton(1, this.width / 2 - 50, this.height / 4 + 156, 100, 20, "Cancel"));
+		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4, "Type: "));
 		this.controlList.add(new GuiButton(3, this.width / 2 - 100, this.height / 4 + 72, "Theme: "));
-		this.controlList.add(new GuiButton(4, this.width / 2 - 100, this.height / 4 + 96 + 12, "Create"));
-		this.controlList.add(new GuiButton(5, this.width / 2 - 100, this.height / 4 + 120 + 12, "Cancel"));
+		this.addSizeSlider(this.sizeSlider = new GuiSliderGeneric(4, this.width / 2 - 100, this.height / 4 + 24, 200, 20, "Size"), SIZE_OPTIONS, 3);
+		this.addSizeSlider(this.heightSlider = new GuiSliderGeneric(5, this.width / 2 - 100, this.height / 4 + 48, 200, 20, "Height"), HEIGHT_OPTIONS, 1);
+		this.controlList.add(new GuiButton(6, this.width / 2 - 100, this.height / 4 + 96, "Structure: "));
+		this.controlList.add(new GuiButton(7, this.width / 2 + 3, this.height / 4 + 132, 97, 20, "Creative"));
 		this.worldOptions();
+	}
+
+	private void addSizeSlider(GuiSliderGeneric slider, String[] options, int value) {
+		slider.round = true;
+		slider.multiplier = options.length - 1;
+		slider.formatter = s -> s.label + ": " + options[(int)s.getValue()];
+		slider.sliderValue = value / slider.multiplier;
+		slider.updateText();
+		this.controlList.add(slider);
 	}
 
 	private void worldOptions() {
-		((GuiButton)this.controlList.get(0)).displayString = "Type: " + this.worldType[this.selectedWorldType];
-		((GuiButton)this.controlList.get(1)).displayString = "Shape: " + this.worldShape[this.selectedWorldShape];
-		((GuiButton)this.controlList.get(2)).displayString = "Size: " + this.worldSize[this.selectedWorldSize];
-		((GuiButton)this.controlList.get(3)).displayString = "Theme: " + this.worldTheme[this.selectedWorldTheme];
+		String randText = this.mc.adventureMode ? "Varing" : "Random";
+
+		if (this.selectedWorldType >= 0) {
+			((GuiButton)this.controlList.get(2)).displayString = "Type: "
+					+ LevelType.fromId(this.selectedWorldType) + " (" + (this.selectedWorldType + 1)
+					+ "/" + LevelType.values().length + ")";
+		} else {
+			((GuiButton)this.controlList.get(2)).displayString = "Type: " + randText;
+		}
+		if (this.selectedWorldTheme >= 0) {
+			((GuiButton)this.controlList.get(3)).displayString = "Theme: "
+					+ LevelTheme.fromId(this.selectedWorldTheme) + " (" + (this.selectedWorldTheme + 1)
+					+ "/" + LevelTheme.values().length + ")";
+		} else {
+			((GuiButton)this.controlList.get(3)).displayString = "Theme: " + randText;
+		}
+		if (this.selectedWorldStructure >= 0) {
+			((GuiButton)this.controlList.get(6)).displayString = "Structure: "
+					+ LevelStructure.fromId(this.selectedWorldStructure) + " (" + (this.selectedWorldStructure + 1)
+					+ "/" + LevelStructure.values().length + ")";
+		} else {
+			((GuiButton)this.controlList.get(6)).displayString = "Structure: " + randText;
+		}
 	}
 
 	protected final void actionPerformed(GuiButton var1) {
-		if(var1.id == 5) {
+		boolean shift = Keyboard.isKeyDown(Keyboard.KEY_LSHIFT);
+		if(var1.id == 1) {
 			this.mc.displayGuiScreen(this.prevGui);
-		} else if(var1.id == 4) {
-			this.mc.generateLevel(this.selectedWorldSize, this.selectedWorldShape, this.selectedWorldType, this.selectedWorldTheme);
+		} else if(var1.id == 0 || var1.id == 7) {
+			if (this.selectedWorldType < 0 && !this.mc.adventureMode) {
+				this.selectedWorldType = RANDOM.nextInt(LevelType.values().length);
+			}
+			if (this.selectedWorldTheme < 0 && !this.mc.adventureMode) {
+				this.selectedWorldTheme = RANDOM.nextInt(LevelTheme.values().length);
+			}
+			if (this.selectedWorldStructure < 0 && !this.mc.adventureMode) {
+				this.selectedWorldStructure = RANDOM.nextInt(LevelStructure.values().length);
+			}
+
+			int width = SIZE_VALUES[(int)this.sizeSlider.getValue()];
+			int length = SIZE_VALUES[(int)this.sizeSlider.getValue()];
+			int height = HEIGHT_VALUES[(int)this.heightSlider.getValue()];
+			this.mc.worldInfo.creative = var1.id == 7;
+			if (this.mc.adventureMode) {
+				this.mc.startWorld(width, length, height,
+						this.selectedWorldType < 0 ? null : LevelType.values()[this.selectedWorldType],
+						this.selectedWorldTheme < 0 ? null : LevelTheme.values()[this.selectedWorldTheme],
+						this.selectedWorldStructure < 0 ? null : LevelStructure.values()[this.selectedWorldStructure]);
+			} else {
+				this.mc.generateLevel(width, length, height, LevelType.values()[this.selectedWorldType], LevelTheme.values()[this.selectedWorldTheme], LevelStructure.values()[this.selectedWorldStructure]);
+			}
 			this.mc.displayGuiScreen((GuiScreen)null);
-		} else if(var1.id == 0) {
-			this.selectedWorldType = (this.selectedWorldType + 1) % this.worldType.length;
-		} else if(var1.id == 1) {
-			this.selectedWorldShape = (this.selectedWorldShape + 1) % this.worldShape.length;
 		} else if(var1.id == 2) {
-			this.selectedWorldSize = (this.selectedWorldSize + 1) % this.worldSize.length;
+			this.selectedWorldType = cycle(this.selectedWorldType, shift, LevelType.values().length);
 		} else if(var1.id == 3) {
-			this.selectedWorldTheme = (this.selectedWorldTheme + 1) % this.worldTheme.length;
+			this.selectedWorldTheme = cycle(this.selectedWorldTheme, shift, LevelTheme.values().length);
+		} else if(var1.id == 6) {
+			this.selectedWorldStructure = cycle(this.selectedWorldStructure, shift, LevelStructure.values().length);
 		}
 
 		this.worldOptions();
+	}
+
+	private static int cycle(int option, boolean back, int wrap) {
+		return Math.floorMod(option + (back ? -1 : 1) + 1, wrap + 1) - 1;
 	}
 
 	public final void drawScreen(int var1, int var2, float var3) {
 		this.drawDefaultBackground();
-		drawCenteredString(this.fontRenderer, "Generate new level", this.width / 2, 40, 16777215);
+		drawCenteredString(this.fontRenderer, this.mc.adventureMode ? "Creating " + this.mc.worldSaveLocation.getName() + "..." : "Generate new level", this.width / 2, 40, 16777215);
 		super.drawScreen(var1, var2, var3);
+
+		int width = SIZE_VALUES[(int)this.sizeSlider.getValue()];
+		int length = SIZE_VALUES[(int)this.sizeSlider.getValue()];
+		int height = HEIGHT_VALUES[(int)this.heightSlider.getValue()];
+		long volume = (long)width * (long)length * (long)height;
+		long memoryRequirement = volume * 6;
+		if (volume >= (long)Integer.MAX_VALUE || memoryRequirement > Runtime.getRuntime().maxMemory()) {
+			drawCenteredString(this.fontRenderer, "TOO MUCH VOLUME! NOT ENOUGH MEMORY!", this.width / 2, this.height / 4 + 120, 0xFF5555);
+		};
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/generator/terrain/NoiseModifierAccess.java
@@ -1,0 +1,16 @@
+package net.minecraft.game.level.generator.terrain;
+
+import net.minecraft.game.level.generator.noise.NoiseGenerator;
+
+@FunctionalInterface
+public interface NoiseModifierAccess {
+	double getValue(double x, double z, NoiseGenerator noise);
+
+	static NoiseModifierAccess constant(double value) {
+		return (x, z, noise) -> value;
+	}
+
+	static NoiseModifierAccess variation(double base, double range, double scale) {
+		return (x, z, noise) -> base + noise.generateNoiseNormalized(x * scale, z * scale) * range;
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/block/BlockDoor.java
@@ -1,0 +1,182 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.entity.player.EntityPlayer;
+import net.minecraft.game.item.Item;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+import net.minecraft.game.physics.AxisAlignedBB;
+import net.minecraft.game.physics.MovingObjectPosition;
+import net.minecraft.game.physics.Vec3D;
+
+import java.util.Random;
+
+public class BlockDoor extends Block {
+    public BlockDoor(int var1, Material var2) {
+        super(var1, var2);
+        this.blockIndexInTexture = 140;
+        if(var2 == Material.iron) {
+            ++this.blockIndexInTexture;
+        }
+
+        float var3 = 0.5F;
+        float var4 = 1.0F;
+        this.setBlockBounds(0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var4, 0.5F + var3);
+    }
+
+    public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
+        if(var1 != 0 && var1 != 1) {
+            int var3 = this.getState(var2);
+            if((var3 == 0 || var3 == 2) ^ var1 <= 3) {
+                return this.blockIndexInTexture;
+            } else {
+                int var4 = var3 / 2 + (var1 & 1 ^ var3);
+                var4 += (var2 & 4) / 4;
+                int var5 = this.blockIndexInTexture - (var2 & 8) * 2;
+                if((var4 & 1) != (var3 & 1)) {
+                    var5 = -var5;
+                }
+
+                return var5;
+            }
+        } else {
+            return this.blockIndexInTexture;
+        }
+    }
+
+    public boolean isOpaqueCube() {
+        return false;
+    }
+
+    public boolean renderAsNormalBlock() {
+        return false;
+    }
+
+    public int getRenderType() {
+        return 7;
+    }
+
+    public AxisAlignedBB getSelectedBoundingBoxFromPoolWithWorld(World var0, int var1, int var2, int var3) {
+        this.setBoundsForRender(var0, var1, var2, var3);
+        return super.getSelectedBoundingBoxFromPoolWithWorld(var0, var1, var2, var3);
+    }
+
+    public AxisAlignedBB getCollisionBoundingBoxFromPool(World var1, int var2, int var3, int var4) {
+        this.setBoundsForRender(var1, var2, var3, var4);
+        return super.getCollisionBoundingBoxFromPool(var1, var2, var3, var4);
+    }
+
+    public void setBoundsForRender(World var1, int var2, int var3, int var4) {
+        this.setDoorRotation(this.getState(var1.getBlockMetadata(var2, var3, var4)));
+    }
+
+    public void setDoorRotation(int var1) {
+        float var2 = 3.0F / 16.0F;
+        this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 2.0F, 1.0F);
+        if(var1 == 0) {
+            this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, var2);
+        }
+
+        if(var1 == 1) {
+            this.setBlockBounds(1.0F - var2, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+        }
+
+        if(var1 == 2) {
+            this.setBlockBounds(0.0F, 0.0F, 1.0F - var2, 1.0F, 1.0F, 1.0F);
+        }
+
+        if(var1 == 3) {
+            this.setBlockBounds(0.0F, 0.0F, 0.0F, var2, 1.0F, 1.0F);
+        }
+
+    }
+
+    public boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+        if(this.material == Material.iron) {
+            return true;
+        } else {
+            int var6 = var1.getBlockMetadata(var2, var3, var4);
+            if((var6 & 8) != 0) {
+                if(var1.getBlockId(var2, var3 - 1, var4) == this.blockID) {
+                    this.blockActivated(var1, var2, var3 - 1, var4, var5);
+                }
+
+                return true;
+            } else {
+                if(var1.getBlockId(var2, var3 + 1, var4) == this.blockID) {
+                    var1.setBlockMetadata(var2, var3 + 1, var4, (var6 ^ 4) + 8);
+                }
+
+                var1.setBlockMetadata(var2, var3, var4, var6 ^ 4);
+                var1.markBlocksDirty(var2, var3 - 1, var4, var2, var3, var4);
+                if(Math.random() < 0.5D) {
+                    var1.playSoundAtPlayer(var2 + 0.5F, var3 + 0.5F, var4 + 0.5F, "random.door_open", 1.0F, var1.random.nextFloat() * 0.1F + 0.9F);
+                } else {
+                    var1.playSoundAtPlayer(var2 + 0.5F, var3 + 0.5F, var4 + 0.5F, "random.door_close", 1.0F, var1.random.nextFloat() * 0.1F + 0.9F);
+                }
+
+                return true;
+            }
+        }
+    }
+
+    public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
+        int var6 = var1.getBlockMetadata(var2, var3, var4);
+        if((var6 & 8) != 0) {
+            if(var1.getBlockId(var2, var3 - 1, var4) != this.blockID) {
+                var1.setBlockWithNotify(var2, var3, var4, 0);
+            }
+        } else {
+            boolean var7 = false;
+            if(var1.getBlockId(var2, var3 + 1, var4) != this.blockID) {
+                var1.setBlockWithNotify(var2, var3, var4, 0);
+                var7 = true;
+            }
+
+            if(!var1.isBlockNormalCube(var2, var3 - 1, var4)) {
+                var1.setBlockWithNotify(var2, var3, var4, 0);
+                var7 = true;
+                if(var1.getBlockId(var2, var3 + 1, var4) == this.blockID) {
+                    var1.setBlockWithNotify(var2, var3 + 1, var4, 0);
+                }
+            }
+
+            if(var7) {
+                this.dropBlockAsItem(var1, var2, var3, var4, var6);
+            }
+        }
+    }
+
+    public int idDropped(int var1, Random var2) {
+        return (var1 & 8) != 0 ? 0 : (this.material == Material.iron ? Item.doorSteel.shiftedIndex : Item.doorWood.shiftedIndex);
+    }
+
+    public MovingObjectPosition collisionRayTrace(World var1, int var2, int var3, int var4, Vec3D var5, Vec3D var6) {
+        this.setBoundsForRender(var1, var2, var3, var4);
+        return super.collisionRayTrace(var1, var2, var3, var4, var5, var6);
+    }
+
+    public int getState(int var1) {
+        return (var1 & 4) == 0 ? var1 - 1 & 3 : var1 & 3;
+    }
+
+    public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
+        return var1.isBlockNormalCube(var2, var3 - 1, var4) && super.canPlaceBlockAt(var1, var2, var3, var4) && super.canPlaceBlockAt(var1, var2, var3 + 1, var4);
+    }
+
+    public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+        this.blockActivated(var1, var2, var3, var4, null);
+    }
+
+    public boolean canReceivePower(World var1, int var2, int var3, int var4, int var5) {
+        return true;
+    }
+
+    public void onPowerReceived(World world, int x, int y, int z, int dir) {
+        int metadata = world.getBlockMetadata(x, y, z);
+        if ((metadata & 8) != 0)
+            y--;
+        if (!world.isBlockUpdateScheduled(x, y, z, this.blockID)) {
+            world.scheduleBlockUpdate(x, y, z, this.blockID, 0);
+        }
+    }
+}
--- /dev/null
+++ net/minecraft/game/level/block/BlockActivator.java
@@ -1,0 +1,28 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.entity.player.EntityPlayer;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+
+public class BlockActivator extends Block {
+	public BlockActivator(int var1, int var2, Material var3) {
+		super(var1, var2, var3);
+	}
+
+	public boolean canReceivePower(World var1, int var2, int var3, int var4, int var5) {
+		return true;
+	}
+
+	public boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+		for (int i = 0; i < 5; i++) {
+			var1.spawnParticle("largesmoke",
+					var2 + var1.random.nextFloat() * 1.5F - 0.25F,
+					var3 + var1.random.nextFloat() * 1.5F - 0.25F,
+					var4 + var1.random.nextFloat() * 1.5F - 0.25F,
+					0.0F, 0.0F, 0.0F);
+		}
+		var1.playSoundAtPlayer((float)var2 + 0.5F, (float)var3 + 0.5F, (float)var4 + 0.5F, "random.wood click", 0.5F, 1.0F);
+		var1.transmitPowerToNeighbors(var2, var3, var4);
+		return true;
+	}
+}
--- net/minecraft/game/item/recipe/CraftingRecipe.java
+++ net/minecraft/game/item/recipe/CraftingRecipe.java
@@ -55,10 +55,24 @@
 	}
 
 	public final ItemStack createResult() {
-		return new ItemStack(this.recipeOutput.itemID, this.recipeOutput.stackSize);
+		return new ItemStack(this.recipeOutput.itemID, this.recipeOutput.stackSize, this.recipeOutput.itemDamage);
 	}
 
 	public final int b() {
 		return this.width * this.height;
+	}
+
+	public ItemStack[] asItemStacks() {
+		ItemStack[] items = new ItemStack[10];
+		for (int y = 0; y < this.height; y++) {
+			for (int x = 0; x < this.width; x++) {
+				int item = this.ingredientMap[x + y * this.width];
+				if (item > 0) {
+					items[x + y * 3] = new ItemStack(item, 1);
+				}
+			}
+		}
+		items[9] = this.recipeOutput;
+		return items;
 	}
 }
--- net/minecraft/game/level/block/BlockFlowing.java
+++ net/minecraft/game/level/block/BlockFlowing.java
@@ -1,241 +1,255 @@
 package net.minecraft.game.level.block;
 
 import java.util.Random;
+
 import net.minecraft.game.level.World;
 import net.minecraft.game.level.material.Material;
-import net.minecraft.game.physics.AxisAlignedBB;
 
 public final class BlockFlowing extends BlockFluid {
-	private int stillId1;
-	private int movingId1;
-	private Random rand = new Random();
-	private int[] liquidIntArray = new int[]{0, 1, 2, 3};
+	private int numAdjacentSources = 0;
+	private boolean[] isOptimalFlowDirection = new boolean[4];
+	private int[] flowCost = new int[4];
 
-	protected BlockFlowing(int var1, Material var2) {
+	public BlockFlowing(int var1, Material var2) {
 		super(var1, var2);
-		this.blockIndexInTexture = 14;
-		if(var2 == Material.lava) {
-			this.blockIndexInTexture = 30;
-		}
-
-		Block.isBlockFluid[var1] = true;
-		this.movingId1 = var1;
-		this.stillId1 = var1 + 1;
-		this.setBlockBounds(0.01F, -0.09F, 0.01F, 1.01F, 0.90999997F, 1.01F);
-		this.setTickOnLoad(true);
 	}
 
-	public final void onBlockAdded(World var1, int var2, int var3, int var4) {
-		var1.scheduleBlockUpdate(var2, var3, var4, this.movingId1);
+	private void updateFlow(World var1, int var2, int var3, int var4) {
+		int var5 = var1.getBlockMetadata(var2, var3, var4);
+		var1.setBlockAndMetadata(var2, var3, var4, this.blockID + 1, var5);
+		var1.markBlocksDirty(var2, var3, var4, var2, var3, var4);
 	}
 
 	public final void updateTick(World var1, int var2, int var3, int var4, Random var5) {
-		this.update(var1, var2, var3, var4, 0);
-	}
-
-	public final boolean update(World var1, int var2, int var3, int var4, int var5) {
-		boolean var10 = false;
-		boolean var6 = this.canFlow(var1, var2 - 1, var3, var4) || this.canFlow(var1, var2 + 1, var3, var4) || this.canFlow(var1, var2, var3, var4 - 1) || this.canFlow(var1, var2, var3, var4 + 1);
-		int var7;
+		int var6 = this.getFlowDecay(var1, var2, var3, var4);
+		boolean var7 = true;
 		int var8;
 		int var9;
-		if(var6 && var1.getBlockMaterial(var2, var3 - 1, var4) == this.material) {
-			var5 = var1.floodFill(var2, var3 - 1, var4, this.movingId1, this.stillId1);
-			if(var5 == 1) {
-				var7 = var1.fluidFlowCheck(var2, var3, var4, this.movingId1, this.stillId1);
-				if(var7 != -9999) {
-					if(var7 < 0) {
-						return false;
-					}
-
-					var8 = var7 % 1024;
-					var7 >>= 10;
-					var9 = var7 % 1024;
-					var7 >>= 10;
-					var2 = var7 % 1024;
-					var1.setBlockWithNotify(var8, var2, var9, 0);
-					return false;
-				}
-
-				return false;
-			}
-		}
-
-		var10 = this.liquidSpread2(var1, var2, var3, var4, var2, var3 - 1, var4);
-
-		for(var7 = 0; var7 < 4; ++var7) {
-			var8 = this.rand.nextInt(4 - var7) + var7;
-			var9 = this.liquidIntArray[var7];
-			this.liquidIntArray[var7] = this.liquidIntArray[var8];
-			this.liquidIntArray[var8] = var9;
-			if(this.liquidIntArray[var7] == 0 && !var10) {
-				var10 = this.liquidSpread2(var1, var2, var3, var4, var2 - 1, var3, var4);
-			}
-
-			if(this.liquidIntArray[var7] == 1 && !var10) {
-				var10 = this.liquidSpread2(var1, var2, var3, var4, var2 + 1, var3, var4);
-			}
-
-			if(this.liquidIntArray[var7] == 2 && !var10) {
-				var10 = this.liquidSpread2(var1, var2, var3, var4, var2, var3, var4 - 1);
-			}
-
-			if(this.liquidIntArray[var7] == 3 && !var10) {
-				var10 = this.liquidSpread2(var1, var2, var3, var4, var2, var3, var4 + 1);
-			}
-		}
-
-		if(!var10 && var6) {
-			if(this.rand.nextInt(3) == 0) {
-				if(this.rand.nextInt(3) == 0) {
-					var10 = false;
-
-					for(var7 = 0; var7 < 4; ++var7) {
-						var8 = this.rand.nextInt(4 - var7) + var7;
-						var9 = this.liquidIntArray[var7];
-						this.liquidIntArray[var7] = this.liquidIntArray[var8];
-						this.liquidIntArray[var8] = var9;
-						if(this.liquidIntArray[var7] == 0 && !var10) {
-							var10 = this.liquidSpread(var1, var2, var3, var4, var2 - 1, var3, var4);
-						}
-
-						if(this.liquidIntArray[var7] == 1 && !var10) {
-							var10 = this.liquidSpread(var1, var2, var3, var4, var2 + 1, var3, var4);
-						}
-
-						if(this.liquidIntArray[var7] == 2 && !var10) {
-							var10 = this.liquidSpread(var1, var2, var3, var4, var2, var3, var4 - 1);
-						}
-
-						if(this.liquidIntArray[var7] == 3 && !var10) {
-							var10 = this.liquidSpread(var1, var2, var3, var4, var2, var3, var4 + 1);
-						}
-					}
-				} else if(this.material == Material.lava) {
-					var1.setBlockWithNotify(var2, var3, var4, Block.stone.blockID);
+		if(var6 > 0) {
+			this.numAdjacentSources = 0;
+			var8 = this.getSmallestFlowDecay(var1, var2 - 1, var3, var4, -100);
+			var8 = this.getSmallestFlowDecay(var1, var2 + 1, var3, var4, var8);
+			var8 = this.getSmallestFlowDecay(var1, var2, var3, var4 - 1, var8);
+			var8 = this.getSmallestFlowDecay(var1, var2, var3, var4 + 1, var8);
+			var9 = var8 + this.liquidType;
+			if(var9 >= 8 || var8 < 0) {
+				var9 = -1;
+			}
+
+			if(this.getFlowDecay(var1, var2, var3 + 1, var4) >= 0) {
+				var8 = this.getFlowDecay(var1, var2, var3 + 1, var4);
+				if(var8 >= 8) {
+					var9 = var8;
 				} else {
+					var9 = var8 + 8;
+				}
+			}
+
+			if(this.numAdjacentSources >= 2 && this.material == Material.water) {
+				var9 = 0;
+			}
+
+			if(this.material == Material.lava && var6 < 8 && var9 < 8 && var9 > var6 && var5.nextInt(4) != 0) {
+				var9 = var6;
+				var7 = false;
+			}
+
+			if(var9 != var6) {
+				var6 = var9;
+				if(var9 < 0) {
 					var1.setBlockWithNotify(var2, var3, var4, 0);
+				} else {
+					var1.setBlockMetadata(var2, var3, var4, var9);
+					var1.scheduleBlockUpdate(var2, var3, var4, this.blockID);
+					var1.notifyBlocksOfNeighborChange(var2, var3, var4, this.blockID);
 				}
+			} else if(var7) {
+				this.updateFlow(var1, var2, var3, var4);
 			}
-
-			return false;
 		} else {
-			if(this.material == Material.water) {
-				var10 |= extinguishFireLava(var1, var2 - 1, var3, var4);
-				var10 |= extinguishFireLava(var1, var2 + 1, var3, var4);
-				var10 |= extinguishFireLava(var1, var2, var3, var4 - 1);
-				var10 |= extinguishFireLava(var1, var2, var3, var4 + 1);
-			}
-
-			if(this.material == Material.lava) {
-				var10 |= flow(var1, var2 - 1, var3, var4);
-				var10 |= flow(var1, var2 + 1, var3, var4);
-				var10 |= flow(var1, var2, var3, var4 - 1);
-				var10 |= flow(var1, var2, var3, var4 + 1);
-			}
-
-			if(!var10) {
-				var1.setTileNoUpdate(var2, var3, var4, this.stillId1);
+			this.updateFlow(var1, var2, var3, var4);
+		}
+
+		if(this.liquidCanDisplaceBlock(var1, var2, var3 - 1, var4)) {
+			if(var6 >= 8) {
+				var1.setBlockAndMetadataWithNotify(var2, var3 - 1, var4, this.blockID, var6);
 			} else {
-				var1.scheduleBlockUpdate(var2, var3, var4, this.movingId1);
-			}
-
-			return var10;
-		}
-	}
-
-	private boolean liquidSpread(World var1, int var2, int var3, int var4, int var5, int var6, int var7) {
-		if(this.canFlow(var1, var5, var6, var7)) {
-			var1.setBlockWithNotify(var5, var6, var7, this.blockID);
-			var1.scheduleBlockUpdate(var5, var6, var7, this.blockID);
-			return true;
-		} else {
-			return false;
-		}
-	}
-
-	private boolean liquidSpread2(World var1, int var2, int var3, int var4, int var5, int var6, int var7) {
-		if(!this.canFlow(var1, var5, var6, var7)) {
-			return false;
-		} else {
-			var2 = var1.fluidFlowCheck(var2, var3, var4, this.movingId1, this.stillId1);
-			if(var2 != -9999) {
-				if(var2 < 0) {
-					return false;
-				}
-
-				var3 = var2 % 1024;
-				var2 >>= 10;
-				var4 = var2 % 1024;
-				var2 >>= 10;
-				var2 %= 1024;
-				if((var2 > var6 || !this.canFlow(var1, var5, var6 - 1, var7)) && var2 <= var6 && var3 != 0 && var3 != var1.width - 1 && var4 != 0 && var4 != var1.length - 1) {
-					return false;
-				}
-
-				var1.setBlockWithNotify(var3, var2, var4, 0);
-			}
-
-			var1.setBlockWithNotify(var5, var6, var7, this.blockID);
-			var1.scheduleBlockUpdate(var5, var6, var7, this.blockID);
-			return true;
-		}
-	}
-
-	public final boolean shouldSideBeRendered(World var1, int var2, int var3, int var4, int var5) {
-		if(var2 >= 0 && var3 >= 0 && var4 >= 0 && var2 < var1.width && var4 < var1.length) {
+				var1.setBlockAndMetadataWithNotify(var2, var3 - 1, var4, this.blockID, var6 + 8);
+			}
+		} else {
+			if(var6 >= 0 && (var6 == 0 || blockBlocksFlow(var1, var2, var3 - 1, var4))) {
+				int var10 = var4;
+				var9 = var3;
+				var8 = var2;
+				World var15 = var1;
+
+				int var11;
+				int var12;
+				for(var11 = 0; var11 < 4; ++var11) {
+					this.flowCost[var11] = 1000;
+					var12 = var8;
+					int var13 = var10;
+					if(var11 == 0) {
+						var12 = var8 - 1;
+					}
+
+					if(var11 == 1) {
+						++var12;
+					}
+
+					if(var11 == 2) {
+						var13 = var10 - 1;
+					}
+
+					if(var11 == 3) {
+						++var13;
+					}
+
+					if(!blockBlocksFlow(var15, var12, var9, var13) && (var15.getBlockMaterial(var12, var9, var13) != this.material || var15.getBlockMetadata(var12, var9, var13) != 0)) {
+						if(!blockBlocksFlow(var15, var12, var9 - 1, var13)) {
+							this.flowCost[var11] = 0;
+						} else {
+							this.flowCost[var11] = this.calculateFlowCost(var15, var12, var9, var13, 1, var11);
+						}
+					}
+				}
+
+				var11 = this.flowCost[0];
+
+				for(var12 = 1; var12 < 4; ++var12) {
+					if(this.flowCost[var12] < var11) {
+						var11 = this.flowCost[var12];
+					}
+				}
+
+				for(var12 = 0; var12 < 4; ++var12) {
+					this.isOptimalFlowDirection[var12] = this.flowCost[var12] == var11;
+				}
+
+				boolean[] var16 = this.isOptimalFlowDirection;
+				var9 = var6 + this.liquidType;
+				if(var6 >= 8) {
+					var9 = 1;
+				}
+
+				if(var9 >= 8) {
+					return;
+				}
+
+				if(var16[0]) {
+					this.flowIntoBlock(var1, var2 - 1, var3, var4, var9);
+				}
+
+				if(var16[1]) {
+					this.flowIntoBlock(var1, var2 + 1, var3, var4, var9);
+				}
+
+				if(var16[2]) {
+					this.flowIntoBlock(var1, var2, var3, var4 - 1, var9);
+				}
+
+				if(var16[3]) {
+					this.flowIntoBlock(var1, var2, var3, var4 + 1, var9);
+				}
+			}
+
+		}
+	}
+
+	private void flowIntoBlock(World var1, int var2, int var3, int var4, int var5) {
+		if(this.liquidCanDisplaceBlock(var1, var2, var3, var4)) {
 			int var6 = var1.getBlockId(var2, var3, var4);
-			return var6 != this.movingId1 && var6 != this.stillId1 ? (var5 != 1 || var1.getBlockId(var2 - 1, var3, var4) != 0 && var1.getBlockId(var2 + 1, var3, var4) != 0 && var1.getBlockId(var2, var3, var4 - 1) != 0 && var1.getBlockId(var2, var3, var4 + 1) != 0 ? super.shouldSideBeRendered(var1, var2, var3, var4, var5) : true) : false;
-		} else {
-			return false;
-		}
-	}
-
-	public final boolean isCollidable() {
-		return false;
-	}
-
-	public final AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
-		return null;
-	}
-
-	public final boolean isOpaqueCube() {
-		return false;
-	}
-
-	public final void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
-	}
-
-	public final int tickRate() {
-		return this.material == Material.lava ? 25 : 5;
-	}
-
-	public final int quantityDropped(Random var1) {
-		return 0;
-	}
-
-	public final int getRenderBlockPass() {
-		return this.material == Material.water ? 1 : 0;
-	}
-
-	private static boolean extinguishFireLava(World var0, int var1, int var2, int var3) {
-		if(var0.getBlockId(var1, var2, var3) == Block.fire.blockID) {
-			var0.setBlockWithNotify(var1, var2, var3, 0);
-			return true;
-		} else if(var0.getBlockId(var1, var2, var3) != Block.lavaMoving.blockID && var0.getBlockId(var1, var2, var3) != Block.lavaStill.blockID) {
-			return false;
-		} else {
-			var0.setBlockWithNotify(var1, var2, var3, Block.stone.blockID);
-			return true;
-		}
-	}
-
-	private static boolean flow(World var0, int var1, int var2, int var3) {
-		if(Block.fire.getChanceOfNeighborsEncouragingFire(var0.getBlockId(var1, var2, var3))) {
-			Block.fire.fireSpread(var0, var1, var2, var3);
-			return true;
-		} else {
-			return false;
-		}
+			if(var6 > 0) {
+				if(this.material == Material.lava) {
+					triggerLavaMixEffects(var1, var2, var3, var4);
+				} else {
+					Block.blocksList[var6].dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+				}
+			}
+
+			var1.setBlockAndMetadataWithNotify(var2, var3, var4, this.blockID, var5);
+		}
+
+	}
+
+	private int calculateFlowCost(World var1, int var2, int var3, int var4, int var5, int var6) {
+		int var7 = 1000;
+
+		for(int var8 = 0; var8 < 4; ++var8) {
+			if((var8 != 0 || var6 != 1) && (var8 != 1 || var6 != 0) && (var8 != 2 || var6 != 3) && (var8 != 3 || var6 != 2)) {
+				int var9 = var2;
+				int var10 = var4;
+				if(var8 == 0) {
+					var9 = var2 - 1;
+				}
+
+				if(var8 == 1) {
+					++var9;
+				}
+
+				if(var8 == 2) {
+					var10 = var4 - 1;
+				}
+
+				if(var8 == 3) {
+					++var10;
+				}
+
+				if(!blockBlocksFlow(var1, var9, var3, var10) && (var1.getBlockMaterial(var9, var3, var10) != this.material || var1.getBlockMetadata(var9, var3, var10) != 0)) {
+					if(!blockBlocksFlow(var1, var9, var3 - 1, var10)) {
+						return var5;
+					}
+
+					if(var5 < 4) {
+						var9 = this.calculateFlowCost(var1, var9, var3, var10, var5 + 1, var8);
+						if(var9 < var7) {
+							var7 = var9;
+						}
+					}
+				}
+			}
+		}
+
+		return var7;
+	}
+
+	private static boolean blockBlocksFlow(World var0, int var1, int var2, int var3) {
+		int var4 = var0.getBlockId(var1, var2, var3);
+		if(var4 == 0 || (var4 == Block.ironGrate.blockID && (var0.getBlockMetadata(var1, var2, var3) & 1) == 1)) {
+			return false;
+		} else {
+			Material var5 = Block.blocksList[var4].material;
+			return var5.isSolid();
+		}
+	}
+
+	private int getSmallestFlowDecay(World var1, int var2, int var3, int var4, int var5) {
+		int var6 = this.getFlowDecay(var1, var2, var3, var4);
+		if(var6 < 0) {
+			return var5;
+		} else {
+			if(var6 == 0) {
+				++this.numAdjacentSources;
+			}
+
+			if(var6 >= 8) {
+				var6 = 0;
+			}
+
+			return var5 >= 0 && var6 >= var5 ? var5 : var6;
+		}
+	}
+
+	private boolean liquidCanDisplaceBlock(World var1, int var2, int var3, int var4) {
+		Material var5 = var1.getBlockMaterial(var2, var3, var4);
+		return var5 == this.material ? false : (var5 == Material.lava ? false : !blockBlocksFlow(var1, var2, var3, var4));
+	}
+
+	public final void onBlockAdded(World var1, int var2, int var3, int var4) {
+		super.onBlockAdded(var1, var2, var3, var4);
+		if(var1.getBlockId(var2, var3, var4) == this.blockID) {
+			var1.scheduleBlockUpdate(var2, var3, var4, this.blockID);
+		}
+
 	}
 }
--- net/minecraft/game/level/block/BlockChest.java
+++ net/minecraft/game/level/block/BlockChest.java
@@ -14,7 +14,7 @@
 public final class BlockChest extends BlockContainer {
 	private Random random = new Random();
 
-	protected BlockChest(int var1) {
+	public BlockChest(int var1) {
 		super(54, Material.wood);
 		this.blockIndexInTexture = 26;
 	}
@@ -135,7 +135,7 @@
 		return var1.getBlockId(var2, var3, var4) != this.blockID ? false : (var1.getBlockId(var2 - 1, var3, var4) == this.blockID ? true : (var1.getBlockId(var2 + 1, var3, var4) == this.blockID ? true : (var1.getBlockId(var2, var3, var4 - 1) == this.blockID ? true : var1.getBlockId(var2, var3, var4 + 1) == this.blockID)));
 	}
 
-	public final void onBlockRemoval(World var1, int var2, int var3, int var4) {
+	public final void onBlockRemoval(World var1, int var2, int var3, int var4, int var4a) {
 		TileEntityChest var5 = (TileEntityChest)var1.getBlockTileEntity(var2, var3, var4);
 
 		for(int var6 = 0; var6 < var5.getSizeInventory(); ++var6) {
@@ -161,10 +161,12 @@
 			}
 		}
 
-		super.onBlockRemoval(var1, var2, var3, var4);
+		super.onBlockRemoval(var1, var2, var3, var4, var4a);
 	}
 
 	public final boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+		if (!var1.survivalWorld) return false;
+
 		Object var6 = (TileEntityChest)var1.getBlockTileEntity(var2, var3, var4);
 		if(var1.isBlockNormalCube(var2, var3 + 1, var4)) {
 			return true;
--- net/minecraft/game/level/block/Block.java
+++ net/minecraft/game/level/block/Block.java
@@ -1,6 +1,8 @@
 package net.minecraft.game.level.block;
 
 import java.util.Random;
+
+import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.misc.EntityItem;
 import net.minecraft.game.entity.player.EntityPlayer;
 import net.minecraft.game.entity.player.InventoryPlayer;
@@ -14,6 +16,12 @@
 import net.minecraft.game.physics.Vec3D;
 
 public class Block {
+	public static final int DROP_FLAG_SILK_TOUCH = 0b1_0000_0000;
+	public static final byte PISTON_PUSH_IMMOVABLE = 0;
+	public static final byte PISTON_PUSH_MOVE = 1;
+	public static final byte PISTON_PUSH_BREAK = 2;
+	public static final byte PISTON_PUSH_DISPLACE = 3;
+
 	private static StepSound soundPowderFootstep = new StepSound("stone", 1.0F, 1.0F);
 	private static StepSound soundWoodFootstep = new StepSound("wood", 1.0F, 1.0F);
 	private static StepSound soundGravelFootstep = new StepSound("gravel", 1.0F, 1.0F);
@@ -30,6 +38,8 @@
 	private static boolean[] canBlockGrass = new boolean[256];
 	public static final boolean[] isBlockFluid = new boolean[256];
 	public static final int[] lightValue = new int[256];
+	public static final boolean[] conductive = new boolean[256];
+	public static final byte[] pistonPushBehavior = new byte[256];
 	public static final Block stone;
 	public static final BlockGrass grass;
 	public static final Block dirt;
@@ -92,6 +102,38 @@
 	public static final Block tilledField;
 	public static final Block stoneOvenIdle;
 	public static final Block stoneOvenActive;
+	public static final Block snow = (new BlockSnow(63, 81)).setHardness(0.1F).setStepSound(soundClothFootstep);
+	public static final Block ice = (new BlockIce(64, 96)).setHardness(0.5F).setLightOpacity(3).setStepSound(soundGlassFootstep);
+	public static final Block blockSnow = (new BlockSnowBlock(65, 81)).setHardness(0.2F).setStepSound(soundClothFootstep);
+	public static final Block cactus = (new BlockCactus(66, 110)).setHardness(0.4F).setStepSound(soundClothFootstep);
+	public static final BlockFlower plantBlue = (BlockFlower)(new BlockFlower(67, 108)).setHardness(0.0F).setStepSound(soundGrassFootstep);
+	public static final Block woodStairDouble = (new BlockStep(68, 4, Material.wood, true)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep);
+	public static final Block woodStairSingle = (new BlockStep(69, 4, Material.wood, false)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep);
+	public static final Block activator = (new BlockActivator(70, 53, Material.iron)).setHardness(3.0F);
+	public static final Block ironGrate = (new BlockGrate(71, 82, Material.iron)).setHardness(1.5F).setStepSound(soundMetalFootstep);
+	public static final Block observer = (new BlockObserver(72)).setHardness(0.5F).setStepSound(soundMetalFootstep);
+	public static final Block oreCopper = (new BlockOre(73, 51)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
+	public static final Block blockCopper = (new BlockOreBlock(74, 101, 3)).setHardness(3.0F).setResistance(10.0F).setStepSound(soundMetalFootstep);
+	public static final Block lampInactive = (new BlockLamp(75, 99, 76)).setHardness(0.5F).setStepSound(soundGlassFootstep);
+	public static final Block lampActive = (new BlockLamp(76, 100, 75)).setHardness(0.5F).setStepSound(soundGlassFootstep).setLightValue(1.0F);
+	public static final Block piston = (new BlockPiston(77, 103, 0)).setHardness(0.5F).setStepSound(soundMetalFootstep);
+	public static final Block pistonCopper = (new BlockPiston(78, 105, 1)).setHardness(0.5F).setStepSound(soundMetalFootstep);
+	public static final Block pistonGold = (new BlockPiston(79, 107, 2)).setHardness(0.5F).setStepSound(soundMetalFootstep);
+	public static final Block diode = (new BlockDiode(80)).setHardness(0.5F).setStepSound(soundMetalFootstep);
+	public static final Block magneticPlatform = (new BlockMagnetPlatform(81, 120)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block woodenGrate = (new BlockGrate(82, 127, Material.wood)).setHardness(1.5F).setStepSound(soundWoodFootstep);
+	public static final Block logicGate = (new BlockLogicGate(83)).setHardness(0.5F).setStepSound(soundMetalFootstep);
+	public static final Block doorWood = (new BlockDoor(84, Material.wood)).setHardness(3.0F).setStepSound(soundWoodFootstep);
+	public static final Block doorSteel = (new BlockDoor(85, Material.iron)).setHardness(5.0F).setStepSound(soundMetalFootstep);
+	public static final Block mud = (new BlockMud(86, 126, Material.ground)).setHardness(0.5F).setStepSound(soundGravelFootstep);
+	public static final Block brownMushroomBlock = (new BlockMushroomCap(87, Material.wood, 145, 0)).setHardness(0.2F).setStepSound(soundWoodFootstep);
+	public static final Block redMushroomBlock = (new BlockMushroomCap(88, Material.wood, 145, 1)).setHardness(0.2F).setStepSound(soundWoodFootstep);
+	public static final Block fumes = (new BlockFumes(89, 130)).setHardness(-1.0F).setResistance(500.0F).setStepSound(soundClothFootstep).setPistonPushBehavior(PISTON_PUSH_DISPLACE);
+	public static final Block clay = (new BlockClay(90, 131, Material.ground)).setHardness(0.6F).setStepSound(soundGravelFootstep);
+	public static final Block ironChain = (new BlockChain(91, 132, 1)).setHardness(0.5F).setStepSound(soundMetalFootstep);
+	public static final Block goldChain = (new BlockChain(92, 133, 2)).setHardness(0.5F).setStepSound(soundMetalFootstep);
+	public static final Block copperChain = (new BlockChain(93, 134, 3)).setHardness(0.5F).setStepSound(soundMetalFootstep);
+	public static final Block goldenGrate = (new BlockGrate(94, 135, Material.rock)).setHardness(1.5F).setStepSound(soundMetalFootstep);
 	public int blockIndexInTexture;
 	public final int blockID;
 	private float hardness;
@@ -106,7 +148,7 @@
 	public float blockParticleGravity;
 	public final Material material;
 
-	protected Block(int var1, Material var2) {
+	public Block(int var1, Material var2) {
 		this.stepSound = soundPowderFootstep;
 		this.blockParticleGravity = 1.0F;
 		if(blocksList[var1] != null) {
@@ -120,10 +162,17 @@
 			lightOpacity[var1] = this.isOpaqueCube() ? 255 : 0;
 			canBlockGrass[var1] = this.renderAsNormalBlock();
 			isBlockFluid[var1] = false;
+			conductive[var1] = this.isConductive();
+			try {
+				pistonPushBehavior[var1] = this.getCollisionBoundingBoxFromPool(null, 0, 0, 0) == null
+					? PISTON_PUSH_BREAK : PISTON_PUSH_MOVE;
+			} catch (NullPointerException e) {
+				pistonPushBehavior[var1] = PISTON_PUSH_MOVE;
+			}
 		}
 	}
 
-	protected Block(int var1, int var2, Material var3) {
+	public Block(int var1, int var2, Material var3) {
 		this(var1, var3);
 		this.blockIndexInTexture = var2;
 	}
@@ -143,6 +192,20 @@
 		return this;
 	}
 
+	protected final Block setStepSound(StepSound var1) {
+		this.stepSound = var1;
+		return this;
+	}
+
+	protected final Block setPistonPushBehavior(byte value) {
+		pistonPushBehavior[this.blockID] = value;
+		return this;
+	}
+
+	public final int getPistonPushBehavior() {
+		return pistonPushBehavior[this.blockID];
+	}
+
 	public boolean renderAsNormalBlock() {
 		return true;
 	}
@@ -151,6 +214,10 @@
 		return 0;
 	}
 
+	public boolean has3DIcon() {
+		return this.getRenderType() == 0;
+	}
+
 	protected final Block setHardness(float var1) {
 		this.hardness = var1;
 		if(this.resistance < var1 * 5.0F) {
@@ -164,7 +231,7 @@
 		tickOnLoad[this.blockID] = var1;
 	}
 
-	protected final void setBlockBounds(float var1, float var2, float var3, float var4, float var5, float var6) {
+	public final void setBlockBounds(float var1, float var2, float var3, float var4, float var5, float var6) {
 		this.minX = var1;
 		this.minY = var2;
 		this.minZ = var3;
@@ -193,11 +260,11 @@
 		return this.blockIndexInTexture;
 	}
 
-	public final AxisAlignedBB getSelectedBoundingBoxFromPool(int var1, int var2, int var3) {
+	public AxisAlignedBB getSelectedBoundingBoxFromPoolWithWorld(World var0, int var1, int var2, int var3) {
 		return new AxisAlignedBB((float)var1 + this.minX, (float)var2 + this.minY, (float)var3 + this.minZ, (float)var1 + this.maxX, (float)var2 + this.maxY, (float)var3 + this.maxZ);
 	}
 
-	public AxisAlignedBB getCollisionBoundingBoxFromPool(int var1, int var2, int var3) {
+	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
 		return new AxisAlignedBB((float)var1 + this.minX, (float)var2 + this.minY, (float)var3 + this.minZ, (float)var1 + this.maxX, (float)var2 + this.maxY, (float)var3 + this.maxZ);
 	}
 
@@ -228,7 +295,7 @@
 	public void onBlockAdded(World var1, int var2, int var3, int var4) {
 	}
 
-	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
+	public void onBlockRemoval(World var1, int var2, int var3, int var4, int var4a) {
 	}
 
 	public int quantityDropped(Random var1) {
@@ -239,6 +306,10 @@
 		return this.blockID;
 	}
 
+	public int damageDropped(int metadata, int dropId, Random var1) {
+		return 0;
+	}
+
 	public final float blockStrength(EntityPlayer var1) {
 		if(this.hardness < 0.0F) {
 			return 0.0F;
@@ -265,21 +336,22 @@
 		}
 	}
 
-	public final void dropBlockAsItem(World var1, int var2, int var3, int var4, int var5) {
+	public void dropBlockAsItem(World var1, int var2, int var3, int var4, int var5) {
 		this.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, 1.0F);
 	}
 
-	public final void dropBlockAsItemWithChance(World var1, int var2, int var3, int var4, int var5, float var6) {
+	public void dropBlockAsItemWithChance(World var1, int var2, int var3, int var4, int var5, float var6) {
 		int var7 = this.quantityDropped(var1.random);
 
 		for(int var8 = 0; var8 < var7; ++var8) {
 			if(var1.random.nextFloat() <= var6) {
 				int var9 = this.idDropped(var5, var1.random);
 				if(var9 > 0) {
+					int var9a = this.damageDropped(var5, var9, var1.random);
 					float var10 = var1.random.nextFloat() * 0.7F + 0.15F;
 					float var11 = var1.random.nextFloat() * 0.7F + 0.15F;
 					float var12 = var1.random.nextFloat() * 0.7F + 0.15F;
-					EntityItem var13 = new EntityItem(var1, (float)var2 + var10, (float)var3 + var11, (float)var4 + var12, new ItemStack(var9));
+					EntityItem var13 = new EntityItem(var1, (float)var2 + var10, (float)var3 + var11, (float)var4 + var12, new ItemStack(var9, 1, var9a));
 					var13.delayBeforeCanPickup = 10;
 					var1.spawnEntityInWorld(var13);
 				}
@@ -415,6 +487,41 @@
 	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
 	}
 
+	public void onEntityCollidedWithBlock(World var1, int var2, int var3, int var4, Entity var5) {
+	}
+
+	public boolean canBlockStay(World var1, int var2, int var3, int var4) {
+		return true;
+	}
+
+	public void setBoundsForRender(World var1, int var2, int var3, int var4) {
+	}
+
+	public void velocityToAddToEntity(World var1, int var2, int var3, int var4, Vec3D var5) {
+	}
+
+	public void resetBlockBounds() {
+	}
+
+	public boolean isConductive() {
+		return false;
+	}
+
+	public boolean conductWithBlock(Block block) {
+		return true;
+	}
+
+	public boolean canReceivePower(World var1, int var2, int var3, int var4, int var5) {
+		return false;
+	}
+
+	public void onPowerReceived(World world, int x, int y, int z, int dir) {
+	}
+
+	public boolean displace(World world, int x, int y, int z) {
+		return false;
+	}
+
 	static {
 		Block var10000 = (new BlockStone(1, 1)).setHardness(1.5F).setResistance(10.0F);
 		StepSound var1 = soundStoneFootstep;
@@ -450,11 +557,12 @@
 		var1 = soundStoneFootstep;
 		var0 = var10000;
 		var0.stepSound = var1;
+		var0.setPistonPushBehavior(PISTON_PUSH_IMMOVABLE);
 		bedrock = var0;
-		waterMoving = (new BlockFlowing(8, Material.water)).setHardness(100.0F).setLightOpacity(3);
-		waterStill = (new BlockStationary(9, Material.water)).setHardness(100.0F).setLightOpacity(3);
-		lavaMoving = (new BlockFlowing(10, Material.lava)).setHardness(0.0F).setLightValue(1.0F).setLightOpacity(255);
-		lavaStill = (new BlockStationary(11, Material.lava)).setHardness(100.0F).setLightValue(1.0F).setLightOpacity(255);
+		waterMoving = (new BlockFlowing(8, Material.water)).setHardness(100.0F).setLightOpacity(3).setPistonPushBehavior(PISTON_PUSH_DISPLACE);
+		waterStill = (new BlockStationary(9, Material.water)).setHardness(100.0F).setLightOpacity(3).setPistonPushBehavior(PISTON_PUSH_DISPLACE);
+		lavaMoving = (new BlockFlowing(10, Material.lava)).setHardness(0.0F).setLightValue(1.0F).setLightOpacity(255).setPistonPushBehavior(PISTON_PUSH_DISPLACE);
+		lavaStill = (new BlockStationary(11, Material.lava)).setHardness(100.0F).setLightValue(1.0F).setLightOpacity(255).setPistonPushBehavior(PISTON_PUSH_DISPLACE);
 		var10000 = (new BlockSand(12, 18)).setHardness(0.5F);
 		var1 = soundSandFootstep;
 		var0 = var10000;
@@ -600,22 +708,22 @@
 		var0 = var10000;
 		var0.stepSound = var1;
 		mushroomRed = (BlockFlower)var0;
-		var10000 = (new BlockOreBlock(41, 39)).setHardness(3.0F).setResistance(10.0F);
+		var10000 = (new BlockOreBlock(41, 39, 2)).setHardness(3.0F).setResistance(10.0F);
 		var1 = soundMetalFootstep;
 		var0 = var10000;
 		var0.stepSound = var1;
 		blockGold = var0;
-		var10000 = (new BlockOreBlock(42, 38)).setHardness(5.0F).setResistance(10.0F);
+		var10000 = (new BlockOreBlock(42, 38, 1)).setHardness(5.0F).setResistance(10.0F);
 		var1 = soundMetalFootstep;
 		var0 = var10000;
 		var0.stepSound = var1;
 		blockSteel = var0;
-		var10000 = (new BlockStep(43, true)).setHardness(2.0F).setResistance(10.0F);
+		var10000 = (new BlockStep(43, 6, Material.rock, true)).setHardness(2.0F).setResistance(10.0F);
 		var1 = soundStoneFootstep;
 		var0 = var10000;
 		var0.stepSound = var1;
 		stairDouble = var0;
-		var10000 = (new BlockStep(44, false)).setHardness(2.0F).setResistance(10.0F);
+		var10000 = (new BlockStep(44, 6, Material.rock, false)).setHardness(2.0F).setResistance(10.0F);
 		var1 = soundStoneFootstep;
 		var0 = var10000;
 		var0.stepSound = var1;
@@ -640,11 +748,12 @@
 		var0 = var10000;
 		var0.stepSound = var1;
 		cobblestoneMossy = var0;
-		var10000 = (new BlockStone(49, 37)).setHardness(10.0F).setResistance(10.0F);
+		var10000 = (new Block(49, 37, Material.rock)).setHardness(10.0F).setResistance(2000.0F);
 		var1 = soundStoneFootstep;
 		var0 = var10000;
 		var0.stepSound = var1;
 		obsidian = var0;
+		var0.setPistonPushBehavior(PISTON_PUSH_IMMOVABLE);
 		var10000 = (new BlockTorch(50, 80)).setHardness(0.0F).setLightValue(14.0F / 16.0F);
 		var1 = soundWoodFootstep;
 		var0 = var10000;
@@ -670,7 +779,7 @@
 		var0 = var10000;
 		var0.stepSound = var1;
 		crate = var0;
-		var10000 = (new BlockGears(55, 62)).setHardness(0.5F);
+		var10000 = (new BlockGears(55, 62)).setHardness(0.5F).setPistonPushBehavior(PISTON_PUSH_MOVE);
 		var1 = soundMetalFootstep;
 		var0 = var10000;
 		var0.stepSound = var1;
@@ -680,7 +789,7 @@
 		var0 = var10000;
 		var0.stepSound = var1;
 		oreDiamond = var0;
-		var10000 = (new BlockOreBlock(57, 40)).setHardness(5.0F).setResistance(10.0F);
+		var10000 = (new BlockOreBlock(57, 40, 0)).setHardness(5.0F).setResistance(10.0F);
 		var1 = soundMetalFootstep;
 		var0 = var10000;
 		var0.stepSound = var1;
--- util/MathHelper.java
+++ util/MathHelper.java
@@ -29,6 +29,18 @@
 		return var0 >= 0.0F ? var0 : -var0;
 	}
 
+	public static int clamp(int x, int min, int max) {
+		return Math.min(Math.max(x, min), max);
+	}
+
+	public static float lerp(float a, float b, float t) {
+		return a + (b - a) * t;
+	}
+
+	public static double lerp(double a, double b, double t) {
+		return a + (b - a) * t;
+	}
+
 	static {
 		for(int var0 = 0; var0 < 65536; ++var0) {
 			SIN_TABLE[var0] = (float)Math.sin((double)var0 * Math.PI * 2.0D / 65536.0D);
--- /dev/null
+++ net/minecraft/client/MinecraftImpl.java
@@ -1,0 +1,14 @@
+package net.minecraft.client;
+
+import java.awt.Canvas;
+import java.awt.Component;
+import java.awt.Frame;
+
+public final class MinecraftImpl extends Minecraft {
+	final Frame mcFrame;
+
+	public MinecraftImpl(Canvas var2, MinecraftApplet var3, int var4, int var5, boolean var6, Frame var7) {
+		super(var2, var3, var4, var5, var6);
+		this.mcFrame = var7;
+	}
+}
--- /dev/null
+++ net/minecraft/game/level/generator/feature/FeatureBigTree.java
@@ -1,0 +1,358 @@
+package net.minecraft.game.level.generator.feature;
+
+import net.minecraft.game.level.World;
+import util.MathHelper;
+
+import java.util.Random;
+
+public class FeatureBigTree implements Feature {
+	static final byte[] otherCoordPairs = new byte[]{(byte)2, (byte)0, (byte)0, (byte)1, (byte)2, (byte)1};
+	public int log = 17;
+	public int leaves = 18;
+	public Random rand = new Random();
+	public World worldObj;
+	public int[] basePos = new int[]{0, 0, 0};
+	public int heightLimit = 0;
+	public int height;
+	public double heightAttenuation = 0.618D;
+	public double branchDensity = 1.0D;
+	public double branchSlope = 0.381D;
+	public double scaleWidth = 1.0D;
+	public double leafDensity = 1.0D;
+	public int trunkSize = 1;
+	public int heightLimitLimit = 12;
+	public int leafDistanceLimit = 5;
+	public int[][] leafNodes;
+
+	void generateLeafNodeList() {
+		this.height = (int)((double)this.heightLimit * this.heightAttenuation);
+		if(this.height >= this.heightLimit) {
+			this.height = this.heightLimit - 1;
+		}
+
+		int var1 = (int)(1.382D + Math.pow(this.leafDensity * (double)this.heightLimit / 13.0D, 2.0D));
+		if(var1 < 1) {
+			var1 = 1;
+		}
+
+		int[][] var2 = new int[var1 * this.heightLimit][4];
+		int var3 = this.basePos[1] + this.heightLimit - this.leafDistanceLimit;
+		int var4 = 1;
+		int var5 = this.basePos[1] + this.height;
+		int var6 = var3 - this.basePos[1];
+		var2[0][0] = this.basePos[0];
+		var2[0][1] = var3;
+		var2[0][2] = this.basePos[2];
+		var2[0][3] = var5;
+		--var3;
+
+		while(true) {
+			while(var6 >= 0) {
+				int var7 = 0;
+				float var8 = this.layerSize(var6);
+				if(var8 < 0.0F) {
+					--var3;
+					--var6;
+				} else {
+					for(double var9 = 0.5D; var7 < var1; ++var7) {
+						double var11 = this.scaleWidth * (double)var8 * ((double)this.rand.nextFloat() + 0.328D);
+						double var13 = (double)this.rand.nextFloat() * 2.0D * 3.14159D;
+						int var15 = (int)(var11 * Math.sin(var13) + (double)this.basePos[0] + var9);
+						int var16 = (int)(var11 * Math.cos(var13) + (double)this.basePos[2] + var9);
+						int[] var17 = new int[]{var15, var3, var16};
+						int[] var18 = new int[]{var15, var3 + this.leafDistanceLimit, var16};
+						if(this.checkBlockLine(var17, var18) == -1) {
+							int[] var19 = new int[]{this.basePos[0], this.basePos[1], this.basePos[2]};
+							double var20 = Math.sqrt(Math.pow((double)Math.abs(this.basePos[0] - var17[0]), 2.0D) + Math.pow((double)Math.abs(this.basePos[2] - var17[2]), 2.0D));
+							double var22 = var20 * this.branchSlope;
+							if((double)var17[1] - var22 > (double)var5) {
+								var19[1] = var5;
+							} else {
+								var19[1] = (int)((double)var17[1] - var22);
+							}
+
+							if(this.checkBlockLine(var19, var17) == -1) {
+								var2[var4][0] = var15;
+								var2[var4][1] = var3;
+								var2[var4][2] = var16;
+								var2[var4][3] = var19[1];
+								++var4;
+							}
+						}
+					}
+
+					--var3;
+					--var6;
+				}
+			}
+
+			this.leafNodes = new int[var4][4];
+			System.arraycopy(var2, 0, this.leafNodes, 0, var4);
+			return;
+		}
+	}
+
+	void genTreeLayer(int var1, int var2, int var3, float var4, byte var5, int var6) {
+		int var7 = (int)((double)var4 + 0.618D);
+		byte var8 = otherCoordPairs[var5];
+		byte var9 = otherCoordPairs[var5 + 3];
+		int[] var10 = new int[]{var1, var2, var3};
+		int[] var11 = new int[]{0, 0, 0};
+		int var12 = -var7;
+		int var13 = -var7;
+
+		label32:
+		for(var11[var5] = var10[var5]; var12 <= var7; ++var12) {
+			var11[var8] = var10[var8] + var12;
+			var13 = -var7;
+
+			while(true) {
+				while(true) {
+					if(var13 > var7) {
+						continue label32;
+					}
+
+					double var15 = Math.sqrt(Math.pow((double)Math.abs(var12) + 0.5D, 2.0D) + Math.pow((double)Math.abs(var13) + 0.5D, 2.0D));
+					if(var15 > (double)var4) {
+						++var13;
+					} else {
+						var11[var9] = var10[var9] + var13;
+						int var14 = this.worldObj.getBlockId(var11[0], var11[1], var11[2]);
+						if(var14 != 0 && var14 != this.leaves) {
+							++var13;
+						} else {
+							this.worldObj.setBlock(var11[0], var11[1], var11[2], var6);
+							++var13;
+						}
+					}
+				}
+			}
+		}
+
+	}
+
+	float layerSize(int var1) {
+		if((double)var1 < (double)((float)this.heightLimit) * 0.3D) {
+			return -1.618F;
+		} else {
+			float var2 = (float)this.heightLimit / 2.0F;
+			float var3 = (float)this.heightLimit / 2.0F - (float)var1;
+			float var4;
+			if(var3 == 0.0F) {
+				var4 = var2;
+			} else if(Math.abs(var3) >= var2) {
+				var4 = 0.0F;
+			} else {
+				var4 = (float)Math.sqrt(Math.pow((double)Math.abs(var2), 2.0D) - Math.pow((double)Math.abs(var3), 2.0D));
+			}
+
+			var4 *= 0.5F;
+			return var4;
+		}
+	}
+
+	float leafSize(int var1) {
+		return var1 >= 0 && var1 < this.leafDistanceLimit ? (var1 != 0 && var1 != this.leafDistanceLimit - 1 ? 3.0F : 2.0F) : -1.0F;
+	}
+
+	void generateLeafNode(int var1, int var2, int var3) {
+		int var4 = var2;
+
+		for(int var5 = var2 + this.leafDistanceLimit; var4 < var5; ++var4) {
+			float var6 = this.leafSize(var4 - var2);
+			this.genTreeLayer(var1, var4, var3, var6, (byte)1, this.leaves);
+		}
+
+	}
+
+	void placeBlockLine(int[] var1, int[] var2, int var3) {
+		int[] var4 = new int[]{0, 0, 0};
+		byte var5 = 0;
+
+		byte var6;
+		for(var6 = 0; var5 < 3; ++var5) {
+			var4[var5] = var2[var5] - var1[var5];
+			if(Math.abs(var4[var5]) > Math.abs(var4[var6])) {
+				var6 = var5;
+			}
+		}
+
+		if(var4[var6] != 0) {
+			byte var7 = otherCoordPairs[var6];
+			byte var8 = otherCoordPairs[var6 + 3];
+			byte var9;
+			if(var4[var6] > 0) {
+				var9 = 1;
+			} else {
+				var9 = -1;
+			}
+
+			double var10 = (double)var4[var7] / (double)var4[var6];
+			double var12 = (double)var4[var8] / (double)var4[var6];
+			int[] var14 = new int[]{0, 0, 0};
+			int var15 = 0;
+
+			for(int var16 = var4[var6] + var9; var15 != var16; var15 += var9) {
+				var14[var6] = MathHelper.floor_double((double)(var1[var6] + var15) + 0.5D);
+				var14[var7] = MathHelper.floor_double((double)var1[var7] + (double)var15 * var10 + 0.5D);
+				var14[var8] = MathHelper.floor_double((double)var1[var8] + (double)var15 * var12 + 0.5D);
+				this.worldObj.setBlock(var14[0], var14[1], var14[2], var3);
+			}
+
+		}
+	}
+
+	void generateLeaves() {
+		int var1 = 0;
+
+		for(int var2 = this.leafNodes.length; var1 < var2; ++var1) {
+			int var3 = this.leafNodes[var1][0];
+			int var4 = this.leafNodes[var1][1];
+			int var5 = this.leafNodes[var1][2];
+			this.generateLeafNode(var3, var4, var5);
+		}
+
+	}
+
+	boolean leafNodeNeedsBase(int var1) {
+		return (double)var1 >= (double)this.heightLimit * 0.2D;
+	}
+
+	void generateTrunk() {
+		int var1 = this.basePos[0];
+		int var2 = this.basePos[1];
+		int var3 = this.basePos[1] + this.height;
+		int var4 = this.basePos[2];
+		int[] var5 = new int[]{var1, var2, var4};
+		int[] var6 = new int[]{var1, var3, var4};
+		this.placeBlockLine(var5, var6, this.log);
+		if(this.trunkSize == 2) {
+			++var5[0];
+			++var6[0];
+			this.placeBlockLine(var5, var6, this.log);
+			++var5[2];
+			++var6[2];
+			this.placeBlockLine(var5, var6, this.log);
+			var5[0] += -1;
+			var6[0] += -1;
+			this.placeBlockLine(var5, var6, this.log);
+		}
+
+	}
+
+	void generateLeafNodeBases() {
+		int var1 = 0;
+		int var2 = this.leafNodes.length;
+
+		for(int[] var3 = new int[]{this.basePos[0], this.basePos[1], this.basePos[2]}; var1 < var2; ++var1) {
+			int[] var4 = this.leafNodes[var1];
+			int[] var5 = new int[]{var4[0], var4[1], var4[2]};
+			var3[1] = var4[3];
+			int var6 = var3[1] - this.basePos[1];
+			if(this.leafNodeNeedsBase(var6)) {
+				this.placeBlockLine(var3, var5, this.log);
+			}
+		}
+
+	}
+
+	int checkBlockLine(int[] var1, int[] var2) {
+		int[] var3 = new int[]{0, 0, 0};
+		byte var4 = 0;
+
+		byte var5;
+		for(var5 = 0; var4 < 3; ++var4) {
+			var3[var4] = var2[var4] - var1[var4];
+			if(Math.abs(var3[var4]) > Math.abs(var3[var5])) {
+				var5 = var4;
+			}
+		}
+
+		if(var3[var5] == 0) {
+			return -1;
+		} else {
+			byte var6 = otherCoordPairs[var5];
+			byte var7 = otherCoordPairs[var5 + 3];
+			byte var8;
+			if(var3[var5] > 0) {
+				var8 = 1;
+			} else {
+				var8 = -1;
+			}
+
+			double var9 = (double)var3[var6] / (double)var3[var5];
+			double var11 = (double)var3[var7] / (double)var3[var5];
+			int[] var13 = new int[]{0, 0, 0};
+			int var14 = 0;
+
+			int var15;
+			for(var15 = var3[var5] + var8; var14 != var15; var14 += var8) {
+				var13[var5] = var1[var5] + var14;
+				var13[var6] = (int)((double)var1[var6] + (double)var14 * var9);
+				var13[var7] = (int)((double)var1[var7] + (double)var14 * var11);
+				int var16 = this.worldObj.getBlockId(var13[0], var13[1], var13[2]);
+				if(var16 != 0 && var16 != this.leaves) {
+					break;
+				}
+			}
+
+			return var14 == var15 ? -1 : Math.abs(var14);
+		}
+	}
+
+	boolean validTreeLocation() {
+		if (this.basePos[0] <= 0 || this.basePos[1] <= 0 || this.basePos[2] <= 0
+				|| this.basePos[0] >= this.worldObj.width - 1
+				|| this.basePos[1] >= this.worldObj.height - 1
+				|| this.basePos[2] >= this.worldObj.length - 1) {
+			return false;
+		}
+
+		int[] var1 = new int[]{this.basePos[0], this.basePos[1], this.basePos[2]};
+		int[] var2 = new int[]{this.basePos[0], this.basePos[1] + this.heightLimit - 1, this.basePos[2]};
+		int var3 = this.worldObj.getBlockId(this.basePos[0], this.basePos[1] - 1, this.basePos[2]);
+		if(var3 != 2 && var3 != 3) {
+			return false;
+		} else {
+			int var4 = this.checkBlockLine(var1, var2);
+			if(var4 == -1) {
+				return true;
+			} else if(var4 < 6) {
+				return false;
+			} else {
+				this.heightLimit = var4;
+				return true;
+			}
+		}
+	}
+
+	public void setScale(double var1, double var3, double var5) {
+		this.heightLimitLimit = (int)(var1 * 12.0D);
+		if(var1 > 0.5D) {
+			this.leafDistanceLimit = 5;
+		}
+
+		this.scaleWidth = var3;
+		this.leafDensity = var5;
+	}
+
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		this.worldObj = var1;
+		long var6 = var2.nextLong();
+		this.rand.setSeed(var6);
+		this.basePos[0] = var3;
+		this.basePos[1] = var4;
+		this.basePos[2] = var5;
+		this.heightLimit = 5 + this.rand.nextInt(this.heightLimitLimit);
+
+		if(!this.validTreeLocation()) {
+			return false;
+		} else {
+			this.generateLeafNodeList();
+			this.generateLeaves();
+			this.generateTrunk();
+			this.generateLeafNodeBases();
+			return true;
+		}
+	}
+}
--- net/minecraft/client/model/ModelRenderer.java
+++ net/minecraft/client/model/ModelRenderer.java
@@ -9,9 +9,9 @@
 	private TexturedQuad[] faces;
 	private int textureOffsetX;
 	private int textureOffsetY;
-	private float rotationPointX;
-	private float rotationPointY;
-	private float rotationPointZ;
+	public float rotationPointX;
+	public float rotationPointY;
+	public float rotationPointZ;
 	public float rotateAngleX;
 	public float rotateAngleY;
 	public float rotateAngleZ;
--- net/minecraft/game/level/block/BlockSource.java
+++ net/minecraft/game/level/block/BlockSource.java
@@ -7,7 +7,7 @@
 public final class BlockSource extends Block {
 	private int fluid;
 
-	protected BlockSource(int var1, int var2) {
+	public BlockSource(int var1, int var2) {
 		super(var1, Block.blocksList[var2].blockIndexInTexture, Material.water);
 		this.fluid = var2;
 		this.setTickOnLoad(true);
--- net/minecraft/game/level/block/BlockLog.java
+++ net/minecraft/game/level/block/BlockLog.java
@@ -1,10 +1,12 @@
 package net.minecraft.game.level.block;
 
 import java.util.Random;
+
+import net.minecraft.game.level.World;
 import net.minecraft.game.level.material.Material;
 
 public final class BlockLog extends Block {
-	protected BlockLog(int var1) {
+	public BlockLog(int var1) {
 		super(17, Material.wood);
 		this.blockIndexInTexture = 20;
 	}
--- /dev/null
+++ net/minecraft/client/d.java
@@ -1,0 +1,9 @@
+package net.minecraft.client;
+
+import java.awt.*;
+
+public class d extends Minecraft {
+	public d(Canvas var1, MinecraftApplet var2, int var3, int var4, boolean var5) {
+		super(var1, var2, var3, var4, var5);
+	}
+}
--- net/minecraft/game/level/block/BlockOre.java
+++ net/minecraft/game/level/block/BlockOre.java
@@ -10,6 +10,9 @@
 	}
 
 	public final int idDropped(int var1, Random var2) {
+		if ((var1 & DROP_FLAG_SILK_TOUCH) != 0) {
+			return super.idDropped(var1, var2);
+		}
 		return this.blockID == Block.oreCoal.blockID ? Item.coal.shiftedIndex : (this.blockID == Block.oreDiamond.blockID ? Item.diamond.shiftedIndex : this.blockID);
 	}
 
--- net/minecraft/client/ChatLine.java
+++ net/minecraft/client/ChatLine.java
@@ -1,5 +1,10 @@
 package net.minecraft.client;
 
 public final class ChatLine {
-	public int updateCounter;
+	public String content;
+	public int displayTime;
+
+	public ChatLine(String content) {
+		this.content = content;
+	}
 }
--- net/minecraft/game/entity/monster/EntityMob.java
+++ net/minecraft/game/entity/monster/EntityMob.java
@@ -11,6 +11,7 @@
 	public EntityMob(World var1) {
 		super(var1);
 		this.health = 20;
+		this.scoreValue = 100;
 	}
 
 	public void onLivingUpdate() {
--- net/minecraft/game/entity/Entity.java
+++ net/minecraft/game/entity/Entity.java
@@ -36,6 +36,7 @@
 	public boolean isCollidedHorizontally = false;
 	private boolean surfaceCollision = true;
 	public boolean isDead = false;
+	public boolean notUpdating = false;
 	public float yOffset = 0.0F;
 	public float width = 0.6F;
 	public float height = 1.8F;
@@ -47,7 +48,7 @@
 	public float lastTickPosX;
 	public float lastTickPosY;
 	public float lastTickPosZ;
-	private float ySize = 0.0F;
+	protected float ySize = 0.0F;
 	public float stepHeight = 0.0F;
 	public boolean noClip = false;
 	private float entityCollisionReduction = 0.0F;
@@ -60,6 +61,7 @@
 	public int heartsLife = 0;
 	public int air = 300;
 	private boolean isFirstUpdate = true;
+	public int scoreValue = 0;
 	public String skinUrl;
 
 	public Entity(World var1) {
@@ -94,7 +96,7 @@
 		this.height = var2;
 	}
 
-	protected final void setPosition(float var1, float var2, float var3) {
+	public final void setPosition(float var1, float var2, float var3) {
 		this.posX = var1;
 		this.posY = var2;
 		this.posZ = var3;
@@ -157,27 +159,6 @@
 			this.fire = 600;
 		}
 
-		float var5;
-		if(this.posX < -8.0F) {
-			var5 = -(this.posX + 8.0F);
-			this.motionX += var5 * 0.001F;
-		}
-
-		if(this.posZ < -8.0F) {
-			var5 = -(this.posZ + 8.0F);
-			this.motionZ += var5 * 0.001F;
-		}
-
-		if(this.posX > (float)this.worldObj.width + 8.0F) {
-			var5 = this.posX - (float)this.worldObj.width + 8.0F;
-			this.motionX -= var5 * 0.001F;
-		}
-
-		if(this.posZ > (float)this.worldObj.length + 8.0F) {
-			var5 = this.posZ - (float)this.worldObj.length + 8.0F;
-			this.motionZ -= var5 * 0.001F;
-		}
-
 		this.isFirstUpdate = false;
 	}
 
@@ -204,6 +185,29 @@
 			float var7 = var2;
 			float var8 = var3;
 			AxisAlignedBB var9 = this.boundingBox.copy();
+			boolean sneaking = this.onGround && this.isSneaking();
+			if(sneaking) {
+				float i;
+				for(i = 0.05F; var1 != 0.0F && this.worldObj.getCollidingBoundingBoxes(this.boundingBox.getOffsetBoundingBox(var1, -1.0F, 0.0F)).size() == 0; var6 = var1) {
+					if(var1 < i && var1 >= -i) {
+						var1 = 0.0F;
+					} else if(var1 > 0.0F) {
+						var1 -= i;
+					} else {
+						var1 += i;
+					}
+				}
+
+				for(; var3 != 0.0F && this.worldObj.getCollidingBoundingBoxes(this.boundingBox.getOffsetBoundingBox(0.0F, -1.0F, var3)).size() == 0; var8 = var3) {
+					if(var3 < i && var3 >= -i) {
+						var3 = 0.0F;
+					} else if(var3 > 0.0F) {
+						var3 -= i;
+					} else {
+						var3 += i;
+					}
+				}
+			}
 			ArrayList var10 = this.worldObj.getCollidingBoundingBoxes(this.boundingBox.addCoord(var1, var2, var3));
 
 			for(int var11 = 0; var11 < var10.size(); ++var11) {
@@ -311,6 +315,8 @@
 				}
 			} else if(var2 < 0.0F) {
 				this.fallDistance -= var2;
+			} else if(var2 > 0.0F) {
+				this.fallDistance = 0.0F;
 			}
 
 			if(var6 != var1) {
@@ -328,19 +334,39 @@
 			var20 = this.posX - var4;
 			var19 = this.posZ - var5;
 			this.distanceWalkedModified = (float)((double)this.distanceWalkedModified + (double)MathHelper.sqrt_float(var20 * var20 + var19 * var19) * 0.6D);
-			if(this.canTriggerWalking) {
+			if(true) {
 				int var21 = (int)this.posX;
-				int var23 = (int)(this.posY - 0.2F - this.yOffset);
+				int var23 = (int)(this.posY - this.yOffset);
 				var17 = (int)this.posZ;
 				int var16 = this.worldObj.getBlockId(var21, var23, var17);
+				if (var16 == 0) {
+					var16 = this.worldObj.getBlockId(var21, (int)(this.posY - 0.2F - this.yOffset), var17);
+				}
 				if(this.distanceWalkedModified > (float)this.nextStepDistance && var16 > 0) {
 					++this.nextStepDistance;
 					StepSound var15 = Block.blocksList[var16].stepSound;
-					if(!Block.blocksList[var16].material.getIsLiquid()) {
+					if(!Block.blocksList[var16].material.getIsLiquid() && this.canTriggerWalking && !sneaking) {
 						this.worldObj.playSoundAtEntity(this, var15.stepSoundDir2(), var15.soundVolume * 0.15F, var15.soundPitch);
-					}
-
-					Block.blocksList[var16].onEntityWalking(this.worldObj, var21, var23, var17);
+						Block.blocksList[var16].onEntityWalking(this.worldObj, var21, var23, var17);
+					}
+				}
+			}
+
+			int iminX = MathHelper.floor_double(this.boundingBox.minX);
+			int iminY = MathHelper.floor_double(this.boundingBox.minY);
+			int iminZ = MathHelper.floor_double(this.boundingBox.minZ);
+			int imaxX = MathHelper.floor_double(this.boundingBox.maxX);
+			int imaxY = MathHelper.floor_double(this.boundingBox.maxY);
+			int imaxZ = MathHelper.floor_double(this.boundingBox.maxZ);
+
+			for(int var31 = iminX; var31 <= imaxX; ++var31) {
+				for(int var32 = iminY; var32 <= imaxY; ++var32) {
+					for(int var33 = iminZ; var33 <= imaxZ; ++var33) {
+						int var34 = this.worldObj.getBlockId(var31, var32, var33);
+						if(var34 > 0) {
+							Block.blocksList[var34].onEntityCollidedWithBlock(this.worldObj, var31, var32, var33, this);
+						}
+					}
 				}
 			}
 
@@ -374,12 +400,16 @@
 	}
 
 	public final boolean handleWaterMovement() {
-		return this.worldObj.handleMaterialAcceleration(this.boundingBox.expand(0.0F, -0.4F, 0.0F), Material.water);
+		return this.worldObj.handleMaterialAcceleration(this.boundingBox.expand(0.0F, -0.4F, 0.0F), Material.water, this);
 	}
 
 	public final boolean isInsideOfWater() {
-		int var1 = this.worldObj.getBlockId((int)this.posX, (int)(this.posY + this.getEyeHeight()), (int)this.posZ);
-		return var1 != 0 ? Block.blocksList[var1].material == Material.water : false;
+		int var1 = this.getBlockInHead();
+		return var1 != 0 && Block.blocksList[var1].material == Material.water;
+	}
+
+	public final int getBlockInHead() {
+		return this.worldObj.getBlockId((int)this.posX, (int)(this.posY + this.getEyeHeight()), (int)this.posZ);
 	}
 
 	protected float getEyeHeight() {
@@ -387,7 +417,7 @@
 	}
 
 	public final boolean handleLavaMovement() {
-		return this.worldObj.handleMaterialAcceleration(this.boundingBox.expand(0.0F, -0.4F, 0.0F), Material.lava);
+		return this.worldObj.handleMaterialAcceleration(this.boundingBox.expand(0.0F, -0.4F, 0.0F), Material.lava, this);
 	}
 
 	public final void moveFlying(float var1, float var2, float var3) {
@@ -434,6 +464,13 @@
 		return var2 * var2 + var3 * var3 + var4 * var4;
 	}
 
+	public final float getDistanceSqToBlock(int x, int y, int z) {
+		float var2 = this.posX - x;
+		float var3 = this.posY - y;
+		float var4 = this.posZ - z;
+		return var2 * var2 + var3 * var3 + var4 * var4;
+	}
+
 	public void onCollideWithPlayer(EntityPlayer var1) {
 	}
 
@@ -506,7 +543,7 @@
 		this.fallDistance = var1.getFloat("FallDistance");
 		this.fire = var1.getShort("Fire");
 		this.air = var1.getShort("Air");
-		this.setPositionAndRotation(this.posX, this.posY, this.posZ, this.rotationYaw, this.rotationPitch);
+		this.setPositionAndRotation(this.posX, this.posY - this.yOffset, this.posZ, this.rotationYaw, this.rotationPitch);
 		this.readEntityFromNBT(var1);
 	}
 
@@ -546,5 +583,9 @@
 
 	public boolean isEntityAlive() {
 		return !this.isDead;
+	}
+
+	public boolean isSneaking() {
+		return false;
 	}
 }
--- /dev/null
+++ net/minecraft/game/level/block/BlockCactus.java
@@ -1,0 +1,74 @@
+package net.minecraft.game.level.block;
+
+import net.minecraft.game.entity.Entity;
+import net.minecraft.game.level.World;
+import net.minecraft.game.level.material.Material;
+import net.minecraft.game.physics.AxisAlignedBB;
+
+import java.util.Random;
+
+public class BlockCactus extends Block {
+	public BlockCactus(int var1, int var2) {
+		super(var1, var2, Material.leaves);
+		this.setTickOnLoad(true);
+	}
+
+	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
+		if(var1.getBlockId(var2, var3 + 1, var4) == 0) {
+			int var6;
+			for(var6 = 1; var1.getBlockId(var2, var3 - var6, var4) == this.blockID; ++var6) {
+			}
+
+			if(var6 < 3) {
+				int var7 = var1.getBlockMetadata(var2, var3, var4);
+				if(var7 == 15) {
+					var1.setBlockWithNotify(var2, var3 + 1, var4, this.blockID);
+					var1.setBlockMetadata(var2, var3, var4, 0);
+				} else {
+					var1.setBlockMetadata(var2, var3, var4, var7 + 1);
+				}
+			}
+		}
+
+	}
+
+	public int getBlockTextureFromSide(int var1) {
+		return var1 == 1 ? this.blockIndexInTexture - 1 : (var1 == 0 ? this.blockIndexInTexture + 1 : this.blockIndexInTexture);
+	}
+
+	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
+		return super.canPlaceBlockAt(var1, var2, var3, var4) && this.canBlockStay(var1, var2, var3, var4);
+	}
+
+	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var0, int var1, int var2, int var3) {
+		float var4 = 1.0F / 16.0F;
+		return new AxisAlignedBB(((float)var1 + var4), var2, ((float)var3 + var4), ((float)(var1 + 1) - var4), ((float)(var2 + 1) - var4), ((float)(var3 + 1) - var4));
+	}
+
+	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
+		if(!this.canBlockStay(var1, var2, var3, var4)) {
+			this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+			var1.setBlockWithNotify(var2, var3, var4, 0);
+		}
+
+	}
+
+	public boolean canBlockStay(World var1, int var2, int var3, int var4) {
+		if(var1.getBlockMaterial(var2 - 1, var3, var4).isSolid()) {
+			return false;
+		} else if(var1.getBlockMaterial(var2 + 1, var3, var4).isSolid()) {
+			return false;
+		} else if(var1.getBlockMaterial(var2, var3, var4 - 1).isSolid()) {
+			return false;
+		} else if(var1.getBlockMaterial(var2, var3, var4 + 1).isSolid()) {
+			return false;
+		} else {
+			int var5 = var1.getBlockId(var2, var3 - 1, var4);
+			return var5 == Block.cactus.blockID || var5 == Block.sand.blockID;
+		}
+	}
+
+	public void onEntityCollidedWithBlock(World var1, int var2, int var3, int var4, Entity var5) {
+		var5.attackEntityFrom(null, 1);
+	}
+}
